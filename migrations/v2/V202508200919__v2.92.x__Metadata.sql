-- SQL Logging Session
-- Session ID: 15956fc4-5135-49a3-a7ce-ed4f94e617ed
-- Started: 2025-08-20T14:17:00.304Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_48dc47ae NVARCHAR(500),
@DisplayName_48dc47ae NVARCHAR(500),
@Version_48dc47ae NVARCHAR(100),
@GlobalVariable_48dc47ae NVARCHAR(255),
@Category_48dc47ae NVARCHAR(100),
@CDNUrl_48dc47ae NVARCHAR(1000),
@CDNCssUrl_48dc47ae NVARCHAR(1000),
@Description_48dc47ae NVARCHAR(MAX),
@Status_48dc47ae NVARCHAR(20),
@LintRules_48dc47ae NVARCHAR(MAX),
@ID_48dc47ae UNIQUEIDENTIFIER
SET
  @Name_48dc47ae = N'd3'
SET
  @DisplayName_48dc47ae = N'D3.js'
SET
  @Version_48dc47ae = N'7.8.5'
SET
  @GlobalVariable_48dc47ae = N'd3'
SET
  @Category_48dc47ae = N'Charting'
SET
  @CDNUrl_48dc47ae = N'https://unpkg.com/d3@7.8.5/dist/d3.min.js'
SET
  @Description_48dc47ae = N'Data visualization library for creating custom charts'
SET
  @Status_48dc47ae = N'Active'
SET
  @LintRules_48dc47ae = N'{
  "initialization": {
    "factoryMethod": "select",
    "elementType": "svg",
    "requiresNew": false
  },
  "lifecycle": {
    "cleanupMethods": [
      "remove",
      "interrupt"
    ],
    "requiredMethods": [],
    "updateMethods": [
      "data",
      "attr",
      "style"
    ]
  },
  "validators": {
    "checkSelectionCleanup": {
      "description": "Ensure D3 selections are properly cleaned up",
      "severity": "critical",
      "validate": "/**\n * Ensure D3 selections are properly cleaned up\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for D3 selections in useEffect without cleanup\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.object) &&\n      path.node.callee.object.name === ''d3'' &&\n      t.isIdentifier(path.node.callee.property) &&\n      [''select'', ''selectAll''].includes(path.node.callee.property.name)) {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                hasCleanup = true;\n                break;\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''d3-missing-cleanup'',\n              severity: ''critical'',\n              message: ''D3 selections must be cleaned up in useEffect to prevent memory leaks'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { d3.select(ref.current).selectAll(\"*\").remove(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkJoinPattern": {
      "description": "Recommend modern join() pattern over enter/exit",
      "severity": "low",
      "validate": "/**\n * Recommend modern join() pattern over enter/exit\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for old enter/append pattern\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.property) &&\n      path.node.callee.property.name === ''enter'') {\n    \n    // Check if followed by append\n    if (t.isMemberExpression(path.parent) &&\n        path.parent.object === path.node &&\n        t.isCallExpression(path.parent.parent) &&\n        t.isIdentifier(path.parent.property) &&\n        path.parent.property.name === ''append'') {\n      \n      return {\n        rule: ''d3-use-join'',\n        severity: ''low'',\n        message: ''Consider using the modern .join() pattern instead of .enter().append()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''.join(\"element\") // Handles enter, update, and exit automatically''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_48dc47ae = '12416186-FBBD-4973-A7F4-D030FD84994B'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_48dc47ae,
  @DisplayName = @DisplayName_48dc47ae,
  @Version = @Version_48dc47ae,
  @GlobalVariable = @GlobalVariable_48dc47ae,
  @Category = @Category_48dc47ae,
  @CDNUrl = @CDNUrl_48dc47ae,
  @CDNCssUrl = @CDNCssUrl_48dc47ae,
  @Description = @Description_48dc47ae,
  @Status = @Status_48dc47ae,
  @LintRules = @LintRules_48dc47ae,
  @ID = @ID_48dc47ae;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_fb8d0e41 NVARCHAR(500),
@DisplayName_fb8d0e41 NVARCHAR(500),
@Version_fb8d0e41 NVARCHAR(100),
@GlobalVariable_fb8d0e41 NVARCHAR(255),
@Category_fb8d0e41 NVARCHAR(100),
@CDNUrl_fb8d0e41 NVARCHAR(1000),
@CDNCssUrl_fb8d0e41 NVARCHAR(1000),
@Description_fb8d0e41 NVARCHAR(MAX),
@Status_fb8d0e41 NVARCHAR(20),
@LintRules_fb8d0e41 NVARCHAR(MAX),
@ID_fb8d0e41 UNIQUEIDENTIFIER
SET
  @Name_fb8d0e41 = N'Recharts'
SET
  @DisplayName_fb8d0e41 = N'Recharts'
SET
  @Version_fb8d0e41 = N'2.10.4'
SET
  @GlobalVariable_fb8d0e41 = N'Recharts'
SET
  @Category_fb8d0e41 = N'Charting'
SET
  @CDNUrl_fb8d0e41 = N'https://cdn.jsdelivr.net/npm/recharts@2.10.4/umd/Recharts.min.js'
SET
  @Description_fb8d0e41 = N'React charting library built on D3'
SET
  @Status_fb8d0e41 = N'Disabled'
SET
  @LintRules_fb8d0e41 = N'{
  "initialization": {
    "factoryMethod": null,
    "elementType": "div",
    "requiresNew": false
  },
  "lifecycle": {
    "requiredMethods": [],
    "cleanupMethods": [],
    "updateMethods": []
  },
  "validators": {
    "checkResponsiveContainer": {
      "description": "Check ResponsiveContainer has proper parent dimensions",
      "severity": "critical",
      "validate": "/**\n * Check ResponsiveContainer has proper parent dimensions\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for ResponsiveContainer usage\n  if (t.isJSXElement(path.node) &&\n      t.isJSXIdentifier(path.node.openingElement.name) &&\n      path.node.openingElement.name.name === ''ResponsiveContainer'') {\n    \n    // Check if width=\"100%\" and height=\"100%\" are used\n    const attributes = path.node.openingElement.attributes;\n    let hasPercentHeight = false;\n    \n    attributes.forEach(attr => {\n      if (t.isJSXAttribute(attr) &&\n          t.isJSXIdentifier(attr.name) &&\n          attr.name.name === ''height'') {\n        \n        if (t.isStringLiteral(attr.value) && attr.value.value === ''100%'') {\n          hasPercentHeight = true;\n        } else if (t.isJSXExpressionContainer(attr.value) &&\n                   t.isStringLiteral(attr.value.expression) &&\n                   attr.value.expression.value === ''100%'') {\n          hasPercentHeight = true;\n        }\n      }\n    });\n    \n    if (hasPercentHeight) {\n      return {\n        rule: ''recharts-responsive-container-height'',\n        severity: ''critical'',\n        message: ''ResponsiveContainer with height=\"100%\" requires parent element to have explicit height'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''Set parent div style={{ height: 400 }} or use fixed height on ResponsiveContainer''\n      };\n    }\n  }\n  return null;\n}"
    },
    "checkDataProp": {
      "description": "Ensure chart components have data prop",
      "severity": "high",
      "validate": "/**\n * Ensure chart components have data prop\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for Recharts chart components\n  const chartComponents = [''LineChart'', ''BarChart'', ''AreaChart'', ''PieChart'', ''ScatterChart'', ''RadarChart''];\n  \n  if (t.isJSXElement(path.node) &&\n      t.isJSXIdentifier(path.node.openingElement.name) &&\n      chartComponents.includes(path.node.openingElement.name.name)) {\n    \n    const attributes = path.node.openingElement.attributes;\n    let hasData = false;\n    \n    attributes.forEach(attr => {\n      if (t.isJSXAttribute(attr) &&\n          t.isJSXIdentifier(attr.name) &&\n          attr.name.name === ''data'') {\n        hasData = true;\n      }\n    });\n    \n    if (!hasData) {\n      return {\n        rule: ''recharts-missing-data'',\n        severity: ''high'',\n        message: `$' + '{path.node.openingElement.name.name} requires a data prop`,\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''data={chartData}''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_fb8d0e41 = '5A8C6518-889B-4868-BA20-4E50531309C6'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_fb8d0e41,
  @DisplayName = @DisplayName_fb8d0e41,
  @Version = @Version_fb8d0e41,
  @GlobalVariable = @GlobalVariable_fb8d0e41,
  @Category = @Category_fb8d0e41,
  @CDNUrl = @CDNUrl_fb8d0e41,
  @CDNCssUrl = @CDNCssUrl_fb8d0e41,
  @Description = @Description_fb8d0e41,
  @Status = @Status_fb8d0e41,
  @LintRules = @LintRules_fb8d0e41,
  @ID = @ID_fb8d0e41;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_fbc99519 NVARCHAR(500),
@DisplayName_fbc99519 NVARCHAR(500),
@Version_fbc99519 NVARCHAR(100),
@GlobalVariable_fbc99519 NVARCHAR(255),
@Category_fbc99519 NVARCHAR(100),
@CDNUrl_fbc99519 NVARCHAR(1000),
@CDNCssUrl_fbc99519 NVARCHAR(1000),
@Description_fbc99519 NVARCHAR(MAX),
@Status_fbc99519 NVARCHAR(20),
@LintRules_fbc99519 NVARCHAR(MAX),
@ID_fbc99519 UNIQUEIDENTIFIER
SET
  @Name_fbc99519 = N'chart.js'
SET
  @DisplayName_fbc99519 = N'Chart.js'
SET
  @Version_fbc99519 = N'4.4.1'
SET
  @GlobalVariable_fbc99519 = N'Chart'
SET
  @Category_fbc99519 = N'Charting'
SET
  @CDNUrl_fbc99519 = N'https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js'
SET
  @Description_fbc99519 = N'Simple yet flexible JavaScript charting library'
SET
  @Status_fbc99519 = N'Active'
SET
  @LintRules_fbc99519 = N'{
  "initialization": {
    "constructorName": "Chart",
    "requiresNew": true,
    "elementType": "canvas",
    "requiredConfig": [
      "type",
      "data"
    ]
  },
  "lifecycle": {
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "update"
    ],
    "requiredMethods": []
  },
  "validators": {
    "checkDestroyBeforeRecreate": {
      "description": "Ensure Chart instances are destroyed before recreating on same canvas",
      "severity": "critical",
      "validate": "/**\n * Ensure Chart instances are destroyed before recreating on same canvas\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context with libraryName, globalVariable, instanceVariables\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'') {\n    \n    // Check if we''re in a useEffect\n    let inUseEffect = false;\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        inUseEffect = true;\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n    \n    if (inUseEffect) {\n      // Look for cleanup function return\n      let hasCleanup = false;\n      const effectFn = useEffectPath.node.arguments[0];\n      if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n        // Check if it returns a cleanup function\n        const body = effectFn.body;\n        if (t.isBlockStatement(body)) {\n          for (const stmt of body.body) {\n            if (t.isReturnStatement(stmt) && stmt.argument) {\n              hasCleanup = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      if (!hasCleanup) {\n        return {\n          rule: ''chart-missing-cleanup'',\n          severity: ''critical'',\n          message: ''Chart.js instances must be destroyed in useEffect cleanup to prevent memory leaks'',\n          line: path.node.loc?.start.line || 0,\n          column: path.node.loc?.start.column || 0,\n          fix: ''return () => { chartInstance.current?.destroy(); }''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkCanvasContext": {
      "description": "Validate canvas context is obtained correctly",
      "severity": "high",
      "validate": "/**\n * Validate canvas context is obtained correctly\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'' &&\n      path.node.arguments[0]) {\n    \n    const firstArg = path.node.arguments[0];\n    \n    // Check if it''s a getContext(''2d'') call\n    if (t.isCallExpression(firstArg) &&\n        t.isMemberExpression(firstArg.callee) &&\n        t.isIdentifier(firstArg.callee.property) &&\n        firstArg.callee.property.name === ''getContext'') {\n      \n      const contextArg = firstArg.arguments[0];\n      if (!t.isStringLiteral(contextArg) || contextArg.value !== ''2d'') {\n        return {\n          rule: ''chart-invalid-context'',\n          severity: ''high'',\n          message: ''Chart.js requires a 2D canvas context'',\n          line: contextArg?.loc?.start.line || 0,\n          column: contextArg?.loc?.start.column || 0,\n          fix: \"getContext(''2d'')\"\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkChartRegistration": {
      "description": "Check for Chart.register() when using tree-shaking",
      "severity": "medium",
      "validate": "/**\n * Check for Chart.register() when using tree-shaking\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Only check if we see specific controller imports\n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js/auto'') {\n    return null; // auto import includes everything\n  }\n  \n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js'' &&\n      path.node.specifiers.some(spec => \n        t.isImportSpecifier(spec) &&\n        t.isIdentifier(spec.imported) &&\n        [''BarController'', ''LineController'', ''PieController''].includes(spec.imported.name)\n      )) {\n    \n    // Look for Chart.register call\n    let hasRegister = false;\n    ast.program.body.forEach(node => {\n      if (t.isExpressionStatement(node) &&\n          t.isCallExpression(node.expression) &&\n          t.isMemberExpression(node.expression.callee) &&\n          t.isIdentifier(node.expression.callee.object) &&\n          node.expression.callee.object.name === ''Chart'' &&\n          t.isIdentifier(node.expression.callee.property) &&\n          node.expression.callee.property.name === ''register'') {\n        hasRegister = true;\n      }\n    });\n    \n    if (!hasRegister) {\n      return {\n        rule: ''chart-missing-registration'',\n        severity: ''medium'',\n        message: ''When importing specific Chart.js components, you must call Chart.register()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''Chart.register(BarController, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_fbc99519 = '754D12D4-B182-45E8-B4BB-98FB8A366B02'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_fbc99519,
  @DisplayName = @DisplayName_fbc99519,
  @Version = @Version_fbc99519,
  @GlobalVariable = @GlobalVariable_fbc99519,
  @Category = @Category_fbc99519,
  @CDNUrl = @CDNUrl_fbc99519,
  @CDNCssUrl = @CDNCssUrl_fbc99519,
  @Description = @Description_fbc99519,
  @Status = @Status_fbc99519,
  @LintRules = @LintRules_fbc99519,
  @ID = @ID_fbc99519;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_a71546d0 NVARCHAR(500),
@DisplayName_a71546d0 NVARCHAR(500),
@Version_a71546d0 NVARCHAR(100),
@GlobalVariable_a71546d0 NVARCHAR(255),
@Category_a71546d0 NVARCHAR(100),
@CDNUrl_a71546d0 NVARCHAR(1000),
@CDNCssUrl_a71546d0 NVARCHAR(1000),
@Description_a71546d0 NVARCHAR(MAX),
@Status_a71546d0 NVARCHAR(20),
@LintRules_a71546d0 NVARCHAR(MAX),
@ID_a71546d0 UNIQUEIDENTIFIER
SET
  @Name_a71546d0 = N'ApexCharts'
SET
  @DisplayName_a71546d0 = N'ApexCharts'
SET
  @Version_a71546d0 = N'3.45.1'
SET
  @GlobalVariable_a71546d0 = N'ApexCharts'
SET
  @Category_a71546d0 = N'Charting'
SET
  @CDNUrl_a71546d0 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_a71546d0 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_a71546d0 = N'Modern interactive JavaScript charts library'
SET
  @Status_a71546d0 = N'Active'
SET
  @LintRules_a71546d0 = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [
      "render"
    ],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''critical'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_a71546d0 = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_a71546d0,
  @DisplayName = @DisplayName_a71546d0,
  @Version = @Version_a71546d0,
  @GlobalVariable = @GlobalVariable_a71546d0,
  @Category = @Category_a71546d0,
  @CDNUrl = @CDNUrl_a71546d0,
  @CDNCssUrl = @CDNCssUrl_a71546d0,
  @Description = @Description_a71546d0,
  @Status = @Status_a71546d0,
  @LintRules = @LintRules_a71546d0,
  @ID = @ID_a71546d0;


-- End of SQL Logging Session
-- Session ID: 15956fc4-5135-49a3-a7ce-ed4f94e617ed
-- Completed: 2025-08-20T14:17:30.734Z
-- Duration: 30430ms
-- Total Statements: 4







































-- SQL Logging Session
-- Session ID: ecd6cd35-9c33-4249-ad34-9b35697069c2
-- Started: 2025-08-20T14:54:42.722Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_620db5b4 NVARCHAR(500),
@DisplayName_620db5b4 NVARCHAR(500),
@Version_620db5b4 NVARCHAR(100),
@GlobalVariable_620db5b4 NVARCHAR(255),
@Category_620db5b4 NVARCHAR(100),
@CDNUrl_620db5b4 NVARCHAR(1000),
@CDNCssUrl_620db5b4 NVARCHAR(1000),
@Description_620db5b4 NVARCHAR(MAX),
@Status_620db5b4 NVARCHAR(20),
@LintRules_620db5b4 NVARCHAR(MAX),
@ID_620db5b4 UNIQUEIDENTIFIER
SET
  @Name_620db5b4 = N'ApexCharts'
SET
  @DisplayName_620db5b4 = N'ApexCharts'
SET
  @Version_620db5b4 = N'3.45.1'
SET
  @GlobalVariable_620db5b4 = N'ApexCharts'
SET
  @Category_620db5b4 = N'Charting'
SET
  @CDNUrl_620db5b4 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_620db5b4 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_620db5b4 = N'Modern interactive JavaScript charts library'
SET
  @Status_620db5b4 = N'Active'
SET
  @LintRules_620db5b4 = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [
      "render"
    ],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''critical'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkSeriesDataFormat": {
      "description": "Validate data is in correct ApexCharts series format",
      "severity": "critical",
      "validate": "// Validates that data passed to ApexCharts is in the correct series format\n(ast, path, t, context) => {\n  // Look for chart creation or series updates\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const configArg = path.node.arguments[1];\n    if (configArg && t.isObjectExpression(configArg)) {\n      const seriesProp = configArg.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''series''\n      );\n      \n      if (seriesProp && t.isIdentifier(seriesProp.value)) {\n        // Track the variable name for later validation\n        context.apexSeriesVars = context.apexSeriesVars || new Set();\n        context.apexSeriesVars.add(seriesProp.value.name);\n      }\n    }\n  }\n  \n  // Check updateSeries calls\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''updateSeries'') {\n    const parent = path.parent;\n    if (t.isCallExpression(parent)) {\n      const arg = parent.arguments[0];\n      if (arg && t.isIdentifier(arg)) {\n        // Flag for validation - series data should be array of objects with name and data\n        context.violations.push({\n          type: ''warning'',\n          message: `Verify that ''$' + '{arg.name}'' is formatted as ApexCharts series: [{name: string, data: [{x, y}]}]`,\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Transform data to: selectedMetrics.map(metric => ({ name: metric, data: points.map(p => ({x: timestamp, y: value})) }))''\n        });\n      }\n    }\n  }\n  \n  // Look for common data format mistakes\n  if (t.isObjectExpression(path.node)) {\n    const hasDateProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''date''\n    );\n    const hasDurationProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''duration''\n    );\n    const hasCostProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''cost''\n    );\n    \n    // This looks like processed data that needs transformation\n    if (hasDateProp && (hasDurationProp || hasCostProp)) {\n      // Check if this is being passed to chart\n      let parent = path.parent;\n      let depth = 0;\n      while (parent && depth < 5) {\n        if (t.isJSXAttribute(parent) && parent.name?.name === ''seriesData'') {\n          context.violations.push({\n            type: ''error'',\n            message: ''Data structure {date, duration, cost} needs transformation to ApexCharts series format'',\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''Transform to: [{name: \"Duration\", data: [{x: timestamp, y: value}]}, ...]''\n          });\n          break;\n        }\n        parent = parent.parent;\n        depth++;\n      }\n    }\n  }\n}"
    },
    "checkChartRefManagement": {
      "description": "Ensure chart instances are properly stored in refs for exports",
      "severity": "high",
      "validate": "// Validates that chart instances are properly stored and exposed via refs\n(ast, path, t, context) => {\n  // Check for new ApexCharts creation\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const parent = path.parent;\n    \n    // Check if the chart instance is being stored\n    if (t.isVariableDeclarator(parent)) {\n      const varName = parent.id.name;\n      context.apexChartVars = context.apexChartVars || new Set();\n      context.apexChartVars.add(varName);\n      \n      // Now check if this variable is attached to a ref\n      const scope = path.scope;\n      const binding = scope.getBinding(varName);\n      if (binding) {\n        let isAttachedToRef = false;\n        \n        for (const refPath of binding.referencePaths) {\n          // Check for patterns like: chartRef.current = chart\n          if (t.isMemberExpression(refPath.parent) && \n              refPath.parent.property?.name === ''current'') {\n            isAttachedToRef = true;\n            break;\n          }\n          // Check for: chartRef.current._chart = chart\n          if (t.isMemberExpression(refPath.parent?.left) &&\n              refPath.parent?.left?.property?.name === ''_chart'') {\n            isAttachedToRef = true;\n            break;\n          }\n        }\n        \n        if (!isAttachedToRef) {\n          context.violations.push({\n            type: ''error'',  \n            message: `ApexCharts instance ''$' + '{varName}'' should be attached to a ref for export functionality`,\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''After creating chart, store it: chartRef.current = chart;''\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for dataURI usage without proper ref\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''dataURI'') {\n    const object = path.node.object;\n    \n    // Check if it''s accessing through a ref\n    if (t.isMemberExpression(object)) {\n      if (!object.property || object.property.name !== ''current'') {\n        context.violations.push({\n          type: ''warning'',\n          message: ''dataURI() should be called on chart instance stored in ref.current'',\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Use: chartRef.current?.dataURI() or chart.dataURI()''\n        });\n      }\n    }\n  }\n  \n  // Check for missing chart storage in useEffect\n  if (t.isCallExpression(path.node) && \n      t.isMemberExpression(path.node.callee) &&\n      path.node.callee.object?.name === ''chart'' &&\n      path.node.callee.property?.name === ''render'') {\n    \n    // Look for the chart variable in parent scope\n    let foundChartStorage = false;\n    let parent = path.parent;\n    let depth = 0;\n    \n    while (parent && depth < 10) {\n      if (t.isBlockStatement(parent)) {\n        // Check if chartRef.current is set in this block\n        const statements = parent.body;\n        foundChartStorage = statements.some(stmt => {\n          if (t.isExpressionStatement(stmt) && \n              t.isAssignmentExpression(stmt.expression)) {\n            const left = stmt.expression.left;\n            return t.isMemberExpression(left) && \n                   left.property?.name === ''current'';\n          }\n          return false;\n        });\n        \n        if (foundChartStorage) break;\n      }\n      parent = parent.parent;\n      depth++;\n    }\n    \n    if (!foundChartStorage) {\n      context.violations.push({\n        type: ''warning'',\n        message: ''Chart instance may not be stored in ref for export functionality'',\n        line: path.node.loc?.start.line,\n        column: path.node.loc?.start.column,\n        suggestion: ''Store chart in ref: chartRef.current = chart;''\n      });\n    }\n  }\n}"
    },
    "checkAnomalyFormat": {
      "description": "Validate anomaly data format for annotations",
      "severity": "medium",
      "validate": "// Validates that anomaly data for ApexCharts annotations is correctly formatted\n(ast, path, t, context) => {\n  // Look for annotations configuration in chart options\n  if (t.isObjectProperty(path.node) && \n      t.isIdentifier(path.node.key) && \n      path.node.key.name === ''annotations'') {\n    \n    const value = path.node.value;\n    if (t.isObjectExpression(value)) {\n      // Check for points property\n      const pointsProp = value.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''points''\n      );\n      \n      if (pointsProp) {\n        // Check if it''s mapping over anomalies\n        if (t.isCallExpression(pointsProp.value) && \n            t.isMemberExpression(pointsProp.value.callee) &&\n            pointsProp.value.callee.property?.name === ''map'') {\n          \n          const mapArg = pointsProp.value.arguments[0];\n          if (t.isArrowFunctionExpression(mapArg) || t.isFunctionExpression(mapArg)) {\n            const body = mapArg.body;\n            \n            // Check the structure being returned\n            if (t.isObjectExpression(body) || \n                (t.isBlockStatement(body) && body.body.length > 0)) {\n              \n              // Look for common mistakes\n              const checkForDateField = (obj) => {\n                if (t.isObjectExpression(obj)) {\n                  const hasDate = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''date''\n                  );\n                  const hasX = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''x''\n                  );\n                  \n                  if (hasDate && !hasX) {\n                    context.violations.push({\n                      type: ''error'',\n                      message: ''Anomaly annotations should use \"x\" property with timestamp, not \"date\"'',\n                      line: obj.loc?.start.line,\n                      column: obj.loc?.start.column,\n                      suggestion: ''Change to: { x: new Date(anomaly.date).getTime(), y: anomaly.value, ... }''\n                    });\n                  }\n                }\n              };\n              \n              if (t.isObjectExpression(body)) {\n                checkForDateField(body);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for anomaly data being set in state\n  if (t.isCallExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''setAnomalies'') {\n    \n    const arg = path.node.arguments[0];\n    if (t.isArrayExpression(arg) && arg.elements.length > 0) {\n      const firstElement = arg.elements[0];\n      \n      if (t.isObjectExpression(firstElement)) {\n        const hasDate = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''date''\n        );\n        const hasX = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''x''\n        );\n        \n        if (hasDate && !hasX) {\n          context.violations.push({\n            type: ''warning'',\n            message: ''Anomaly data should include \"x\" property for ApexCharts compatibility'',\n            line: firstElement.loc?.start.line,\n            column: firstElement.loc?.start.column,\n            suggestion: ''Include: { x: new Date(point.date), y: value, metric: metricName }''\n          });\n        }\n      }\n    }\n  }\n}"
    }
  }
}'
SET
  @ID_620db5b4 = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_620db5b4,
  @DisplayName = @DisplayName_620db5b4,
  @Version = @Version_620db5b4,
  @GlobalVariable = @GlobalVariable_620db5b4,
  @Category = @Category_620db5b4,
  @CDNUrl = @CDNUrl_620db5b4,
  @CDNCssUrl = @CDNCssUrl_620db5b4,
  @Description = @Description_620db5b4,
  @Status = @Status_620db5b4,
  @LintRules = @LintRules_620db5b4,
  @ID = @ID_620db5b4;


-- End of SQL Logging Session
-- Session ID: ecd6cd35-9c33-4249-ad34-9b35697069c2
-- Completed: 2025-08-20T14:55:07.790Z
-- Duration: 25068ms
-- Total Statements: 1



























-- SQL Logging Session
-- Session ID: 9adb7a3d-3c52-4395-9ccf-e892c274b70c
-- Started: 2025-08-20T21:50:15.493Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_c06616c0 NVARCHAR(500),
@DisplayName_c06616c0 NVARCHAR(500),
@Version_c06616c0 NVARCHAR(100),
@GlobalVariable_c06616c0 NVARCHAR(255),
@Category_c06616c0 NVARCHAR(100),
@CDNUrl_c06616c0 NVARCHAR(1000),
@CDNCssUrl_c06616c0 NVARCHAR(1000),
@Description_c06616c0 NVARCHAR(MAX),
@Status_c06616c0 NVARCHAR(20),
@LintRules_c06616c0 NVARCHAR(MAX),
@ID_c06616c0 UNIQUEIDENTIFIER
SET
  @Name_c06616c0 = N'ApexCharts'
SET
  @DisplayName_c06616c0 = N'ApexCharts'
SET
  @Version_c06616c0 = N'3.45.1'
SET
  @GlobalVariable_c06616c0 = N'ApexCharts'
SET
  @Category_c06616c0 = N'Charting'
SET
  @CDNUrl_c06616c0 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_c06616c0 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_c06616c0 = N'Modern interactive JavaScript charts library'
SET
  @Status_c06616c0 = N'Active'
SET
  @LintRules_c06616c0 = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''critical'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkSeriesDataFormat": {
      "description": "Validate data is in correct ApexCharts series format",
      "severity": "critical",
      "validate": "// Validates that data passed to ApexCharts is in the correct series format\n(ast, path, t, context) => {\n  // Look for chart creation or series updates\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const configArg = path.node.arguments[1];\n    if (configArg && t.isObjectExpression(configArg)) {\n      const seriesProp = configArg.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''series''\n      );\n      \n      if (seriesProp && t.isIdentifier(seriesProp.value)) {\n        // Track the variable name for later validation\n        context.apexSeriesVars = context.apexSeriesVars || new Set();\n        context.apexSeriesVars.add(seriesProp.value.name);\n      }\n    }\n  }\n  \n  // Check updateSeries calls\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''updateSeries'') {\n    const parent = path.parent;\n    if (t.isCallExpression(parent)) {\n      const arg = parent.arguments[0];\n      if (arg && t.isIdentifier(arg)) {\n        // Flag for validation - series data should be array of objects with name and data\n        context.violations.push({\n          type: ''warning'',\n          message: `Verify that ''$' + '{arg.name}'' is formatted as ApexCharts series: [{name: string, data: [{x, y}]}]`,\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Transform data to: selectedMetrics.map(metric => ({ name: metric, data: points.map(p => ({x: timestamp, y: value})) }))''\n        });\n      }\n    }\n  }\n  \n  // Look for common data format mistakes\n  if (t.isObjectExpression(path.node)) {\n    const hasDateProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''date''\n    );\n    const hasDurationProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''duration''\n    );\n    const hasCostProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''cost''\n    );\n    \n    // This looks like processed data that needs transformation\n    if (hasDateProp && (hasDurationProp || hasCostProp)) {\n      // Check if this is being passed to chart\n      let parent = path.parent;\n      let depth = 0;\n      while (parent && depth < 5) {\n        if (t.isJSXAttribute(parent) && parent.name?.name === ''seriesData'') {\n          context.violations.push({\n            type: ''error'',\n            message: ''Data structure {date, duration, cost} needs transformation to ApexCharts series format'',\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''Transform to: [{name: \"Duration\", data: [{x: timestamp, y: value}]}, ...]''\n          });\n          break;\n        }\n        parent = parent.parent;\n        depth++;\n      }\n    }\n  }\n}"
    },
    "checkChartRefManagement": {
      "description": "Ensure chart instances are properly stored in refs for exports",
      "severity": "high",
      "validate": "// Validates that chart instances are properly stored and exposed via refs\n(ast, path, t, context) => {\n  // Check for new ApexCharts creation\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const parent = path.parent;\n    \n    // Check if the chart instance is being stored\n    if (t.isVariableDeclarator(parent)) {\n      const varName = parent.id.name;\n      context.apexChartVars = context.apexChartVars || new Set();\n      context.apexChartVars.add(varName);\n      \n      // Now check if this variable is attached to a ref\n      const scope = path.scope;\n      const binding = scope.getBinding(varName);\n      if (binding) {\n        let isAttachedToRef = false;\n        \n        for (const refPath of binding.referencePaths) {\n          // Check for patterns like: chartRef.current = chart\n          if (t.isMemberExpression(refPath.parent) && \n              refPath.parent.property?.name === ''current'') {\n            isAttachedToRef = true;\n            break;\n          }\n          // Check for: chartRef.current._chart = chart\n          if (t.isMemberExpression(refPath.parent?.left) &&\n              refPath.parent?.left?.property?.name === ''_chart'') {\n            isAttachedToRef = true;\n            break;\n          }\n        }\n        \n        if (!isAttachedToRef) {\n          context.violations.push({\n            type: ''error'',  \n            message: `ApexCharts instance ''$' + '{varName}'' should be attached to a ref for export functionality`,\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''After creating chart, store it: chartRef.current = chart;''\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for dataURI usage without proper ref\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''dataURI'') {\n    const object = path.node.object;\n    \n    // Check if it''s accessing through a ref\n    if (t.isMemberExpression(object)) {\n      if (!object.property || object.property.name !== ''current'') {\n        context.violations.push({\n          type: ''warning'',\n          message: ''dataURI() should be called on chart instance stored in ref.current'',\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Use: chartRef.current?.dataURI() or chart.dataURI()''\n        });\n      }\n    }\n  }\n  \n  // Check for missing chart storage in useEffect\n  if (t.isCallExpression(path.node) && \n      t.isMemberExpression(path.node.callee) &&\n      path.node.callee.object?.name === ''chart'' &&\n      path.node.callee.property?.name === ''render'') {\n    \n    // Look for the chart variable in parent scope\n    let foundChartStorage = false;\n    let parent = path.parent;\n    let depth = 0;\n    \n    while (parent && depth < 10) {\n      if (t.isBlockStatement(parent)) {\n        // Check if chartRef.current is set in this block\n        const statements = parent.body;\n        foundChartStorage = statements.some(stmt => {\n          if (t.isExpressionStatement(stmt) && \n              t.isAssignmentExpression(stmt.expression)) {\n            const left = stmt.expression.left;\n            return t.isMemberExpression(left) && \n                   left.property?.name === ''current'';\n          }\n          return false;\n        });\n        \n        if (foundChartStorage) break;\n      }\n      parent = parent.parent;\n      depth++;\n    }\n    \n    if (!foundChartStorage) {\n      context.violations.push({\n        type: ''warning'',\n        message: ''Chart instance may not be stored in ref for export functionality'',\n        line: path.node.loc?.start.line,\n        column: path.node.loc?.start.column,\n        suggestion: ''Store chart in ref: chartRef.current = chart;''\n      });\n    }\n  }\n}"
    },
    "checkAnomalyFormat": {
      "description": "Validate anomaly data format for annotations",
      "severity": "medium",
      "validate": "// Validates that anomaly data for ApexCharts annotations is correctly formatted\n(ast, path, t, context) => {\n  // Look for annotations configuration in chart options\n  if (t.isObjectProperty(path.node) && \n      t.isIdentifier(path.node.key) && \n      path.node.key.name === ''annotations'') {\n    \n    const value = path.node.value;\n    if (t.isObjectExpression(value)) {\n      // Check for points property\n      const pointsProp = value.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''points''\n      );\n      \n      if (pointsProp) {\n        // Check if it''s mapping over anomalies\n        if (t.isCallExpression(pointsProp.value) && \n            t.isMemberExpression(pointsProp.value.callee) &&\n            pointsProp.value.callee.property?.name === ''map'') {\n          \n          const mapArg = pointsProp.value.arguments[0];\n          if (t.isArrowFunctionExpression(mapArg) || t.isFunctionExpression(mapArg)) {\n            const body = mapArg.body;\n            \n            // Check the structure being returned\n            if (t.isObjectExpression(body) || \n                (t.isBlockStatement(body) && body.body.length > 0)) {\n              \n              // Look for common mistakes\n              const checkForDateField = (obj) => {\n                if (t.isObjectExpression(obj)) {\n                  const hasDate = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''date''\n                  );\n                  const hasX = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''x''\n                  );\n                  \n                  if (hasDate && !hasX) {\n                    context.violations.push({\n                      type: ''error'',\n                      message: ''Anomaly annotations should use \"x\" property with timestamp, not \"date\"'',\n                      line: obj.loc?.start.line,\n                      column: obj.loc?.start.column,\n                      suggestion: ''Change to: { x: new Date(anomaly.date).getTime(), y: anomaly.value, ... }''\n                    });\n                  }\n                }\n              };\n              \n              if (t.isObjectExpression(body)) {\n                checkForDateField(body);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for anomaly data being set in state\n  if (t.isCallExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''setAnomalies'') {\n    \n    const arg = path.node.arguments[0];\n    if (t.isArrayExpression(arg) && arg.elements.length > 0) {\n      const firstElement = arg.elements[0];\n      \n      if (t.isObjectExpression(firstElement)) {\n        const hasDate = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''date''\n        );\n        const hasX = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''x''\n        );\n        \n        if (hasDate && !hasX) {\n          context.violations.push({\n            type: ''warning'',\n            message: ''Anomaly data should include \"x\" property for ApexCharts compatibility'',\n            line: firstElement.loc?.start.line,\n            column: firstElement.loc?.start.column,\n            suggestion: ''Include: { x: new Date(point.date), y: value, metric: metricName }''\n          });\n        }\n      }\n    }\n  }\n}"
    }
  }
}'
SET
  @ID_c06616c0 = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_c06616c0,
  @DisplayName = @DisplayName_c06616c0,
  @Version = @Version_c06616c0,
  @GlobalVariable = @GlobalVariable_c06616c0,
  @Category = @Category_c06616c0,
  @CDNUrl = @CDNUrl_c06616c0,
  @CDNCssUrl = @CDNCssUrl_c06616c0,
  @Description = @Description_c06616c0,
  @Status = @Status_c06616c0,
  @LintRules = @LintRules_c06616c0,
  @ID = @ID_c06616c0;


-- End of SQL Logging Session
-- Session ID: 9adb7a3d-3c52-4395-9ccf-e892c274b70c
-- Completed: 2025-08-20T21:50:43.976Z
-- Duration: 28483ms
-- Total Statements: 1





























-- SQL Logging Session
-- Session ID: 6eab4e48-0669-4607-aeb9-f467ecb45a4a
-- Started: 2025-08-20T22:48:44.820Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_3a49e3e6 NVARCHAR(500),
@DisplayName_3a49e3e6 NVARCHAR(500),
@Version_3a49e3e6 NVARCHAR(100),
@GlobalVariable_3a49e3e6 NVARCHAR(255),
@Category_3a49e3e6 NVARCHAR(100),
@CDNUrl_3a49e3e6 NVARCHAR(1000),
@CDNCssUrl_3a49e3e6 NVARCHAR(1000),
@Description_3a49e3e6 NVARCHAR(MAX),
@Status_3a49e3e6 NVARCHAR(20),
@LintRules_3a49e3e6 NVARCHAR(MAX),
@ID_3a49e3e6 UNIQUEIDENTIFIER
SET
  @Name_3a49e3e6 = N'd3'
SET
  @DisplayName_3a49e3e6 = N'D3.js'
SET
  @Version_3a49e3e6 = N'7.8.5'
SET
  @GlobalVariable_3a49e3e6 = N'd3'
SET
  @Category_3a49e3e6 = N'Charting'
SET
  @CDNUrl_3a49e3e6 = N'https://unpkg.com/d3@7.8.5/dist/d3.min.js'
SET
  @Description_3a49e3e6 = N'Data visualization library for creating custom charts'
SET
  @Status_3a49e3e6 = N'Active'
SET
  @LintRules_3a49e3e6 = N'{
  "initialization": {
    "factoryMethod": "select",
    "elementType": "svg",
    "requiresNew": false
  },
  "lifecycle": {
    "cleanupMethods": [
      "remove",
      "interrupt"
    ],
    "requiredMethods": [],
    "updateMethods": [
      "data",
      "attr",
      "style"
    ]
  },
  "validators": {
    "checkSelectionCleanup": {
      "description": "Ensure D3 selections are properly cleaned up",
      "severity": "medium",
      "validate": "/**\n * Ensure D3 selections are properly cleaned up\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for D3 selections in useEffect without cleanup\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.object) &&\n      path.node.callee.object.name === ''d3'' &&\n      t.isIdentifier(path.node.callee.property) &&\n      [''select'', ''selectAll''].includes(path.node.callee.property.name)) {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                hasCleanup = true;\n                break;\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''d3-missing-cleanup'',\n              severity: ''medium'',\n              message: ''D3 selections must be cleaned up in useEffect to prevent memory leaks'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { d3.select(ref.current).selectAll(\"*\").remove(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkJoinPattern": {
      "description": "Recommend modern join() pattern over enter/exit",
      "severity": "low",
      "validate": "/**\n * Recommend modern join() pattern over enter/exit\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for old enter/append pattern\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.property) &&\n      path.node.callee.property.name === ''enter'') {\n    \n    // Check if followed by append\n    if (t.isMemberExpression(path.parent) &&\n        path.parent.object === path.node &&\n        t.isCallExpression(path.parent.parent) &&\n        t.isIdentifier(path.parent.property) &&\n        path.parent.property.name === ''append'') {\n      \n      return {\n        rule: ''d3-use-join'',\n        severity: ''low'',\n        message: ''Consider using the modern .join() pattern instead of .enter().append()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''.join(\"element\") // Handles enter, update, and exit automatically''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_3a49e3e6 = '12416186-FBBD-4973-A7F4-D030FD84994B'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_3a49e3e6,
  @DisplayName = @DisplayName_3a49e3e6,
  @Version = @Version_3a49e3e6,
  @GlobalVariable = @GlobalVariable_3a49e3e6,
  @Category = @Category_3a49e3e6,
  @CDNUrl = @CDNUrl_3a49e3e6,
  @CDNCssUrl = @CDNCssUrl_3a49e3e6,
  @Description = @Description_3a49e3e6,
  @Status = @Status_3a49e3e6,
  @LintRules = @LintRules_3a49e3e6,
  @ID = @ID_3a49e3e6;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_c4777c51 NVARCHAR(500),
@DisplayName_c4777c51 NVARCHAR(500),
@Version_c4777c51 NVARCHAR(100),
@GlobalVariable_c4777c51 NVARCHAR(255),
@Category_c4777c51 NVARCHAR(100),
@CDNUrl_c4777c51 NVARCHAR(1000),
@CDNCssUrl_c4777c51 NVARCHAR(1000),
@Description_c4777c51 NVARCHAR(MAX),
@Status_c4777c51 NVARCHAR(20),
@LintRules_c4777c51 NVARCHAR(MAX),
@ID_c4777c51 UNIQUEIDENTIFIER
SET
  @Name_c4777c51 = N'chart.js'
SET
  @DisplayName_c4777c51 = N'Chart.js'
SET
  @Version_c4777c51 = N'4.4.1'
SET
  @GlobalVariable_c4777c51 = N'Chart'
SET
  @Category_c4777c51 = N'Charting'
SET
  @CDNUrl_c4777c51 = N'https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js'
SET
  @Description_c4777c51 = N'Simple yet flexible JavaScript charting library'
SET
  @Status_c4777c51 = N'Active'
SET
  @LintRules_c4777c51 = N'{
  "initialization": {
    "constructorName": "Chart",
    "requiresNew": true,
    "elementType": "canvas",
    "requiredConfig": [
      "type",
      "data"
    ]
  },
  "lifecycle": {
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "update"
    ],
    "requiredMethods": []
  },
  "validators": {
    "checkDestroyBeforeRecreate": {
      "description": "Ensure Chart instances are destroyed before recreating on same canvas",
      "severity": "medium",
      "validate": "/**\n * Ensure Chart instances are destroyed before recreating on same canvas\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context with libraryName, globalVariable, instanceVariables\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'') {\n    \n    // Check if we''re in a useEffect\n    let inUseEffect = false;\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        inUseEffect = true;\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n    \n    if (inUseEffect) {\n      // Look for cleanup function return\n      let hasCleanup = false;\n      const effectFn = useEffectPath.node.arguments[0];\n      if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n        // Check if it returns a cleanup function\n        const body = effectFn.body;\n        if (t.isBlockStatement(body)) {\n          for (const stmt of body.body) {\n            if (t.isReturnStatement(stmt) && stmt.argument) {\n              hasCleanup = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      if (!hasCleanup) {\n        return {\n          rule: ''chart-missing-cleanup'',\n          severity: ''medium'',\n          message: ''Chart.js instances must be destroyed in useEffect cleanup to prevent memory leaks'',\n          line: path.node.loc?.start.line || 0,\n          column: path.node.loc?.start.column || 0,\n          fix: ''return () => { chartInstance.current?.destroy(); }''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkCanvasContext": {
      "description": "Validate canvas context is obtained correctly",
      "severity": "high",
      "validate": "/**\n * Validate canvas context is obtained correctly\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'' &&\n      path.node.arguments[0]) {\n    \n    const firstArg = path.node.arguments[0];\n    \n    // Check if it''s a getContext(''2d'') call\n    if (t.isCallExpression(firstArg) &&\n        t.isMemberExpression(firstArg.callee) &&\n        t.isIdentifier(firstArg.callee.property) &&\n        firstArg.callee.property.name === ''getContext'') {\n      \n      const contextArg = firstArg.arguments[0];\n      if (!t.isStringLiteral(contextArg) || contextArg.value !== ''2d'') {\n        return {\n          rule: ''chart-invalid-context'',\n          severity: ''high'',\n          message: ''Chart.js requires a 2D canvas context'',\n          line: contextArg?.loc?.start.line || 0,\n          column: contextArg?.loc?.start.column || 0,\n          fix: \"getContext(''2d'')\"\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkChartRegistration": {
      "description": "Check for Chart.register() when using tree-shaking",
      "severity": "medium",
      "validate": "/**\n * Check for Chart.register() when using tree-shaking\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Only check if we see specific controller imports\n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js/auto'') {\n    return null; // auto import includes everything\n  }\n  \n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js'' &&\n      path.node.specifiers.some(spec => \n        t.isImportSpecifier(spec) &&\n        t.isIdentifier(spec.imported) &&\n        [''BarController'', ''LineController'', ''PieController''].includes(spec.imported.name)\n      )) {\n    \n    // Look for Chart.register call\n    let hasRegister = false;\n    ast.program.body.forEach(node => {\n      if (t.isExpressionStatement(node) &&\n          t.isCallExpression(node.expression) &&\n          t.isMemberExpression(node.expression.callee) &&\n          t.isIdentifier(node.expression.callee.object) &&\n          node.expression.callee.object.name === ''Chart'' &&\n          t.isIdentifier(node.expression.callee.property) &&\n          node.expression.callee.property.name === ''register'') {\n        hasRegister = true;\n      }\n    });\n    \n    if (!hasRegister) {\n      return {\n        rule: ''chart-missing-registration'',\n        severity: ''medium'',\n        message: ''When importing specific Chart.js components, you must call Chart.register()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''Chart.register(BarController, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_c4777c51 = '754D12D4-B182-45E8-B4BB-98FB8A366B02'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_c4777c51,
  @DisplayName = @DisplayName_c4777c51,
  @Version = @Version_c4777c51,
  @GlobalVariable = @GlobalVariable_c4777c51,
  @Category = @Category_c4777c51,
  @CDNUrl = @CDNUrl_c4777c51,
  @CDNCssUrl = @CDNCssUrl_c4777c51,
  @Description = @Description_c4777c51,
  @Status = @Status_c4777c51,
  @LintRules = @LintRules_c4777c51,
  @ID = @ID_c4777c51;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_feb863dd NVARCHAR(500),
@DisplayName_feb863dd NVARCHAR(500),
@Version_feb863dd NVARCHAR(100),
@GlobalVariable_feb863dd NVARCHAR(255),
@Category_feb863dd NVARCHAR(100),
@CDNUrl_feb863dd NVARCHAR(1000),
@CDNCssUrl_feb863dd NVARCHAR(1000),
@Description_feb863dd NVARCHAR(MAX),
@Status_feb863dd NVARCHAR(20),
@LintRules_feb863dd NVARCHAR(MAX),
@ID_feb863dd UNIQUEIDENTIFIER
SET
  @Name_feb863dd = N'ApexCharts'
SET
  @DisplayName_feb863dd = N'ApexCharts'
SET
  @Version_feb863dd = N'3.45.1'
SET
  @GlobalVariable_feb863dd = N'ApexCharts'
SET
  @Category_feb863dd = N'Charting'
SET
  @CDNUrl_feb863dd = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_feb863dd = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_feb863dd = N'Modern interactive JavaScript charts library'
SET
  @Status_feb863dd = N'Active'
SET
  @LintRules_feb863dd = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "medium",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''medium'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkSeriesDataFormat": {
      "description": "Validate data is in correct ApexCharts series format",
      "severity": "critical",
      "validate": "// Validates that data passed to ApexCharts is in the correct series format\n(ast, path, t, context) => {\n  // Look for chart creation or series updates\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const configArg = path.node.arguments[1];\n    if (configArg && t.isObjectExpression(configArg)) {\n      const seriesProp = configArg.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''series''\n      );\n      \n      if (seriesProp && t.isIdentifier(seriesProp.value)) {\n        // Track the variable name for later validation\n        context.apexSeriesVars = context.apexSeriesVars || new Set();\n        context.apexSeriesVars.add(seriesProp.value.name);\n      }\n    }\n  }\n  \n  // Check updateSeries calls\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''updateSeries'') {\n    const parent = path.parent;\n    if (t.isCallExpression(parent)) {\n      const arg = parent.arguments[0];\n      if (arg && t.isIdentifier(arg)) {\n        // Flag for validation - series data should be array of objects with name and data\n        context.violations.push({\n          type: ''warning'',\n          message: `Verify that ''$' + '{arg.name}'' is formatted as ApexCharts series: [{name: string, data: [{x, y}]}]`,\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Transform data to: selectedMetrics.map(metric => ({ name: metric, data: points.map(p => ({x: timestamp, y: value})) }))''\n        });\n      }\n    }\n  }\n  \n  // Look for common data format mistakes\n  if (t.isObjectExpression(path.node)) {\n    const hasDateProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''date''\n    );\n    const hasDurationProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''duration''\n    );\n    const hasCostProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''cost''\n    );\n    \n    // This looks like processed data that needs transformation\n    if (hasDateProp && (hasDurationProp || hasCostProp)) {\n      // Check if this is being passed to chart\n      let parent = path.parent;\n      let depth = 0;\n      while (parent && depth < 5) {\n        if (t.isJSXAttribute(parent) && parent.name?.name === ''seriesData'') {\n          context.violations.push({\n            type: ''error'',\n            message: ''Data structure {date, duration, cost} needs transformation to ApexCharts series format'',\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''Transform to: [{name: \"Duration\", data: [{x: timestamp, y: value}]}, ...]''\n          });\n          break;\n        }\n        parent = parent.parent;\n        depth++;\n      }\n    }\n  }\n}"
    },
    "checkChartRefManagement": {
      "description": "Ensure chart instances are properly stored in refs for exports",
      "severity": "high",
      "validate": "// Validates that chart instances are properly stored and exposed via refs\n(ast, path, t, context) => {\n  // Check for new ApexCharts creation\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const parent = path.parent;\n    \n    // Check if the chart instance is being stored\n    if (t.isVariableDeclarator(parent)) {\n      const varName = parent.id.name;\n      context.apexChartVars = context.apexChartVars || new Set();\n      context.apexChartVars.add(varName);\n      \n      // Now check if this variable is attached to a ref\n      const scope = path.scope;\n      const binding = scope.getBinding(varName);\n      if (binding) {\n        let isAttachedToRef = false;\n        \n        for (const refPath of binding.referencePaths) {\n          // Check for patterns like: chartRef.current = chart\n          if (t.isMemberExpression(refPath.parent) && \n              refPath.parent.property?.name === ''current'') {\n            isAttachedToRef = true;\n            break;\n          }\n          // Check for: chartRef.current._chart = chart\n          if (t.isMemberExpression(refPath.parent?.left) &&\n              refPath.parent?.left?.property?.name === ''_chart'') {\n            isAttachedToRef = true;\n            break;\n          }\n        }\n        \n        if (!isAttachedToRef) {\n          context.violations.push({\n            type: ''error'',  \n            message: `ApexCharts instance ''$' + '{varName}'' should be attached to a ref for export functionality`,\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''After creating chart, store it: chartRef.current = chart;''\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for dataURI usage without proper ref\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''dataURI'') {\n    const object = path.node.object;\n    \n    // Check if it''s accessing through a ref\n    if (t.isMemberExpression(object)) {\n      if (!object.property || object.property.name !== ''current'') {\n        context.violations.push({\n          type: ''warning'',\n          message: ''dataURI() should be called on chart instance stored in ref.current'',\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Use: chartRef.current?.dataURI() or chart.dataURI()''\n        });\n      }\n    }\n  }\n  \n  // Check for missing chart storage in useEffect\n  if (t.isCallExpression(path.node) && \n      t.isMemberExpression(path.node.callee) &&\n      path.node.callee.object?.name === ''chart'' &&\n      path.node.callee.property?.name === ''render'') {\n    \n    // Look for the chart variable in parent scope\n    let foundChartStorage = false;\n    let parent = path.parent;\n    let depth = 0;\n    \n    while (parent && depth < 10) {\n      if (t.isBlockStatement(parent)) {\n        // Check if chartRef.current is set in this block\n        const statements = parent.body;\n        foundChartStorage = statements.some(stmt => {\n          if (t.isExpressionStatement(stmt) && \n              t.isAssignmentExpression(stmt.expression)) {\n            const left = stmt.expression.left;\n            return t.isMemberExpression(left) && \n                   left.property?.name === ''current'';\n          }\n          return false;\n        });\n        \n        if (foundChartStorage) break;\n      }\n      parent = parent.parent;\n      depth++;\n    }\n    \n    if (!foundChartStorage) {\n      context.violations.push({\n        type: ''warning'',\n        message: ''Chart instance may not be stored in ref for export functionality'',\n        line: path.node.loc?.start.line,\n        column: path.node.loc?.start.column,\n        suggestion: ''Store chart in ref: chartRef.current = chart;''\n      });\n    }\n  }\n}"
    },
    "checkAnomalyFormat": {
      "description": "Validate anomaly data format for annotations",
      "severity": "medium",
      "validate": "// Validates that anomaly data for ApexCharts annotations is correctly formatted\n(ast, path, t, context) => {\n  // Look for annotations configuration in chart options\n  if (t.isObjectProperty(path.node) && \n      t.isIdentifier(path.node.key) && \n      path.node.key.name === ''annotations'') {\n    \n    const value = path.node.value;\n    if (t.isObjectExpression(value)) {\n      // Check for points property\n      const pointsProp = value.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''points''\n      );\n      \n      if (pointsProp) {\n        // Check if it''s mapping over anomalies\n        if (t.isCallExpression(pointsProp.value) && \n            t.isMemberExpression(pointsProp.value.callee) &&\n            pointsProp.value.callee.property?.name === ''map'') {\n          \n          const mapArg = pointsProp.value.arguments[0];\n          if (t.isArrowFunctionExpression(mapArg) || t.isFunctionExpression(mapArg)) {\n            const body = mapArg.body;\n            \n            // Check the structure being returned\n            if (t.isObjectExpression(body) || \n                (t.isBlockStatement(body) && body.body.length > 0)) {\n              \n              // Look for common mistakes\n              const checkForDateField = (obj) => {\n                if (t.isObjectExpression(obj)) {\n                  const hasDate = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''date''\n                  );\n                  const hasX = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''x''\n                  );\n                  \n                  if (hasDate && !hasX) {\n                    context.violations.push({\n                      type: ''error'',\n                      message: ''Anomaly annotations should use \"x\" property with timestamp, not \"date\"'',\n                      line: obj.loc?.start.line,\n                      column: obj.loc?.start.column,\n                      suggestion: ''Change to: { x: new Date(anomaly.date).getTime(), y: anomaly.value, ... }''\n                    });\n                  }\n                }\n              };\n              \n              if (t.isObjectExpression(body)) {\n                checkForDateField(body);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for anomaly data being set in state\n  if (t.isCallExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''setAnomalies'') {\n    \n    const arg = path.node.arguments[0];\n    if (t.isArrayExpression(arg) && arg.elements.length > 0) {\n      const firstElement = arg.elements[0];\n      \n      if (t.isObjectExpression(firstElement)) {\n        const hasDate = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''date''\n        );\n        const hasX = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''x''\n        );\n        \n        if (hasDate && !hasX) {\n          context.violations.push({\n            type: ''warning'',\n            message: ''Anomaly data should include \"x\" property for ApexCharts compatibility'',\n            line: firstElement.loc?.start.line,\n            column: firstElement.loc?.start.column,\n            suggestion: ''Include: { x: new Date(point.date), y: value, metric: metricName }''\n          });\n        }\n      }\n    }\n  }\n}"
    }
  }
}'
SET
  @ID_feb863dd = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_feb863dd,
  @DisplayName = @DisplayName_feb863dd,
  @Version = @Version_feb863dd,
  @GlobalVariable = @GlobalVariable_feb863dd,
  @Category = @Category_feb863dd,
  @CDNUrl = @CDNUrl_feb863dd,
  @CDNCssUrl = @CDNCssUrl_feb863dd,
  @Description = @Description_feb863dd,
  @Status = @Status_feb863dd,
  @LintRules = @LintRules_feb863dd,
  @ID = @ID_feb863dd;


-- End of SQL Logging Session
-- Session ID: 6eab4e48-0669-4607-aeb9-f467ecb45a4a
-- Completed: 2025-08-20T22:49:08.684Z
-- Duration: 23864ms
-- Total Statements: 3





















-- SQL Logging Session
-- Session ID: 5c7e4cb5-acd4-4d70-a012-b57351fb9209
-- Started: 2025-08-21T02:17:28.897Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_59218d6b NVARCHAR(500),
@DisplayName_59218d6b NVARCHAR(500),
@Version_59218d6b NVARCHAR(100),
@GlobalVariable_59218d6b NVARCHAR(255),
@Category_59218d6b NVARCHAR(100),
@CDNUrl_59218d6b NVARCHAR(1000),
@CDNCssUrl_59218d6b NVARCHAR(1000),
@Description_59218d6b NVARCHAR(MAX),
@Status_59218d6b NVARCHAR(20),
@LintRules_59218d6b NVARCHAR(MAX),
@ID_59218d6b UNIQUEIDENTIFIER
SET
  @Name_59218d6b = N'd3'
SET
  @DisplayName_59218d6b = N'D3.js'
SET
  @Version_59218d6b = N'7.8.5'
SET
  @GlobalVariable_59218d6b = N'd3'
SET
  @Category_59218d6b = N'Charting'
SET
  @CDNUrl_59218d6b = N'https://unpkg.com/d3@7.8.5/dist/d3.min.js'
SET
  @Description_59218d6b = N'Data visualization library for creating custom charts'
SET
  @Status_59218d6b = N'Active'
SET
  @LintRules_59218d6b = N'{
  "initialization": {
    "factoryMethod": "select",
    "elementType": "svg",
    "requiresNew": false
  },
  "lifecycle": {
    "cleanupMethods": [
      "remove",
      "interrupt"
    ],
    "requiredMethods": [],
    "updateMethods": [
      "data",
      "attr",
      "style"
    ]
  },
  "validators": {
    "checkSelectionCleanup": {
      "description": "Ensure D3 selections are properly cleaned up",
      "severity": "high",
      "validate": "/**\n * Ensure D3 selections are properly cleaned up\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for D3 selections in useEffect without cleanup\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.object) &&\n      path.node.callee.object.name === ''d3'' &&\n      t.isIdentifier(path.node.callee.property) &&\n      [''select'', ''selectAll''].includes(path.node.callee.property.name)) {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                hasCleanup = true;\n                break;\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''d3-missing-cleanup'',\n              severity: ''high'',\n              message: ''D3 selections must be cleaned up in useEffect to prevent memory leaks'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { d3.select(ref.current).selectAll(\"*\").remove(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkJoinPattern": {
      "description": "Recommend modern join() pattern over enter/exit",
      "severity": "low",
      "validate": "/**\n * Recommend modern join() pattern over enter/exit\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for old enter/append pattern\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.property) &&\n      path.node.callee.property.name === ''enter'') {\n    \n    // Check if followed by append\n    if (t.isMemberExpression(path.parent) &&\n        path.parent.object === path.node &&\n        t.isCallExpression(path.parent.parent) &&\n        t.isIdentifier(path.parent.property) &&\n        path.parent.property.name === ''append'') {\n      \n      return {\n        rule: ''d3-use-join'',\n        severity: ''low'',\n        message: ''Consider using the modern .join() pattern instead of .enter().append()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''.join(\"element\") // Handles enter, update, and exit automatically''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_59218d6b = '12416186-FBBD-4973-A7F4-D030FD84994B'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_59218d6b,
  @DisplayName = @DisplayName_59218d6b,
  @Version = @Version_59218d6b,
  @GlobalVariable = @GlobalVariable_59218d6b,
  @Category = @Category_59218d6b,
  @CDNUrl = @CDNUrl_59218d6b,
  @CDNCssUrl = @CDNCssUrl_59218d6b,
  @Description = @Description_59218d6b,
  @Status = @Status_59218d6b,
  @LintRules = @LintRules_59218d6b,
  @ID = @ID_59218d6b;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_e5a4c001 NVARCHAR(500),
@DisplayName_e5a4c001 NVARCHAR(500),
@Version_e5a4c001 NVARCHAR(100),
@GlobalVariable_e5a4c001 NVARCHAR(255),
@Category_e5a4c001 NVARCHAR(100),
@CDNUrl_e5a4c001 NVARCHAR(1000),
@CDNCssUrl_e5a4c001 NVARCHAR(1000),
@Description_e5a4c001 NVARCHAR(MAX),
@Status_e5a4c001 NVARCHAR(20),
@LintRules_e5a4c001 NVARCHAR(MAX),
@ID_e5a4c001 UNIQUEIDENTIFIER
SET
  @Name_e5a4c001 = N'chart.js'
SET
  @DisplayName_e5a4c001 = N'Chart.js'
SET
  @Version_e5a4c001 = N'4.4.1'
SET
  @GlobalVariable_e5a4c001 = N'Chart'
SET
  @Category_e5a4c001 = N'Charting'
SET
  @CDNUrl_e5a4c001 = N'https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js'
SET
  @Description_e5a4c001 = N'Simple yet flexible JavaScript charting library'
SET
  @Status_e5a4c001 = N'Active'
SET
  @LintRules_e5a4c001 = N'{
  "initialization": {
    "constructorName": "Chart",
    "requiresNew": true,
    "elementType": "canvas",
    "requiredConfig": [
      "type",
      "data"
    ]
  },
  "lifecycle": {
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "update"
    ],
    "requiredMethods": []
  },
  "validators": {
    "checkDestroyBeforeRecreate": {
      "description": "Ensure Chart instances are destroyed before recreating on same canvas",
      "severity": "high",
      "validate": "/**\n * Ensure Chart instances are destroyed before recreating on same canvas\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context with libraryName, globalVariable, instanceVariables\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'') {\n    \n    // Check if we''re in a useEffect\n    let inUseEffect = false;\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        inUseEffect = true;\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n    \n    if (inUseEffect) {\n      // Look for cleanup function return\n      let hasCleanup = false;\n      const effectFn = useEffectPath.node.arguments[0];\n      if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n        // Check if it returns a cleanup function\n        const body = effectFn.body;\n        if (t.isBlockStatement(body)) {\n          for (const stmt of body.body) {\n            if (t.isReturnStatement(stmt) && stmt.argument) {\n              hasCleanup = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      if (!hasCleanup) {\n        return {\n          rule: ''chart-missing-cleanup'',\n          severity: ''high'',\n          message: ''Chart.js instances must be destroyed in useEffect cleanup to prevent memory leaks'',\n          line: path.node.loc?.start.line || 0,\n          column: path.node.loc?.start.column || 0,\n          fix: ''return () => { chartInstance.current?.destroy(); }''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkCanvasContext": {
      "description": "Validate canvas context is obtained correctly",
      "severity": "high",
      "validate": "/**\n * Validate canvas context is obtained correctly\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'' &&\n      path.node.arguments[0]) {\n    \n    const firstArg = path.node.arguments[0];\n    \n    // Check if it''s a getContext(''2d'') call\n    if (t.isCallExpression(firstArg) &&\n        t.isMemberExpression(firstArg.callee) &&\n        t.isIdentifier(firstArg.callee.property) &&\n        firstArg.callee.property.name === ''getContext'') {\n      \n      const contextArg = firstArg.arguments[0];\n      if (!t.isStringLiteral(contextArg) || contextArg.value !== ''2d'') {\n        return {\n          rule: ''chart-invalid-context'',\n          severity: ''high'',\n          message: ''Chart.js requires a 2D canvas context'',\n          line: contextArg?.loc?.start.line || 0,\n          column: contextArg?.loc?.start.column || 0,\n          fix: \"getContext(''2d'')\"\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkChartRegistration": {
      "description": "Check for Chart.register() when using tree-shaking",
      "severity": "medium",
      "validate": "/**\n * Check for Chart.register() when using tree-shaking\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Only check if we see specific controller imports\n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js/auto'') {\n    return null; // auto import includes everything\n  }\n  \n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js'' &&\n      path.node.specifiers.some(spec => \n        t.isImportSpecifier(spec) &&\n        t.isIdentifier(spec.imported) &&\n        [''BarController'', ''LineController'', ''PieController''].includes(spec.imported.name)\n      )) {\n    \n    // Look for Chart.register call\n    let hasRegister = false;\n    ast.program.body.forEach(node => {\n      if (t.isExpressionStatement(node) &&\n          t.isCallExpression(node.expression) &&\n          t.isMemberExpression(node.expression.callee) &&\n          t.isIdentifier(node.expression.callee.object) &&\n          node.expression.callee.object.name === ''Chart'' &&\n          t.isIdentifier(node.expression.callee.property) &&\n          node.expression.callee.property.name === ''register'') {\n        hasRegister = true;\n      }\n    });\n    \n    if (!hasRegister) {\n      return {\n        rule: ''chart-missing-registration'',\n        severity: ''medium'',\n        message: ''When importing specific Chart.js components, you must call Chart.register()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''Chart.register(BarController, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_e5a4c001 = '754D12D4-B182-45E8-B4BB-98FB8A366B02'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_e5a4c001,
  @DisplayName = @DisplayName_e5a4c001,
  @Version = @Version_e5a4c001,
  @GlobalVariable = @GlobalVariable_e5a4c001,
  @Category = @Category_e5a4c001,
  @CDNUrl = @CDNUrl_e5a4c001,
  @CDNCssUrl = @CDNCssUrl_e5a4c001,
  @Description = @Description_e5a4c001,
  @Status = @Status_e5a4c001,
  @LintRules = @LintRules_e5a4c001,
  @ID = @ID_e5a4c001;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_3707bf65 NVARCHAR(500),
@DisplayName_3707bf65 NVARCHAR(500),
@Version_3707bf65 NVARCHAR(100),
@GlobalVariable_3707bf65 NVARCHAR(255),
@Category_3707bf65 NVARCHAR(100),
@CDNUrl_3707bf65 NVARCHAR(1000),
@CDNCssUrl_3707bf65 NVARCHAR(1000),
@Description_3707bf65 NVARCHAR(MAX),
@Status_3707bf65 NVARCHAR(20),
@LintRules_3707bf65 NVARCHAR(MAX),
@ID_3707bf65 UNIQUEIDENTIFIER
SET
  @Name_3707bf65 = N'ApexCharts'
SET
  @DisplayName_3707bf65 = N'ApexCharts'
SET
  @Version_3707bf65 = N'3.45.1'
SET
  @GlobalVariable_3707bf65 = N'ApexCharts'
SET
  @Category_3707bf65 = N'Charting'
SET
  @CDNUrl_3707bf65 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_3707bf65 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_3707bf65 = N'Modern interactive JavaScript charts library'
SET
  @Status_3707bf65 = N'Active'
SET
  @LintRules_3707bf65 = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "high",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''high'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkSeriesDataFormat": {
      "description": "Validate data is in correct ApexCharts series format",
      "severity": "critical",
      "validate": "// Validates that data passed to ApexCharts is in the correct series format\n(ast, path, t, context) => {\n  // Look for chart creation or series updates\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const configArg = path.node.arguments[1];\n    if (configArg && t.isObjectExpression(configArg)) {\n      const seriesProp = configArg.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''series''\n      );\n      \n      if (seriesProp && t.isIdentifier(seriesProp.value)) {\n        // Track the variable name for later validation\n        context.apexSeriesVars = context.apexSeriesVars || new Set();\n        context.apexSeriesVars.add(seriesProp.value.name);\n      }\n    }\n  }\n  \n  // Check updateSeries calls\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''updateSeries'') {\n    const parent = path.parent;\n    if (t.isCallExpression(parent)) {\n      const arg = parent.arguments[0];\n      if (arg && t.isIdentifier(arg)) {\n        // Flag for validation - series data should be array of objects with name and data\n        context.violations.push({\n          severity: ''medium'',\n          message: `Verify that ''$' + '{arg.name}'' is formatted as ApexCharts series: [{name: string, data: [{x, y}]}]`,\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Transform data to: selectedMetrics.map(metric => ({ name: metric, data: points.map(p => ({x: timestamp, y: value})) }))''\n        });\n      }\n    }\n  }\n  \n  // Look for common data format mistakes\n  if (t.isObjectExpression(path.node)) {\n    const hasDateProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''date''\n    );\n    const hasDurationProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''duration''\n    );\n    const hasCostProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''cost''\n    );\n    \n    // This looks like processed data that needs transformation\n    if (hasDateProp && (hasDurationProp || hasCostProp)) {\n      // Check if this is being passed to chart\n      let parent = path.parent;\n      let depth = 0;\n      while (parent && depth < 5) {\n        if (t.isJSXAttribute(parent) && parent.name?.name === ''seriesData'') {\n          context.violations.push({\n            severity: ''critical'',\n            message: ''Data structure {date, duration, cost} needs transformation to ApexCharts series format'',\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''Transform to: [{name: \"Duration\", data: [{x: timestamp, y: value}]}, ...]''\n          });\n          break;\n        }\n        parent = parent.parent;\n        depth++;\n      }\n    }\n  }\n}"
    },
    "checkChartRefManagement": {
      "description": "Ensure chart instances are properly stored in refs for exports",
      "severity": "low",
      "validate": "// Validates that chart instances are properly stored and exposed via refs\n(ast, path, t, context) => {\n  // Initialize tracking sets if not already done\n  context.apexChartVars = context.apexChartVars || new Set();\n  context.apexChartVarsWithRefWarning = context.apexChartVarsWithRefWarning || new Set();\n  \n  // Check for new ApexCharts creation\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const parent = path.parent;\n    \n    // Check if the chart instance is being stored\n    if (t.isVariableDeclarator(parent)) {\n      const varName = parent.id.name;\n      context.apexChartVars.add(varName);\n      \n      // Now check if this variable is attached to a ref\n      const scope = path.scope;\n      const binding = scope.getBinding(varName);\n      if (binding) {\n        let isAttachedToRef = false;\n        \n        for (const refPath of binding.referencePaths) {\n          // Check for patterns like: chartRef.current = chart\n          if (t.isAssignmentExpression(refPath.parent) &&\n              t.isMemberExpression(refPath.parent.left) && \n              refPath.parent.left.property?.name === ''current'') {\n            isAttachedToRef = true;\n            break;\n          }\n          // Check for: chartRef.current._chart = chart\n          if (t.isAssignmentExpression(refPath.parent) &&\n              t.isMemberExpression(refPath.parent.left) &&\n              refPath.parent.left.property?.name === ''_chart'') {\n            isAttachedToRef = true;\n            break;\n          }\n        }\n        \n        if (!isAttachedToRef) {\n          // Mark that we already warned about this chart variable\n          context.apexChartVarsWithRefWarning.add(varName);\n          context.violations.push({\n            severity: ''low'',  \n            message: `ApexCharts instance ''$' + '{varName}'' should be attached to a ref for export functionality`,\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''After creating chart, store it: chartRef.current = chart;''\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for dataURI usage without proper ref\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''dataURI'') {\n    const object = path.node.object;\n    \n    // Check if it''s accessing through a ref\n    if (t.isMemberExpression(object)) {\n      if (!object.property || object.property.name !== ''current'') {\n        context.violations.push({\n          severity: ''low'',\n          message: ''dataURI() should be called on chart instance stored in ref.current'',\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Use: chartRef.current?.dataURI() or chart.dataURI()''\n        });\n      }\n    }\n  }\n  \n  // Check for chart.render() calls - but skip if we already warned about this chart variable\n  if (t.isCallExpression(path.node) && \n      t.isMemberExpression(path.node.callee) &&\n      path.node.callee.object?.name === ''chart'' &&\n      path.node.callee.property?.name === ''render'') {\n    \n    const chartVarName = path.node.callee.object.name;\n    \n    // Skip if we already warned about this chart variable not being in a ref\n    if (context.apexChartVarsWithRefWarning && context.apexChartVarsWithRefWarning.has(chartVarName)) {\n      return; // Don''t duplicate the warning\n    }\n    \n    // Also skip if this chart variable was properly created and tracked\n    if (context.apexChartVars && context.apexChartVars.has(chartVarName)) {\n      // We already checked this variable when it was created\n      return;\n    }\n    \n    // This is a render() call on a chart we haven''t seen created (might be from props/params)\n    // Check if it''s stored in a ref in the current scope\n    let foundChartStorage = false;\n    let currentPath = path;\n    \n    // Look up the tree for the containing function/block\n    while (currentPath && !t.isFunctionDeclaration(currentPath.node) && \n           !t.isFunctionExpression(currentPath.node) && \n           !t.isArrowFunctionExpression(currentPath.node)) {\n      currentPath = currentPath.parentPath;\n    }\n    \n    if (currentPath) {\n      // Check if chartRef.current = chart exists in this scope\n      currentPath.traverse({\n        AssignmentExpression(assignPath) {\n          if (t.isMemberExpression(assignPath.node.left) &&\n              assignPath.node.left.property?.name === ''current'' &&\n              t.isIdentifier(assignPath.node.right) &&\n              assignPath.node.right.name === chartVarName) {\n            foundChartStorage = true;\n          }\n        }\n      });\n    }\n    \n    if (!foundChartStorage) {\n      context.violations.push({\n        severity: ''low'',\n        message: `Chart instance ''$' + '{chartVarName}'' may not be stored in ref for export functionality`,\n        line: path.node.loc?.start.line,\n        column: path.node.loc?.start.column,\n        suggestion: ''Store chart in ref: chartRef.current = chart;''\n      });\n    }\n  }\n}"
    },
    "checkAnomalyFormat": {
      "description": "Validate anomaly data format for annotations",
      "severity": "medium",
      "validate": "// Validates that anomaly data for ApexCharts annotations is correctly formatted\n(ast, path, t, context) => {\n  // Look for annotations configuration in chart options\n  if (t.isObjectProperty(path.node) && \n      t.isIdentifier(path.node.key) && \n      path.node.key.name === ''annotations'') {\n    \n    const value = path.node.value;\n    if (t.isObjectExpression(value)) {\n      // Check for points property\n      const pointsProp = value.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''points''\n      );\n      \n      if (pointsProp) {\n        // Check if it''s mapping over anomalies\n        if (t.isCallExpression(pointsProp.value) && \n            t.isMemberExpression(pointsProp.value.callee) &&\n            pointsProp.value.callee.property?.name === ''map'') {\n          \n          const mapArg = pointsProp.value.arguments[0];\n          if (t.isArrowFunctionExpression(mapArg) || t.isFunctionExpression(mapArg)) {\n            const body = mapArg.body;\n            \n            // Check the structure being returned\n            if (t.isObjectExpression(body) || \n                (t.isBlockStatement(body) && body.body.length > 0)) {\n              \n              // Look for common mistakes\n              const checkForDateField = (obj) => {\n                if (t.isObjectExpression(obj)) {\n                  const hasDate = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''date''\n                  );\n                  const hasX = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''x''\n                  );\n                  \n                  if (hasDate && !hasX) {\n                    context.violations.push({\n                      severity: ''critical'',\n                      message: ''Anomaly annotations should use \"x\" property with timestamp, not \"date\"'',\n                      line: obj.loc?.start.line,\n                      column: obj.loc?.start.column,\n                      suggestion: ''Change to: { x: new Date(anomaly.date).getTime(), y: anomaly.value, ... }''\n                    });\n                  }\n                }\n              };\n              \n              if (t.isObjectExpression(body)) {\n                checkForDateField(body);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for anomaly data being set in state\n  if (t.isCallExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''setAnomalies'') {\n    \n    const arg = path.node.arguments[0];\n    if (t.isArrayExpression(arg) && arg.elements.length > 0) {\n      const firstElement = arg.elements[0];\n      \n      if (t.isObjectExpression(firstElement)) {\n        const hasDate = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''date''\n        );\n        const hasX = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''x''\n        );\n        \n        if (hasDate && !hasX) {\n          context.violations.push({\n            severity: ''medium'',\n            message: ''Anomaly data should include \"x\" property for ApexCharts compatibility'',\n            line: firstElement.loc?.start.line,\n            column: firstElement.loc?.start.column,\n            suggestion: ''Include: { x: new Date(point.date), y: value, metric: metricName }''\n          });\n        }\n      }\n    }\n  }\n}"
    }
  }
}'
SET
  @ID_3707bf65 = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_3707bf65,
  @DisplayName = @DisplayName_3707bf65,
  @Version = @Version_3707bf65,
  @GlobalVariable = @GlobalVariable_3707bf65,
  @Category = @Category_3707bf65,
  @CDNUrl = @CDNUrl_3707bf65,
  @CDNCssUrl = @CDNCssUrl_3707bf65,
  @Description = @Description_3707bf65,
  @Status = @Status_3707bf65,
  @LintRules = @LintRules_3707bf65,
  @ID = @ID_3707bf65;


-- End of SQL Logging Session
-- Session ID: 5c7e4cb5-acd4-4d70-a012-b57351fb9209
-- Completed: 2025-08-21T02:17:54.396Z
-- Duration: 25499ms
-- Total Statements: 3
















































































-- SQL Logging Session
-- Session ID: b713aa64-9012-4492-ac13-76bacd14f71d
-- Started: 2025-08-21T12:14:28.464Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save Template Contents (core SP call only)
DECLARE @TemplateID_8cc7cf5d UNIQUEIDENTIFIER,
@TypeID_8cc7cf5d UNIQUEIDENTIFIER,
@TemplateText_8cc7cf5d NVARCHAR(MAX),
@Priority_8cc7cf5d INT,
@IsActive_8cc7cf5d BIT,
@ID_8cc7cf5d UNIQUEIDENTIFIER
SET
  @TemplateID_8cc7cf5d = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @TypeID_8cc7cf5d = 'E7AFCCEC-6A37-EF11-86D4-000D3A4E707E'
SET
  @TemplateText_8cc7cf5d = N'# Flow Agent System Prompt

You are executing a step in a deterministic workflow. Your role is to make decisions at key decision points when the workflow requires AI-driven judgment.

# Response Format
Return ONLY valid JSON with your decision:

```typescript
interface FlowAgentPromptResponse {
    // The name of the next step to execute (if you know specific steps)
    nextStepName?: string;
    
    // Your reasoning for this decision
    reasoning?: string;
    
    // Confidence level (0.0-1.0) in your decision
    confidence?: number;
    
    // Set to true if the workflow should terminate
    terminate?: boolean;
    
    // Optional message about your decision
    message?: string;
}
```

## Example Response
```json
{
    "nextStepName": "Manual Review Required",
    "reasoning": "The order amount exceeds the automatic approval threshold and contains restricted items",
    "confidence": 0.95,
    "terminate": false,
    "message": "Routing to manual review due to high value and restricted items"
}
```

## Important Rules
- If you determine the workflow should end, set `terminate: true`
- If you''re unsure about available steps, explain your reasoning without specifying `nextStepName`
- Always provide clear reasoning for your decision
- Consider edge cases and error conditions

## Current Flow Context
**Current Step:** {{ flowContext.currentStepId }}
**Completed Steps:** {{ flowContext.completedSteps | length }}
**Execution Path:** {{ flowContext.executionPath | join(''  '') }}

**Payload State:**
```json
{{ _CURRENT_PAYLOAD | dump | safe }}
```

## Your Task
You are at a decision point in the workflow. Based on the current state and the available information, you need to determine the next step to execute.

{%- if availableNextSteps %}
## Available Next Steps
The following steps are potential next actions in this workflow:
{{ availableNextSteps | safe }}
{%- endif %}

## Decision Criteria
Consider the following when making your decision:
1. Current payload state and any recent changes
2. Results from previous steps in the execution path
3. The overall goal of the workflow
4. Any business rules or constraints

{%- if decisionGuidance %}
## Specific Guidance
{{ decisionGuidance | safe }}
{%- endif %}

# Agent: {{ agentName }}
{{ agentDescription | safe }}

## Workflow Description
{{ agentSpecificPrompt | safe }}

# **CRITICAL**
- Your **entire** response must be only JSON with no leading or trailing characters!
- Your response must adhere to the [FlowAgentPromptResponse interface](#response-format)'
SET
  @Priority_8cc7cf5d = 1
SET
  @IsActive_8cc7cf5d = 1
SET
  @ID_8cc7cf5d = '06ECFDB2-BBED-45F6-A04A-02062FD8E887'
EXEC [${flyway:defaultSchema}].spUpdateTemplateContent @TemplateID = @TemplateID_8cc7cf5d,
  @TypeID = @TypeID_8cc7cf5d,
  @TemplateText = @TemplateText_8cc7cf5d,
  @Priority = @Priority_8cc7cf5d,
  @IsActive = @IsActive_8cc7cf5d,
  @ID = @ID_8cc7cf5d;

-- Save Template Contents (core SP call only)
DECLARE @TemplateID_0ffae226 UNIQUEIDENTIFIER,
@TypeID_0ffae226 UNIQUEIDENTIFIER,
@TemplateText_0ffae226 NVARCHAR(MAX),
@Priority_0ffae226 INT,
@IsActive_0ffae226 BIT,
@ID_0ffae226 UNIQUEIDENTIFIER
SET
  @TemplateID_0ffae226 = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @TypeID_0ffae226 = 'E7AFCCEC-6A37-EF11-86D4-000D3A4E707E'
SET
  @TemplateText_0ffae226 = N'# Loop Agent System Prompt

You operate in a continuous loop pattern, working iteratively to complete the user''s goal.

# Response Format
Return ONLY JSON adhering to the interface `LoopAgentResponse`
```ts
import { AgentPayloadChangeRequest } from "@memberjunction/ai-core-plus";

/**
 * Response structure for Loop Agent Type
 */
export interface LoopAgentResponse<P = any> {
    /**
     * Task completion status. true = terminate loop, false = continue
     */
    taskComplete?: boolean;
    
    /**
     * Plain text message (<100 words). Required for ''Chat'' type, omit for others
     */
    message?: string;

    /**
     * Payload changes. Omit if no changes needed
     */
    payloadChangeRequest?: AgentPayloadChangeRequest<P>;
    
    /**
     * Internal reasoning for debugging
     */
    reasoning?: string;
    
    /**
     * Confidence level (0.0-1.0)
     */
    confidence?: number;

    /**
     * Next action. Required when taskComplete=false
     */
    nextStep?: {
        /**
         * Operation type: ''Actions'' | ''Sub-Agent'' | ''Chat''
         */
        type: ''Actions'' | ''Sub-Agent'' | ''Chat'';
        
        /**
         * Actions to execute (when type=''Actions'')
         */
        actions?: Array<{
            name: string;
            params: Record<string, unknown>;
        }>;
         
        /**
         * Sub-agent details (when type=''Sub-Agent'')
         */
        subAgent?: {
            name: string;

            /**
             * Instructions for the sub-agent, NOT the payload, that is handled elsewhere
             */
            message: string;  

            /**
             * Extra parameters - NOT the payload, only use these if the sub-agent 
             * specifically **defines** parameters in its metadata, otherwise these will be
             * ignored and waste tokens!
             */
            templateParameters?: Record<string, any>;

            /**
             * true=end parent, false=continue
             */
            terminateAfter: boolean; 
        };
    };
}

//\n/**
 * Defines a structured way to request changes to the payload. If you are making a COMPLEX change to an object
 * you can either use `updateElements` as described below to make **surgical** changes to the payload, OR, a simple
 * approach is to use `replaceElements` to remove the entire object and replace it with a new object.
 * 
 * If you are providing the ENTIRE object again, use the **replaceElements** instead of **updateElements** approach like this:
 * {
 *   replaceElements: {
 *     user: { // user object will REPLACE the entire existing object
 *       id: "new-id",
 *       name: "new-name"
 *       moreComplexData: {
 *         keyA: "valA",
 *         keyB: "valB"
 *       }
 *     }
 *   }
 * }
 * 
 * Alternatively, to make surgical changes review the documentation below for @see updateElements where you can make
 * small incremental additions/updates/removals to the payload which is more token efficient and cleaner.
 */
export type AgentPayloadChangeRequest<P = any> = {
    /**
     * A partial of P that includes all new elements added that were **not** previously present in
     * the payload prior to the prompt execution. This allows the AI to specify the new elements
     * to be added clearly here. The structure is identical to the payload type P with just the
     * portions filled out that need to be added.
     * 
     * To add a new item:
     * 
     * {    
     *   "newItem": "newValue"
     * }
     * To add multiple new items:
     * 
     * {
     *   newItem1: "newValue1",
     *   newItem2: "newValue2"
     * }
     */
    newElements?: Partial<P>;

    /**
     * A partial of P that includes all elements that should be updated in the payload.
     * The structure is identical to the payload type P with just the portions filled out
     * that need to be updated. **DO NOT INCLUDE ELEMENTS THAT ARE NOT CHANGING**.
     * 
     * Example - update single item:
     *  {
     *     "itemToUpdate": "newValue"
     *  }
     * 
     *  To update multiple items:
     *  {
     *      itemToUpdate1: "newValue1",
     *      itemToUpdate2: "newValue2"
     *  }
     * 
     *  Arrays: Include placeholder objects `{}` for items that are being kept in the array.
     *  For example, if the payload was:
     *  {
     *      items: [
     *          {}, // placeholder object is ignored
     *          { someKey: ''this is a new value for someKey'' },
     *          {} // placeholder object is ignored - since it is trailing, can be ommitted, this is for illustration
     *      ]
     *  }
     * 
     * DELETION WITHIN UPDATES:
     * You can use "__DELETE__" within updateElements to remove properties or array elements at any depth:
     * 
     * Deleting object properties:
     * {
     *   updateElements: {
     *     user: {
     *       name: "New Name",      // update this property
     *       tempData: "__DELETE__"   // remove this property
     *     }
     *   }
     * }
     * 
     * Deleting array elements:
     * {
     *   updateElements: {
     *     items: [
     *       {},          // keep item 0
     *       "__DELETE__",  // remove item 1
     *       { value: 5 }, // update item 2
     *       "__DELETE__"   // remove item 3
     *     ]
     *   }
     * }
     * 
     * Complex nested example - updating and deleting within deep structures:
     * {
     *   updateElements: {
     *     dataRequirements: {
     *       dynamicData: {
     *         requiredEntities: [
     *           {
     *             displayFields: ["Name", "UpdatedAt"], // update array
     *             fieldMetadata: [
     *               {},          // keep field 0
     *               {},          // keep field 1
     *               {},          // keep field 2
     *               "__DELETE__"   // remove field 3 (e.g., LastUpdated)
     *             ],
     *             oldProperty: "__DELETE__"  // remove this property
     *           }
     *         ]
     *       }
     *     }
     *   }
     * }
     * 
     * IMPORTANT: When using "__DELETE__" in arrays, deletions are processed after updates at each depth level,
     * ensuring correct index management. Multiple deletions in the same array are handled properly.
     * 
     * Alternative for complete replacement: If you need to completely replace a complex structure,
     * you can use replaceElements pattern INSTEAD of updateElements:
     * {
     *   replaceElements: { complexObject: { keyA: "valA", keyB: "valB" } } // This replaces the entire complexObject
     * }
     */
    updateElements?: Partial<P>;

    /**
     * This partial of P includes all elements that should be replaced in the payload.
     * The structure is identical to the payload type P with just the portions filled out
     * that need to be replaced. This is useful when you want to replace an entire object
     * or array with a new version. See @see updateElements for surgical updates instead of doing
     * complete replacements.
     */
    replaceElements?: Partial<P>;

    /**
     * This partial of P includes all elements that should be removed from the payload. When an
     * item needs to be removed, include the item here with a value of "__DELETE__".
     * 
     * For 1 removal:
     * {
     *   itemToRemove: ''__DELETE__''
     * }
     * 
     * This indicates that the itemToRemove should be removed from the payload.
     * 
     * For multiple removals:
     * {
     *   itemToRemove1: ''__DELETE__'',
     *   itemToRemove2: ''__DELETE__''
     * }
     * 
     * Arrays: Include placeholder objects `{}` for items that are being kept in the array.
     * For updating object elements in arrays, only include the properties to change:
     * 
     * Original array:
     * {
     *   items: [
     *     { id: 1, name: "Item 1", value: 100 },
     *     { id: 2, name: "Item 2", value: 200 },
     *     { id: 3, name: "Item 3", value: 300 }
     *   ]
     * }
     * 
     * To update only the value of the second item:
     * {
     *   items: [
     *     {}, // placeholder - keeps item 1 unchanged
     *     { value: 250 }, // updates ONLY the value property of item 2
     *     {} // placeholder - keeps item 3 unchanged (can be omitted if trailing)
     *   ]
     * }
     * 
     * Result after merge:
     * {
     *   items: [
     *     { id: 1, name: "Item 1", value: 100 },
     *     { id: 2, name: "Item 2", value: 250 }, // only value changed
     *     { id: 3, name: "Item 3", value: 300 }
     *   ]
     * }
     * 
     * NOTE: For token efficiency, do **NOT** emit array elements that are being **kept** 
     * instead emit empty objects `{}` for items being kept.  
     * 
     * NESTED OBJECTS:
     * {
     *   nestedObject: {
     *     itemToRemove: ''__DELETE__''
     *   }
     * }
     * 
     * In this case if there was a payload like this:
     * {
     *   nestedObject: {
     *    itemToRemove: ''value'',
     *    itemToKeep: ''value''
     *   },
     *   anotherItemToRemove: ''__DELETE__'',
     *   anotherItemToKeep: 12345  
     * }
     *
     * The result of the operation would be :
     * {
     *   nestedObject: {
     *     itemToKeep: ''value''
     *   },
     *   anotherItemToKeep: 12345
     * }
     */
    removeElements?: Partial<P>;

    /**
     * Description of the reasoning behind the changes requested.
     */
    reasoning?: string;
}
```

## Current State
**Payload:** Represents your work state. Request changes via `payloadChangeRequest`
```json
{{ _CURRENT_PAYLOAD | dump | safe }}
```

{%- if parentAgentName == '''' and subAgentCount > 0 -%}
## Role: Top-Level Agent
You have {{subAgentCount}} sub-agents. Delegate appropriately.
{%- elseif parentAgentName != '''' -%}
## Role: Sub-Agent
Parent: {{ parentAgentName }}. Your results return to parent, not user.
{%- endif -%}

{%- if subAgentCount > 0 or actionCount > 0 -%}
## Capabilities
{%- if subAgentCount > 0 -%}
### Sub-Agents ({{subAgentCount}} available)
Execute one at a time. Their completion  your task completion.
{{ subAgentDetails | safe }}
{%- endif -%}

{%- if actionCount > 0 -%}
### Actions ({{actionCount}} available)
Execute multiple in parallel if independent. Retry failed actions up to 3x with adjusted parameters.
{{ actionDetails | safe }}
{%- endif -%}
{%- endif -%}

## Execution Pattern
Each iteration:
1. Assess progress toward goal
2. Identify remaining work
3. Choose next step:
   - Continue reasoning
   {% if subAgentCount > 0 %}- Invoke sub-agent{% endif %}
   {% if actionCount > 0 %}- Execute action(s){% endif %}
4. Loop until done or blocked

Stop only when: goal complete OR unrecoverable failure.

# Agent: {{ agentName }}
{{ agentDescription | safe }}

## Specialization
{{ agentSpecificPrompt | safe }}

## Key Rules
- `taskComplete`: true only when **ENTIRE** user request fulfilled
- `payloadChangeRequest`: Include only changes (new/update/remove)
- `terminateAfter`: Usually false - review sub-agent results before completing
{% if subAgentCount == 0 %}- No sub-agents available{% endif %}
{% if actionCount == 0 %}- No actions available{% endif %}

# **CRITICAL**
- Your **entire** response must be only JSON with no leading or trailing characters!
- Must adhere to [LoopAgentResponse](#response-format)'
SET
  @Priority_0ffae226 = 1
SET
  @IsActive_0ffae226 = 1
SET
  @ID_0ffae226 = '1C4B8853-04B8-4BF1-92D6-B102436837D7'
EXEC [${flyway:defaultSchema}].spUpdateTemplateContent @TemplateID = @TemplateID_0ffae226,
  @TypeID = @TypeID_0ffae226,
  @TemplateText = @TemplateText_0ffae226,
  @Priority = @Priority_0ffae226,
  @IsActive = @IsActive_0ffae226,
  @ID = @ID_0ffae226;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_e8175144 UNIQUEIDENTIFIER,
@Name_e8175144 NVARCHAR(255),
@Description_e8175144 NVARCHAR(MAX),
@Type_e8175144 NVARCHAR(20),
@DefaultValue_e8175144 NVARCHAR(MAX),
@IsRequired_e8175144 BIT,
@LinkedParameterName_e8175144 NVARCHAR(255),
@LinkedParameterField_e8175144 NVARCHAR(500),
@ExtraFilter_e8175144 NVARCHAR(MAX),
@EntityID_e8175144 UNIQUEIDENTIFIER,
@RecordID_e8175144 NVARCHAR(2000),
@OrderBy_e8175144 NVARCHAR(MAX),
@TemplateContentID_e8175144 UNIQUEIDENTIFIER,
@ID_e8175144 UNIQUEIDENTIFIER
SET
  @TemplateID_e8175144 = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @Name_e8175144 = N'agentSpecificPrompt'
SET
  @Description_e8175144 = N'Workflow-specific prompt or instructions for the agent'
SET
  @Type_e8175144 = N'Scalar'
SET
  @IsRequired_e8175144 = 0
SET
  @ID_e8175144 = 'A6410813-5E3E-4F27-B35B-055E23F32CB8'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_e8175144,
  @Name = @Name_e8175144,
  @Description = @Description_e8175144,
  @Type = @Type_e8175144,
  @DefaultValue = @DefaultValue_e8175144,
  @IsRequired = @IsRequired_e8175144,
  @LinkedParameterName = @LinkedParameterName_e8175144,
  @LinkedParameterField = @LinkedParameterField_e8175144,
  @ExtraFilter = @ExtraFilter_e8175144,
  @EntityID = @EntityID_e8175144,
  @RecordID = @RecordID_e8175144,
  @OrderBy = @OrderBy_e8175144,
  @TemplateContentID = @TemplateContentID_e8175144,
  @ID = @ID_e8175144;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_fc40c961 UNIQUEIDENTIFIER,
@Name_fc40c961 NVARCHAR(255),
@Description_fc40c961 NVARCHAR(MAX),
@Type_fc40c961 NVARCHAR(20),
@DefaultValue_fc40c961 NVARCHAR(MAX),
@IsRequired_fc40c961 BIT,
@LinkedParameterName_fc40c961 NVARCHAR(255),
@LinkedParameterField_fc40c961 NVARCHAR(500),
@ExtraFilter_fc40c961 NVARCHAR(MAX),
@EntityID_fc40c961 UNIQUEIDENTIFIER,
@RecordID_fc40c961 NVARCHAR(2000),
@OrderBy_fc40c961 NVARCHAR(MAX),
@TemplateContentID_fc40c961 UNIQUEIDENTIFIER,
@ID_fc40c961 UNIQUEIDENTIFIER
SET
  @TemplateID_fc40c961 = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @Name_fc40c961 = N'availableNextSteps'
SET
  @Description_fc40c961 = N'List of potential next steps available in the workflow'
SET
  @Type_fc40c961 = N'Array'
SET
  @IsRequired_fc40c961 = 0
SET
  @ID_fc40c961 = 'BA3764DD-A53D-45F3-B572-3A55CA723ED8'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_fc40c961,
  @Name = @Name_fc40c961,
  @Description = @Description_fc40c961,
  @Type = @Type_fc40c961,
  @DefaultValue = @DefaultValue_fc40c961,
  @IsRequired = @IsRequired_fc40c961,
  @LinkedParameterName = @LinkedParameterName_fc40c961,
  @LinkedParameterField = @LinkedParameterField_fc40c961,
  @ExtraFilter = @ExtraFilter_fc40c961,
  @EntityID = @EntityID_fc40c961,
  @RecordID = @RecordID_fc40c961,
  @OrderBy = @OrderBy_fc40c961,
  @TemplateContentID = @TemplateContentID_fc40c961,
  @ID = @ID_fc40c961;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_c1c69460 UNIQUEIDENTIFIER,
@Name_c1c69460 NVARCHAR(255),
@Description_c1c69460 NVARCHAR(MAX),
@Type_c1c69460 NVARCHAR(20),
@DefaultValue_c1c69460 NVARCHAR(MAX),
@IsRequired_c1c69460 BIT,
@LinkedParameterName_c1c69460 NVARCHAR(255),
@LinkedParameterField_c1c69460 NVARCHAR(500),
@ExtraFilter_c1c69460 NVARCHAR(MAX),
@EntityID_c1c69460 UNIQUEIDENTIFIER,
@RecordID_c1c69460 NVARCHAR(2000),
@OrderBy_c1c69460 NVARCHAR(MAX),
@TemplateContentID_c1c69460 UNIQUEIDENTIFIER,
@ID_c1c69460 UNIQUEIDENTIFIER
SET
  @TemplateID_c1c69460 = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @Name_c1c69460 = N'flowContext'
SET
  @Description_c1c69460 = N'Context object containing workflow execution state including current step, completed steps count, and execution path'
SET
  @Type_c1c69460 = N'Object'
SET
  @IsRequired_c1c69460 = 0
SET
  @ID_c1c69460 = 'F9051E70-1014-4F78-9376-5AD49984B521'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_c1c69460,
  @Name = @Name_c1c69460,
  @Description = @Description_c1c69460,
  @Type = @Type_c1c69460,
  @DefaultValue = @DefaultValue_c1c69460,
  @IsRequired = @IsRequired_c1c69460,
  @LinkedParameterName = @LinkedParameterName_c1c69460,
  @LinkedParameterField = @LinkedParameterField_c1c69460,
  @ExtraFilter = @ExtraFilter_c1c69460,
  @EntityID = @EntityID_c1c69460,
  @RecordID = @RecordID_c1c69460,
  @OrderBy = @OrderBy_c1c69460,
  @TemplateContentID = @TemplateContentID_c1c69460,
  @ID = @ID_c1c69460;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_44652e38 UNIQUEIDENTIFIER,
@Name_44652e38 NVARCHAR(255),
@Description_44652e38 NVARCHAR(MAX),
@Type_44652e38 NVARCHAR(20),
@DefaultValue_44652e38 NVARCHAR(MAX),
@IsRequired_44652e38 BIT,
@LinkedParameterName_44652e38 NVARCHAR(255),
@LinkedParameterField_44652e38 NVARCHAR(500),
@ExtraFilter_44652e38 NVARCHAR(MAX),
@EntityID_44652e38 UNIQUEIDENTIFIER,
@RecordID_44652e38 NVARCHAR(2000),
@OrderBy_44652e38 NVARCHAR(MAX),
@TemplateContentID_44652e38 UNIQUEIDENTIFIER,
@ID_44652e38 UNIQUEIDENTIFIER
SET
  @TemplateID_44652e38 = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @Name_44652e38 = N'agentDescription'
SET
  @Description_44652e38 = N'Description of the agent''s role and capabilities'
SET
  @Type_44652e38 = N'Scalar'
SET
  @IsRequired_44652e38 = 0
SET
  @ID_44652e38 = '76E746AD-F130-4A8C-ADC0-8A005AD1131C'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_44652e38,
  @Name = @Name_44652e38,
  @Description = @Description_44652e38,
  @Type = @Type_44652e38,
  @DefaultValue = @DefaultValue_44652e38,
  @IsRequired = @IsRequired_44652e38,
  @LinkedParameterName = @LinkedParameterName_44652e38,
  @LinkedParameterField = @LinkedParameterField_44652e38,
  @ExtraFilter = @ExtraFilter_44652e38,
  @EntityID = @EntityID_44652e38,
  @RecordID = @RecordID_44652e38,
  @OrderBy = @OrderBy_44652e38,
  @TemplateContentID = @TemplateContentID_44652e38,
  @ID = @ID_44652e38;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_111d5e52 UNIQUEIDENTIFIER,
@Name_111d5e52 NVARCHAR(255),
@Description_111d5e52 NVARCHAR(MAX),
@Type_111d5e52 NVARCHAR(20),
@DefaultValue_111d5e52 NVARCHAR(MAX),
@IsRequired_111d5e52 BIT,
@LinkedParameterName_111d5e52 NVARCHAR(255),
@LinkedParameterField_111d5e52 NVARCHAR(500),
@ExtraFilter_111d5e52 NVARCHAR(MAX),
@EntityID_111d5e52 UNIQUEIDENTIFIER,
@RecordID_111d5e52 NVARCHAR(2000),
@OrderBy_111d5e52 NVARCHAR(MAX),
@TemplateContentID_111d5e52 UNIQUEIDENTIFIER,
@ID_111d5e52 UNIQUEIDENTIFIER
SET
  @TemplateID_111d5e52 = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @Name_111d5e52 = N'decisionGuidance'
SET
  @Description_111d5e52 = N'Specific guidance for making decisions at the current workflow step'
SET
  @Type_111d5e52 = N'Scalar'
SET
  @IsRequired_111d5e52 = 0
SET
  @ID_111d5e52 = '443A21BC-2AB0-484D-8EE9-9C672276FCA5'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_111d5e52,
  @Name = @Name_111d5e52,
  @Description = @Description_111d5e52,
  @Type = @Type_111d5e52,
  @DefaultValue = @DefaultValue_111d5e52,
  @IsRequired = @IsRequired_111d5e52,
  @LinkedParameterName = @LinkedParameterName_111d5e52,
  @LinkedParameterField = @LinkedParameterField_111d5e52,
  @ExtraFilter = @ExtraFilter_111d5e52,
  @EntityID = @EntityID_111d5e52,
  @RecordID = @RecordID_111d5e52,
  @OrderBy = @OrderBy_111d5e52,
  @TemplateContentID = @TemplateContentID_111d5e52,
  @ID = @ID_111d5e52;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_089bae2a UNIQUEIDENTIFIER,
@Name_089bae2a NVARCHAR(255),
@Description_089bae2a NVARCHAR(MAX),
@Type_089bae2a NVARCHAR(20),
@DefaultValue_089bae2a NVARCHAR(MAX),
@IsRequired_089bae2a BIT,
@LinkedParameterName_089bae2a NVARCHAR(255),
@LinkedParameterField_089bae2a NVARCHAR(500),
@ExtraFilter_089bae2a NVARCHAR(MAX),
@EntityID_089bae2a UNIQUEIDENTIFIER,
@RecordID_089bae2a NVARCHAR(2000),
@OrderBy_089bae2a NVARCHAR(MAX),
@TemplateContentID_089bae2a UNIQUEIDENTIFIER,
@ID_089bae2a UNIQUEIDENTIFIER
SET
  @TemplateID_089bae2a = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @Name_089bae2a = N'agentName'
SET
  @Description_089bae2a = N'Name of the current agent executing the workflow step'
SET
  @Type_089bae2a = N'Scalar'
SET
  @IsRequired_089bae2a = 0
SET
  @ID_089bae2a = '442A11D3-C9CE-4FDB-96B8-A7EF45280DDD'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_089bae2a,
  @Name = @Name_089bae2a,
  @Description = @Description_089bae2a,
  @Type = @Type_089bae2a,
  @DefaultValue = @DefaultValue_089bae2a,
  @IsRequired = @IsRequired_089bae2a,
  @LinkedParameterName = @LinkedParameterName_089bae2a,
  @LinkedParameterField = @LinkedParameterField_089bae2a,
  @ExtraFilter = @ExtraFilter_089bae2a,
  @EntityID = @EntityID_089bae2a,
  @RecordID = @RecordID_089bae2a,
  @OrderBy = @OrderBy_089bae2a,
  @TemplateContentID = @TemplateContentID_089bae2a,
  @ID = @ID_089bae2a;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_7f8233f5 UNIQUEIDENTIFIER,
@Name_7f8233f5 NVARCHAR(255),
@Description_7f8233f5 NVARCHAR(MAX),
@Type_7f8233f5 NVARCHAR(20),
@DefaultValue_7f8233f5 NVARCHAR(MAX),
@IsRequired_7f8233f5 BIT,
@LinkedParameterName_7f8233f5 NVARCHAR(255),
@LinkedParameterField_7f8233f5 NVARCHAR(500),
@ExtraFilter_7f8233f5 NVARCHAR(MAX),
@EntityID_7f8233f5 UNIQUEIDENTIFIER,
@RecordID_7f8233f5 NVARCHAR(2000),
@OrderBy_7f8233f5 NVARCHAR(MAX),
@TemplateContentID_7f8233f5 UNIQUEIDENTIFIER,
@ID_7f8233f5 UNIQUEIDENTIFIER
SET
  @TemplateID_7f8233f5 = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @Name_7f8233f5 = N'_CURRENT_PAYLOAD'
SET
  @Description_7f8233f5 = N'Current state of the payload being processed in the workflow'
SET
  @Type_7f8233f5 = N'Object'
SET
  @IsRequired_7f8233f5 = 0
SET
  @ID_7f8233f5 = 'D0B57918-F25C-4DCA-AB2A-C9A79E4A3840'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_7f8233f5,
  @Name = @Name_7f8233f5,
  @Description = @Description_7f8233f5,
  @Type = @Type_7f8233f5,
  @DefaultValue = @DefaultValue_7f8233f5,
  @IsRequired = @IsRequired_7f8233f5,
  @LinkedParameterName = @LinkedParameterName_7f8233f5,
  @LinkedParameterField = @LinkedParameterField_7f8233f5,
  @ExtraFilter = @ExtraFilter_7f8233f5,
  @EntityID = @EntityID_7f8233f5,
  @RecordID = @RecordID_7f8233f5,
  @OrderBy = @OrderBy_7f8233f5,
  @TemplateContentID = @TemplateContentID_7f8233f5,
  @ID = @ID_7f8233f5;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_f3e2ccb8 UNIQUEIDENTIFIER,
@Name_f3e2ccb8 NVARCHAR(255),
@Description_f3e2ccb8 NVARCHAR(MAX),
@Type_f3e2ccb8 NVARCHAR(20),
@DefaultValue_f3e2ccb8 NVARCHAR(MAX),
@IsRequired_f3e2ccb8 BIT,
@LinkedParameterName_f3e2ccb8 NVARCHAR(255),
@LinkedParameterField_f3e2ccb8 NVARCHAR(500),
@ExtraFilter_f3e2ccb8 NVARCHAR(MAX),
@EntityID_f3e2ccb8 UNIQUEIDENTIFIER,
@RecordID_f3e2ccb8 NVARCHAR(2000),
@OrderBy_f3e2ccb8 NVARCHAR(MAX),
@TemplateContentID_f3e2ccb8 UNIQUEIDENTIFIER,
@ID_f3e2ccb8 UNIQUEIDENTIFIER
SET
  @TemplateID_f3e2ccb8 = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_f3e2ccb8 = N'actionCount'
SET
  @Description_f3e2ccb8 = N'Number of available actions'
SET
  @Type_f3e2ccb8 = N'Scalar'
SET
  @IsRequired_f3e2ccb8 = 0
SET
  @ID_f3e2ccb8 = '45998072-D862-4550-BA01-3F28E5C48CDE'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_f3e2ccb8,
  @Name = @Name_f3e2ccb8,
  @Description = @Description_f3e2ccb8,
  @Type = @Type_f3e2ccb8,
  @DefaultValue = @DefaultValue_f3e2ccb8,
  @IsRequired = @IsRequired_f3e2ccb8,
  @LinkedParameterName = @LinkedParameterName_f3e2ccb8,
  @LinkedParameterField = @LinkedParameterField_f3e2ccb8,
  @ExtraFilter = @ExtraFilter_f3e2ccb8,
  @EntityID = @EntityID_f3e2ccb8,
  @RecordID = @RecordID_f3e2ccb8,
  @OrderBy = @OrderBy_f3e2ccb8,
  @TemplateContentID = @TemplateContentID_f3e2ccb8,
  @ID = @ID_f3e2ccb8;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_a2026af9 UNIQUEIDENTIFIER,
@Name_a2026af9 NVARCHAR(255),
@Description_a2026af9 NVARCHAR(MAX),
@Type_a2026af9 NVARCHAR(20),
@DefaultValue_a2026af9 NVARCHAR(MAX),
@IsRequired_a2026af9 BIT,
@LinkedParameterName_a2026af9 NVARCHAR(255),
@LinkedParameterField_a2026af9 NVARCHAR(500),
@ExtraFilter_a2026af9 NVARCHAR(MAX),
@EntityID_a2026af9 UNIQUEIDENTIFIER,
@RecordID_a2026af9 NVARCHAR(2000),
@OrderBy_a2026af9 NVARCHAR(MAX),
@TemplateContentID_a2026af9 UNIQUEIDENTIFIER,
@ID_a2026af9 UNIQUEIDENTIFIER
SET
  @TemplateID_a2026af9 = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_a2026af9 = N'subAgentDetails'
SET
  @Description_a2026af9 = N'Detailed information about available sub-agents'
SET
  @Type_a2026af9 = N'Scalar'
SET
  @IsRequired_a2026af9 = 0
SET
  @ID_a2026af9 = '78EE7440-A988-45A3-B7DC-40C2C521743D'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_a2026af9,
  @Name = @Name_a2026af9,
  @Description = @Description_a2026af9,
  @Type = @Type_a2026af9,
  @DefaultValue = @DefaultValue_a2026af9,
  @IsRequired = @IsRequired_a2026af9,
  @LinkedParameterName = @LinkedParameterName_a2026af9,
  @LinkedParameterField = @LinkedParameterField_a2026af9,
  @ExtraFilter = @ExtraFilter_a2026af9,
  @EntityID = @EntityID_a2026af9,
  @RecordID = @RecordID_a2026af9,
  @OrderBy = @OrderBy_a2026af9,
  @TemplateContentID = @TemplateContentID_a2026af9,
  @ID = @ID_a2026af9;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_f8ef2dfe UNIQUEIDENTIFIER,
@Name_f8ef2dfe NVARCHAR(255),
@Description_f8ef2dfe NVARCHAR(MAX),
@Type_f8ef2dfe NVARCHAR(20),
@DefaultValue_f8ef2dfe NVARCHAR(MAX),
@IsRequired_f8ef2dfe BIT,
@LinkedParameterName_f8ef2dfe NVARCHAR(255),
@LinkedParameterField_f8ef2dfe NVARCHAR(500),
@ExtraFilter_f8ef2dfe NVARCHAR(MAX),
@EntityID_f8ef2dfe UNIQUEIDENTIFIER,
@RecordID_f8ef2dfe NVARCHAR(2000),
@OrderBy_f8ef2dfe NVARCHAR(MAX),
@TemplateContentID_f8ef2dfe UNIQUEIDENTIFIER,
@ID_f8ef2dfe UNIQUEIDENTIFIER
SET
  @TemplateID_f8ef2dfe = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_f8ef2dfe = N'agentDescription'
SET
  @Description_f8ef2dfe = N'Description of the current agent''s purpose'
SET
  @Type_f8ef2dfe = N'Scalar'
SET
  @IsRequired_f8ef2dfe = 0
SET
  @ID_f8ef2dfe = '9B5491C6-68A5-4BB9-B945-4F152EC4F159'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_f8ef2dfe,
  @Name = @Name_f8ef2dfe,
  @Description = @Description_f8ef2dfe,
  @Type = @Type_f8ef2dfe,
  @DefaultValue = @DefaultValue_f8ef2dfe,
  @IsRequired = @IsRequired_f8ef2dfe,
  @LinkedParameterName = @LinkedParameterName_f8ef2dfe,
  @LinkedParameterField = @LinkedParameterField_f8ef2dfe,
  @ExtraFilter = @ExtraFilter_f8ef2dfe,
  @EntityID = @EntityID_f8ef2dfe,
  @RecordID = @RecordID_f8ef2dfe,
  @OrderBy = @OrderBy_f8ef2dfe,
  @TemplateContentID = @TemplateContentID_f8ef2dfe,
  @ID = @ID_f8ef2dfe;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_5c88ea77 UNIQUEIDENTIFIER,
@Name_5c88ea77 NVARCHAR(255),
@Description_5c88ea77 NVARCHAR(MAX),
@Type_5c88ea77 NVARCHAR(20),
@DefaultValue_5c88ea77 NVARCHAR(MAX),
@IsRequired_5c88ea77 BIT,
@LinkedParameterName_5c88ea77 NVARCHAR(255),
@LinkedParameterField_5c88ea77 NVARCHAR(500),
@ExtraFilter_5c88ea77 NVARCHAR(MAX),
@EntityID_5c88ea77 UNIQUEIDENTIFIER,
@RecordID_5c88ea77 NVARCHAR(2000),
@OrderBy_5c88ea77 NVARCHAR(MAX),
@TemplateContentID_5c88ea77 UNIQUEIDENTIFIER,
@ID_5c88ea77 UNIQUEIDENTIFIER
SET
  @TemplateID_5c88ea77 = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_5c88ea77 = N'agentName'
SET
  @Description_5c88ea77 = N'Name of the current agent'
SET
  @Type_5c88ea77 = N'Scalar'
SET
  @IsRequired_5c88ea77 = 0
SET
  @ID_5c88ea77 = 'A4BBF656-2403-422E-A3C4-630F9ED5AF06'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_5c88ea77,
  @Name = @Name_5c88ea77,
  @Description = @Description_5c88ea77,
  @Type = @Type_5c88ea77,
  @DefaultValue = @DefaultValue_5c88ea77,
  @IsRequired = @IsRequired_5c88ea77,
  @LinkedParameterName = @LinkedParameterName_5c88ea77,
  @LinkedParameterField = @LinkedParameterField_5c88ea77,
  @ExtraFilter = @ExtraFilter_5c88ea77,
  @EntityID = @EntityID_5c88ea77,
  @RecordID = @RecordID_5c88ea77,
  @OrderBy = @OrderBy_5c88ea77,
  @TemplateContentID = @TemplateContentID_5c88ea77,
  @ID = @ID_5c88ea77;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_7e429ee2 UNIQUEIDENTIFIER,
@Name_7e429ee2 NVARCHAR(255),
@Description_7e429ee2 NVARCHAR(MAX),
@Type_7e429ee2 NVARCHAR(20),
@DefaultValue_7e429ee2 NVARCHAR(MAX),
@IsRequired_7e429ee2 BIT,
@LinkedParameterName_7e429ee2 NVARCHAR(255),
@LinkedParameterField_7e429ee2 NVARCHAR(500),
@ExtraFilter_7e429ee2 NVARCHAR(MAX),
@EntityID_7e429ee2 UNIQUEIDENTIFIER,
@RecordID_7e429ee2 NVARCHAR(2000),
@OrderBy_7e429ee2 NVARCHAR(MAX),
@TemplateContentID_7e429ee2 UNIQUEIDENTIFIER,
@ID_7e429ee2 UNIQUEIDENTIFIER
SET
  @TemplateID_7e429ee2 = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_7e429ee2 = N'actionDetails'
SET
  @Description_7e429ee2 = N'Detailed information about available actions'
SET
  @Type_7e429ee2 = N'Scalar'
SET
  @IsRequired_7e429ee2 = 0
SET
  @ID_7e429ee2 = 'F5494D19-064C-4428-B1BE-6B6E35A9ACFC'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_7e429ee2,
  @Name = @Name_7e429ee2,
  @Description = @Description_7e429ee2,
  @Type = @Type_7e429ee2,
  @DefaultValue = @DefaultValue_7e429ee2,
  @IsRequired = @IsRequired_7e429ee2,
  @LinkedParameterName = @LinkedParameterName_7e429ee2,
  @LinkedParameterField = @LinkedParameterField_7e429ee2,
  @ExtraFilter = @ExtraFilter_7e429ee2,
  @EntityID = @EntityID_7e429ee2,
  @RecordID = @RecordID_7e429ee2,
  @OrderBy = @OrderBy_7e429ee2,
  @TemplateContentID = @TemplateContentID_7e429ee2,
  @ID = @ID_7e429ee2;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_e397edf6 UNIQUEIDENTIFIER,
@Name_e397edf6 NVARCHAR(255),
@Description_e397edf6 NVARCHAR(MAX),
@Type_e397edf6 NVARCHAR(20),
@DefaultValue_e397edf6 NVARCHAR(MAX),
@IsRequired_e397edf6 BIT,
@LinkedParameterName_e397edf6 NVARCHAR(255),
@LinkedParameterField_e397edf6 NVARCHAR(500),
@ExtraFilter_e397edf6 NVARCHAR(MAX),
@EntityID_e397edf6 UNIQUEIDENTIFIER,
@RecordID_e397edf6 NVARCHAR(2000),
@OrderBy_e397edf6 NVARCHAR(MAX),
@TemplateContentID_e397edf6 UNIQUEIDENTIFIER,
@ID_e397edf6 UNIQUEIDENTIFIER
SET
  @TemplateID_e397edf6 = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_e397edf6 = N'subAgentCount'
SET
  @Description_e397edf6 = N'Number of available sub-agents'
SET
  @Type_e397edf6 = N'Scalar'
SET
  @IsRequired_e397edf6 = 0
SET
  @ID_e397edf6 = 'F5254B05-509D-474C-809B-78070AB1FE7D'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_e397edf6,
  @Name = @Name_e397edf6,
  @Description = @Description_e397edf6,
  @Type = @Type_e397edf6,
  @DefaultValue = @DefaultValue_e397edf6,
  @IsRequired = @IsRequired_e397edf6,
  @LinkedParameterName = @LinkedParameterName_e397edf6,
  @LinkedParameterField = @LinkedParameterField_e397edf6,
  @ExtraFilter = @ExtraFilter_e397edf6,
  @EntityID = @EntityID_e397edf6,
  @RecordID = @RecordID_e397edf6,
  @OrderBy = @OrderBy_e397edf6,
  @TemplateContentID = @TemplateContentID_e397edf6,
  @ID = @ID_e397edf6;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_d056a0ee UNIQUEIDENTIFIER,
@Name_d056a0ee NVARCHAR(255),
@Description_d056a0ee NVARCHAR(MAX),
@Type_d056a0ee NVARCHAR(20),
@DefaultValue_d056a0ee NVARCHAR(MAX),
@IsRequired_d056a0ee BIT,
@LinkedParameterName_d056a0ee NVARCHAR(255),
@LinkedParameterField_d056a0ee NVARCHAR(500),
@ExtraFilter_d056a0ee NVARCHAR(MAX),
@EntityID_d056a0ee UNIQUEIDENTIFIER,
@RecordID_d056a0ee NVARCHAR(2000),
@OrderBy_d056a0ee NVARCHAR(MAX),
@TemplateContentID_d056a0ee UNIQUEIDENTIFIER,
@ID_d056a0ee UNIQUEIDENTIFIER
SET
  @TemplateID_d056a0ee = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_d056a0ee = N'agentSpecificPrompt'
SET
  @Description_d056a0ee = N'Agent-specific instructions or specialization details'
SET
  @Type_d056a0ee = N'Scalar'
SET
  @IsRequired_d056a0ee = 0
SET
  @ID_d056a0ee = '2CA590FB-7E6A-41B1-AD1D-C55A30D6B27F'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_d056a0ee,
  @Name = @Name_d056a0ee,
  @Description = @Description_d056a0ee,
  @Type = @Type_d056a0ee,
  @DefaultValue = @DefaultValue_d056a0ee,
  @IsRequired = @IsRequired_d056a0ee,
  @LinkedParameterName = @LinkedParameterName_d056a0ee,
  @LinkedParameterField = @LinkedParameterField_d056a0ee,
  @ExtraFilter = @ExtraFilter_d056a0ee,
  @EntityID = @EntityID_d056a0ee,
  @RecordID = @RecordID_d056a0ee,
  @OrderBy = @OrderBy_d056a0ee,
  @TemplateContentID = @TemplateContentID_d056a0ee,
  @ID = @ID_d056a0ee;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_b859ddca UNIQUEIDENTIFIER,
@Name_b859ddca NVARCHAR(255),
@Description_b859ddca NVARCHAR(MAX),
@Type_b859ddca NVARCHAR(20),
@DefaultValue_b859ddca NVARCHAR(MAX),
@IsRequired_b859ddca BIT,
@LinkedParameterName_b859ddca NVARCHAR(255),
@LinkedParameterField_b859ddca NVARCHAR(500),
@ExtraFilter_b859ddca NVARCHAR(MAX),
@EntityID_b859ddca UNIQUEIDENTIFIER,
@RecordID_b859ddca NVARCHAR(2000),
@OrderBy_b859ddca NVARCHAR(MAX),
@TemplateContentID_b859ddca UNIQUEIDENTIFIER,
@ID_b859ddca UNIQUEIDENTIFIER
SET
  @TemplateID_b859ddca = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_b859ddca = N'_CURRENT_PAYLOAD'
SET
  @Description_b859ddca = N'Current state payload for the loop agent, represented as a JSON object'
SET
  @Type_b859ddca = N'Object'
SET
  @IsRequired_b859ddca = 0
SET
  @ID_b859ddca = '764510EE-75D2-4679-BE78-E5BC0DEE9AD1'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_b859ddca,
  @Name = @Name_b859ddca,
  @Description = @Description_b859ddca,
  @Type = @Type_b859ddca,
  @DefaultValue = @DefaultValue_b859ddca,
  @IsRequired = @IsRequired_b859ddca,
  @LinkedParameterName = @LinkedParameterName_b859ddca,
  @LinkedParameterField = @LinkedParameterField_b859ddca,
  @ExtraFilter = @ExtraFilter_b859ddca,
  @EntityID = @EntityID_b859ddca,
  @RecordID = @RecordID_b859ddca,
  @OrderBy = @OrderBy_b859ddca,
  @TemplateContentID = @TemplateContentID_b859ddca,
  @ID = @ID_b859ddca;

-- Save Template Params (core SP call only)
DECLARE @TemplateID_efce3fee UNIQUEIDENTIFIER,
@Name_efce3fee NVARCHAR(255),
@Description_efce3fee NVARCHAR(MAX),
@Type_efce3fee NVARCHAR(20),
@DefaultValue_efce3fee NVARCHAR(MAX),
@IsRequired_efce3fee BIT,
@LinkedParameterName_efce3fee NVARCHAR(255),
@LinkedParameterField_efce3fee NVARCHAR(500),
@ExtraFilter_efce3fee NVARCHAR(MAX),
@EntityID_efce3fee UNIQUEIDENTIFIER,
@RecordID_efce3fee NVARCHAR(2000),
@OrderBy_efce3fee NVARCHAR(MAX),
@TemplateContentID_efce3fee UNIQUEIDENTIFIER,
@ID_efce3fee UNIQUEIDENTIFIER
SET
  @TemplateID_efce3fee = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @Name_efce3fee = N'parentAgentName'
SET
  @Description_efce3fee = N'Name of the parent agent when this is a sub-agent'
SET
  @Type_efce3fee = N'Scalar'
SET
  @IsRequired_efce3fee = 0
SET
  @ID_efce3fee = '4B7703EE-40C7-4B13-8C8A-F948D0950FB3'
EXEC [${flyway:defaultSchema}].spUpdateTemplateParam @TemplateID = @TemplateID_efce3fee,
  @Name = @Name_efce3fee,
  @Description = @Description_efce3fee,
  @Type = @Type_efce3fee,
  @DefaultValue = @DefaultValue_efce3fee,
  @IsRequired = @IsRequired_efce3fee,
  @LinkedParameterName = @LinkedParameterName_efce3fee,
  @LinkedParameterField = @LinkedParameterField_efce3fee,
  @ExtraFilter = @ExtraFilter_efce3fee,
  @EntityID = @EntityID_efce3fee,
  @RecordID = @RecordID_efce3fee,
  @OrderBy = @OrderBy_efce3fee,
  @TemplateContentID = @TemplateContentID_efce3fee,
  @ID = @ID_efce3fee;

-- Save AI Prompts (core SP call only)
DECLARE @Name_452266a3 NVARCHAR(255),
@Description_452266a3 NVARCHAR(MAX),
@TemplateID_452266a3 UNIQUEIDENTIFIER,
@CategoryID_452266a3 UNIQUEIDENTIFIER,
@TypeID_452266a3 UNIQUEIDENTIFIER,
@Status_452266a3 NVARCHAR(50),
@ResponseFormat_452266a3 NVARCHAR(20),
@ModelSpecificResponseFormat_452266a3 NVARCHAR(MAX),
@AIModelTypeID_452266a3 UNIQUEIDENTIFIER,
@MinPowerRank_452266a3 INT,
@SelectionStrategy_452266a3 NVARCHAR(20),
@PowerPreference_452266a3 NVARCHAR(20),
@ParallelizationMode_452266a3 NVARCHAR(20),
@ParallelCount_452266a3 INT,
@ParallelConfigParam_452266a3 NVARCHAR(100),
@OutputType_452266a3 NVARCHAR(50),
@OutputExample_452266a3 NVARCHAR(MAX),
@ValidationBehavior_452266a3 NVARCHAR(50),
@MaxRetries_452266a3 INT,
@RetryDelayMS_452266a3 INT,
@RetryStrategy_452266a3 NVARCHAR(20),
@ResultSelectorPromptID_452266a3 UNIQUEIDENTIFIER,
@EnableCaching_452266a3 BIT,
@CacheTTLSeconds_452266a3 INT,
@CacheMatchType_452266a3 NVARCHAR(20),
@CacheSimilarityThreshold_452266a3 FLOAT(53),
@CacheMustMatchModel_452266a3 BIT,
@CacheMustMatchVendor_452266a3 BIT,
@CacheMustMatchAgent_452266a3 BIT,
@CacheMustMatchConfig_452266a3 BIT,
@PromptRole_452266a3 NVARCHAR(20),
@PromptPosition_452266a3 NVARCHAR(20),
@Temperature_452266a3 DECIMAL(3, 2),
@TopP_452266a3 DECIMAL(3, 2),
@TopK_452266a3 INT,
@MinP_452266a3 DECIMAL(3, 2),
@FrequencyPenalty_452266a3 DECIMAL(3, 2),
@PresencePenalty_452266a3 DECIMAL(3, 2),
@Seed_452266a3 INT,
@StopSequences_452266a3 NVARCHAR(1000),
@IncludeLogProbs_452266a3 BIT,
@TopLogProbs_452266a3 INT,
@FailoverStrategy_452266a3 NVARCHAR(50),
@FailoverMaxAttempts_452266a3 INT,
@FailoverDelaySeconds_452266a3 INT,
@FailoverModelStrategy_452266a3 NVARCHAR(50),
@FailoverErrorScope_452266a3 NVARCHAR(50),
@EffortLevel_452266a3 INT,
@ID_452266a3 UNIQUEIDENTIFIER
SET
  @Name_452266a3 = N'Flow Agent Type: System Prompt'
SET
  @Description_452266a3 = N'Used for Flow Agents when they have Step Types == Prompt'
SET
  @TemplateID_452266a3 = '2768459B-DE31-4B46-8EEB-9DE935307E61'
SET
  @CategoryID_452266a3 = '838572BE-9464-4935-BC34-4806FD80A69C'
SET
  @TypeID_452266a3 = 'A6DA423E-F36B-1410-8DAC-00021F8B792E'
SET
  @Status_452266a3 = N'Active'
SET
  @ResponseFormat_452266a3 = N'Any'
SET
  @MinPowerRank_452266a3 = 0
SET
  @SelectionStrategy_452266a3 = N'Specific'
SET
  @PowerPreference_452266a3 = N'Highest'
SET
  @ParallelizationMode_452266a3 = N'None'
SET
  @OutputType_452266a3 = N'object'
SET
  @OutputExample_452266a3 = N'{
  "taskComplete?": "[BOOLEAN: true if task is fully complete, false if more steps needed, defaults to false]",
  "message?": "[STRING: A brief, human-readable message about current status or final result. Limit to 100 words.]",
  "payloadChangeRequest*": {
    "[NOTE]": "Follow the format of AgentPayloadChangeRequest. OMIT payloadChangeRequest entirely if no changes are needed."
  },
  "reasoning?": "[STRING: Your internal explanation of why you made this decision - helps with debugging]",
  "confidence?": "[OPTIONAL NUMBER: 0.0 to 1.0 indicating confidence in this decision]",
  "nextStep?": {
    "type?": "REQUIRED: Should be one of the options in the type definition. If not provided, if subAgent key provided it will default to ''subAgent'' and if actions key is provided it will default to ''actions''. If type is not provided and neither actions or subAgent keys are specified, it will be an error condition!",
    "actions?": [
      {
        "name": "[STRING: The exact name from available actions list]",
        "params*": {
          "[PARAM_NAME]": "[PARAM_VALUE: Must match action''s expected parameters]",
          "[ANOTHER_PARAM]": "[Value matching the action''s parameter type]"
        }
      }
    ],
    "subAgent?": {
      "name": "[STRING: The exact name from available sub-agents list]",
      "message": "[STRING: Complete context and instructions for the sub-agent - they don''t see conversation history]",
      "templateParameters*": {
        "[TEMPLATE_PARAM_NAME]": "[VALUE: If sub-agent has template parameters, provide values here]"
      },
      "terminateAfter?": "[BOOLEAN: true to end parent agent after sub-agent completes, false to continue]"
    }
  }
}'
SET
  @ValidationBehavior_452266a3 = N'Warn'
SET
  @MaxRetries_452266a3 = 2
SET
  @RetryDelayMS_452266a3 = 1000
SET
  @RetryStrategy_452266a3 = N'Fixed'
SET
  @EnableCaching_452266a3 = 0
SET
  @CacheMatchType_452266a3 = N'Exact'
SET
  @CacheMustMatchModel_452266a3 = 1
SET
  @CacheMustMatchVendor_452266a3 = 1
SET
  @CacheMustMatchAgent_452266a3 = 0
SET
  @CacheMustMatchConfig_452266a3 = 0
SET
  @PromptRole_452266a3 = N'System'
SET
  @PromptPosition_452266a3 = N'First'
SET
  @IncludeLogProbs_452266a3 = 0
SET
  @FailoverStrategy_452266a3 = N'SameModelDifferentVendor'
SET
  @FailoverMaxAttempts_452266a3 = 3
SET
  @FailoverDelaySeconds_452266a3 = 5
SET
  @FailoverModelStrategy_452266a3 = N'PreferSameModel'
SET
  @FailoverErrorScope_452266a3 = N'All'
SET
  @ID_452266a3 = '43A6D122-4A76-453F-97D6-82CACC619227'
EXEC [${flyway:defaultSchema}].spUpdateAIPrompt @Name = @Name_452266a3,
  @Description = @Description_452266a3,
  @TemplateID = @TemplateID_452266a3,
  @CategoryID = @CategoryID_452266a3,
  @TypeID = @TypeID_452266a3,
  @Status = @Status_452266a3,
  @ResponseFormat = @ResponseFormat_452266a3,
  @ModelSpecificResponseFormat = @ModelSpecificResponseFormat_452266a3,
  @AIModelTypeID = @AIModelTypeID_452266a3,
  @MinPowerRank = @MinPowerRank_452266a3,
  @SelectionStrategy = @SelectionStrategy_452266a3,
  @PowerPreference = @PowerPreference_452266a3,
  @ParallelizationMode = @ParallelizationMode_452266a3,
  @ParallelCount = @ParallelCount_452266a3,
  @ParallelConfigParam = @ParallelConfigParam_452266a3,
  @OutputType = @OutputType_452266a3,
  @OutputExample = @OutputExample_452266a3,
  @ValidationBehavior = @ValidationBehavior_452266a3,
  @MaxRetries = @MaxRetries_452266a3,
  @RetryDelayMS = @RetryDelayMS_452266a3,
  @RetryStrategy = @RetryStrategy_452266a3,
  @ResultSelectorPromptID = @ResultSelectorPromptID_452266a3,
  @EnableCaching = @EnableCaching_452266a3,
  @CacheTTLSeconds = @CacheTTLSeconds_452266a3,
  @CacheMatchType = @CacheMatchType_452266a3,
  @CacheSimilarityThreshold = @CacheSimilarityThreshold_452266a3,
  @CacheMustMatchModel = @CacheMustMatchModel_452266a3,
  @CacheMustMatchVendor = @CacheMustMatchVendor_452266a3,
  @CacheMustMatchAgent = @CacheMustMatchAgent_452266a3,
  @CacheMustMatchConfig = @CacheMustMatchConfig_452266a3,
  @PromptRole = @PromptRole_452266a3,
  @PromptPosition = @PromptPosition_452266a3,
  @Temperature = @Temperature_452266a3,
  @TopP = @TopP_452266a3,
  @TopK = @TopK_452266a3,
  @MinP = @MinP_452266a3,
  @FrequencyPenalty = @FrequencyPenalty_452266a3,
  @PresencePenalty = @PresencePenalty_452266a3,
  @Seed = @Seed_452266a3,
  @StopSequences = @StopSequences_452266a3,
  @IncludeLogProbs = @IncludeLogProbs_452266a3,
  @TopLogProbs = @TopLogProbs_452266a3,
  @FailoverStrategy = @FailoverStrategy_452266a3,
  @FailoverMaxAttempts = @FailoverMaxAttempts_452266a3,
  @FailoverDelaySeconds = @FailoverDelaySeconds_452266a3,
  @FailoverModelStrategy = @FailoverModelStrategy_452266a3,
  @FailoverErrorScope = @FailoverErrorScope_452266a3,
  @EffortLevel = @EffortLevel_452266a3,
  @ID = @ID_452266a3;

-- Save AI Prompts (core SP call only)
DECLARE @Name_ad78b4f9 NVARCHAR(255),
@Description_ad78b4f9 NVARCHAR(MAX),
@TemplateID_ad78b4f9 UNIQUEIDENTIFIER,
@CategoryID_ad78b4f9 UNIQUEIDENTIFIER,
@TypeID_ad78b4f9 UNIQUEIDENTIFIER,
@Status_ad78b4f9 NVARCHAR(50),
@ResponseFormat_ad78b4f9 NVARCHAR(20),
@ModelSpecificResponseFormat_ad78b4f9 NVARCHAR(MAX),
@AIModelTypeID_ad78b4f9 UNIQUEIDENTIFIER,
@MinPowerRank_ad78b4f9 INT,
@SelectionStrategy_ad78b4f9 NVARCHAR(20),
@PowerPreference_ad78b4f9 NVARCHAR(20),
@ParallelizationMode_ad78b4f9 NVARCHAR(20),
@ParallelCount_ad78b4f9 INT,
@ParallelConfigParam_ad78b4f9 NVARCHAR(100),
@OutputType_ad78b4f9 NVARCHAR(50),
@OutputExample_ad78b4f9 NVARCHAR(MAX),
@ValidationBehavior_ad78b4f9 NVARCHAR(50),
@MaxRetries_ad78b4f9 INT,
@RetryDelayMS_ad78b4f9 INT,
@RetryStrategy_ad78b4f9 NVARCHAR(20),
@ResultSelectorPromptID_ad78b4f9 UNIQUEIDENTIFIER,
@EnableCaching_ad78b4f9 BIT,
@CacheTTLSeconds_ad78b4f9 INT,
@CacheMatchType_ad78b4f9 NVARCHAR(20),
@CacheSimilarityThreshold_ad78b4f9 FLOAT(53),
@CacheMustMatchModel_ad78b4f9 BIT,
@CacheMustMatchVendor_ad78b4f9 BIT,
@CacheMustMatchAgent_ad78b4f9 BIT,
@CacheMustMatchConfig_ad78b4f9 BIT,
@PromptRole_ad78b4f9 NVARCHAR(20),
@PromptPosition_ad78b4f9 NVARCHAR(20),
@Temperature_ad78b4f9 DECIMAL(3, 2),
@TopP_ad78b4f9 DECIMAL(3, 2),
@TopK_ad78b4f9 INT,
@MinP_ad78b4f9 DECIMAL(3, 2),
@FrequencyPenalty_ad78b4f9 DECIMAL(3, 2),
@PresencePenalty_ad78b4f9 DECIMAL(3, 2),
@Seed_ad78b4f9 INT,
@StopSequences_ad78b4f9 NVARCHAR(1000),
@IncludeLogProbs_ad78b4f9 BIT,
@TopLogProbs_ad78b4f9 INT,
@FailoverStrategy_ad78b4f9 NVARCHAR(50),
@FailoverMaxAttempts_ad78b4f9 INT,
@FailoverDelaySeconds_ad78b4f9 INT,
@FailoverModelStrategy_ad78b4f9 NVARCHAR(50),
@FailoverErrorScope_ad78b4f9 NVARCHAR(50),
@EffortLevel_ad78b4f9 INT,
@ID_ad78b4f9 UNIQUEIDENTIFIER
SET
  @Name_ad78b4f9 = N'Loop Agent Type: System Prompt'
SET
  @Description_ad78b4f9 = N'Basic control structure for the Loop Agent Type'
SET
  @TemplateID_ad78b4f9 = '8E5F83E5-837B-4C53-9171-08272BF605A4'
SET
  @CategoryID_ad78b4f9 = '838572BE-9464-4935-BC34-4806FD80A69C'
SET
  @TypeID_ad78b4f9 = 'A6DA423E-F36B-1410-8DAC-00021F8B792E'
SET
  @Status_ad78b4f9 = N'Active'
SET
  @ResponseFormat_ad78b4f9 = N'Any'
SET
  @MinPowerRank_ad78b4f9 = 0
SET
  @SelectionStrategy_ad78b4f9 = N'Specific'
SET
  @PowerPreference_ad78b4f9 = N'Highest'
SET
  @ParallelizationMode_ad78b4f9 = N'None'
SET
  @OutputType_ad78b4f9 = N'object'
SET
  @OutputExample_ad78b4f9 = N'{
  "taskComplete?": "[BOOLEAN: true if task is fully complete, false if more steps needed, defaults to false]",
  "message?": "[STRING: A brief, human-readable message about current status or final result. Limit to 100 words.]",
  "payloadChangeRequest*": {
    "[NOTE]": "Follow the format of AgentPayloadChangeRequest. OMIT payloadChangeRequest entirely if no changes are needed."
  },
  "reasoning?": "[STRING: Your internal explanation of why you made this decision - helps with debugging]",
  "confidence?": "[OPTIONAL NUMBER: 0.0 to 1.0 indicating confidence in this decision]",
  "nextStep?": {
    "type?": "REQUIRED: Should be one of the options in the type definition. If not provided, if subAgent key provided it will default to ''subAgent'' and if actions key is provided it will default to ''actions''. If type is not provided and neither actions or subAgent keys are specified, it will be an error condition!",
    "actions?": [
      {
        "name": "[STRING: The exact name from available actions list]",
        "params*": {
          "[PARAM_NAME]": "[PARAM_VALUE: Must match action''s expected parameters]",
          "[ANOTHER_PARAM]": "[Value matching the action''s parameter type]"
        }
      }
    ],
    "subAgent?": {
      "name": "[STRING: The exact name from available sub-agents list]",
      "message": "[STRING: Complete context and instructions for the sub-agent - they don''t see conversation history]",
      "templateParameters*": {
        "[TEMPLATE_PARAM_NAME]": "[VALUE: If sub-agent has template parameters, provide values here]"
      },
      "terminateAfter?": "[BOOLEAN: true to end parent agent after sub-agent completes, false to continue]"
    }
  }
}'
SET
  @ValidationBehavior_ad78b4f9 = N'Warn'
SET
  @MaxRetries_ad78b4f9 = 2
SET
  @RetryDelayMS_ad78b4f9 = 1000
SET
  @RetryStrategy_ad78b4f9 = N'Fixed'
SET
  @EnableCaching_ad78b4f9 = 0
SET
  @CacheMatchType_ad78b4f9 = N'Exact'
SET
  @CacheMustMatchModel_ad78b4f9 = 1
SET
  @CacheMustMatchVendor_ad78b4f9 = 1
SET
  @CacheMustMatchAgent_ad78b4f9 = 0
SET
  @CacheMustMatchConfig_ad78b4f9 = 0
SET
  @PromptRole_ad78b4f9 = N'System'
SET
  @PromptPosition_ad78b4f9 = N'First'
SET
  @IncludeLogProbs_ad78b4f9 = 0
SET
  @FailoverStrategy_ad78b4f9 = N'SameModelDifferentVendor'
SET
  @FailoverModelStrategy_ad78b4f9 = N'PreferSameModel'
SET
  @FailoverErrorScope_ad78b4f9 = N'All'
SET
  @ID_ad78b4f9 = 'FF7D441F-36E1-458A-B548-0FC2208923BE'
EXEC [${flyway:defaultSchema}].spUpdateAIPrompt @Name = @Name_ad78b4f9,
  @Description = @Description_ad78b4f9,
  @TemplateID = @TemplateID_ad78b4f9,
  @CategoryID = @CategoryID_ad78b4f9,
  @TypeID = @TypeID_ad78b4f9,
  @Status = @Status_ad78b4f9,
  @ResponseFormat = @ResponseFormat_ad78b4f9,
  @ModelSpecificResponseFormat = @ModelSpecificResponseFormat_ad78b4f9,
  @AIModelTypeID = @AIModelTypeID_ad78b4f9,
  @MinPowerRank = @MinPowerRank_ad78b4f9,
  @SelectionStrategy = @SelectionStrategy_ad78b4f9,
  @PowerPreference = @PowerPreference_ad78b4f9,
  @ParallelizationMode = @ParallelizationMode_ad78b4f9,
  @ParallelCount = @ParallelCount_ad78b4f9,
  @ParallelConfigParam = @ParallelConfigParam_ad78b4f9,
  @OutputType = @OutputType_ad78b4f9,
  @OutputExample = @OutputExample_ad78b4f9,
  @ValidationBehavior = @ValidationBehavior_ad78b4f9,
  @MaxRetries = @MaxRetries_ad78b4f9,
  @RetryDelayMS = @RetryDelayMS_ad78b4f9,
  @RetryStrategy = @RetryStrategy_ad78b4f9,
  @ResultSelectorPromptID = @ResultSelectorPromptID_ad78b4f9,
  @EnableCaching = @EnableCaching_ad78b4f9,
  @CacheTTLSeconds = @CacheTTLSeconds_ad78b4f9,
  @CacheMatchType = @CacheMatchType_ad78b4f9,
  @CacheSimilarityThreshold = @CacheSimilarityThreshold_ad78b4f9,
  @CacheMustMatchModel = @CacheMustMatchModel_ad78b4f9,
  @CacheMustMatchVendor = @CacheMustMatchVendor_ad78b4f9,
  @CacheMustMatchAgent = @CacheMustMatchAgent_ad78b4f9,
  @CacheMustMatchConfig = @CacheMustMatchConfig_ad78b4f9,
  @PromptRole = @PromptRole_ad78b4f9,
  @PromptPosition = @PromptPosition_ad78b4f9,
  @Temperature = @Temperature_ad78b4f9,
  @TopP = @TopP_ad78b4f9,
  @TopK = @TopK_ad78b4f9,
  @MinP = @MinP_ad78b4f9,
  @FrequencyPenalty = @FrequencyPenalty_ad78b4f9,
  @PresencePenalty = @PresencePenalty_ad78b4f9,
  @Seed = @Seed_ad78b4f9,
  @StopSequences = @StopSequences_ad78b4f9,
  @IncludeLogProbs = @IncludeLogProbs_ad78b4f9,
  @TopLogProbs = @TopLogProbs_ad78b4f9,
  @FailoverStrategy = @FailoverStrategy_ad78b4f9,
  @FailoverMaxAttempts = @FailoverMaxAttempts_ad78b4f9,
  @FailoverDelaySeconds = @FailoverDelaySeconds_ad78b4f9,
  @FailoverModelStrategy = @FailoverModelStrategy_ad78b4f9,
  @FailoverErrorScope = @FailoverErrorScope_ad78b4f9,
  @EffortLevel = @EffortLevel_ad78b4f9,
  @ID = @ID_ad78b4f9;


-- End of SQL Logging Session
-- Session ID: b713aa64-9012-4492-ac13-76bacd14f71d
-- Completed: 2025-08-21T12:15:02.279Z
-- Duration: 33815ms
-- Total Statements: 20
