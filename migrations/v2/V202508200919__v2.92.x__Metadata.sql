-- SQL Logging Session
-- Session ID: 15956fc4-5135-49a3-a7ce-ed4f94e617ed
-- Started: 2025-08-20T14:17:00.304Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_48dc47ae NVARCHAR(500),
@DisplayName_48dc47ae NVARCHAR(500),
@Version_48dc47ae NVARCHAR(100),
@GlobalVariable_48dc47ae NVARCHAR(255),
@Category_48dc47ae NVARCHAR(100),
@CDNUrl_48dc47ae NVARCHAR(1000),
@CDNCssUrl_48dc47ae NVARCHAR(1000),
@Description_48dc47ae NVARCHAR(MAX),
@Status_48dc47ae NVARCHAR(20),
@LintRules_48dc47ae NVARCHAR(MAX),
@ID_48dc47ae UNIQUEIDENTIFIER
SET
  @Name_48dc47ae = N'd3'
SET
  @DisplayName_48dc47ae = N'D3.js'
SET
  @Version_48dc47ae = N'7.8.5'
SET
  @GlobalVariable_48dc47ae = N'd3'
SET
  @Category_48dc47ae = N'Charting'
SET
  @CDNUrl_48dc47ae = N'https://unpkg.com/d3@7.8.5/dist/d3.min.js'
SET
  @Description_48dc47ae = N'Data visualization library for creating custom charts'
SET
  @Status_48dc47ae = N'Active'
SET
  @LintRules_48dc47ae = N'{
  "initialization": {
    "factoryMethod": "select",
    "elementType": "svg",
    "requiresNew": false
  },
  "lifecycle": {
    "cleanupMethods": [
      "remove",
      "interrupt"
    ],
    "requiredMethods": [],
    "updateMethods": [
      "data",
      "attr",
      "style"
    ]
  },
  "validators": {
    "checkSelectionCleanup": {
      "description": "Ensure D3 selections are properly cleaned up",
      "severity": "critical",
      "validate": "/**\n * Ensure D3 selections are properly cleaned up\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for D3 selections in useEffect without cleanup\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.object) &&\n      path.node.callee.object.name === ''d3'' &&\n      t.isIdentifier(path.node.callee.property) &&\n      [''select'', ''selectAll''].includes(path.node.callee.property.name)) {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                hasCleanup = true;\n                break;\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''d3-missing-cleanup'',\n              severity: ''critical'',\n              message: ''D3 selections must be cleaned up in useEffect to prevent memory leaks'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { d3.select(ref.current).selectAll(\"*\").remove(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkJoinPattern": {
      "description": "Recommend modern join() pattern over enter/exit",
      "severity": "low",
      "validate": "/**\n * Recommend modern join() pattern over enter/exit\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for old enter/append pattern\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.property) &&\n      path.node.callee.property.name === ''enter'') {\n    \n    // Check if followed by append\n    if (t.isMemberExpression(path.parent) &&\n        path.parent.object === path.node &&\n        t.isCallExpression(path.parent.parent) &&\n        t.isIdentifier(path.parent.property) &&\n        path.parent.property.name === ''append'') {\n      \n      return {\n        rule: ''d3-use-join'',\n        severity: ''low'',\n        message: ''Consider using the modern .join() pattern instead of .enter().append()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''.join(\"element\") // Handles enter, update, and exit automatically''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_48dc47ae = '12416186-FBBD-4973-A7F4-D030FD84994B'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_48dc47ae,
  @DisplayName = @DisplayName_48dc47ae,
  @Version = @Version_48dc47ae,
  @GlobalVariable = @GlobalVariable_48dc47ae,
  @Category = @Category_48dc47ae,
  @CDNUrl = @CDNUrl_48dc47ae,
  @CDNCssUrl = @CDNCssUrl_48dc47ae,
  @Description = @Description_48dc47ae,
  @Status = @Status_48dc47ae,
  @LintRules = @LintRules_48dc47ae,
  @ID = @ID_48dc47ae;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_fb8d0e41 NVARCHAR(500),
@DisplayName_fb8d0e41 NVARCHAR(500),
@Version_fb8d0e41 NVARCHAR(100),
@GlobalVariable_fb8d0e41 NVARCHAR(255),
@Category_fb8d0e41 NVARCHAR(100),
@CDNUrl_fb8d0e41 NVARCHAR(1000),
@CDNCssUrl_fb8d0e41 NVARCHAR(1000),
@Description_fb8d0e41 NVARCHAR(MAX),
@Status_fb8d0e41 NVARCHAR(20),
@LintRules_fb8d0e41 NVARCHAR(MAX),
@ID_fb8d0e41 UNIQUEIDENTIFIER
SET
  @Name_fb8d0e41 = N'Recharts'
SET
  @DisplayName_fb8d0e41 = N'Recharts'
SET
  @Version_fb8d0e41 = N'2.10.4'
SET
  @GlobalVariable_fb8d0e41 = N'Recharts'
SET
  @Category_fb8d0e41 = N'Charting'
SET
  @CDNUrl_fb8d0e41 = N'https://cdn.jsdelivr.net/npm/recharts@2.10.4/umd/Recharts.min.js'
SET
  @Description_fb8d0e41 = N'React charting library built on D3'
SET
  @Status_fb8d0e41 = N'Disabled'
SET
  @LintRules_fb8d0e41 = N'{
  "initialization": {
    "factoryMethod": null,
    "elementType": "div",
    "requiresNew": false
  },
  "lifecycle": {
    "requiredMethods": [],
    "cleanupMethods": [],
    "updateMethods": []
  },
  "validators": {
    "checkResponsiveContainer": {
      "description": "Check ResponsiveContainer has proper parent dimensions",
      "severity": "critical",
      "validate": "/**\n * Check ResponsiveContainer has proper parent dimensions\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for ResponsiveContainer usage\n  if (t.isJSXElement(path.node) &&\n      t.isJSXIdentifier(path.node.openingElement.name) &&\n      path.node.openingElement.name.name === ''ResponsiveContainer'') {\n    \n    // Check if width=\"100%\" and height=\"100%\" are used\n    const attributes = path.node.openingElement.attributes;\n    let hasPercentHeight = false;\n    \n    attributes.forEach(attr => {\n      if (t.isJSXAttribute(attr) &&\n          t.isJSXIdentifier(attr.name) &&\n          attr.name.name === ''height'') {\n        \n        if (t.isStringLiteral(attr.value) && attr.value.value === ''100%'') {\n          hasPercentHeight = true;\n        } else if (t.isJSXExpressionContainer(attr.value) &&\n                   t.isStringLiteral(attr.value.expression) &&\n                   attr.value.expression.value === ''100%'') {\n          hasPercentHeight = true;\n        }\n      }\n    });\n    \n    if (hasPercentHeight) {\n      return {\n        rule: ''recharts-responsive-container-height'',\n        severity: ''critical'',\n        message: ''ResponsiveContainer with height=\"100%\" requires parent element to have explicit height'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''Set parent div style={{ height: 400 }} or use fixed height on ResponsiveContainer''\n      };\n    }\n  }\n  return null;\n}"
    },
    "checkDataProp": {
      "description": "Ensure chart components have data prop",
      "severity": "high",
      "validate": "/**\n * Ensure chart components have data prop\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for Recharts chart components\n  const chartComponents = [''LineChart'', ''BarChart'', ''AreaChart'', ''PieChart'', ''ScatterChart'', ''RadarChart''];\n  \n  if (t.isJSXElement(path.node) &&\n      t.isJSXIdentifier(path.node.openingElement.name) &&\n      chartComponents.includes(path.node.openingElement.name.name)) {\n    \n    const attributes = path.node.openingElement.attributes;\n    let hasData = false;\n    \n    attributes.forEach(attr => {\n      if (t.isJSXAttribute(attr) &&\n          t.isJSXIdentifier(attr.name) &&\n          attr.name.name === ''data'') {\n        hasData = true;\n      }\n    });\n    \n    if (!hasData) {\n      return {\n        rule: ''recharts-missing-data'',\n        severity: ''high'',\n        message: `$' + '{path.node.openingElement.name.name} requires a data prop`,\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''data={chartData}''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_fb8d0e41 = '5A8C6518-889B-4868-BA20-4E50531309C6'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_fb8d0e41,
  @DisplayName = @DisplayName_fb8d0e41,
  @Version = @Version_fb8d0e41,
  @GlobalVariable = @GlobalVariable_fb8d0e41,
  @Category = @Category_fb8d0e41,
  @CDNUrl = @CDNUrl_fb8d0e41,
  @CDNCssUrl = @CDNCssUrl_fb8d0e41,
  @Description = @Description_fb8d0e41,
  @Status = @Status_fb8d0e41,
  @LintRules = @LintRules_fb8d0e41,
  @ID = @ID_fb8d0e41;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_fbc99519 NVARCHAR(500),
@DisplayName_fbc99519 NVARCHAR(500),
@Version_fbc99519 NVARCHAR(100),
@GlobalVariable_fbc99519 NVARCHAR(255),
@Category_fbc99519 NVARCHAR(100),
@CDNUrl_fbc99519 NVARCHAR(1000),
@CDNCssUrl_fbc99519 NVARCHAR(1000),
@Description_fbc99519 NVARCHAR(MAX),
@Status_fbc99519 NVARCHAR(20),
@LintRules_fbc99519 NVARCHAR(MAX),
@ID_fbc99519 UNIQUEIDENTIFIER
SET
  @Name_fbc99519 = N'chart.js'
SET
  @DisplayName_fbc99519 = N'Chart.js'
SET
  @Version_fbc99519 = N'4.4.1'
SET
  @GlobalVariable_fbc99519 = N'Chart'
SET
  @Category_fbc99519 = N'Charting'
SET
  @CDNUrl_fbc99519 = N'https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js'
SET
  @Description_fbc99519 = N'Simple yet flexible JavaScript charting library'
SET
  @Status_fbc99519 = N'Active'
SET
  @LintRules_fbc99519 = N'{
  "initialization": {
    "constructorName": "Chart",
    "requiresNew": true,
    "elementType": "canvas",
    "requiredConfig": [
      "type",
      "data"
    ]
  },
  "lifecycle": {
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "update"
    ],
    "requiredMethods": []
  },
  "validators": {
    "checkDestroyBeforeRecreate": {
      "description": "Ensure Chart instances are destroyed before recreating on same canvas",
      "severity": "critical",
      "validate": "/**\n * Ensure Chart instances are destroyed before recreating on same canvas\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context with libraryName, globalVariable, instanceVariables\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'') {\n    \n    // Check if we''re in a useEffect\n    let inUseEffect = false;\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        inUseEffect = true;\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n    \n    if (inUseEffect) {\n      // Look for cleanup function return\n      let hasCleanup = false;\n      const effectFn = useEffectPath.node.arguments[0];\n      if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n        // Check if it returns a cleanup function\n        const body = effectFn.body;\n        if (t.isBlockStatement(body)) {\n          for (const stmt of body.body) {\n            if (t.isReturnStatement(stmt) && stmt.argument) {\n              hasCleanup = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      if (!hasCleanup) {\n        return {\n          rule: ''chart-missing-cleanup'',\n          severity: ''critical'',\n          message: ''Chart.js instances must be destroyed in useEffect cleanup to prevent memory leaks'',\n          line: path.node.loc?.start.line || 0,\n          column: path.node.loc?.start.column || 0,\n          fix: ''return () => { chartInstance.current?.destroy(); }''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkCanvasContext": {
      "description": "Validate canvas context is obtained correctly",
      "severity": "high",
      "validate": "/**\n * Validate canvas context is obtained correctly\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'' &&\n      path.node.arguments[0]) {\n    \n    const firstArg = path.node.arguments[0];\n    \n    // Check if it''s a getContext(''2d'') call\n    if (t.isCallExpression(firstArg) &&\n        t.isMemberExpression(firstArg.callee) &&\n        t.isIdentifier(firstArg.callee.property) &&\n        firstArg.callee.property.name === ''getContext'') {\n      \n      const contextArg = firstArg.arguments[0];\n      if (!t.isStringLiteral(contextArg) || contextArg.value !== ''2d'') {\n        return {\n          rule: ''chart-invalid-context'',\n          severity: ''high'',\n          message: ''Chart.js requires a 2D canvas context'',\n          line: contextArg?.loc?.start.line || 0,\n          column: contextArg?.loc?.start.column || 0,\n          fix: \"getContext(''2d'')\"\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkChartRegistration": {
      "description": "Check for Chart.register() when using tree-shaking",
      "severity": "medium",
      "validate": "/**\n * Check for Chart.register() when using tree-shaking\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Only check if we see specific controller imports\n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js/auto'') {\n    return null; // auto import includes everything\n  }\n  \n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js'' &&\n      path.node.specifiers.some(spec => \n        t.isImportSpecifier(spec) &&\n        t.isIdentifier(spec.imported) &&\n        [''BarController'', ''LineController'', ''PieController''].includes(spec.imported.name)\n      )) {\n    \n    // Look for Chart.register call\n    let hasRegister = false;\n    ast.program.body.forEach(node => {\n      if (t.isExpressionStatement(node) &&\n          t.isCallExpression(node.expression) &&\n          t.isMemberExpression(node.expression.callee) &&\n          t.isIdentifier(node.expression.callee.object) &&\n          node.expression.callee.object.name === ''Chart'' &&\n          t.isIdentifier(node.expression.callee.property) &&\n          node.expression.callee.property.name === ''register'') {\n        hasRegister = true;\n      }\n    });\n    \n    if (!hasRegister) {\n      return {\n        rule: ''chart-missing-registration'',\n        severity: ''medium'',\n        message: ''When importing specific Chart.js components, you must call Chart.register()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''Chart.register(BarController, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_fbc99519 = '754D12D4-B182-45E8-B4BB-98FB8A366B02'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_fbc99519,
  @DisplayName = @DisplayName_fbc99519,
  @Version = @Version_fbc99519,
  @GlobalVariable = @GlobalVariable_fbc99519,
  @Category = @Category_fbc99519,
  @CDNUrl = @CDNUrl_fbc99519,
  @CDNCssUrl = @CDNCssUrl_fbc99519,
  @Description = @Description_fbc99519,
  @Status = @Status_fbc99519,
  @LintRules = @LintRules_fbc99519,
  @ID = @ID_fbc99519;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_a71546d0 NVARCHAR(500),
@DisplayName_a71546d0 NVARCHAR(500),
@Version_a71546d0 NVARCHAR(100),
@GlobalVariable_a71546d0 NVARCHAR(255),
@Category_a71546d0 NVARCHAR(100),
@CDNUrl_a71546d0 NVARCHAR(1000),
@CDNCssUrl_a71546d0 NVARCHAR(1000),
@Description_a71546d0 NVARCHAR(MAX),
@Status_a71546d0 NVARCHAR(20),
@LintRules_a71546d0 NVARCHAR(MAX),
@ID_a71546d0 UNIQUEIDENTIFIER
SET
  @Name_a71546d0 = N'ApexCharts'
SET
  @DisplayName_a71546d0 = N'ApexCharts'
SET
  @Version_a71546d0 = N'3.45.1'
SET
  @GlobalVariable_a71546d0 = N'ApexCharts'
SET
  @Category_a71546d0 = N'Charting'
SET
  @CDNUrl_a71546d0 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_a71546d0 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_a71546d0 = N'Modern interactive JavaScript charts library'
SET
  @Status_a71546d0 = N'Active'
SET
  @LintRules_a71546d0 = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [
      "render"
    ],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''critical'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_a71546d0 = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_a71546d0,
  @DisplayName = @DisplayName_a71546d0,
  @Version = @Version_a71546d0,
  @GlobalVariable = @GlobalVariable_a71546d0,
  @Category = @Category_a71546d0,
  @CDNUrl = @CDNUrl_a71546d0,
  @CDNCssUrl = @CDNCssUrl_a71546d0,
  @Description = @Description_a71546d0,
  @Status = @Status_a71546d0,
  @LintRules = @LintRules_a71546d0,
  @ID = @ID_a71546d0;


-- End of SQL Logging Session
-- Session ID: 15956fc4-5135-49a3-a7ce-ed4f94e617ed
-- Completed: 2025-08-20T14:17:30.734Z
-- Duration: 30430ms
-- Total Statements: 4







































-- SQL Logging Session
-- Session ID: ecd6cd35-9c33-4249-ad34-9b35697069c2
-- Started: 2025-08-20T14:54:42.722Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_620db5b4 NVARCHAR(500),
@DisplayName_620db5b4 NVARCHAR(500),
@Version_620db5b4 NVARCHAR(100),
@GlobalVariable_620db5b4 NVARCHAR(255),
@Category_620db5b4 NVARCHAR(100),
@CDNUrl_620db5b4 NVARCHAR(1000),
@CDNCssUrl_620db5b4 NVARCHAR(1000),
@Description_620db5b4 NVARCHAR(MAX),
@Status_620db5b4 NVARCHAR(20),
@LintRules_620db5b4 NVARCHAR(MAX),
@ID_620db5b4 UNIQUEIDENTIFIER
SET
  @Name_620db5b4 = N'ApexCharts'
SET
  @DisplayName_620db5b4 = N'ApexCharts'
SET
  @Version_620db5b4 = N'3.45.1'
SET
  @GlobalVariable_620db5b4 = N'ApexCharts'
SET
  @Category_620db5b4 = N'Charting'
SET
  @CDNUrl_620db5b4 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_620db5b4 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_620db5b4 = N'Modern interactive JavaScript charts library'
SET
  @Status_620db5b4 = N'Active'
SET
  @LintRules_620db5b4 = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [
      "render"
    ],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''critical'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkSeriesDataFormat": {
      "description": "Validate data is in correct ApexCharts series format",
      "severity": "critical",
      "validate": "// Validates that data passed to ApexCharts is in the correct series format\n(ast, path, t, context) => {\n  // Look for chart creation or series updates\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const configArg = path.node.arguments[1];\n    if (configArg && t.isObjectExpression(configArg)) {\n      const seriesProp = configArg.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''series''\n      );\n      \n      if (seriesProp && t.isIdentifier(seriesProp.value)) {\n        // Track the variable name for later validation\n        context.apexSeriesVars = context.apexSeriesVars || new Set();\n        context.apexSeriesVars.add(seriesProp.value.name);\n      }\n    }\n  }\n  \n  // Check updateSeries calls\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''updateSeries'') {\n    const parent = path.parent;\n    if (t.isCallExpression(parent)) {\n      const arg = parent.arguments[0];\n      if (arg && t.isIdentifier(arg)) {\n        // Flag for validation - series data should be array of objects with name and data\n        context.violations.push({\n          type: ''warning'',\n          message: `Verify that ''$' + '{arg.name}'' is formatted as ApexCharts series: [{name: string, data: [{x, y}]}]`,\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Transform data to: selectedMetrics.map(metric => ({ name: metric, data: points.map(p => ({x: timestamp, y: value})) }))''\n        });\n      }\n    }\n  }\n  \n  // Look for common data format mistakes\n  if (t.isObjectExpression(path.node)) {\n    const hasDateProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''date''\n    );\n    const hasDurationProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''duration''\n    );\n    const hasCostProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''cost''\n    );\n    \n    // This looks like processed data that needs transformation\n    if (hasDateProp && (hasDurationProp || hasCostProp)) {\n      // Check if this is being passed to chart\n      let parent = path.parent;\n      let depth = 0;\n      while (parent && depth < 5) {\n        if (t.isJSXAttribute(parent) && parent.name?.name === ''seriesData'') {\n          context.violations.push({\n            type: ''error'',\n            message: ''Data structure {date, duration, cost} needs transformation to ApexCharts series format'',\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''Transform to: [{name: \"Duration\", data: [{x: timestamp, y: value}]}, ...]''\n          });\n          break;\n        }\n        parent = parent.parent;\n        depth++;\n      }\n    }\n  }\n}"
    },
    "checkChartRefManagement": {
      "description": "Ensure chart instances are properly stored in refs for exports",
      "severity": "high",
      "validate": "// Validates that chart instances are properly stored and exposed via refs\n(ast, path, t, context) => {\n  // Check for new ApexCharts creation\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const parent = path.parent;\n    \n    // Check if the chart instance is being stored\n    if (t.isVariableDeclarator(parent)) {\n      const varName = parent.id.name;\n      context.apexChartVars = context.apexChartVars || new Set();\n      context.apexChartVars.add(varName);\n      \n      // Now check if this variable is attached to a ref\n      const scope = path.scope;\n      const binding = scope.getBinding(varName);\n      if (binding) {\n        let isAttachedToRef = false;\n        \n        for (const refPath of binding.referencePaths) {\n          // Check for patterns like: chartRef.current = chart\n          if (t.isMemberExpression(refPath.parent) && \n              refPath.parent.property?.name === ''current'') {\n            isAttachedToRef = true;\n            break;\n          }\n          // Check for: chartRef.current._chart = chart\n          if (t.isMemberExpression(refPath.parent?.left) &&\n              refPath.parent?.left?.property?.name === ''_chart'') {\n            isAttachedToRef = true;\n            break;\n          }\n        }\n        \n        if (!isAttachedToRef) {\n          context.violations.push({\n            type: ''error'',  \n            message: `ApexCharts instance ''$' + '{varName}'' should be attached to a ref for export functionality`,\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''After creating chart, store it: chartRef.current = chart;''\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for dataURI usage without proper ref\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''dataURI'') {\n    const object = path.node.object;\n    \n    // Check if it''s accessing through a ref\n    if (t.isMemberExpression(object)) {\n      if (!object.property || object.property.name !== ''current'') {\n        context.violations.push({\n          type: ''warning'',\n          message: ''dataURI() should be called on chart instance stored in ref.current'',\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Use: chartRef.current?.dataURI() or chart.dataURI()''\n        });\n      }\n    }\n  }\n  \n  // Check for missing chart storage in useEffect\n  if (t.isCallExpression(path.node) && \n      t.isMemberExpression(path.node.callee) &&\n      path.node.callee.object?.name === ''chart'' &&\n      path.node.callee.property?.name === ''render'') {\n    \n    // Look for the chart variable in parent scope\n    let foundChartStorage = false;\n    let parent = path.parent;\n    let depth = 0;\n    \n    while (parent && depth < 10) {\n      if (t.isBlockStatement(parent)) {\n        // Check if chartRef.current is set in this block\n        const statements = parent.body;\n        foundChartStorage = statements.some(stmt => {\n          if (t.isExpressionStatement(stmt) && \n              t.isAssignmentExpression(stmt.expression)) {\n            const left = stmt.expression.left;\n            return t.isMemberExpression(left) && \n                   left.property?.name === ''current'';\n          }\n          return false;\n        });\n        \n        if (foundChartStorage) break;\n      }\n      parent = parent.parent;\n      depth++;\n    }\n    \n    if (!foundChartStorage) {\n      context.violations.push({\n        type: ''warning'',\n        message: ''Chart instance may not be stored in ref for export functionality'',\n        line: path.node.loc?.start.line,\n        column: path.node.loc?.start.column,\n        suggestion: ''Store chart in ref: chartRef.current = chart;''\n      });\n    }\n  }\n}"
    },
    "checkAnomalyFormat": {
      "description": "Validate anomaly data format for annotations",
      "severity": "medium",
      "validate": "// Validates that anomaly data for ApexCharts annotations is correctly formatted\n(ast, path, t, context) => {\n  // Look for annotations configuration in chart options\n  if (t.isObjectProperty(path.node) && \n      t.isIdentifier(path.node.key) && \n      path.node.key.name === ''annotations'') {\n    \n    const value = path.node.value;\n    if (t.isObjectExpression(value)) {\n      // Check for points property\n      const pointsProp = value.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''points''\n      );\n      \n      if (pointsProp) {\n        // Check if it''s mapping over anomalies\n        if (t.isCallExpression(pointsProp.value) && \n            t.isMemberExpression(pointsProp.value.callee) &&\n            pointsProp.value.callee.property?.name === ''map'') {\n          \n          const mapArg = pointsProp.value.arguments[0];\n          if (t.isArrowFunctionExpression(mapArg) || t.isFunctionExpression(mapArg)) {\n            const body = mapArg.body;\n            \n            // Check the structure being returned\n            if (t.isObjectExpression(body) || \n                (t.isBlockStatement(body) && body.body.length > 0)) {\n              \n              // Look for common mistakes\n              const checkForDateField = (obj) => {\n                if (t.isObjectExpression(obj)) {\n                  const hasDate = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''date''\n                  );\n                  const hasX = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''x''\n                  );\n                  \n                  if (hasDate && !hasX) {\n                    context.violations.push({\n                      type: ''error'',\n                      message: ''Anomaly annotations should use \"x\" property with timestamp, not \"date\"'',\n                      line: obj.loc?.start.line,\n                      column: obj.loc?.start.column,\n                      suggestion: ''Change to: { x: new Date(anomaly.date).getTime(), y: anomaly.value, ... }''\n                    });\n                  }\n                }\n              };\n              \n              if (t.isObjectExpression(body)) {\n                checkForDateField(body);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for anomaly data being set in state\n  if (t.isCallExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''setAnomalies'') {\n    \n    const arg = path.node.arguments[0];\n    if (t.isArrayExpression(arg) && arg.elements.length > 0) {\n      const firstElement = arg.elements[0];\n      \n      if (t.isObjectExpression(firstElement)) {\n        const hasDate = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''date''\n        );\n        const hasX = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''x''\n        );\n        \n        if (hasDate && !hasX) {\n          context.violations.push({\n            type: ''warning'',\n            message: ''Anomaly data should include \"x\" property for ApexCharts compatibility'',\n            line: firstElement.loc?.start.line,\n            column: firstElement.loc?.start.column,\n            suggestion: ''Include: { x: new Date(point.date), y: value, metric: metricName }''\n          });\n        }\n      }\n    }\n  }\n}"
    }
  }
}'
SET
  @ID_620db5b4 = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_620db5b4,
  @DisplayName = @DisplayName_620db5b4,
  @Version = @Version_620db5b4,
  @GlobalVariable = @GlobalVariable_620db5b4,
  @Category = @Category_620db5b4,
  @CDNUrl = @CDNUrl_620db5b4,
  @CDNCssUrl = @CDNCssUrl_620db5b4,
  @Description = @Description_620db5b4,
  @Status = @Status_620db5b4,
  @LintRules = @LintRules_620db5b4,
  @ID = @ID_620db5b4;


-- End of SQL Logging Session
-- Session ID: ecd6cd35-9c33-4249-ad34-9b35697069c2
-- Completed: 2025-08-20T14:55:07.790Z
-- Duration: 25068ms
-- Total Statements: 1



























-- SQL Logging Session
-- Session ID: 9adb7a3d-3c52-4395-9ccf-e892c274b70c
-- Started: 2025-08-20T21:50:15.493Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_c06616c0 NVARCHAR(500),
@DisplayName_c06616c0 NVARCHAR(500),
@Version_c06616c0 NVARCHAR(100),
@GlobalVariable_c06616c0 NVARCHAR(255),
@Category_c06616c0 NVARCHAR(100),
@CDNUrl_c06616c0 NVARCHAR(1000),
@CDNCssUrl_c06616c0 NVARCHAR(1000),
@Description_c06616c0 NVARCHAR(MAX),
@Status_c06616c0 NVARCHAR(20),
@LintRules_c06616c0 NVARCHAR(MAX),
@ID_c06616c0 UNIQUEIDENTIFIER
SET
  @Name_c06616c0 = N'ApexCharts'
SET
  @DisplayName_c06616c0 = N'ApexCharts'
SET
  @Version_c06616c0 = N'3.45.1'
SET
  @GlobalVariable_c06616c0 = N'ApexCharts'
SET
  @Category_c06616c0 = N'Charting'
SET
  @CDNUrl_c06616c0 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_c06616c0 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_c06616c0 = N'Modern interactive JavaScript charts library'
SET
  @Status_c06616c0 = N'Active'
SET
  @LintRules_c06616c0 = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''critical'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkSeriesDataFormat": {
      "description": "Validate data is in correct ApexCharts series format",
      "severity": "critical",
      "validate": "// Validates that data passed to ApexCharts is in the correct series format\n(ast, path, t, context) => {\n  // Look for chart creation or series updates\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const configArg = path.node.arguments[1];\n    if (configArg && t.isObjectExpression(configArg)) {\n      const seriesProp = configArg.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''series''\n      );\n      \n      if (seriesProp && t.isIdentifier(seriesProp.value)) {\n        // Track the variable name for later validation\n        context.apexSeriesVars = context.apexSeriesVars || new Set();\n        context.apexSeriesVars.add(seriesProp.value.name);\n      }\n    }\n  }\n  \n  // Check updateSeries calls\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''updateSeries'') {\n    const parent = path.parent;\n    if (t.isCallExpression(parent)) {\n      const arg = parent.arguments[0];\n      if (arg && t.isIdentifier(arg)) {\n        // Flag for validation - series data should be array of objects with name and data\n        context.violations.push({\n          type: ''warning'',\n          message: `Verify that ''$' + '{arg.name}'' is formatted as ApexCharts series: [{name: string, data: [{x, y}]}]`,\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Transform data to: selectedMetrics.map(metric => ({ name: metric, data: points.map(p => ({x: timestamp, y: value})) }))''\n        });\n      }\n    }\n  }\n  \n  // Look for common data format mistakes\n  if (t.isObjectExpression(path.node)) {\n    const hasDateProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''date''\n    );\n    const hasDurationProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''duration''\n    );\n    const hasCostProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''cost''\n    );\n    \n    // This looks like processed data that needs transformation\n    if (hasDateProp && (hasDurationProp || hasCostProp)) {\n      // Check if this is being passed to chart\n      let parent = path.parent;\n      let depth = 0;\n      while (parent && depth < 5) {\n        if (t.isJSXAttribute(parent) && parent.name?.name === ''seriesData'') {\n          context.violations.push({\n            type: ''error'',\n            message: ''Data structure {date, duration, cost} needs transformation to ApexCharts series format'',\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''Transform to: [{name: \"Duration\", data: [{x: timestamp, y: value}]}, ...]''\n          });\n          break;\n        }\n        parent = parent.parent;\n        depth++;\n      }\n    }\n  }\n}"
    },
    "checkChartRefManagement": {
      "description": "Ensure chart instances are properly stored in refs for exports",
      "severity": "high",
      "validate": "// Validates that chart instances are properly stored and exposed via refs\n(ast, path, t, context) => {\n  // Check for new ApexCharts creation\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const parent = path.parent;\n    \n    // Check if the chart instance is being stored\n    if (t.isVariableDeclarator(parent)) {\n      const varName = parent.id.name;\n      context.apexChartVars = context.apexChartVars || new Set();\n      context.apexChartVars.add(varName);\n      \n      // Now check if this variable is attached to a ref\n      const scope = path.scope;\n      const binding = scope.getBinding(varName);\n      if (binding) {\n        let isAttachedToRef = false;\n        \n        for (const refPath of binding.referencePaths) {\n          // Check for patterns like: chartRef.current = chart\n          if (t.isMemberExpression(refPath.parent) && \n              refPath.parent.property?.name === ''current'') {\n            isAttachedToRef = true;\n            break;\n          }\n          // Check for: chartRef.current._chart = chart\n          if (t.isMemberExpression(refPath.parent?.left) &&\n              refPath.parent?.left?.property?.name === ''_chart'') {\n            isAttachedToRef = true;\n            break;\n          }\n        }\n        \n        if (!isAttachedToRef) {\n          context.violations.push({\n            type: ''error'',  \n            message: `ApexCharts instance ''$' + '{varName}'' should be attached to a ref for export functionality`,\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''After creating chart, store it: chartRef.current = chart;''\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for dataURI usage without proper ref\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''dataURI'') {\n    const object = path.node.object;\n    \n    // Check if it''s accessing through a ref\n    if (t.isMemberExpression(object)) {\n      if (!object.property || object.property.name !== ''current'') {\n        context.violations.push({\n          type: ''warning'',\n          message: ''dataURI() should be called on chart instance stored in ref.current'',\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Use: chartRef.current?.dataURI() or chart.dataURI()''\n        });\n      }\n    }\n  }\n  \n  // Check for missing chart storage in useEffect\n  if (t.isCallExpression(path.node) && \n      t.isMemberExpression(path.node.callee) &&\n      path.node.callee.object?.name === ''chart'' &&\n      path.node.callee.property?.name === ''render'') {\n    \n    // Look for the chart variable in parent scope\n    let foundChartStorage = false;\n    let parent = path.parent;\n    let depth = 0;\n    \n    while (parent && depth < 10) {\n      if (t.isBlockStatement(parent)) {\n        // Check if chartRef.current is set in this block\n        const statements = parent.body;\n        foundChartStorage = statements.some(stmt => {\n          if (t.isExpressionStatement(stmt) && \n              t.isAssignmentExpression(stmt.expression)) {\n            const left = stmt.expression.left;\n            return t.isMemberExpression(left) && \n                   left.property?.name === ''current'';\n          }\n          return false;\n        });\n        \n        if (foundChartStorage) break;\n      }\n      parent = parent.parent;\n      depth++;\n    }\n    \n    if (!foundChartStorage) {\n      context.violations.push({\n        type: ''warning'',\n        message: ''Chart instance may not be stored in ref for export functionality'',\n        line: path.node.loc?.start.line,\n        column: path.node.loc?.start.column,\n        suggestion: ''Store chart in ref: chartRef.current = chart;''\n      });\n    }\n  }\n}"
    },
    "checkAnomalyFormat": {
      "description": "Validate anomaly data format for annotations",
      "severity": "medium",
      "validate": "// Validates that anomaly data for ApexCharts annotations is correctly formatted\n(ast, path, t, context) => {\n  // Look for annotations configuration in chart options\n  if (t.isObjectProperty(path.node) && \n      t.isIdentifier(path.node.key) && \n      path.node.key.name === ''annotations'') {\n    \n    const value = path.node.value;\n    if (t.isObjectExpression(value)) {\n      // Check for points property\n      const pointsProp = value.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''points''\n      );\n      \n      if (pointsProp) {\n        // Check if it''s mapping over anomalies\n        if (t.isCallExpression(pointsProp.value) && \n            t.isMemberExpression(pointsProp.value.callee) &&\n            pointsProp.value.callee.property?.name === ''map'') {\n          \n          const mapArg = pointsProp.value.arguments[0];\n          if (t.isArrowFunctionExpression(mapArg) || t.isFunctionExpression(mapArg)) {\n            const body = mapArg.body;\n            \n            // Check the structure being returned\n            if (t.isObjectExpression(body) || \n                (t.isBlockStatement(body) && body.body.length > 0)) {\n              \n              // Look for common mistakes\n              const checkForDateField = (obj) => {\n                if (t.isObjectExpression(obj)) {\n                  const hasDate = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''date''\n                  );\n                  const hasX = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''x''\n                  );\n                  \n                  if (hasDate && !hasX) {\n                    context.violations.push({\n                      type: ''error'',\n                      message: ''Anomaly annotations should use \"x\" property with timestamp, not \"date\"'',\n                      line: obj.loc?.start.line,\n                      column: obj.loc?.start.column,\n                      suggestion: ''Change to: { x: new Date(anomaly.date).getTime(), y: anomaly.value, ... }''\n                    });\n                  }\n                }\n              };\n              \n              if (t.isObjectExpression(body)) {\n                checkForDateField(body);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for anomaly data being set in state\n  if (t.isCallExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''setAnomalies'') {\n    \n    const arg = path.node.arguments[0];\n    if (t.isArrayExpression(arg) && arg.elements.length > 0) {\n      const firstElement = arg.elements[0];\n      \n      if (t.isObjectExpression(firstElement)) {\n        const hasDate = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''date''\n        );\n        const hasX = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''x''\n        );\n        \n        if (hasDate && !hasX) {\n          context.violations.push({\n            type: ''warning'',\n            message: ''Anomaly data should include \"x\" property for ApexCharts compatibility'',\n            line: firstElement.loc?.start.line,\n            column: firstElement.loc?.start.column,\n            suggestion: ''Include: { x: new Date(point.date), y: value, metric: metricName }''\n          });\n        }\n      }\n    }\n  }\n}"
    }
  }
}'
SET
  @ID_c06616c0 = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_c06616c0,
  @DisplayName = @DisplayName_c06616c0,
  @Version = @Version_c06616c0,
  @GlobalVariable = @GlobalVariable_c06616c0,
  @Category = @Category_c06616c0,
  @CDNUrl = @CDNUrl_c06616c0,
  @CDNCssUrl = @CDNCssUrl_c06616c0,
  @Description = @Description_c06616c0,
  @Status = @Status_c06616c0,
  @LintRules = @LintRules_c06616c0,
  @ID = @ID_c06616c0;


-- End of SQL Logging Session
-- Session ID: 9adb7a3d-3c52-4395-9ccf-e892c274b70c
-- Completed: 2025-08-20T21:50:43.976Z
-- Duration: 28483ms
-- Total Statements: 1





























-- SQL Logging Session
-- Session ID: 6eab4e48-0669-4607-aeb9-f467ecb45a4a
-- Started: 2025-08-20T22:48:44.820Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_3a49e3e6 NVARCHAR(500),
@DisplayName_3a49e3e6 NVARCHAR(500),
@Version_3a49e3e6 NVARCHAR(100),
@GlobalVariable_3a49e3e6 NVARCHAR(255),
@Category_3a49e3e6 NVARCHAR(100),
@CDNUrl_3a49e3e6 NVARCHAR(1000),
@CDNCssUrl_3a49e3e6 NVARCHAR(1000),
@Description_3a49e3e6 NVARCHAR(MAX),
@Status_3a49e3e6 NVARCHAR(20),
@LintRules_3a49e3e6 NVARCHAR(MAX),
@ID_3a49e3e6 UNIQUEIDENTIFIER
SET
  @Name_3a49e3e6 = N'd3'
SET
  @DisplayName_3a49e3e6 = N'D3.js'
SET
  @Version_3a49e3e6 = N'7.8.5'
SET
  @GlobalVariable_3a49e3e6 = N'd3'
SET
  @Category_3a49e3e6 = N'Charting'
SET
  @CDNUrl_3a49e3e6 = N'https://unpkg.com/d3@7.8.5/dist/d3.min.js'
SET
  @Description_3a49e3e6 = N'Data visualization library for creating custom charts'
SET
  @Status_3a49e3e6 = N'Active'
SET
  @LintRules_3a49e3e6 = N'{
  "initialization": {
    "factoryMethod": "select",
    "elementType": "svg",
    "requiresNew": false
  },
  "lifecycle": {
    "cleanupMethods": [
      "remove",
      "interrupt"
    ],
    "requiredMethods": [],
    "updateMethods": [
      "data",
      "attr",
      "style"
    ]
  },
  "validators": {
    "checkSelectionCleanup": {
      "description": "Ensure D3 selections are properly cleaned up",
      "severity": "medium",
      "validate": "/**\n * Ensure D3 selections are properly cleaned up\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for D3 selections in useEffect without cleanup\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.object) &&\n      path.node.callee.object.name === ''d3'' &&\n      t.isIdentifier(path.node.callee.property) &&\n      [''select'', ''selectAll''].includes(path.node.callee.property.name)) {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                hasCleanup = true;\n                break;\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''d3-missing-cleanup'',\n              severity: ''medium'',\n              message: ''D3 selections must be cleaned up in useEffect to prevent memory leaks'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { d3.select(ref.current).selectAll(\"*\").remove(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkJoinPattern": {
      "description": "Recommend modern join() pattern over enter/exit",
      "severity": "low",
      "validate": "/**\n * Recommend modern join() pattern over enter/exit\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for old enter/append pattern\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.property) &&\n      path.node.callee.property.name === ''enter'') {\n    \n    // Check if followed by append\n    if (t.isMemberExpression(path.parent) &&\n        path.parent.object === path.node &&\n        t.isCallExpression(path.parent.parent) &&\n        t.isIdentifier(path.parent.property) &&\n        path.parent.property.name === ''append'') {\n      \n      return {\n        rule: ''d3-use-join'',\n        severity: ''low'',\n        message: ''Consider using the modern .join() pattern instead of .enter().append()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''.join(\"element\") // Handles enter, update, and exit automatically''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_3a49e3e6 = '12416186-FBBD-4973-A7F4-D030FD84994B'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_3a49e3e6,
  @DisplayName = @DisplayName_3a49e3e6,
  @Version = @Version_3a49e3e6,
  @GlobalVariable = @GlobalVariable_3a49e3e6,
  @Category = @Category_3a49e3e6,
  @CDNUrl = @CDNUrl_3a49e3e6,
  @CDNCssUrl = @CDNCssUrl_3a49e3e6,
  @Description = @Description_3a49e3e6,
  @Status = @Status_3a49e3e6,
  @LintRules = @LintRules_3a49e3e6,
  @ID = @ID_3a49e3e6;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_c4777c51 NVARCHAR(500),
@DisplayName_c4777c51 NVARCHAR(500),
@Version_c4777c51 NVARCHAR(100),
@GlobalVariable_c4777c51 NVARCHAR(255),
@Category_c4777c51 NVARCHAR(100),
@CDNUrl_c4777c51 NVARCHAR(1000),
@CDNCssUrl_c4777c51 NVARCHAR(1000),
@Description_c4777c51 NVARCHAR(MAX),
@Status_c4777c51 NVARCHAR(20),
@LintRules_c4777c51 NVARCHAR(MAX),
@ID_c4777c51 UNIQUEIDENTIFIER
SET
  @Name_c4777c51 = N'chart.js'
SET
  @DisplayName_c4777c51 = N'Chart.js'
SET
  @Version_c4777c51 = N'4.4.1'
SET
  @GlobalVariable_c4777c51 = N'Chart'
SET
  @Category_c4777c51 = N'Charting'
SET
  @CDNUrl_c4777c51 = N'https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js'
SET
  @Description_c4777c51 = N'Simple yet flexible JavaScript charting library'
SET
  @Status_c4777c51 = N'Active'
SET
  @LintRules_c4777c51 = N'{
  "initialization": {
    "constructorName": "Chart",
    "requiresNew": true,
    "elementType": "canvas",
    "requiredConfig": [
      "type",
      "data"
    ]
  },
  "lifecycle": {
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "update"
    ],
    "requiredMethods": []
  },
  "validators": {
    "checkDestroyBeforeRecreate": {
      "description": "Ensure Chart instances are destroyed before recreating on same canvas",
      "severity": "medium",
      "validate": "/**\n * Ensure Chart instances are destroyed before recreating on same canvas\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context with libraryName, globalVariable, instanceVariables\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'') {\n    \n    // Check if we''re in a useEffect\n    let inUseEffect = false;\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        inUseEffect = true;\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n    \n    if (inUseEffect) {\n      // Look for cleanup function return\n      let hasCleanup = false;\n      const effectFn = useEffectPath.node.arguments[0];\n      if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n        // Check if it returns a cleanup function\n        const body = effectFn.body;\n        if (t.isBlockStatement(body)) {\n          for (const stmt of body.body) {\n            if (t.isReturnStatement(stmt) && stmt.argument) {\n              hasCleanup = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      if (!hasCleanup) {\n        return {\n          rule: ''chart-missing-cleanup'',\n          severity: ''medium'',\n          message: ''Chart.js instances must be destroyed in useEffect cleanup to prevent memory leaks'',\n          line: path.node.loc?.start.line || 0,\n          column: path.node.loc?.start.column || 0,\n          fix: ''return () => { chartInstance.current?.destroy(); }''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkCanvasContext": {
      "description": "Validate canvas context is obtained correctly",
      "severity": "high",
      "validate": "/**\n * Validate canvas context is obtained correctly\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'' &&\n      path.node.arguments[0]) {\n    \n    const firstArg = path.node.arguments[0];\n    \n    // Check if it''s a getContext(''2d'') call\n    if (t.isCallExpression(firstArg) &&\n        t.isMemberExpression(firstArg.callee) &&\n        t.isIdentifier(firstArg.callee.property) &&\n        firstArg.callee.property.name === ''getContext'') {\n      \n      const contextArg = firstArg.arguments[0];\n      if (!t.isStringLiteral(contextArg) || contextArg.value !== ''2d'') {\n        return {\n          rule: ''chart-invalid-context'',\n          severity: ''high'',\n          message: ''Chart.js requires a 2D canvas context'',\n          line: contextArg?.loc?.start.line || 0,\n          column: contextArg?.loc?.start.column || 0,\n          fix: \"getContext(''2d'')\"\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkChartRegistration": {
      "description": "Check for Chart.register() when using tree-shaking",
      "severity": "medium",
      "validate": "/**\n * Check for Chart.register() when using tree-shaking\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Only check if we see specific controller imports\n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js/auto'') {\n    return null; // auto import includes everything\n  }\n  \n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js'' &&\n      path.node.specifiers.some(spec => \n        t.isImportSpecifier(spec) &&\n        t.isIdentifier(spec.imported) &&\n        [''BarController'', ''LineController'', ''PieController''].includes(spec.imported.name)\n      )) {\n    \n    // Look for Chart.register call\n    let hasRegister = false;\n    ast.program.body.forEach(node => {\n      if (t.isExpressionStatement(node) &&\n          t.isCallExpression(node.expression) &&\n          t.isMemberExpression(node.expression.callee) &&\n          t.isIdentifier(node.expression.callee.object) &&\n          node.expression.callee.object.name === ''Chart'' &&\n          t.isIdentifier(node.expression.callee.property) &&\n          node.expression.callee.property.name === ''register'') {\n        hasRegister = true;\n      }\n    });\n    \n    if (!hasRegister) {\n      return {\n        rule: ''chart-missing-registration'',\n        severity: ''medium'',\n        message: ''When importing specific Chart.js components, you must call Chart.register()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''Chart.register(BarController, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_c4777c51 = '754D12D4-B182-45E8-B4BB-98FB8A366B02'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_c4777c51,
  @DisplayName = @DisplayName_c4777c51,
  @Version = @Version_c4777c51,
  @GlobalVariable = @GlobalVariable_c4777c51,
  @Category = @Category_c4777c51,
  @CDNUrl = @CDNUrl_c4777c51,
  @CDNCssUrl = @CDNCssUrl_c4777c51,
  @Description = @Description_c4777c51,
  @Status = @Status_c4777c51,
  @LintRules = @LintRules_c4777c51,
  @ID = @ID_c4777c51;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_feb863dd NVARCHAR(500),
@DisplayName_feb863dd NVARCHAR(500),
@Version_feb863dd NVARCHAR(100),
@GlobalVariable_feb863dd NVARCHAR(255),
@Category_feb863dd NVARCHAR(100),
@CDNUrl_feb863dd NVARCHAR(1000),
@CDNCssUrl_feb863dd NVARCHAR(1000),
@Description_feb863dd NVARCHAR(MAX),
@Status_feb863dd NVARCHAR(20),
@LintRules_feb863dd NVARCHAR(MAX),
@ID_feb863dd UNIQUEIDENTIFIER
SET
  @Name_feb863dd = N'ApexCharts'
SET
  @DisplayName_feb863dd = N'ApexCharts'
SET
  @Version_feb863dd = N'3.45.1'
SET
  @GlobalVariable_feb863dd = N'ApexCharts'
SET
  @Category_feb863dd = N'Charting'
SET
  @CDNUrl_feb863dd = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_feb863dd = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_feb863dd = N'Modern interactive JavaScript charts library'
SET
  @Status_feb863dd = N'Active'
SET
  @LintRules_feb863dd = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "medium",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''medium'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkSeriesDataFormat": {
      "description": "Validate data is in correct ApexCharts series format",
      "severity": "critical",
      "validate": "// Validates that data passed to ApexCharts is in the correct series format\n(ast, path, t, context) => {\n  // Look for chart creation or series updates\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const configArg = path.node.arguments[1];\n    if (configArg && t.isObjectExpression(configArg)) {\n      const seriesProp = configArg.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''series''\n      );\n      \n      if (seriesProp && t.isIdentifier(seriesProp.value)) {\n        // Track the variable name for later validation\n        context.apexSeriesVars = context.apexSeriesVars || new Set();\n        context.apexSeriesVars.add(seriesProp.value.name);\n      }\n    }\n  }\n  \n  // Check updateSeries calls\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''updateSeries'') {\n    const parent = path.parent;\n    if (t.isCallExpression(parent)) {\n      const arg = parent.arguments[0];\n      if (arg && t.isIdentifier(arg)) {\n        // Flag for validation - series data should be array of objects with name and data\n        context.violations.push({\n          type: ''warning'',\n          message: `Verify that ''$' + '{arg.name}'' is formatted as ApexCharts series: [{name: string, data: [{x, y}]}]`,\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Transform data to: selectedMetrics.map(metric => ({ name: metric, data: points.map(p => ({x: timestamp, y: value})) }))''\n        });\n      }\n    }\n  }\n  \n  // Look for common data format mistakes\n  if (t.isObjectExpression(path.node)) {\n    const hasDateProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''date''\n    );\n    const hasDurationProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''duration''\n    );\n    const hasCostProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''cost''\n    );\n    \n    // This looks like processed data that needs transformation\n    if (hasDateProp && (hasDurationProp || hasCostProp)) {\n      // Check if this is being passed to chart\n      let parent = path.parent;\n      let depth = 0;\n      while (parent && depth < 5) {\n        if (t.isJSXAttribute(parent) && parent.name?.name === ''seriesData'') {\n          context.violations.push({\n            type: ''error'',\n            message: ''Data structure {date, duration, cost} needs transformation to ApexCharts series format'',\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''Transform to: [{name: \"Duration\", data: [{x: timestamp, y: value}]}, ...]''\n          });\n          break;\n        }\n        parent = parent.parent;\n        depth++;\n      }\n    }\n  }\n}"
    },
    "checkChartRefManagement": {
      "description": "Ensure chart instances are properly stored in refs for exports",
      "severity": "high",
      "validate": "// Validates that chart instances are properly stored and exposed via refs\n(ast, path, t, context) => {\n  // Check for new ApexCharts creation\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const parent = path.parent;\n    \n    // Check if the chart instance is being stored\n    if (t.isVariableDeclarator(parent)) {\n      const varName = parent.id.name;\n      context.apexChartVars = context.apexChartVars || new Set();\n      context.apexChartVars.add(varName);\n      \n      // Now check if this variable is attached to a ref\n      const scope = path.scope;\n      const binding = scope.getBinding(varName);\n      if (binding) {\n        let isAttachedToRef = false;\n        \n        for (const refPath of binding.referencePaths) {\n          // Check for patterns like: chartRef.current = chart\n          if (t.isMemberExpression(refPath.parent) && \n              refPath.parent.property?.name === ''current'') {\n            isAttachedToRef = true;\n            break;\n          }\n          // Check for: chartRef.current._chart = chart\n          if (t.isMemberExpression(refPath.parent?.left) &&\n              refPath.parent?.left?.property?.name === ''_chart'') {\n            isAttachedToRef = true;\n            break;\n          }\n        }\n        \n        if (!isAttachedToRef) {\n          context.violations.push({\n            type: ''error'',  \n            message: `ApexCharts instance ''$' + '{varName}'' should be attached to a ref for export functionality`,\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''After creating chart, store it: chartRef.current = chart;''\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for dataURI usage without proper ref\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''dataURI'') {\n    const object = path.node.object;\n    \n    // Check if it''s accessing through a ref\n    if (t.isMemberExpression(object)) {\n      if (!object.property || object.property.name !== ''current'') {\n        context.violations.push({\n          type: ''warning'',\n          message: ''dataURI() should be called on chart instance stored in ref.current'',\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Use: chartRef.current?.dataURI() or chart.dataURI()''\n        });\n      }\n    }\n  }\n  \n  // Check for missing chart storage in useEffect\n  if (t.isCallExpression(path.node) && \n      t.isMemberExpression(path.node.callee) &&\n      path.node.callee.object?.name === ''chart'' &&\n      path.node.callee.property?.name === ''render'') {\n    \n    // Look for the chart variable in parent scope\n    let foundChartStorage = false;\n    let parent = path.parent;\n    let depth = 0;\n    \n    while (parent && depth < 10) {\n      if (t.isBlockStatement(parent)) {\n        // Check if chartRef.current is set in this block\n        const statements = parent.body;\n        foundChartStorage = statements.some(stmt => {\n          if (t.isExpressionStatement(stmt) && \n              t.isAssignmentExpression(stmt.expression)) {\n            const left = stmt.expression.left;\n            return t.isMemberExpression(left) && \n                   left.property?.name === ''current'';\n          }\n          return false;\n        });\n        \n        if (foundChartStorage) break;\n      }\n      parent = parent.parent;\n      depth++;\n    }\n    \n    if (!foundChartStorage) {\n      context.violations.push({\n        type: ''warning'',\n        message: ''Chart instance may not be stored in ref for export functionality'',\n        line: path.node.loc?.start.line,\n        column: path.node.loc?.start.column,\n        suggestion: ''Store chart in ref: chartRef.current = chart;''\n      });\n    }\n  }\n}"
    },
    "checkAnomalyFormat": {
      "description": "Validate anomaly data format for annotations",
      "severity": "medium",
      "validate": "// Validates that anomaly data for ApexCharts annotations is correctly formatted\n(ast, path, t, context) => {\n  // Look for annotations configuration in chart options\n  if (t.isObjectProperty(path.node) && \n      t.isIdentifier(path.node.key) && \n      path.node.key.name === ''annotations'') {\n    \n    const value = path.node.value;\n    if (t.isObjectExpression(value)) {\n      // Check for points property\n      const pointsProp = value.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''points''\n      );\n      \n      if (pointsProp) {\n        // Check if it''s mapping over anomalies\n        if (t.isCallExpression(pointsProp.value) && \n            t.isMemberExpression(pointsProp.value.callee) &&\n            pointsProp.value.callee.property?.name === ''map'') {\n          \n          const mapArg = pointsProp.value.arguments[0];\n          if (t.isArrowFunctionExpression(mapArg) || t.isFunctionExpression(mapArg)) {\n            const body = mapArg.body;\n            \n            // Check the structure being returned\n            if (t.isObjectExpression(body) || \n                (t.isBlockStatement(body) && body.body.length > 0)) {\n              \n              // Look for common mistakes\n              const checkForDateField = (obj) => {\n                if (t.isObjectExpression(obj)) {\n                  const hasDate = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''date''\n                  );\n                  const hasX = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''x''\n                  );\n                  \n                  if (hasDate && !hasX) {\n                    context.violations.push({\n                      type: ''error'',\n                      message: ''Anomaly annotations should use \"x\" property with timestamp, not \"date\"'',\n                      line: obj.loc?.start.line,\n                      column: obj.loc?.start.column,\n                      suggestion: ''Change to: { x: new Date(anomaly.date).getTime(), y: anomaly.value, ... }''\n                    });\n                  }\n                }\n              };\n              \n              if (t.isObjectExpression(body)) {\n                checkForDateField(body);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for anomaly data being set in state\n  if (t.isCallExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''setAnomalies'') {\n    \n    const arg = path.node.arguments[0];\n    if (t.isArrayExpression(arg) && arg.elements.length > 0) {\n      const firstElement = arg.elements[0];\n      \n      if (t.isObjectExpression(firstElement)) {\n        const hasDate = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''date''\n        );\n        const hasX = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''x''\n        );\n        \n        if (hasDate && !hasX) {\n          context.violations.push({\n            type: ''warning'',\n            message: ''Anomaly data should include \"x\" property for ApexCharts compatibility'',\n            line: firstElement.loc?.start.line,\n            column: firstElement.loc?.start.column,\n            suggestion: ''Include: { x: new Date(point.date), y: value, metric: metricName }''\n          });\n        }\n      }\n    }\n  }\n}"
    }
  }
}'
SET
  @ID_feb863dd = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_feb863dd,
  @DisplayName = @DisplayName_feb863dd,
  @Version = @Version_feb863dd,
  @GlobalVariable = @GlobalVariable_feb863dd,
  @Category = @Category_feb863dd,
  @CDNUrl = @CDNUrl_feb863dd,
  @CDNCssUrl = @CDNCssUrl_feb863dd,
  @Description = @Description_feb863dd,
  @Status = @Status_feb863dd,
  @LintRules = @LintRules_feb863dd,
  @ID = @ID_feb863dd;


-- End of SQL Logging Session
-- Session ID: 6eab4e48-0669-4607-aeb9-f467ecb45a4a
-- Completed: 2025-08-20T22:49:08.684Z
-- Duration: 23864ms
-- Total Statements: 3





















-- SQL Logging Session
-- Session ID: 5c7e4cb5-acd4-4d70-a012-b57351fb9209
-- Started: 2025-08-21T02:17:28.897Z
-- Description: MetadataSync push operation
-- Format: Migration-ready with Flyway schema placeholders
-- Generated by MemberJunction SQLServerDataProvider

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_59218d6b NVARCHAR(500),
@DisplayName_59218d6b NVARCHAR(500),
@Version_59218d6b NVARCHAR(100),
@GlobalVariable_59218d6b NVARCHAR(255),
@Category_59218d6b NVARCHAR(100),
@CDNUrl_59218d6b NVARCHAR(1000),
@CDNCssUrl_59218d6b NVARCHAR(1000),
@Description_59218d6b NVARCHAR(MAX),
@Status_59218d6b NVARCHAR(20),
@LintRules_59218d6b NVARCHAR(MAX),
@ID_59218d6b UNIQUEIDENTIFIER
SET
  @Name_59218d6b = N'd3'
SET
  @DisplayName_59218d6b = N'D3.js'
SET
  @Version_59218d6b = N'7.8.5'
SET
  @GlobalVariable_59218d6b = N'd3'
SET
  @Category_59218d6b = N'Charting'
SET
  @CDNUrl_59218d6b = N'https://unpkg.com/d3@7.8.5/dist/d3.min.js'
SET
  @Description_59218d6b = N'Data visualization library for creating custom charts'
SET
  @Status_59218d6b = N'Active'
SET
  @LintRules_59218d6b = N'{
  "initialization": {
    "factoryMethod": "select",
    "elementType": "svg",
    "requiresNew": false
  },
  "lifecycle": {
    "cleanupMethods": [
      "remove",
      "interrupt"
    ],
    "requiredMethods": [],
    "updateMethods": [
      "data",
      "attr",
      "style"
    ]
  },
  "validators": {
    "checkSelectionCleanup": {
      "description": "Ensure D3 selections are properly cleaned up",
      "severity": "high",
      "validate": "/**\n * Ensure D3 selections are properly cleaned up\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for D3 selections in useEffect without cleanup\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.object) &&\n      path.node.callee.object.name === ''d3'' &&\n      t.isIdentifier(path.node.callee.property) &&\n      [''select'', ''selectAll''].includes(path.node.callee.property.name)) {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                hasCleanup = true;\n                break;\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''d3-missing-cleanup'',\n              severity: ''high'',\n              message: ''D3 selections must be cleaned up in useEffect to prevent memory leaks'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { d3.select(ref.current).selectAll(\"*\").remove(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkJoinPattern": {
      "description": "Recommend modern join() pattern over enter/exit",
      "severity": "low",
      "validate": "/**\n * Recommend modern join() pattern over enter/exit\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Check for old enter/append pattern\n  if (t.isCallExpression(path.node) &&\n      t.isMemberExpression(path.node.callee) &&\n      t.isIdentifier(path.node.callee.property) &&\n      path.node.callee.property.name === ''enter'') {\n    \n    // Check if followed by append\n    if (t.isMemberExpression(path.parent) &&\n        path.parent.object === path.node &&\n        t.isCallExpression(path.parent.parent) &&\n        t.isIdentifier(path.parent.property) &&\n        path.parent.property.name === ''append'') {\n      \n      return {\n        rule: ''d3-use-join'',\n        severity: ''low'',\n        message: ''Consider using the modern .join() pattern instead of .enter().append()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''.join(\"element\") // Handles enter, update, and exit automatically''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_59218d6b = '12416186-FBBD-4973-A7F4-D030FD84994B'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_59218d6b,
  @DisplayName = @DisplayName_59218d6b,
  @Version = @Version_59218d6b,
  @GlobalVariable = @GlobalVariable_59218d6b,
  @Category = @Category_59218d6b,
  @CDNUrl = @CDNUrl_59218d6b,
  @CDNCssUrl = @CDNCssUrl_59218d6b,
  @Description = @Description_59218d6b,
  @Status = @Status_59218d6b,
  @LintRules = @LintRules_59218d6b,
  @ID = @ID_59218d6b;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_e5a4c001 NVARCHAR(500),
@DisplayName_e5a4c001 NVARCHAR(500),
@Version_e5a4c001 NVARCHAR(100),
@GlobalVariable_e5a4c001 NVARCHAR(255),
@Category_e5a4c001 NVARCHAR(100),
@CDNUrl_e5a4c001 NVARCHAR(1000),
@CDNCssUrl_e5a4c001 NVARCHAR(1000),
@Description_e5a4c001 NVARCHAR(MAX),
@Status_e5a4c001 NVARCHAR(20),
@LintRules_e5a4c001 NVARCHAR(MAX),
@ID_e5a4c001 UNIQUEIDENTIFIER
SET
  @Name_e5a4c001 = N'chart.js'
SET
  @DisplayName_e5a4c001 = N'Chart.js'
SET
  @Version_e5a4c001 = N'4.4.1'
SET
  @GlobalVariable_e5a4c001 = N'Chart'
SET
  @Category_e5a4c001 = N'Charting'
SET
  @CDNUrl_e5a4c001 = N'https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js'
SET
  @Description_e5a4c001 = N'Simple yet flexible JavaScript charting library'
SET
  @Status_e5a4c001 = N'Active'
SET
  @LintRules_e5a4c001 = N'{
  "initialization": {
    "constructorName": "Chart",
    "requiresNew": true,
    "elementType": "canvas",
    "requiredConfig": [
      "type",
      "data"
    ]
  },
  "lifecycle": {
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "update"
    ],
    "requiredMethods": []
  },
  "validators": {
    "checkDestroyBeforeRecreate": {
      "description": "Ensure Chart instances are destroyed before recreating on same canvas",
      "severity": "high",
      "validate": "/**\n * Ensure Chart instances are destroyed before recreating on same canvas\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context with libraryName, globalVariable, instanceVariables\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'') {\n    \n    // Check if we''re in a useEffect\n    let inUseEffect = false;\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        inUseEffect = true;\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n    \n    if (inUseEffect) {\n      // Look for cleanup function return\n      let hasCleanup = false;\n      const effectFn = useEffectPath.node.arguments[0];\n      if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n        // Check if it returns a cleanup function\n        const body = effectFn.body;\n        if (t.isBlockStatement(body)) {\n          for (const stmt of body.body) {\n            if (t.isReturnStatement(stmt) && stmt.argument) {\n              hasCleanup = true;\n              break;\n            }\n          }\n        }\n      }\n      \n      if (!hasCleanup) {\n        return {\n          rule: ''chart-missing-cleanup'',\n          severity: ''high'',\n          message: ''Chart.js instances must be destroyed in useEffect cleanup to prevent memory leaks'',\n          line: path.node.loc?.start.line || 0,\n          column: path.node.loc?.start.column || 0,\n          fix: ''return () => { chartInstance.current?.destroy(); }''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkCanvasContext": {
      "description": "Validate canvas context is obtained correctly",
      "severity": "high",
      "validate": "/**\n * Validate canvas context is obtained correctly\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''Chart'' &&\n      path.node.arguments[0]) {\n    \n    const firstArg = path.node.arguments[0];\n    \n    // Check if it''s a getContext(''2d'') call\n    if (t.isCallExpression(firstArg) &&\n        t.isMemberExpression(firstArg.callee) &&\n        t.isIdentifier(firstArg.callee.property) &&\n        firstArg.callee.property.name === ''getContext'') {\n      \n      const contextArg = firstArg.arguments[0];\n      if (!t.isStringLiteral(contextArg) || contextArg.value !== ''2d'') {\n        return {\n          rule: ''chart-invalid-context'',\n          severity: ''high'',\n          message: ''Chart.js requires a 2D canvas context'',\n          line: contextArg?.loc?.start.line || 0,\n          column: contextArg?.loc?.start.column || 0,\n          fix: \"getContext(''2d'')\"\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkChartRegistration": {
      "description": "Check for Chart.register() when using tree-shaking",
      "severity": "medium",
      "validate": "/**\n * Check for Chart.register() when using tree-shaking\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  // Only check if we see specific controller imports\n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js/auto'') {\n    return null; // auto import includes everything\n  }\n  \n  if (t.isImportDeclaration(path.node) &&\n      path.node.source.value === ''chart.js'' &&\n      path.node.specifiers.some(spec => \n        t.isImportSpecifier(spec) &&\n        t.isIdentifier(spec.imported) &&\n        [''BarController'', ''LineController'', ''PieController''].includes(spec.imported.name)\n      )) {\n    \n    // Look for Chart.register call\n    let hasRegister = false;\n    ast.program.body.forEach(node => {\n      if (t.isExpressionStatement(node) &&\n          t.isCallExpression(node.expression) &&\n          t.isMemberExpression(node.expression.callee) &&\n          t.isIdentifier(node.expression.callee.object) &&\n          node.expression.callee.object.name === ''Chart'' &&\n          t.isIdentifier(node.expression.callee.property) &&\n          node.expression.callee.property.name === ''register'') {\n        hasRegister = true;\n      }\n    });\n    \n    if (!hasRegister) {\n      return {\n        rule: ''chart-missing-registration'',\n        severity: ''medium'',\n        message: ''When importing specific Chart.js components, you must call Chart.register()'',\n        line: path.node.loc?.start.line || 0,\n        column: path.node.loc?.start.column || 0,\n        fix: ''Chart.register(BarController, CategoryScale, LinearScale, BarElement, Title, Tooltip, Legend);''\n      };\n    }\n  }\n  return null;\n}"
    }
  }
}'
SET
  @ID_e5a4c001 = '754D12D4-B182-45E8-B4BB-98FB8A366B02'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_e5a4c001,
  @DisplayName = @DisplayName_e5a4c001,
  @Version = @Version_e5a4c001,
  @GlobalVariable = @GlobalVariable_e5a4c001,
  @Category = @Category_e5a4c001,
  @CDNUrl = @CDNUrl_e5a4c001,
  @CDNCssUrl = @CDNCssUrl_e5a4c001,
  @Description = @Description_e5a4c001,
  @Status = @Status_e5a4c001,
  @LintRules = @LintRules_e5a4c001,
  @ID = @ID_e5a4c001;

-- Save MJ: Component Libraries (core SP call only)
DECLARE @Name_3707bf65 NVARCHAR(500),
@DisplayName_3707bf65 NVARCHAR(500),
@Version_3707bf65 NVARCHAR(100),
@GlobalVariable_3707bf65 NVARCHAR(255),
@Category_3707bf65 NVARCHAR(100),
@CDNUrl_3707bf65 NVARCHAR(1000),
@CDNCssUrl_3707bf65 NVARCHAR(1000),
@Description_3707bf65 NVARCHAR(MAX),
@Status_3707bf65 NVARCHAR(20),
@LintRules_3707bf65 NVARCHAR(MAX),
@ID_3707bf65 UNIQUEIDENTIFIER
SET
  @Name_3707bf65 = N'ApexCharts'
SET
  @DisplayName_3707bf65 = N'ApexCharts'
SET
  @Version_3707bf65 = N'3.45.1'
SET
  @GlobalVariable_3707bf65 = N'ApexCharts'
SET
  @Category_3707bf65 = N'Charting'
SET
  @CDNUrl_3707bf65 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js'
SET
  @CDNCssUrl_3707bf65 = N'https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.css'
SET
  @Description_3707bf65 = N'Modern interactive JavaScript charts library'
SET
  @Status_3707bf65 = N'Active'
SET
  @LintRules_3707bf65 = N'{
  "initialization": {
    "constructorName": "ApexCharts",
    "requiresNew": true,
    "elementType": "div",
    "requiredConfig": [
      "chart",
      "series"
    ]
  },
  "lifecycle": {
    "requiredMethods": [],
    "cleanupMethods": [
      "destroy"
    ],
    "updateMethods": [
      "updateOptions",
      "updateSeries",
      "appendSeries"
    ]
  },
  "validators": {
    "checkRenderCall": {
      "description": "Ensure ApexCharts instances call render() after creation",
      "severity": "critical",
      "validate": "/**\n * Ensure ApexCharts instances call render() after creation\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if this is assigned to a variable\n    if (t.isVariableDeclarator(path.parent)) {\n      const varName = t.isIdentifier(path.parent.id) ? path.parent.id.name : null;\n      \n      if (varName) {\n        // Look for render call on this variable\n        let hasRender = false;\n        const parentScope = path.getFunctionParent();\n        \n        if (parentScope) {\n          parentScope.traverse({\n            CallExpression(callPath) {\n              if (t.isMemberExpression(callPath.node.callee) &&\n                  t.isIdentifier(callPath.node.callee.object) &&\n                  callPath.node.callee.object.name === varName &&\n                  t.isIdentifier(callPath.node.callee.property) &&\n                  callPath.node.callee.property.name === ''render'') {\n                hasRender = true;\n              }\n            }\n          });\n        }\n        \n        if (!hasRender) {\n          return {\n            rule: ''apexcharts-missing-render'',\n            severity: ''critical'',\n            message: ''ApexCharts instances must call .render() to display the chart'',\n            line: path.node.loc?.start.line || 0,\n            column: path.node.loc?.start.column || 0,\n            fix: `$' + '{varName}.render();`\n          };\n        }\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkDestroyInCleanup": {
      "description": "Ensure ApexCharts instances are destroyed in cleanup",
      "severity": "high",
      "validate": "/**\n * Ensure ApexCharts instances are destroyed in cleanup\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'') {\n    \n    // Check if we''re in a useEffect\n    let useEffectPath = path;\n    while (useEffectPath) {\n      if (t.isCallExpression(useEffectPath.node) && \n          t.isIdentifier(useEffectPath.node.callee) &&\n          useEffectPath.node.callee.name === ''useEffect'') {\n        \n        // Check for cleanup return\n        const effectFn = useEffectPath.node.arguments[0];\n        if (t.isArrowFunctionExpression(effectFn) || t.isFunctionExpression(effectFn)) {\n          const body = effectFn.body;\n          let hasCleanup = false;\n          \n          if (t.isBlockStatement(body)) {\n            for (const stmt of body.body) {\n              if (t.isReturnStatement(stmt) && stmt.argument) {\n                // Check if the return contains destroy call\n                const returnArg = stmt.argument;\n                if (t.isArrowFunctionExpression(returnArg) || t.isFunctionExpression(returnArg)) {\n                  hasCleanup = true;\n                }\n              }\n            }\n          }\n          \n          if (!hasCleanup) {\n            return {\n              rule: ''apexcharts-missing-cleanup'',\n              severity: ''high'',\n              message: ''ApexCharts instances must be destroyed in useEffect cleanup'',\n              line: path.node.loc?.start.line || 0,\n              column: path.node.loc?.start.column || 0,\n              fix: ''return () => { chart?.destroy(); }''\n            };\n          }\n        }\n        break;\n      }\n      useEffectPath = useEffectPath.parentPath;\n    }\n  }\n  return null;\n}"
    },
    "checkOptionsStructure": {
      "description": "Validate ApexCharts options structure",
      "severity": "high",
      "validate": "/**\n * Validate ApexCharts options structure\n * @param {Object} ast - The full AST\n * @param {Object} path - Current node path being validated\n * @param {Object} t - Babel types\n * @param {Object} context - Additional context\n * @returns {Object|null} Violation object or null if valid\n */\n(ast, path, t, context) => {\n  if (t.isNewExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''ApexCharts'' &&\n      path.node.arguments[1]) {\n    \n    const optionsArg = path.node.arguments[1];\n    \n    if (t.isObjectExpression(optionsArg)) {\n      const properties = optionsArg.properties;\n      \n      // Check for required properties\n      const hasChart = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''chart''\n      );\n      \n      const hasSeries = properties.some(prop => \n        t.isObjectProperty(prop) &&\n        t.isIdentifier(prop.key) &&\n        prop.key.name === ''series''\n      );\n      \n      if (!hasChart) {\n        return {\n          rule: ''apexcharts-missing-chart-config'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"chart\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''chart: { type: \"bar\", height: 350 }''\n        };\n      }\n      \n      if (!hasSeries) {\n        return {\n          rule: ''apexcharts-missing-series'',\n          severity: ''high'',\n          message: ''ApexCharts options must include a \"series\" property'',\n          line: optionsArg.loc?.start.line || 0,\n          column: optionsArg.loc?.start.column || 0,\n          fix: ''series: [{ name: \"Series 1\", data: [] }]''\n        };\n      }\n    }\n  }\n  return null;\n}"
    },
    "checkSeriesDataFormat": {
      "description": "Validate data is in correct ApexCharts series format",
      "severity": "critical",
      "validate": "// Validates that data passed to ApexCharts is in the correct series format\n(ast, path, t, context) => {\n  // Look for chart creation or series updates\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const configArg = path.node.arguments[1];\n    if (configArg && t.isObjectExpression(configArg)) {\n      const seriesProp = configArg.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''series''\n      );\n      \n      if (seriesProp && t.isIdentifier(seriesProp.value)) {\n        // Track the variable name for later validation\n        context.apexSeriesVars = context.apexSeriesVars || new Set();\n        context.apexSeriesVars.add(seriesProp.value.name);\n      }\n    }\n  }\n  \n  // Check updateSeries calls\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''updateSeries'') {\n    const parent = path.parent;\n    if (t.isCallExpression(parent)) {\n      const arg = parent.arguments[0];\n      if (arg && t.isIdentifier(arg)) {\n        // Flag for validation - series data should be array of objects with name and data\n        context.violations.push({\n          severity: ''medium'',\n          message: `Verify that ''$' + '{arg.name}'' is formatted as ApexCharts series: [{name: string, data: [{x, y}]}]`,\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Transform data to: selectedMetrics.map(metric => ({ name: metric, data: points.map(p => ({x: timestamp, y: value})) }))''\n        });\n      }\n    }\n  }\n  \n  // Look for common data format mistakes\n  if (t.isObjectExpression(path.node)) {\n    const hasDateProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''date''\n    );\n    const hasDurationProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''duration''\n    );\n    const hasCostProp = path.node.properties.some(p => \n      t.isObjectProperty(p) && t.isIdentifier(p.key) && p.key.name === ''cost''\n    );\n    \n    // This looks like processed data that needs transformation\n    if (hasDateProp && (hasDurationProp || hasCostProp)) {\n      // Check if this is being passed to chart\n      let parent = path.parent;\n      let depth = 0;\n      while (parent && depth < 5) {\n        if (t.isJSXAttribute(parent) && parent.name?.name === ''seriesData'') {\n          context.violations.push({\n            severity: ''critical'',\n            message: ''Data structure {date, duration, cost} needs transformation to ApexCharts series format'',\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''Transform to: [{name: \"Duration\", data: [{x: timestamp, y: value}]}, ...]''\n          });\n          break;\n        }\n        parent = parent.parent;\n        depth++;\n      }\n    }\n  }\n}"
    },
    "checkChartRefManagement": {
      "description": "Ensure chart instances are properly stored in refs for exports",
      "severity": "low",
      "validate": "// Validates that chart instances are properly stored and exposed via refs\n(ast, path, t, context) => {\n  // Initialize tracking sets if not already done\n  context.apexChartVars = context.apexChartVars || new Set();\n  context.apexChartVarsWithRefWarning = context.apexChartVarsWithRefWarning || new Set();\n  \n  // Check for new ApexCharts creation\n  if (t.isNewExpression(path.node) && path.node.callee.name === ''ApexCharts'') {\n    const parent = path.parent;\n    \n    // Check if the chart instance is being stored\n    if (t.isVariableDeclarator(parent)) {\n      const varName = parent.id.name;\n      context.apexChartVars.add(varName);\n      \n      // Now check if this variable is attached to a ref\n      const scope = path.scope;\n      const binding = scope.getBinding(varName);\n      if (binding) {\n        let isAttachedToRef = false;\n        \n        for (const refPath of binding.referencePaths) {\n          // Check for patterns like: chartRef.current = chart\n          if (t.isAssignmentExpression(refPath.parent) &&\n              t.isMemberExpression(refPath.parent.left) && \n              refPath.parent.left.property?.name === ''current'') {\n            isAttachedToRef = true;\n            break;\n          }\n          // Check for: chartRef.current._chart = chart\n          if (t.isAssignmentExpression(refPath.parent) &&\n              t.isMemberExpression(refPath.parent.left) &&\n              refPath.parent.left.property?.name === ''_chart'') {\n            isAttachedToRef = true;\n            break;\n          }\n        }\n        \n        if (!isAttachedToRef) {\n          // Mark that we already warned about this chart variable\n          context.apexChartVarsWithRefWarning.add(varName);\n          context.violations.push({\n            severity: ''low'',  \n            message: `ApexCharts instance ''$' + '{varName}'' should be attached to a ref for export functionality`,\n            line: path.node.loc?.start.line,\n            column: path.node.loc?.start.column,\n            suggestion: ''After creating chart, store it: chartRef.current = chart;''\n          });\n        }\n      }\n    }\n  }\n  \n  // Check for dataURI usage without proper ref\n  if (t.isMemberExpression(path.node) && \n      t.isIdentifier(path.node.property) && \n      path.node.property.name === ''dataURI'') {\n    const object = path.node.object;\n    \n    // Check if it''s accessing through a ref\n    if (t.isMemberExpression(object)) {\n      if (!object.property || object.property.name !== ''current'') {\n        context.violations.push({\n          severity: ''low'',\n          message: ''dataURI() should be called on chart instance stored in ref.current'',\n          line: path.node.loc?.start.line,\n          column: path.node.loc?.start.column,\n          suggestion: ''Use: chartRef.current?.dataURI() or chart.dataURI()''\n        });\n      }\n    }\n  }\n  \n  // Check for chart.render() calls - but skip if we already warned about this chart variable\n  if (t.isCallExpression(path.node) && \n      t.isMemberExpression(path.node.callee) &&\n      path.node.callee.object?.name === ''chart'' &&\n      path.node.callee.property?.name === ''render'') {\n    \n    const chartVarName = path.node.callee.object.name;\n    \n    // Skip if we already warned about this chart variable not being in a ref\n    if (context.apexChartVarsWithRefWarning && context.apexChartVarsWithRefWarning.has(chartVarName)) {\n      return; // Don''t duplicate the warning\n    }\n    \n    // Also skip if this chart variable was properly created and tracked\n    if (context.apexChartVars && context.apexChartVars.has(chartVarName)) {\n      // We already checked this variable when it was created\n      return;\n    }\n    \n    // This is a render() call on a chart we haven''t seen created (might be from props/params)\n    // Check if it''s stored in a ref in the current scope\n    let foundChartStorage = false;\n    let currentPath = path;\n    \n    // Look up the tree for the containing function/block\n    while (currentPath && !t.isFunctionDeclaration(currentPath.node) && \n           !t.isFunctionExpression(currentPath.node) && \n           !t.isArrowFunctionExpression(currentPath.node)) {\n      currentPath = currentPath.parentPath;\n    }\n    \n    if (currentPath) {\n      // Check if chartRef.current = chart exists in this scope\n      currentPath.traverse({\n        AssignmentExpression(assignPath) {\n          if (t.isMemberExpression(assignPath.node.left) &&\n              assignPath.node.left.property?.name === ''current'' &&\n              t.isIdentifier(assignPath.node.right) &&\n              assignPath.node.right.name === chartVarName) {\n            foundChartStorage = true;\n          }\n        }\n      });\n    }\n    \n    if (!foundChartStorage) {\n      context.violations.push({\n        severity: ''low'',\n        message: `Chart instance ''$' + '{chartVarName}'' may not be stored in ref for export functionality`,\n        line: path.node.loc?.start.line,\n        column: path.node.loc?.start.column,\n        suggestion: ''Store chart in ref: chartRef.current = chart;''\n      });\n    }\n  }\n}"
    },
    "checkAnomalyFormat": {
      "description": "Validate anomaly data format for annotations",
      "severity": "medium",
      "validate": "// Validates that anomaly data for ApexCharts annotations is correctly formatted\n(ast, path, t, context) => {\n  // Look for annotations configuration in chart options\n  if (t.isObjectProperty(path.node) && \n      t.isIdentifier(path.node.key) && \n      path.node.key.name === ''annotations'') {\n    \n    const value = path.node.value;\n    if (t.isObjectExpression(value)) {\n      // Check for points property\n      const pointsProp = value.properties.find(p => \n        t.isObjectProperty(p) && \n        t.isIdentifier(p.key) && \n        p.key.name === ''points''\n      );\n      \n      if (pointsProp) {\n        // Check if it''s mapping over anomalies\n        if (t.isCallExpression(pointsProp.value) && \n            t.isMemberExpression(pointsProp.value.callee) &&\n            pointsProp.value.callee.property?.name === ''map'') {\n          \n          const mapArg = pointsProp.value.arguments[0];\n          if (t.isArrowFunctionExpression(mapArg) || t.isFunctionExpression(mapArg)) {\n            const body = mapArg.body;\n            \n            // Check the structure being returned\n            if (t.isObjectExpression(body) || \n                (t.isBlockStatement(body) && body.body.length > 0)) {\n              \n              // Look for common mistakes\n              const checkForDateField = (obj) => {\n                if (t.isObjectExpression(obj)) {\n                  const hasDate = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''date''\n                  );\n                  const hasX = obj.properties.some(p => \n                    t.isObjectProperty(p) && \n                    t.isIdentifier(p.key) && \n                    p.key.name === ''x''\n                  );\n                  \n                  if (hasDate && !hasX) {\n                    context.violations.push({\n                      severity: ''critical'',\n                      message: ''Anomaly annotations should use \"x\" property with timestamp, not \"date\"'',\n                      line: obj.loc?.start.line,\n                      column: obj.loc?.start.column,\n                      suggestion: ''Change to: { x: new Date(anomaly.date).getTime(), y: anomaly.value, ... }''\n                    });\n                  }\n                }\n              };\n              \n              if (t.isObjectExpression(body)) {\n                checkForDateField(body);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Check for anomaly data being set in state\n  if (t.isCallExpression(path.node) && \n      t.isIdentifier(path.node.callee) && \n      path.node.callee.name === ''setAnomalies'') {\n    \n    const arg = path.node.arguments[0];\n    if (t.isArrayExpression(arg) && arg.elements.length > 0) {\n      const firstElement = arg.elements[0];\n      \n      if (t.isObjectExpression(firstElement)) {\n        const hasDate = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''date''\n        );\n        const hasX = firstElement.properties.some(p => \n          t.isObjectProperty(p) && \n          t.isIdentifier(p.key) && \n          p.key.name === ''x''\n        );\n        \n        if (hasDate && !hasX) {\n          context.violations.push({\n            severity: ''medium'',\n            message: ''Anomaly data should include \"x\" property for ApexCharts compatibility'',\n            line: firstElement.loc?.start.line,\n            column: firstElement.loc?.start.column,\n            suggestion: ''Include: { x: new Date(point.date), y: value, metric: metricName }''\n          });\n        }\n      }\n    }\n  }\n}"
    }
  }
}'
SET
  @ID_3707bf65 = '91E9DB43-6688-4838-939E-C4FC1F15C6CE'
EXEC [${flyway:defaultSchema}].spUpdateComponentLibrary @Name = @Name_3707bf65,
  @DisplayName = @DisplayName_3707bf65,
  @Version = @Version_3707bf65,
  @GlobalVariable = @GlobalVariable_3707bf65,
  @Category = @Category_3707bf65,
  @CDNUrl = @CDNUrl_3707bf65,
  @CDNCssUrl = @CDNCssUrl_3707bf65,
  @Description = @Description_3707bf65,
  @Status = @Status_3707bf65,
  @LintRules = @LintRules_3707bf65,
  @ID = @ID_3707bf65;


-- End of SQL Logging Session
-- Session ID: 5c7e4cb5-acd4-4d70-a012-b57351fb9209
-- Completed: 2025-08-21T02:17:54.396Z
-- Duration: 25499ms
-- Total Statements: 3
