# MemberJunction 3.0 Phase 2: CodeGen, Migration & Documentation

## Overview

This document covers **Phase 2** of the MemberJunction 3.0 Minimal App Shell Architecture implementation.

**Prerequisite**: Complete [Phase 1 - Bootstrap Packages](3.0-minimal-app-shell-architecture.md) first, which includes:
- `@memberjunction/server-bootstrap` package
- `@memberjunction/ng-bootstrap` package

**Phase 2 Focus**: Scaffold tooling, CLI commands, CodeGen updates, migration tooling, and comprehensive documentation.

---

## Phase 2 Implementation Tasks

### 1. Scaffold Library & CLI Commands

#### 1.1 New Package: `@memberjunction/scaffold-lib`

**Location**: `packages/Scaffold/`

**Purpose**: Templates and generators used by MJCLI for scaffolding projects.

**Package Structure**:

```
packages/Scaffold/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts
â”‚   â”œâ”€â”€ generators/
â”‚   â”‚   â”œâ”€â”€ ProjectGenerator.ts      # Full project scaffolding
â”‚   â”‚   â”œâ”€â”€ ApiGenerator.ts          # API-only scaffolding
â”‚   â”‚   â”œâ”€â”€ ExplorerGenerator.ts     # Explorer-only scaffolding
â”‚   â”‚   â”œâ”€â”€ PackageGenerator.ts      # Generated package scaffolding
â”‚   â”‚   â”œâ”€â”€ ActionGenerator.ts       # Action class scaffolding
â”‚   â”‚   â”œâ”€â”€ AgentGenerator.ts        # AI Agent scaffolding
â”‚   â”‚   â””â”€â”€ ComponentGenerator.ts    # Angular component scaffolding
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ project/
â”‚   â”‚   â”‚   â”œâ”€â”€ root/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ package.json.hbs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ turbo.json.hbs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ mj.config.cjs.hbs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ .env.example.hbs
â”‚   â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ index.ts.hbs      # Uses @memberjunction/server-bootstrap
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ package.json.hbs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ tsconfig.json.hbs
â”‚   â”‚   â”‚   â”œâ”€â”€ explorer/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ app.module.ts.hbs  # Uses @memberjunction/ng-bootstrap
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ environments/
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ environment.ts.hbs
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ environment.prod.ts.hbs
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ main.ts.hbs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ angular.json.hbs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ package.json.hbs
â”‚   â”‚   â”‚   â””â”€â”€ generated/
â”‚   â”‚   â”‚       â”œâ”€â”€ entities/
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ index.ts.hbs
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ package.json.hbs
â”‚   â”‚   â”‚       â”œâ”€â”€ actions/
â”‚   â”‚   â”‚       â”œâ”€â”€ forms/
â”‚   â”‚   â”‚       â””â”€â”€ resolvers/
â”‚   â”‚   â”œâ”€â”€ action/
â”‚   â”‚   â”‚   â””â”€â”€ action.ts.hbs
â”‚   â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”‚   â””â”€â”€ agent.ts.hbs
â”‚   â”‚   â””â”€â”€ component/
â”‚   â”‚       â”œâ”€â”€ component.ts.hbs
â”‚   â”‚       â”œâ”€â”€ component.html.hbs
â”‚   â”‚       â””â”€â”€ component.scss.hbs
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ TemplateEngine.ts        # Handlebars wrapper
â”‚       â”œâ”€â”€ FileWriter.ts            # Safe file writing with rollback
â”‚       â””â”€â”€ PackageManager.ts        # npm/pnpm detection and operations
â””â”€â”€ package.json
```

#### 1.2 MJCLI New Commands

Add to `packages/MJCLI/src/commands/`:

##### `mj new project`

```typescript
// packages/MJCLI/src/commands/new/project.ts
import { Command, Flags } from '@oclif/core';
import { input, select, confirm } from '@inquirer/prompts';
import { ProjectGenerator } from '@memberjunction/scaffold-lib';
import ora from 'ora-classic';

export default class NewProject extends Command {
  static description = 'Create a new MemberJunction 3.0 project';

  static examples = [
    '<%= config.bin %> new project',
    '<%= config.bin %> new project --name my-project --auth msal',
  ];

  static flags = {
    name: Flags.string({ char: 'n', description: 'Project name' }),
    path: Flags.string({ char: 'p', description: 'Output path', default: '.' }),
    auth: Flags.string({
      description: 'Auth provider',
      options: ['msal', 'auth0', 'both']
    }),
    'skip-api': Flags.boolean({ description: 'Skip API generation' }),
    'skip-explorer': Flags.boolean({ description: 'Skip Explorer generation' }),
    'skip-install': Flags.boolean({ description: 'Skip npm install' }),
  };

  async run(): Promise<void> {
    const { flags } = await this.parse(NewProject);

    this.log('\nðŸš€ MemberJunction 3.0 Project Generator\n');

    const config = {
      name: flags.name || await input({
        message: 'Project name:',
        validate: (v) => /^[a-z][a-z0-9-]*$/.test(v) ||
          'Use lowercase letters, numbers, and hyphens only'
      }),

      path: flags.path,

      includeApi: flags['skip-api'] ? false : await confirm({
        message: 'Include API server?',
        default: true
      }),

      includeExplorer: flags['skip-explorer'] ? false : await confirm({
        message: 'Include Explorer UI?',
        default: true
      }),

      authProvider: flags.auth as 'msal' | 'auth0' | 'both' || await select({
        message: 'Authentication provider:',
        choices: [
          { name: 'Microsoft Entra (MSAL)', value: 'msal' },
          { name: 'Auth0', value: 'auth0' },
          { name: 'Both', value: 'both' }
        ]
      }),

      database: await this.getDatabaseConfig(),

      packageScope: await input({
        message: 'NPM package scope (e.g., @mycompany):',
        default: '@' + (flags.name || 'myproject').replace(/-/g, ''),
        validate: (v) => /^@[a-z][a-z0-9-]*$/.test(v) ||
          'Scope must start with @ followed by lowercase letters'
      })
    };

    const spinner = ora();
    const generator = new ProjectGenerator(config);

    try {
      spinner.start('Creating project structure...');
      await generator.createDirectoryStructure();
      spinner.succeed('Project structure created');

      spinner.start('Generating packages...');
      await generator.generateAllPackages();
      spinner.succeed('Packages generated');

      spinner.start('Writing configuration files...');
      await generator.writeConfigFiles();
      spinner.succeed('Configuration complete');

      if (!flags['skip-install']) {
        spinner.start('Installing dependencies (this may take a few minutes)...');
        await generator.installDependencies();
        spinner.succeed('Dependencies installed');
      }

      this.log('\nâœ… Project created successfully!\n');
      this.logNextSteps(config);

    } catch (error) {
      spinner.fail('Project creation failed');
      throw error;
    }
  }

  private async getDatabaseConfig() {
    const configureDb = await confirm({
      message: 'Configure database connection now?',
      default: true
    });

    if (!configureDb) {
      return null;
    }

    return {
      host: await input({ message: 'Database host:', default: 'localhost' }),
      port: await input({ message: 'Database port:', default: '1433' }),
      database: await input({ message: 'Database name:' }),
      trustCert: await confirm({
        message: 'Trust server certificate (for local dev)?',
        default: true
      })
    };
  }

  private logNextSteps(config: any) {
    this.log('Next steps:\n');
    this.log(`  cd ${config.name}`);
    this.log('  # Edit .env with your database credentials');
    this.log('  mj codegen        # Generate entity/action code from database');
    if (config.includeApi) {
      this.log('  mj start api      # Start the API server');
    }
    if (config.includeExplorer) {
      this.log('  mj start explorer # Start the Explorer UI');
    }
    this.log('');
  }
}
```

##### `mj new api` / `mj new explorer`

Simpler variants that create just one component.

##### `mj scaffold action`

```typescript
// packages/MJCLI/src/commands/scaffold/action.ts
export default class ScaffoldAction extends Command {
  static description = 'Scaffold a new MemberJunction Action';

  static flags = {
    name: Flags.string({ char: 'n', description: 'Action name (PascalCase)' }),
    category: Flags.string({ char: 'c', description: 'Action category' }),
    output: Flags.string({ char: 'o', description: 'Output directory' }),
  };

  async run(): Promise<void> {
    const { flags } = await this.parse(ScaffoldAction);

    const config = {
      name: flags.name || await input({
        message: 'Action name (PascalCase):',
        validate: (v) => /^[A-Z][a-zA-Z0-9]*$/.test(v) ||
          'Use PascalCase (e.g., SendEmail, ProcessPayment)'
      }),
      category: flags.category || await input({
        message: 'Category:',
        default: 'Custom'
      }),
      description: await input({ message: 'Description:' }),
      hasInputParams: await confirm({
        message: 'Does this action have input parameters?',
        default: true
      }),
      hasOutputParams: await confirm({
        message: 'Does this action have output parameters?',
        default: false
      }),
    };

    const generator = new ActionGenerator(config);
    const outputPath = await generator.generate(flags.output);

    this.log(`\nâœ… Action "${config.name}" created at ${outputPath}`);
    this.log('\nNext steps:');
    this.log('  1. Implement the Run() method in the generated file');
    this.log('  2. Run: mj codegen --skipdb');
    this.log('  3. The action will be registered in metadata\n');
  }
}
```

##### `mj scaffold agent`

Similar pattern for AI Agent scaffolding.

##### `mj start api` / `mj start explorer`

```typescript
// packages/MJCLI/src/commands/start/api.ts
export default class StartApi extends Command {
  static description = 'Start the MemberJunction API server';

  static flags = {
    watch: Flags.boolean({ char: 'w', description: 'Watch mode' }),
  };

  async run(): Promise<void> {
    const { flags } = await this.parse(StartApi);
    const cmd = flags.watch ? 'npm run watch' : 'npm run start';

    execSync(cmd, {
      stdio: 'inherit',
      cwd: this.findPackageDir('api')
    });
  }

  private findPackageDir(name: string): string {
    // Look for packages/api, packages/my-api, etc.
    const candidates = [
      `packages/${name}`,
      `packages/my-${name}`,
      name
    ];
    for (const dir of candidates) {
      if (fs.existsSync(dir)) return dir;
    }
    throw new Error(`Cannot find ${name} package`);
  }
}
```

#### Task Breakdown

| Task | Description |
|------|-------------|
| 1.1 | Create `@memberjunction/scaffold-lib` package structure |
| 1.2 | Implement template engine (Handlebars) |
| 1.3 | Create project templates (uses Phase 1 bootstrap packages) |
| 1.4 | Implement `mj new project` command |
| 1.5 | Implement `mj new api/explorer` commands |
| 1.6 | Implement `mj scaffold action/agent/component` commands |
| 1.7 | Implement `mj start` commands |
| 1.8 | Testing and bug fixes |

---

### 2. CodeGen Updates

Update `@memberjunction/codegen-lib` to support package-based output.

#### 2.1 New Configuration Schema

```javascript
// mj.config.cjs
module.exports = {
  // Database settings (unchanged)
  dbHost: process.env.DB_HOST,
  dbDatabase: process.env.DB_DATABASE,
  dbPort: process.env.DB_PORT || 1433,
  codeGenLogin: process.env.CODEGEN_DB_USERNAME,
  codeGenPassword: process.env.CODEGEN_DB_PASSWORD,

  // 3.0 CodeGen Output Configuration
  codeGeneration: {
    // Output mode: 'packages' (3.0) or 'legacy' (2.x compatibility)
    outputMode: 'packages',

    // Package scope for generated packages
    packageScope: '@mycompany',

    // Package configurations
    packages: {
      entities: {
        path: './packages/generated-entities',
        name: '${packageScope}/generated-entities',
        // Include demo subclasses
        includeDemos: false
      },
      actions: {
        path: './packages/generated-actions',
        name: '${packageScope}/generated-actions'
      },
      angularForms: {
        path: './packages/generated-forms',
        name: '${packageScope}/generated-forms'
      },
      graphqlResolvers: {
        path: './packages/generated-resolvers',
        name: '${packageScope}/generated-resolvers'
      }
    }
  },

  // ... rest of config
};
```

#### 2.2 CodeGen Package Output

When `outputMode: 'packages'`, CodeGen will:

1. **Generate package.json** for each generated package:
   ```json
   {
     "name": "@mycompany/generated-entities",
     "version": "1.0.0",
     "main": "dist/index.js",
     "types": "dist/index.d.ts",
     "scripts": {
       "build": "tsc"
     },
     "dependencies": {
       "@memberjunction/core": "^3.0.0",
       "@memberjunction/global": "^3.0.0"
     }
   }
   ```

2. **Generate proper exports**:
   ```typescript
   // packages/generated-entities/src/index.ts
   export * from './generated/entity_subclasses';

   // Side-effect import to register classes
   import './generated/entity_subclasses';

   export function LoadGeneratedEntities() {
     // No-op, but prevents tree-shaking
   }
   ```

3. **Update workspace package.json** to include generated packages:
   ```json
   {
     "workspaces": [
       "packages/*"
     ]
   }
   ```

#### Task Breakdown

| Task | Description |
|------|-------------|
| 2.1 | Add `outputMode: 'packages'` configuration support |
| 2.2 | Generate package.json for each generated package |
| 2.3 | Update entity generation to output to package structure |
| 2.4 | Update action generation to output to package structure |
| 2.5 | Update Angular forms generation to output to package structure |
| 2.6 | Update GraphQL resolver generation to output to package structure |
| 2.7 | Add workspace package.json updates |

---

### 3. Migration Tooling

Create tooling to migrate existing 2.x projects to 3.0 structure.

#### 3.1 `mj migrate to-3.0` Command

```typescript
// packages/MJCLI/src/commands/migrate/to-3-0.ts
import { Command, Flags } from '@oclif/core';
import { confirm } from '@inquirer/prompts';
import ora from 'ora-classic';

export default class MigrateTo30 extends Command {
  static description = 'Migrate MemberJunction 2.x project to 3.0 structure';

  static examples = [
    '<%= config.bin %> migrate to-3.0',
    '<%= config.bin %> migrate to-3.0 --dry-run',
  ];

  static flags = {
    'dry-run': Flags.boolean({
      description: 'Show what would be done without making changes'
    }),
    'skip-backup': Flags.boolean({
      description: 'Skip creating backup (not recommended)'
    }),
    'package-scope': Flags.string({
      description: 'NPM package scope for generated packages',
      default: '@myproject'
    }),
  };

  async run(): Promise<void> {
    const { flags } = await this.parse(MigrateTo30);

    this.log('\nðŸ”„ MemberJunction 3.0 Migration Tool\n');

    // Step 1: Analyze current project
    const spinner = ora();
    spinner.start('Analyzing project structure...');
    const analysis = await this.analyzeProject();
    spinner.succeed('Project analysis complete');

    this.logAnalysisResults(analysis);

    if (!analysis.canMigrate) {
      this.error('Project structure not recognized. Manual migration required.');
    }

    // Step 2: Confirm migration
    if (!flags['dry-run']) {
      const confirmed = await confirm({
        message: 'This will restructure your project. Continue?',
        default: false
      });

      if (!confirmed) {
        this.log('Migration cancelled.');
        return;
      }
    }

    // Step 3: Create backup
    if (!flags['skip-backup'] && !flags['dry-run']) {
      spinner.start('Creating backup...');
      await this.createBackup();
      spinner.succeed('Backup created at ./backup-2.x/');
    }

    // Step 4: Execute migration steps
    try {
      await this.executeMigration(analysis, flags['package-scope'], flags['dry-run']);

      if (flags['dry-run']) {
        this.log('\nâœ… Dry run complete. No changes made.');
      } else {
        this.log('\nâœ… Migration complete!');
        this.logNextSteps();
      }
    } catch (error) {
      this.error(`Migration failed: ${error.message}`);
    }
  }

  private async analyzeProject() {
    // Detect 2.x structure
    const hasMJAPI = fs.existsSync('packages/MJAPI') || fs.existsSync('MJAPI');
    const hasMJExplorer = fs.existsSync('packages/MJExplorer') || fs.existsSync('MJExplorer');
    const hasGeneratedEntities = fs.existsSync('packages/GeneratedEntities') || fs.existsSync('GeneratedEntities');

    return {
      canMigrate: hasMJAPI || hasMJExplorer,
      hasApi: hasMJAPI,
      hasExplorer: hasMJExplorer,
      hasGeneratedPackages: hasGeneratedEntities,
      customCode: await this.findCustomCode(),
      isMonorepo: fs.existsSync('package.json') && JSON.parse(fs.readFileSync('package.json', 'utf8')).workspaces
    };
  }

  private async executeMigration(analysis: any, packageScope: string, dryRun: boolean) {
    const steps = [
      { name: 'Create new package structure', fn: () => this.createPackageStructure(packageScope, dryRun) },
      { name: 'Move generated code to new packages', fn: () => this.moveGeneratedCode(dryRun) },
      { name: 'Update imports in custom code', fn: () => this.updateImports(analysis.customCode, packageScope, dryRun) },
      { name: 'Generate new minimal app files', fn: () => this.generateMinimalApps(packageScope, dryRun) },
      { name: 'Update mj.config.cjs', fn: () => this.updateConfig(packageScope, dryRun) },
      { name: 'Verify build', fn: () => this.verifyBuild(dryRun) },
      { name: 'Clean up old structure', fn: () => this.cleanupOldStructure(dryRun) }
    ];

    for (const step of steps) {
      const spinner = ora(step.name + '...').start();
      try {
        await step.fn();
        spinner.succeed(step.name + (dryRun ? ' (would be done)' : ''));
      } catch (error) {
        spinner.fail(step.name + ' failed');
        throw error;
      }
    }
  }

  private logNextSteps() {
    this.log('\nNext steps:\n');
    this.log('  1. Review the changes in git diff');
    this.log('  2. Run: npm install');
    this.log('  3. Run: npm run build');
    this.log('  4. Test your application thoroughly');
    this.log('  5. Update your CI/CD pipelines if needed');
    this.log('\nBackup available at ./backup-2.x/ if rollback is needed.\n');
  }
}
```

#### Task Breakdown

| Task | Description |
|------|-------------|
| 3.1 | Create `mj migrate to-3.0` command structure |
| 3.2 | Implement project analysis |
| 3.3 | Implement migration plan creation and execution |
| 3.4 | Implement import updating in custom code |
| 3.5 | Implement build verification and rollback |

---

### 4. Generated Project Structure Reference

When running `mj new project my-app`, the following structure is created:

```
my-app/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â””â”€â”€ index.ts              # ~6 lines (from Phase 1)
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”‚
â”‚   â”œâ”€â”€ explorer/
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ app.module.ts      # ~15 lines (from Phase 1)
â”‚   â”‚   â”‚   â”œâ”€â”€ environments/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ environment.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ environment.prod.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ index.html
â”‚   â”‚   â”‚   â”œâ”€â”€ main.ts
â”‚   â”‚   â”‚   â””â”€â”€ styles.scss
â”‚   â”‚   â”œâ”€â”€ angular.json
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”‚
â”‚   â”œâ”€â”€ generated-entities/           # Created by Phase 2 CodeGen
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â””â”€â”€ generated/
â”‚   â”‚   â”‚       â””â”€â”€ entity_subclasses.ts
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”‚
â”‚   â”œâ”€â”€ generated-actions/            # Created by Phase 2 CodeGen
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â””â”€â”€ generated/
â”‚   â”‚   â”‚       â””â”€â”€ action_subclasses.ts
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”‚
â”‚   â”œâ”€â”€ generated-forms/              # Created by Phase 2 CodeGen
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”‚   â””â”€â”€ generated/
â”‚   â”‚   â”‚       â””â”€â”€ generated-forms.module.ts
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ tsconfig.json
â”‚   â”‚
â”‚   â””â”€â”€ generated-resolvers/          # Created by Phase 2 CodeGen
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ index.ts
â”‚       â”‚   â””â”€â”€ generated/
â”‚       â”‚       â””â”€â”€ generated.ts
â”‚       â”œâ”€â”€ package.json
â”‚       â””â”€â”€ tsconfig.json
â”‚
â”œâ”€â”€ .env.example
â”œâ”€â”€ .env
â”œâ”€â”€ .gitignore
â”œâ”€â”€ mj.config.cjs
â”œâ”€â”€ package.json                       # Workspace root
â”œâ”€â”€ turbo.json
â””â”€â”€ README.md
```

---

### 5. Documentation

Comprehensive documentation updates for 3.0 architecture.

#### Task Breakdown

| Task | Description |
|------|-------------|
| 5.1 | Update getting started guide for 3.0 |
| 5.2 | Create migration guide from 2.x |
| 5.3 | Update CLAUDE.md with 3.0 patterns |
| 5.4 | Update architecture documentation |
| 5.5 | Create video walkthrough |

---

## Migration Guide (2.x to 3.0)

### Automatic Migration

```bash
cd my-existing-project
mj migrate to-3.0
```

The migration command will:

1. **Analyze** current project structure
2. **Create** backup of existing project
3. **Create** new package structure alongside existing
4. **Move** generated code to new packages
5. **Update** imports in custom code
6. **Generate** new minimal app files
7. **Update** mj.config.cjs with new settings
8. **Verify** build succeeds
9. **Clean up** old structure (with confirmation)

### Manual Migration Steps

If automatic migration isn't suitable:

1. Create new project with `mj new project`
2. Copy custom code to appropriate locations:
   - Custom actions â†’ `packages/custom-actions/`
   - Custom agents â†’ `packages/custom-agents/`
   - Custom components â†’ appropriate Angular package
3. Update imports to use new package names
4. Copy database configuration to `.env`
5. Run `mj codegen` to populate generated packages
6. Test thoroughly

### Common Migration Scenarios

#### Scenario 1: Standard 2.x Project

**Before:**
```
my-project/
â”œâ”€â”€ MJAPI/
â”œâ”€â”€ MJExplorer/
â”œâ”€â”€ GeneratedEntities/
â””â”€â”€ GeneratedActions/
```

**After:**
```
my-project/
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ api/                 # New minimal shell
â”‚   â”œâ”€â”€ explorer/            # New minimal shell
â”‚   â”œâ”€â”€ generated-entities/  # Generated code moved here
â”‚   â”œâ”€â”€ generated-actions/   # Generated code moved here
â”‚   â”œâ”€â”€ generated-forms/     # New
â”‚   â””â”€â”€ generated-resolvers/ # New
â”œâ”€â”€ mj.config.cjs
â”œâ”€â”€ package.json
â””â”€â”€ turbo.json
```

#### Scenario 2: Project with Custom Actions

**Custom code location:**
- Create `packages/custom-actions/` with same structure as generated packages
- Import in `packages/api/src/index.ts`

#### Scenario 3: Monorepo with Multiple Apps

**Approach:**
- Keep multiple `api` and `explorer` packages (e.g., `packages/api-public`, `packages/api-internal`)
- All reference the same generated packages
- Configure Turbo to handle multiple apps

---

## Success Criteria

### Phase 2 Completion Checklist

#### Scaffold & CLI
- [ ] `@memberjunction/scaffold-lib` package created
  - [ ] Template engine working
  - [ ] All generators implemented
  - [ ] Templates reference Phase 1 bootstrap packages
- [ ] `mj new project` creates fully functional monorepo
- [ ] Generated project has < 50 lines of custom code in api/explorer
- [ ] `mj new api` creates standalone API project
- [ ] `mj new explorer` creates standalone Explorer project
- [ ] `mj scaffold action/agent/component` commands work
- [ ] `mj start` commands work correctly

#### CodeGen Updates
- [ ] CodeGen supports `outputMode: 'packages'` configuration
- [ ] CodeGen generates proper package.json for each generated package
- [ ] Entity generation outputs to package structure
- [ ] Action generation outputs to package structure
- [ ] Angular forms generation outputs to package structure
- [ ] GraphQL resolver generation outputs to package structure

#### Migration & Testing
- [ ] `mj migrate to-3.0` command works for standard 2.x projects
- [ ] Migration handles custom code correctly
- [ ] Build verification detects issues
- [ ] Rollback mechanism works
- [ ] All existing tests pass with new structure
- [ ] New integration tests cover all scenarios

#### Documentation
- [ ] Documentation is complete and accurate
- [ ] Migration guide tested with real projects
- [ ] Video walkthrough created

### Combined Phase 1 & 2 Validation

- [ ] Full workflow works end-to-end:
  1. `mj new project` â†’ creates monorepo (Phase 2)
  2. `mj codegen` â†’ generates packages (Phase 2)
  3. `npm run build` â†’ all packages build (Phase 1 + 2)
  4. `npm start` â†’ apps run using bootstrap packages (Phase 1)
- [ ] All MJ updates come via `npm update`
- [ ] Existing 2.x projects can migrate automatically
- [ ] Manual migration is well-documented
- [ ] Breaking changes are clearly documented

---

## Open Questions & Decisions

### 1. Package Versioning Strategy

**Question**: Should generated packages have independent versions or track MJ version?

**Recommendation**: Start at 1.0.0, increment on schema changes. Independent of MJ version.

**Rationale**:
- Generated packages reflect customer's database schema, not MJ version
- Schema changes should trigger version bumps
- Customers can publish and version independently

### 2. Custom Code Location

**Question**: Where should customers put custom Actions, Agents, etc. that aren't generated?

**Recommendation**: Create separate packages:
- `packages/custom-actions/`
- `packages/custom-agents/`
- `packages/custom-components/`

**Rationale**:
- Consistent structure with generated packages
- Clear separation of generated vs. custom code
- Easy to reference in imports

### 3. Migration Safety Net

**Question**: How to ensure migrations are safe and reversible?

**Decision**:
- Always create backup by default
- Implement dry-run mode
- Verify build before cleanup
- Provide rollback instructions
- Log all changes made

### 4. Legacy Mode Support

**Question**: Should we maintain 2.x output mode indefinitely?

**Recommendation**: Support `outputMode: 'legacy'` for 1-2 major versions, then deprecate.

**Timeline**:
- 3.0: Both modes supported, packages mode default
- 3.1-3.x: Legacy mode deprecated with warnings
- 4.0: Legacy mode removed

---

## Testing Strategy

### Unit Tests

- CodeGen configuration parsing
- Package.json generation
- Import path updates
- Workspace configuration updates

### Integration Tests

- Full `mj new project` â†’ `mj codegen` â†’ build cycle
- Migration of sample 2.x project
- Custom code preservation during migration
- Multi-package monorepo scenarios

### Manual Testing

- Migration of real customer projects (beta testing)
- Performance comparison (2.x vs 3.0)
- Developer experience feedback
- Documentation walkthroughs

---

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Migration breaks custom code | High | Medium | Thorough import analysis, dry-run mode, backups |
| CodeGen output incompatible | High | Low | Extensive testing, gradual rollout |
| Performance degradation | Medium | Low | Benchmark before/after, optimize as needed |
| Documentation gaps | Medium | Medium | Beta user feedback, iterative docs updates |
| Adoption resistance | Medium | Medium | Clear benefits, smooth migration path, support |

---

## Rollout Plan

### Beta Phase (Weeks 1-2)

- Select 3-5 pilot customers
- Provide dedicated support
- Gather feedback on migration experience
- Iterate on tooling and documentation

### General Availability (Week 3+)

- Publish 3.0 release
- Announcement with migration guide
- Office hours for migration support
- Monitor issues and provide patches

### Deprecation Timeline

- **3.0 Release**: 2.x mode fully supported
- **3.1 (3 months later)**: Deprecation warnings for 2.x mode
- **4.0 (12 months later)**: Remove 2.x mode support

---

*Document Created: 2026-01-13*
*Status: Planning*
*Version: 3.0 Phase 2*
*Depends On: Phase 1 - Package Development & CLI*
