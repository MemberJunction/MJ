# Unified Interactive Components Architecture for Forms and Dashboards

**Date:** 2025-11-03
**Branch:** `claude/form-design-011CUkyixvnUcdT9oHLPP7WR`
**Status:** ARCHITECTURAL PROPOSAL

---

## Executive Summary

This document proposes a **unified architecture** for extending MemberJunction's forms and dashboards with Interactive Components as a third implementation type, alongside existing generated/config-based and code-based approaches.

**Key Insight:** Forms and Dashboards already share nearly identical architectural patterns:

| Aspect | Forms | Dashboards |
|--------|-------|------------|
| **Type 1** | Generated forms (CodeGen) | Config-based (UIConfigDetails JSON) |
| **Type 2** | Code-based (@RegisterClass) | Code-based (@RegisterClass) |
| **Type 3** | *(proposed)* Interactive Components | *(proposed)* Interactive Components |
| **Base Class** | `BaseFormComponent` | `BaseDashboard` |
| **Resolution** | ClassFactory by entity name | ClassFactory by DriverClass |
| **Metadata** | EntityField, EntitySettings | Dashboard entity, UIConfigDetails |
| **User Prefs** | *(none currently)* | DashboardUserPreferenceEntity |
| **User State** | *(forms are stateless)* | DashboardUserStateEntity |

**Proposal:** Add Interactive Components as a third type for both, with shared infrastructure for registration, resolution, and AI agent management.

---

## Part 1: Current State Analysis

### Forms System Summary

**Three Layers:**
1. **Generated Forms** (Type 1)
   - Auto-generated by CodeGen from entity metadata
   - Located in `core-entity-forms/generated/`
   - Template-driven with `<mj-form-field>` components
   - Registered with `@RegisterClass(BaseFormComponent, entityName)`

2. **Code-Based Custom Forms** (Type 2)
   - Custom Angular components extending generated forms
   - Located in `core-entity-forms/custom/`
   - Full Angular capabilities
   - Higher priority overrides generated forms
   - Examples: AIAgentFormComponentExtended, TemplatesFormExtendedComponent

3. **Interactive Components** (Type 3 - Proposed)
   - Metadata-driven React components
   - Built using Interactive Components spec
   - AI-agent generatable
   - User/role-specific customization

**Current Resolution:**
```typescript
// In SingleRecordComponent.LoadForm()
const formReg = MJGlobal.Instance.ClassFactory.GetRegistration(
  BaseFormComponent,
  entityName  // e.g., 'AI Agents'
);
```

**Gaps:**
- No user/role-specific form variations
- No priority/preference metadata
- No way to register multiple form types per entity with selection logic
- AI agents can't easily create/modify forms

### Dashboard System Summary

**Three Types:**
1. **Config-Based** (Type 1)
   - UIConfigDetails JSON with grid layout
   - Kendo TileLayout for responsive widgets
   - User-editable (drag-drop, resize)
   - No coding required

2. **Code-Based** (Type 2)
   - Custom Angular components extending BaseDashboard
   - Specified via DriverClass field
   - Full Angular capabilities
   - Examples: AIDashboardComponent, EntityAdminDashboardComponent

3. **Dynamic Code** (Type 3 - Current)
   - Skip-generated runtime JavaScript
   - Exists but not widely used

4. **Interactive Components** (Type 3 - Proposed)
   - Replace or augment Dynamic Code approach
   - Built using Interactive Components spec
   - AI-agent generatable

**Current Resolution:**
```typescript
// In TabbedDashboardComponent.getDashboardInstance()
if (dashboard.Type === 'Code') {
  const classInfo = ClassFactory.GetRegistration(BaseDashboard, dashboard.DriverClass);
  componentRef = createComponent(classInfo.SubClass);
} else {
  componentRef = createComponent(SingleDashboardComponent);
}
```

**Strengths:**
- User preferences (DashboardUserPreferenceEntity) control visibility/order
- User state persistence (DashboardUserStateEntity)
- Scope management (Global vs App-specific)
- Hierarchical categories

### Interactive Components System Summary

**Capabilities:**
- Declarative component specification (ComponentSpec)
- React component compilation and execution
- Runtime environment with full MJ utilities
- Component registry (local + external)
- Library dependency management
- Caching and versioning

**Current Usage:**
- Reports and analytics components
- Component Studio for development
- Dashboard widgets (partially)

**Architecture:**
```
ComponentSpec (metadata + code)
  ↓
ComponentManager (fetch → compile → register)
  ↓
ComponentCompiler (Babel transpilation)
  ↓
ComponentRegistry (in-memory cache)
  ↓
MJReactComponent (Angular wrapper)
  ↓
React root + DOM rendering
```

---

## Part 2: Proposed Unified Architecture

### Core Principle: Type-Based Implementation Selection

Both forms and dashboards should support a **Type field** that determines implementation:

**Forms:**
- `Type = 'Generated'` → Use CodeGen-generated form (default, fallback)
- `Type = 'Code'` → Use ClassFactory-registered Angular component
- `Type = 'Interactive'` → Use Interactive Component from registry

**Dashboards:**
- `Type = 'Config'` → Use UIConfigDetails JSON layout (current default)
- `Type = 'Code'` → Use ClassFactory-registered Angular component (current)
- `Type = 'Interactive'` → Use Interactive Component from registry (new)

### New Metadata Entities

#### 1. InteractiveComponentFormTypeEntity

**Purpose:** Registers Interactive Components as form implementations

```typescript
class InteractiveComponentFormTypeEntity {
  ID: string;                           // GUID
  EntityID: string;                     // FK to Entities (which entity this form is for)
  ComponentID: string;                  // FK to ComponentEntity (which Interactive Component)
  Name: string;                         // Display name (e.g., "Enhanced Customer Form")
  Description?: string;                 // Optional description
  Priority: number;                     // Higher = preferred (default: auto-increment)
  Scope: 'Global' | 'Role' | 'User';    // Who can use this form type
  RoleID?: string;                      // FK to Roles (if Scope='Role')
  UserID?: string;                      // FK to Users (if Scope='User')
  IsDefault: boolean;                   // Is this the default for the scope?
  Status: 'Active' | 'Inactive' | 'Deprecated';

  // Validation (table-level constraint):
  // - If Scope='Role', RoleID must be NOT NULL
  // - If Scope='User', UserID must be NOT NULL
  // - If Scope='Global', both must be NULL
}
```

#### 2. InteractiveComponentDashboardTypeEntity

**Purpose:** Registers Interactive Components as dashboard implementations

```typescript
class InteractiveComponentDashboardTypeEntity {
  ID: string;                           // GUID
  DashboardCategoryID?: string;         // FK to DashboardCategory (optional grouping)
  ComponentID: string;                  // FK to ComponentEntity
  Name: string;                         // Display name (e.g., "Real-time Sales Dashboard")
  Description?: string;
  Priority: number;
  Scope: 'Global' | 'Role' | 'User';
  RoleID?: string;
  UserID?: string;
  IsDefault: boolean;
  Status: 'Active' | 'Inactive' | 'Deprecated';

  // Same validation as forms
}
```

#### 3. Extend Existing Entities

**EntityEntity** - Add optional field:
```typescript
PreferredFormType: 'Generated' | 'Code' | 'Interactive' | null;  // System default
PreferredFormComponentID?: string;  // FK to ComponentEntity (if Interactive)
```

**DashboardEntity** - Extend Type field:
```typescript
Type: 'Config' | 'Code' | 'Interactive';  // Add 'Interactive' to existing enum
ComponentID?: string;  // FK to ComponentEntity (if Type='Interactive')
```

---

## Part 3: Resolution Logic

### Form Resolution Algorithm

```typescript
function resolveFormComponent(
  entityName: string,
  currentUser: UserInfo
): ComponentReference {

  // Step 1: Check for Interactive Component forms
  const interactiveForms = RunView<InteractiveComponentFormTypeEntity>({
    EntityName: 'MJ: Interactive Component Form Types',
    ExtraFilter: `
      EntityID IN (SELECT ID FROM __mj.Entity WHERE Name='${entityName}')
      AND Status='Active'
      AND (
        (Scope='User' AND UserID='${currentUser.ID}')
        OR (Scope='Role' AND RoleID IN (SELECT RoleID FROM __mj.UserRole WHERE UserID='${currentUser.ID}'))
        OR (Scope='Global')
      )
    `,
    OrderBy: 'Priority DESC, Scope ASC'  // User > Role > Global, then by priority
  });

  if (interactiveForms.length > 0) {
    const topForm = interactiveForms[0];
    const component = await ComponentManager.loadComponent(topForm.ComponentID);
    return { type: 'Interactive', component };
  }

  // Step 2: Check for Code-based custom forms
  const codeReg = ClassFactory.GetRegistration(BaseFormComponent, entityName);
  if (codeReg && codeReg.Priority > 1) {  // Priority > 1 means custom (not generated)
    return { type: 'Code', class: codeReg.SubClass };
  }

  // Step 3: Fallback to generated form
  const generatedReg = ClassFactory.GetRegistration(BaseFormComponent, entityName);
  return { type: 'Generated', class: generatedReg.SubClass };
}
```

### Dashboard Resolution Algorithm

```typescript
function resolveDashboardComponent(
  dashboard: DashboardEntity,
  currentUser: UserInfo
): ComponentReference {

  // Step 1: Check dashboard Type field
  if (dashboard.Type === 'Interactive') {
    if (!dashboard.ComponentID) {
      throw new Error('Dashboard Type is Interactive but ComponentID is null');
    }
    const component = await ComponentManager.loadComponent(dashboard.ComponentID);
    return { type: 'Interactive', component };
  }

  if (dashboard.Type === 'Code') {
    if (!dashboard.DriverClass) {
      throw new Error('Dashboard Type is Code but DriverClass is null');
    }
    const classInfo = ClassFactory.GetRegistration(BaseDashboard, dashboard.DriverClass);
    return { type: 'Code', class: classInfo.SubClass };
  }

  // Step 2: Fallback to Config-based
  return { type: 'Config', class: SingleDashboardComponent };
}
```

---

## Part 4: Angular Integration

### Wrapper Component for Interactive Forms

```typescript
@Component({
  selector: 'mj-interactive-form',
  template: `
    <mj-react-component
      [componentSpec]="componentSpec"
      [data]="formData"
      (eventEmitted)="onFormEvent($event)">
    </mj-react-component>
  `
})
export class InteractiveFormComponent extends BaseFormComponent {
  @Input() componentSpec: ComponentSpec;
  @Input() record: BaseEntity;

  public get formData(): any {
    return {
      record: this.record.GetAll(),  // Plain object with all fields
      metadata: this.getEntityMetadata(),
      editMode: this.EditMode,
      currentUser: this.currentUser
    };
  }

  public onFormEvent(event: ComponentEvent): void {
    switch (event.name) {
      case 'save':
        this.handleSave(event.data);
        break;
      case 'cancel':
        this.handleCancel();
        break;
      case 'fieldChanged':
        this.handleFieldChange(event.data.fieldName, event.data.value);
        break;
    }
  }

  private async handleSave(data: any): Promise<void> {
    // Update record from form data
    Object.keys(data).forEach(key => {
      if (this.record[key] !== undefined) {
        this.record[key] = data[key];
      }
    });

    // Call base form save logic
    const saved = await this.InternalSaveRecord();
    if (saved) {
      this.emit('saved', this.record);
    }
  }
}
```

### Wrapper Component for Interactive Dashboards

```typescript
@Component({
  selector: 'mj-interactive-dashboard',
  template: `
    <mj-react-component
      [componentSpec]="componentSpec"
      [data]="dashboardData"
      (eventEmitted)="onDashboardEvent($event)">
    </mj-react-component>
  `
})
export class InteractiveDashboardComponent extends BaseDashboard {
  @Input() componentSpec: ComponentSpec;

  public get dashboardData(): any {
    return {
      config: this.Config,
      userState: this.Config?.userState,
      currentUser: this.currentUser,
      scope: this.Config?.dashboard?.Scope,
      applicationId: this.Config?.dashboard?.ApplicationID
    };
  }

  public initDashboard(): void {
    // Interactive dashboard handles its own initialization
  }

  public loadData(): void {
    // Interactive dashboard handles its own data loading
    this.LoadingComplete.emit();
  }

  public onDashboardEvent(event: ComponentEvent): void {
    switch (event.name) {
      case 'userStateChanged':
        this.UserStateChanged.emit(event.data);
        break;
      case 'openRecord':
        this.OpenEntityRecord.emit(event.data);
        break;
      case 'error':
        this.Error.emit(new Error(event.data.message));
        break;
    }
  }
}
```

### Updated SingleRecordComponent

```typescript
export class SingleRecordComponent {
  public async LoadForm(primaryKey: CompositeKey, entityName: string) {
    // Resolve form component using new algorithm
    const formRef = await this.formResolver.resolveFormComponent(
      entityName,
      this.currentUser
    );

    // Load the entity record
    const record = await this.metadata.GetEntityObject<BaseEntity>(entityName);
    if (primaryKey.HasValue) {
      await record.InnerLoad(primaryKey);
    } else {
      record.NewRecord();
    }

    // Create component based on type
    let componentRef: ComponentRef<BaseFormComponent>;

    if (formRef.type === 'Interactive') {
      // Create Interactive form wrapper
      componentRef = this.viewContainer.createComponent(InteractiveFormComponent);
      componentRef.instance.componentSpec = formRef.component;
      componentRef.instance.record = record;
    } else {
      // Create Code or Generated form
      componentRef = this.viewContainer.createComponent(formRef.class);
      componentRef.instance.record = record;
    }

    componentRef.instance.EditMode = !primaryKey.HasValue;
  }
}
```

### Updated TabbedDashboardComponent

```typescript
export class TabbedDashboardComponent {
  private async getDashboardInstance(dashboardId: string): Promise<ComponentRef<BaseDashboard>> {
    const dashboard = this.dashboards.find(d => d.ID === dashboardId);

    // Resolve dashboard component using new algorithm
    const dashboardRef = await this.dashboardResolver.resolveDashboardComponent(
      dashboard,
      this.currentUser
    );

    let componentRef: ComponentRef<BaseDashboard>;

    if (dashboardRef.type === 'Interactive') {
      // Create Interactive dashboard wrapper
      componentRef = this.tabstripContainer.createComponent(InteractiveDashboardComponent);
      componentRef.instance.componentSpec = dashboardRef.component;
    } else if (dashboardRef.type === 'Code') {
      // Create Code-based dashboard
      componentRef = this.tabstripContainer.createComponent(dashboardRef.class);
    } else {
      // Create Config-based dashboard
      componentRef = this.tabstripContainer.createComponent(SingleDashboardComponent);
    }

    // Load user state and wire up events (same as before)
    const userState = await this.loadUserState(dashboardId);
    const config = new DashboardConfig(dashboard, userState);
    componentRef.instance.Config = config;

    // Wire up events
    componentRef.instance.LoadingComplete.subscribe(() => this.onDashboardLoaded(dashboardId));
    componentRef.instance.UserStateChanged.subscribe(state => this.saveUserState(dashboardId, state));

    return componentRef;
  }
}
```

---

## Part 5: Component Specification Examples

### Example: Interactive Customer Form

```typescript
const customerFormSpec: ComponentSpec = {
  name: "EnhancedCustomerForm",
  location: "registry",
  registry: "MemberJunction Registry",
  namespace: "forms/entities",
  version: "1.0.0",
  type: "form",

  properties: [
    { name: "record", type: "object", required: true },
    { name: "metadata", type: "object", required: true },
    { name: "editMode", type: "boolean", required: true },
    { name: "currentUser", type: "object", required: true }
  ],

  events: [
    { name: "save", parameters: ["data: object"] },
    { name: "cancel", parameters: [] },
    { name: "fieldChanged", parameters: ["fieldName: string", "value: any"] }
  ],

  code: `
    function EnhancedCustomerForm({ record, metadata, editMode, currentUser, mjGlobal, emit }) {
      const [formData, setFormData] = React.useState(record);
      const [errors, setErrors] = React.useState({});

      // Custom validation logic
      const validate = () => {
        const newErrors = {};
        if (!formData.Name || formData.Name.trim() === '') {
          newErrors.Name = 'Company name is required';
        }
        if (formData.Revenue && formData.Revenue < 0) {
          newErrors.Revenue = 'Revenue cannot be negative';
        }
        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
      };

      // Handle field change
      const handleChange = (fieldName, value) => {
        setFormData({ ...formData, [fieldName]: value });
        emit('fieldChanged', { fieldName, value });
      };

      // Handle save
      const handleSave = () => {
        if (validate()) {
          emit('save', formData);
        }
      };

      return (
        <div className="enhanced-customer-form">
          <h2>{editMode ? 'Edit Customer' : 'View Customer'}</h2>

          <div className="form-section">
            <label>Company Name *</label>
            <input
              type="text"
              value={formData.Name || ''}
              onChange={e => handleChange('Name', e.target.value)}
              disabled={!editMode}
            />
            {errors.Name && <span className="error">{errors.Name}</span>}
          </div>

          <div className="form-section">
            <label>Annual Revenue</label>
            <input
              type="number"
              value={formData.Revenue || 0}
              onChange={e => handleChange('Revenue', parseFloat(e.target.value))}
              disabled={!editMode}
            />
            {errors.Revenue && <span className="error">{errors.Revenue}</span>}
          </div>

          {editMode && (
            <div className="form-actions">
              <button onClick={handleSave}>Save</button>
              <button onClick={() => emit('cancel')}>Cancel</button>
            </div>
          )}
        </div>
      );
    }
  `,

  libraries: [
    { name: "react", version: "^18.0.0" }
  ],

  description: "Enhanced customer form with custom validation and layout",
  functionalRequirements: "Customer CRUD with revenue validation and custom UI",
  technicalDesign: "React functional component with hooks"
};
```

### Example: Interactive Sales Dashboard

```typescript
const salesDashboardSpec: ComponentSpec = {
  name: "RealtimeSalesDashboard",
  location: "registry",
  registry: "MemberJunction Registry",
  namespace: "dashboards/sales",
  version: "1.0.0",
  type: "dashboard",

  properties: [
    { name: "config", type: "object", required: true },
    { name: "userState", type: "object", required: false },
    { name: "currentUser", type: "object", required: true }
  ],

  events: [
    { name: "userStateChanged", parameters: ["state: object"] },
    { name: "openRecord", parameters: ["entityName: string", "recordId: string"] },
    { name: "error", parameters: ["message: string"] }
  ],

  code: `
    function RealtimeSalesDashboard({ config, userState, currentUser, mjGlobal, emit }) {
      const [salesData, setSalesData] = React.useState([]);
      const [timeRange, setTimeRange] = React.useState(userState?.timeRange || '30d');
      const [loading, setLoading] = React.useState(true);

      // Load sales data
      React.useEffect(() => {
        async function loadData() {
          try {
            setLoading(true);
            const rv = new mjGlobal.RunView();
            const result = await rv.RunView({
              EntityName: 'Sales Orders',
              ExtraFilter: \`CreatedAt >= DATEADD(day, -\${parseInt(timeRange)}, GETDATE())\`,
              OrderBy: 'CreatedAt DESC',
              ResultType: 'entity_object'
            }, currentUser);

            if (result.Success) {
              setSalesData(result.Results);
            } else {
              emit('error', result.ErrorMessage);
            }
          } catch (error) {
            emit('error', error.message);
          } finally {
            setLoading(false);
          }
        }

        loadData();
      }, [timeRange]);

      // Persist time range selection
      const handleTimeRangeChange = (range) => {
        setTimeRange(range);
        emit('userStateChanged', { timeRange: range });
      };

      // Calculate metrics
      const totalRevenue = salesData.reduce((sum, order) => sum + (order.TotalAmount || 0), 0);
      const avgOrderValue = salesData.length > 0 ? totalRevenue / salesData.length : 0;

      return (
        <div className="sales-dashboard">
          <div className="dashboard-header">
            <h2>Sales Dashboard</h2>
            <select value={timeRange} onChange={e => handleTimeRangeChange(e.target.value)}>
              <option value="7">Last 7 Days</option>
              <option value="30">Last 30 Days</option>
              <option value="90">Last 90 Days</option>
            </select>
          </div>

          {loading ? (
            <div>Loading...</div>
          ) : (
            <>
              <div className="metrics">
                <div className="metric-card">
                  <h3>Total Revenue</h3>
                  <p>\${totalRevenue.toFixed(2)}</p>
                </div>
                <div className="metric-card">
                  <h3>Orders</h3>
                  <p>{salesData.length}</p>
                </div>
                <div className="metric-card">
                  <h3>Avg Order Value</h3>
                  <p>\${avgOrderValue.toFixed(2)}</p>
                </div>
              </div>

              <div className="recent-orders">
                <h3>Recent Orders</h3>
                <table>
                  <thead>
                    <tr>
                      <th>Order #</th>
                      <th>Customer</th>
                      <th>Amount</th>
                      <th>Date</th>
                    </tr>
                  </thead>
                  <tbody>
                    {salesData.slice(0, 10).map(order => (
                      <tr key={order.ID} onClick={() => emit('openRecord', { entityName: 'Sales Orders', recordId: order.ID })}>
                        <td>{order.OrderNumber}</td>
                        <td>{order.CustomerName}</td>
                        <td>\${order.TotalAmount}</td>
                        <td>{new Date(order.CreatedAt).toLocaleDateString()}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </>
          )}
        </div>
      );
    }
  `,

  libraries: [
    { name: "react", version: "^18.0.0" }
  ],

  description: "Real-time sales dashboard with metrics and recent orders",
  functionalRequirements: "Display sales metrics, recent orders, and allow time range selection",
  technicalDesign: "React component with MJ data access via RunView"
};
```

---

## Part 6: AI Agent Integration

### Form Manager Agent

**Purpose:** Creates and modifies Interactive Component forms based on user requests

**Capabilities:**
1. **Generate Form Specifications**
   - Analyzes entity metadata
   - Creates ComponentSpec with appropriate fields
   - Adds validation rules
   - Generates React code

2. **Preview Forms**
   - Loads sample record
   - Renders form in preview mode
   - User can test and iterate

3. **Register Forms**
   - Saves ComponentSpec to ComponentEntity
   - Creates InteractiveComponentFormTypeEntity record
   - Sets priority and scope
   - Activates form for use

4. **Modify Existing Forms**
   - Loads current form specification
   - Makes requested changes
   - Updates ComponentEntity
   - Increments version

**Example Interaction:**
```
User: "I want a custom form for Customers that shows revenue in a bar chart and has inline address editing"

Agent: "I'll create an enhanced customer form with those features. Let me show you a preview..."
[Agent generates ComponentSpec and displays preview]

User: "Perfect! Make that available for all Sales team members"

Agent: "I'll register this form with Role='Sales' and Priority=10"
[Agent creates InteractiveComponentFormTypeEntity record]
```

### Dashboard Manager Agent

**Purpose:** Creates and modifies Interactive Component dashboards

**Capabilities:**
1. **Generate Dashboard Specifications**
   - Understands data aggregation requirements
   - Creates visualizations (charts, tables, metrics)
   - Handles real-time data updates
   - Implements filtering and drilling

2. **Preview Dashboards**
   - Loads sample data
   - Renders dashboard in preview mode
   - User can test interactions

3. **Register Dashboards**
   - Saves ComponentSpec to ComponentEntity
   - Creates DashboardEntity with Type='Interactive'
   - Sets scope and category
   - Activates dashboard

4. **Modify Existing Dashboards**
   - Loads current dashboard specification
   - Makes requested changes
   - Updates ComponentEntity
   - Increments version

**Example Interaction:**
```
User: "Create a sales dashboard showing revenue by region with a map and trend chart"

Agent: "I'll create a sales analytics dashboard with regional breakdown. Preview loading..."
[Agent generates ComponentSpec and displays preview]

User: "Looks good! Make this available to all users in the Sales application"

Agent: "I'll create the dashboard with Scope='App' and ApplicationID='Sales'"
[Agent creates DashboardEntity with Type='Interactive']
```

### Shared Agent Infrastructure

Both agents share:

**1. ComponentSpec Generator**
- Analyzes metadata
- Generates React code
- Adds MJ utilities integration
- Validates specifications

**2. Preview Renderer**
- Uses MJReactComponent to render preview
- Loads sample data
- Handles user interactions
- Provides feedback loop

**3. Registration Service**
- Validates specifications
- Saves to database
- Updates metadata
- Handles versioning

**4. Interactive Chat UI**
- Form/Dashboard preview embedded in conversation
- User can see changes live
- Iterative refinement workflow
- Final approval before registration

---

## Part 7: Migration Path

### Phase 1: Infrastructure (Week 1-2)

**Backend:**
1. Create database migration:
   - Add InteractiveComponentFormTypeEntity table
   - Add InteractiveComponentDashboardTypeEntity table
   - Extend EntityEntity with PreferredFormType field
   - Extend DashboardEntity Type enum with 'Interactive'

2. Run CodeGen to generate entity classes

3. Create resolution services:
   - FormResolverService
   - DashboardResolverService

**Angular:**
1. Create wrapper components:
   - InteractiveFormComponent
   - InteractiveDashboardComponent

2. Update existing components:
   - SingleRecordComponent (use FormResolverService)
   - TabbedDashboardComponent (use DashboardResolverService)

### Phase 2: Agent Development (Week 3-4)

**Form Manager Agent:**
1. Create agent prompts
2. Implement ComponentSpec generation logic
3. Build preview capabilities
4. Add registration workflow

**Dashboard Manager Agent:**
1. Create agent prompts (reuse Form Manager patterns)
2. Implement dashboard-specific logic
3. Build preview capabilities
4. Add registration workflow

### Phase 3: Testing & Documentation (Week 5)

1. Create sample Interactive forms
2. Create sample Interactive dashboards
3. Test resolution logic with all three types
4. Test priority and scope logic
5. Document AI agent usage
6. Create user guide

### Phase 4: Migration Support (Week 6)

1. Tool to convert existing custom forms to Interactive Components
2. Tool to convert config-based dashboards to Interactive Components
3. Migration guide for developers
4. Best practices documentation

---

## Part 8: Benefits

### For Users

1. **Personalized UX**: Forms and dashboards tailored to roles and preferences
2. **No Code Required**: AI agents generate components via conversation
3. **Instant Iteration**: Preview changes before committing
4. **Consistency**: All components use same specification format

### For Developers

1. **Unified Architecture**: Same pattern for forms and dashboards
2. **Easy Customization**: Metadata-driven without code deployment
3. **Version Control**: Component versioning built-in
4. **Reusability**: Share components across entities/dashboards

### For AI Agents

1. **Standardized Format**: Single specification format to learn
2. **Rich Capabilities**: Full React + MJ utilities available
3. **Validation**: Built-in spec validation
4. **Preview Loop**: Test before registration

### For System

1. **Extensibility**: Easy to add new types without breaking changes
2. **Performance**: ComponentRegistry caching for speed
3. **Security**: User/role-based access control
4. **Maintainability**: Clear separation of concerns

---

## Part 9: Key Design Decisions

### Decision 1: Separate vs Unified Type Entities

**Decision:** Create separate `InteractiveComponentFormTypeEntity` and `InteractiveComponentDashboardTypeEntity`

**Rationale:**
- Forms and dashboards have different metadata needs
- Clearer separation of concerns
- Easier to query and manage
- Allows different validation rules

**Alternative Considered:** Single `InteractiveComponentTypeEntity` with `ResourceType` field
- More flexible but less type-safe
- Query complexity increases
- Harder to enforce domain-specific rules

### Decision 2: Priority vs Preference

**Decision:** Use Priority + Scope for resolution, not user preferences

**Rationale:**
- Forms: User doesn't choose form type (system decides based on priority)
- Dashboards: User already has DashboardUserPreferenceEntity for visibility
- Simpler resolution logic
- Clearer precedence rules (User > Role > Global)

**Alternative Considered:** Explicit user preference table for form types
- More flexible but adds complexity
- Users may not understand form type differences
- Priority-based is more maintainable

### Decision 3: Extend Dashboard.Type vs New Table

**Decision:** Extend existing `Dashboard.Type` field to include 'Interactive'

**Rationale:**
- Consistent with existing pattern ('Config', 'Code')
- No breaking changes to existing dashboards
- Single source of truth for dashboard type
- Simplified resolution logic

**Alternative Considered:** New `DashboardImplementationEntity` table
- More normalized but adds joins
- Complicates queries
- Breaks existing patterns

### Decision 4: Wrapper Components vs Direct Integration

**Decision:** Create wrapper components (InteractiveFormComponent, InteractiveDashboardComponent)

**Rationale:**
- Encapsulates Interactive Component integration
- Maintains BaseFormComponent / BaseDashboard contracts
- Easier to add new Interactive types later
- Cleaner separation of concerns

**Alternative Considered:** Directly embed MJReactComponent in SingleRecordComponent
- Tighter coupling
- Harder to maintain
- Violates single responsibility principle

---

## Part 10: Success Metrics

### Technical Metrics

- **Resolution Performance**: < 100ms to resolve form/dashboard type
- **Compilation Performance**: < 500ms to compile component spec
- **Render Performance**: < 1s to render Interactive Component
- **Cache Hit Rate**: > 90% for compiled components

### User Adoption Metrics

- **Interactive Forms Created**: Track via InteractiveComponentFormTypeEntity
- **Interactive Dashboards Created**: Track via DashboardEntity Type='Interactive'
- **Agent Conversations**: Form Manager + Dashboard Manager usage
- **User Satisfaction**: Survey after using AI-generated components

### Quality Metrics

- **Specification Validation**: 100% of specs validated before registration
- **Error Rate**: < 1% of Interactive Components throw runtime errors
- **Compatibility**: 100% backward compatibility with existing forms/dashboards

---

## Part 11: Risk Mitigation

### Risk 1: Performance Degradation

**Mitigation:**
- Implement aggressive caching (ComponentRegistry)
- Lazy compilation (on-demand, not upfront)
- Monitor resolution performance
- Add performance budgets to CI/CD

### Risk 2: Security Vulnerabilities

**Mitigation:**
- Sandbox React component execution
- Validate component specs before compilation
- Audit AI-generated code before registration
- Role-based access control on component creation

### Risk 3: Complexity Creep

**Mitigation:**
- Clear documentation and examples
- Gradual rollout (forms first, then dashboards)
- Training for AI agent usage
- Best practices guide

### Risk 4: Breaking Changes

**Mitigation:**
- Maintain backward compatibility with Type 1 and Type 2
- Graceful fallbacks if Interactive Component fails
- Version component specs
- Deprecation strategy for old patterns

---

## Conclusion

This unified architecture extends MemberJunction's forms and dashboards with Interactive Components as a third implementation type, while maintaining full backward compatibility with existing generated/config-based and code-based approaches.

**Key Strengths:**
1. **Unified Pattern**: Same approach for forms and dashboards
2. **Flexible Resolution**: User > Role > Global scope with priority
3. **AI-Native**: Designed for AI agent generation and modification
4. **Backward Compatible**: No breaking changes to existing code
5. **Performance**: Caching and lazy compilation for speed
6. **Extensible**: Easy to add new resource types (reports, etc.)

**Next Steps:**
1. Review and approve architecture
2. Create database migration script
3. Implement Phase 1 (Infrastructure)
4. Build Form Manager and Dashboard Manager agents
5. Roll out to users with documentation

This architecture positions MemberJunction to deliver on the vision of AI-generated, metadata-driven, user-customizable forms and dashboards while maintaining the system's existing strengths and flexibility.
