# MJ 3.0 Bootstrap Architecture - Analysis & Revised Approach

## Executive Summary

The initial MJBootstrapModule approach **failed because it tried to wrap Angular module configuration patterns** instead of extracting reusable business logic and UI components. This document proposes a revised architecture that achieves the same goals (minimal MJExplorer footprint) through services and components rather than module wrappers.

## What Went Wrong: Root Cause Analysis

### The Failed Approach
```typescript
// ❌ What we tried
@NgModule({
  imports: [
    MJBootstrapModule.forRoot(environment) // Wrapper that broke auth
  ]
})

// MJBootstrapModule tried to import AuthServicesModule statically
@NgModule({
  imports: [AuthServicesModule] // ← Missing .forRoot() call!
})
```

### Why It Failed

**Problem 1: Lost Provider Registration**
- `AuthServicesModule.forRoot(environment)` returns critical MSAL providers:
  - `MSAL_INSTANCE` (configured PublicClientApplication)
  - `MSAL_GUARD_CONFIG`
  - `MSAL_INTERCEPTOR_CONFIG`
  - `MsalService`, `MsalGuard`, `MsalBroadcastService`
- When we imported `AuthServicesModule` without calling `.forRoot()`, these providers were never registered
- MSAL couldn't initialize, breaking session persistence

**Problem 2: Provider Timing Issues**
- APP_INITIALIZER needs to run before routing
- MJAuthBase needs MSAL providers injected
- Wrapping created dependency resolution race conditions

**Problem 3: Fighting Angular's Design**
- `.forRoot()` pattern exists specifically to configure root providers
- Trying to wrap it in another `.forRoot()` is architecturally fragile
- Different modules have different configuration needs (can't standardize)

### Test Results

**✅ Original code (working):**
```
[MSAL] Starting initialization...
[MSAL] Cached accounts found: 1
[MSAL] Restoring session from cached account: robert.kihm@bluecypress.io
[MSAL] Initialization completed (cached session restored)
```

**❌ MJBootstrapModule code (broken):**
```
[Auth] Current authentication status: false
[Auth] No existing session found
User not authenticated, showing login screen
```
No MSAL logs appeared because MSAL instance wasn't configured.

## The Right Question

We were asking: **"How do we wrap module configuration in a package?"**

We should ask: **"What business logic and UI patterns can we extract from MJExplorer?"**

## What Actually Needs Extraction

### Current MJExplorer AppComponent (242 lines)

**Configuration (must stay in app):**
- Module imports: `AuthServicesModule.forRoot(environment)` ✋ Keep
- APP_INITIALIZER setup ✋ Keep
- Environment-specific values ✋ Keep

**Business Logic (should extract):** ✅
1. GraphQL client setup with token refresh callback
2. Workspace initialization (`SharedService.RefreshData()`)
3. User validation and access control
4. Error classification (no-roles, token expiration, etc.)
5. Auth retry logic
6. Default route navigation
7. Startup validation checks

**UI State Management (should extract):** ✅
1. Loading states (login → workspace loading → ready)
2. Error display with user-friendly messages
3. Validation issue display
4. Sub-header text updates

## Revised Architecture: Service + Component Pattern

### New Package: @memberjunction/ng-workspace-initializer

#### 1. WorkspaceInitializerService (Business Logic)

```typescript
export interface WorkspaceEnvironment {
  GRAPHQL_URI: string;
  GRAPHQL_WS_URI: string;
  MJ_CORE_SCHEMA_NAME: string;
}

export interface WorkspaceInitResult {
  success: boolean;
  error?: WorkspaceInitError;
  validationIssues?: ValidationIssue[];
}

export interface WorkspaceInitError {
  type: 'no_roles' | 'no_access' | 'token_expired' | 'network' | 'unknown';
  message: string;
  userMessage: string;
  shouldRetry: boolean;
}

@Injectable({ providedIn: 'root' })
export class WorkspaceInitializerService {
  constructor(
    private authBase: MJAuthBase,
    private startupValidation: StartupValidationService,
    private router: Router
  ) {}

  /**
   * Initialize workspace with authenticated user
   * Replaces all the logic from AppComponent.handleLogin()
   */
  async initializeWorkspace(
    token: string,
    userInfo: StandardUserInfo,
    environment: WorkspaceEnvironment
  ): Promise<WorkspaceInitResult> {
    try {
      // 1. Setup GraphQL client
      const config = new GraphQLProviderConfigData(
        token,
        environment.GRAPHQL_URI,
        environment.GRAPHQL_WS_URI,
        async () => {
          const result = await this.authBase.refreshToken();
          if (!result.success || !result.token) {
            throw new Error(result.error?.userMessage || 'Failed to refresh token');
          }
          return result.token.idToken;
        },
        environment.MJ_CORE_SCHEMA_NAME
      );

      await setupGraphQLClient(config);

      // 2. Load metadata and validate user
      await SharedService.RefreshData(true);
      const md = new Metadata();

      if (!md.CurrentUser) {
        throw new Error("You don't have access to the application");
      }

      // 3. Run startup validation
      const validationIssues = await this.startupValidation.validateSystemSetup();

      return {
        success: true,
        validationIssues: validationIssues.length > 0 ? validationIssues : undefined
      };
    } catch (err: any) {
      const error = this.classifyError(err);
      return {
        success: false,
        error
      };
    }
  }

  /**
   * Classify errors into actionable types
   * Replaces AppComponent.isNoUserRolesError() logic
   */
  classifyError(err: any): WorkspaceInitError {
    // Check for no-roles error
    if (this.isNoUserRolesError(err)) {
      return {
        type: 'no_roles',
        message: err.message || 'No user roles assigned',
        userMessage: 'Your account does not have any roles assigned. Please contact your administrator.',
        shouldRetry: false
      };
    }

    // Check for access denied
    if (err.message?.includes("don't have access")) {
      return {
        type: 'no_access',
        message: err.message,
        userMessage: err.message,
        shouldRetry: false
      };
    }

    // Check for token expiration
    const authError = this.authBase.classifyError(err);
    if (authError.type === AuthErrorType.TOKEN_EXPIRED) {
      return {
        type: 'token_expired',
        message: authError.message,
        userMessage: authError.userMessage || 'Your session has expired. Please log in again.',
        shouldRetry: true
      };
    }

    // Network errors
    if (err.message?.includes('network') || err.message?.includes('fetch')) {
      return {
        type: 'network',
        message: err.message,
        userMessage: 'Network error. Please check your connection and try again.',
        shouldRetry: true
      };
    }

    // Unknown error
    return {
      type: 'unknown',
      message: err.message || 'Unknown error',
      userMessage: 'An unexpected error occurred. Please try again.',
      shouldRetry: false
    };
  }

  private isNoUserRolesError(err: any): boolean {
    if (!err || typeof err !== 'object') return false;

    if (err.response && Array.isArray(err.response.errors)) {
      return err.response.errors.some((e: any) =>
        e && e.message && e.message.includes('does not have read permissions on User Roles')
      );
    }

    if (err.message) {
      return err.message.includes('does not have read permissions on User Roles') ||
             err.message.includes("Cannot read properties of undefined (reading 'ResourceTypes')");
    }

    return false;
  }

  /**
   * Handle authentication retry with backoff
   * Replaces AppComponent.handleAuthRetry()
   */
  async handleAuthRetry(error: WorkspaceInitError): Promise<boolean> {
    if (!error.shouldRetry) {
      return false;
    }

    const retryKey = 'auth-retry-dt';
    const lastRetryDateTime = localStorage.getItem(retryKey);
    const yesterday = +new Date(Date.now() - 1 * 24 * 60 * 60 * 1000);
    const retriedRecently = lastRetryDateTime && +new Date(lastRetryDateTime) > yesterday;

    if (!retriedRecently && error.type === 'token_expired') {
      localStorage.setItem(retryKey, new Date().toISOString());
      await this.authBase.login({ appState: { target: window.location.pathname } }).toPromise();
      return true;
    }

    return false;
  }
}
```

#### 2. WorkspaceLoaderComponent (UI State Management)

```typescript
@Component({
  selector: 'mj-workspace-loader',
  template: `
    <!-- Login Screen -->
    <div *ngIf="!authenticated" class="login-container">
      <mj-login-screen [subHeaderText]="subHeaderText"></mj-login-screen>
    </div>

    <!-- Loading Workspace -->
    <div *ngIf="authenticated && loading" class="loading-container">
      <mj-loading text="Loading Workspace..."></mj-loading>
    </div>

    <!-- Error Display -->
    <div *ngIf="hasError && !showValidationOnly" class="error-container">
      <mj-error-display
        [error]="errorMessage"
        [canRetry]="canRetry"
        (retry)="retryInitialization()">
      </mj-error-display>
    </div>

    <!-- Validation Issues Only -->
    <div *ngIf="showValidationOnly" class="validation-container">
      <system-validation-banner></system-validation-banner>
    </div>

    <!-- Workspace Ready - Project Content -->
    <ng-content *ngIf="workspaceReady"></ng-content>
  `,
  styleUrls: ['./workspace-loader.component.css']
})
export class WorkspaceLoaderComponent implements OnInit, OnDestroy {
  @Input() environment!: WorkspaceEnvironment;
  @Output() workspaceReady = new EventEmitter<void>();
  @Output() workspaceError = new EventEmitter<WorkspaceInitError>();

  // UI State
  authenticated = false;
  loading = false;
  workspaceReady = false;
  hasError = false;
  errorMessage: string = '';
  canRetry = false;
  showValidationOnly = false;
  subHeaderText = "Welcome back! Please log in to your account.";

  private destroy$ = new Subject<void>();
  private isInitializing = false; // Guard against duplicate calls

  constructor(
    private authBase: MJAuthBase,
    private workspaceInit: WorkspaceInitializerService,
    @Inject(DOCUMENT) private document: Document,
    private router: Router
  ) {}

  async ngOnInit() {
    // Check for existing session
    const isAuth = await this.authBase.isAuthenticated().pipe(take(1)).toPromise();

    if (isAuth) {
      const userInfo = await this.authBase.getUserInfo().pipe(take(1)).toPromise();
      if (userInfo) {
        const token = await this.authBase.getIdToken();
        if (token) {
          await this.initializeWorkspace(token, userInfo);
        }
      }
    }

    // Listen for auth state changes
    this.setupAuthHandlers();
  }

  private setupAuthHandlers() {
    // Listen for user login
    this.authBase.getUserInfo()
      .pipe(takeUntil(this.destroy$))
      .subscribe(async (userInfo) => {
        if (userInfo && !this.isInitializing) {
          const token = await this.authBase.getIdToken();
          if (token) {
            await this.initializeWorkspace(token, userInfo);
          }
        }
      });

    // Listen for auth errors
    this.authBase.isAuthenticated()
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        error: (err: unknown) => {
          const authError = this.authBase.classifyError(err);
          switch (authError.type) {
            case AuthErrorType.NO_ACTIVE_SESSION:
              this.subHeaderText = "Welcome back! Please log in to your account.";
              break;
            case AuthErrorType.INTERACTION_REQUIRED:
            case AuthErrorType.TOKEN_EXPIRED:
              this.subHeaderText = "Your session has expired. Please log in again.";
              break;
            default:
              this.subHeaderText = authError.userMessage || "Welcome back! Please log in to your account.";
          }
        }
      });
  }

  private async initializeWorkspace(token: string, userInfo: StandardUserInfo) {
    if (this.isInitializing) {
      console.log('[Workspace] Initialization already in progress');
      return;
    }

    this.isInitializing = true;
    this.authenticated = true;
    this.loading = true;
    this.hasError = false;
    this.workspaceReady = false;

    try {
      const result = await this.workspaceInit.initializeWorkspace(token, userInfo, this.environment);

      if (result.success) {
        // Check for validation-only mode
        if (result.validationIssues && result.validationIssues.some(i => i.severity === 'critical')) {
          this.showValidationOnly = true;
          this.loading = false;
        } else {
          this.workspaceReady = true;
          this.loading = false;
          this.workspaceReady.emit();
          this.navigateToInitialRoute();
        }
      } else if (result.error) {
        // Handle errors
        const retried = await this.workspaceInit.handleAuthRetry(result.error);
        if (!retried) {
          this.hasError = true;
          this.errorMessage = result.error.userMessage;
          this.canRetry = result.error.shouldRetry;
          this.loading = false;
          this.workspaceError.emit(result.error);
        }
      }
    } catch (err: any) {
      this.hasError = true;
      this.errorMessage = err.message || 'An unexpected error occurred';
      this.canRetry = false;
      this.loading = false;
    } finally {
      this.isInitializing = false;
    }
  }

  private navigateToInitialRoute() {
    const initialPath = window.location.pathname + window.location.search;

    if (initialPath === '/') {
      // Click first drawer item as default
      setTimeout(() => {
        const drawerElement = this.document.querySelector('li.k-drawer-item.k-level-0') as any;
        if (drawerElement) drawerElement.click();
      }, 10);
    } else {
      this.router.navigateByUrl(initialPath, { replaceUrl: true });
    }
  }

  async retryInitialization() {
    this.hasError = false;
    this.errorMessage = '';
    const userInfo = await this.authBase.getUserInfo().pipe(take(1)).toPromise();
    if (userInfo) {
      const token = await this.authBase.getIdToken();
      if (token) {
        await this.initializeWorkspace(token, userInfo);
      }
    }
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

### MJExplorer After Refactor (Minimal)

#### app.module.ts (Configuration Only)
```typescript
import { AuthServicesModule } from '@memberjunction/ng-auth-services';
import { WorkspaceInitializerModule } from '@memberjunction/ng-workspace-initializer';

export function initializeAuth(authService: MJAuthBase): () => Promise<void> {
  return () => authService.initialize();
}

@NgModule({
  declarations: [
    AppComponent,
    // ... other components
  ],
  imports: [
    BrowserModule,
    BrowserAnimationsModule,
    AuthServicesModule.forRoot(environment), // ✅ Direct, not wrapped
    WorkspaceInitializerModule, // ✅ New package with service + component
    ExplorerCoreModule,
    ShellModule,
    // ... other modules
  ],
  providers: [
    {
      provide: APP_INITIALIZER,
      useFactory: initializeAuth,
      deps: [MJAuthBase],
      multi: true
    }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

#### app.component.ts (Minimal Delegation)
```typescript
@Component({
  selector: 'app-root',
  template: `
    <mj-workspace-loader
      [environment]="workspaceEnvironment"
      (workspaceReady)="onWorkspaceReady()"
      (workspaceError)="onWorkspaceError($event)">

      <!-- Shell with router-outlet loaded only when workspace is ready -->
      <mj-shell></mj-shell>

    </mj-workspace-loader>
  `,
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  workspaceEnvironment: WorkspaceEnvironment = {
    GRAPHQL_URI: environment.GRAPHQL_URI,
    GRAPHQL_WS_URI: environment.GRAPHQL_WS_URI,
    MJ_CORE_SCHEMA_NAME: environment.MJ_CORE_SCHEMA_NAME
  };

  onWorkspaceReady() {
    console.log('Workspace ready - navigation complete');
  }

  onWorkspaceError(error: WorkspaceInitError) {
    console.error('Workspace initialization failed:', error);
    // Optional: Custom error tracking
  }
}
```

**Result:** AppComponent reduced from 242 lines to ~25 lines!

## Benefits of Revised Architecture

### ✅ Achieves Original Goals
1. **Minimal MJExplorer footprint** - AppComponent is now 25 lines of template wiring
2. **Business logic in packages** - WorkspaceInitializerService handles all initialization
3. **No need to update MJExplorer** - Future changes go into ng-workspace-initializer package
4. **Reusable across apps** - Any MJ app can use WorkspaceLoaderComponent

### ✅ Avoids Original Problems
1. **No module wrapper fragility** - AuthServicesModule.forRoot() stays direct
2. **No provider timing issues** - APP_INITIALIZER setup is explicit
3. **No fighting Angular patterns** - Uses services and components (Angular's strengths)

### ✅ Additional Benefits
1. **Testable** - WorkspaceInitializerService is easy to unit test
2. **Customizable** - Apps can override behavior via @Input() and @Output()
3. **Type-safe** - Clear interfaces for configuration and results
4. **Maintainable** - Business logic separated from UI concerns
5. **Debuggable** - Clear separation of concerns makes issues easy to isolate

## Migration Path

### Phase 1: Create ng-workspace-initializer Package
1. Create package structure
2. Implement WorkspaceInitializerService
3. Implement WorkspaceLoaderComponent
4. Add comprehensive tests

### Phase 2: Update MJExplorer
1. Import WorkspaceInitializerModule
2. Update AppComponent to use mj-workspace-loader
3. Remove old initialization code
4. Test thoroughly

### Phase 3: Validate with Other Apps
1. Update MJServer (if it has similar patterns)
2. Document usage for new apps
3. Add to templates/scaffolding

## Conclusion

The original MJBootstrapModule approach failed because it fought against Angular's module system. The revised approach:

- ✅ **Extracts business logic** into services (WorkspaceInitializerService)
- ✅ **Extracts UI patterns** into components (WorkspaceLoaderComponent)
- ✅ **Leaves module configuration alone** (AuthServicesModule.forRoot() stays direct)
- ✅ **Achieves the same goals** (minimal MJExplorer footprint)
- ✅ **Avoids the same problems** (no auth breakage)

**This is the right architecture for MJ 3.0.**
