# Flexible Database Support Plan (v3.0)

## Executive Summary

MemberJunction currently assumes well-designed databases with primary keys on all tables and foreign key constraints defining relationships. This excludes significant real-world scenarios: legacy databases, read replicas, ETL outputs, vendor databases, and imported data.

This plan introduces **first-class support for soft relationships and tables without primary keys**, enabling MJ to function as an AI data platform where users can bring in *any* data.

**Key Changes:**
- Auto-generate `__mj_ID` column for tables without primary keys
- Support "Soft" relationships (metadata-defined, no DB constraint)
- Integrate with DBAutoDoc for AI-powered relationship discovery
- Full support across all layers: GraphQL, BaseEntity, and UI

---

## Problem Statement

### Current Limitations

```mermaid
flowchart LR
    subgraph "Current Behavior"
        A[Table without PK] -->|CodeGen| B[SKIPPED]
        C[Relationship without FK] -->|CodeGen| D[INVISIBLE]
    end

    subgraph "Real World Data"
        E[Legacy Systems]
        F[Read Replicas]
        G[ETL Outputs]
        H[Vendor DBs]
        I[Data Imports]
    end

    E & F & G & H & I -->|Often have| A & C
```

### Impact

| Scenario | Current Outcome | Desired Outcome |
|----------|----------------|-----------------|
| Table with no PK | Skipped entirely | Full entity with generated `__mj_ID` |
| Relationship without FK | Invisible to MJ | Discoverable soft relationship |
| Dirty data with orphans | N/A | Tracked with quality metrics |
| AI relationship discovery | Not integrated | DBAutoDoc → MJ metadata |

---

## Core Concepts

### Concept 1: Primary Key Source

How did the entity's primary key come to exist?

```mermaid
flowchart TD
    subgraph "Primary Key Source (Entity Level)"
        A[Table Analyzed] --> B{Has PK Constraint?}
        B -->|Yes| C[PrimaryKeySource = 'Schema']
        B -->|No| D{Config: autoAddPK?}
        D -->|Yes| E[Add __mj_ID column]
        E --> F[PrimaryKeySource = 'Generated']
        D -->|No| G[Skip Table]
    end

    style C fill:#90EE90
    style F fill:#87CEEB
    style G fill:#FFB6C1
```

| Value | Description |
|-------|-------------|
| **Schema** | Primary key defined in database (normal case) |
| **Generated** | MJ added `__mj_ID` column because table lacked PK |

### Concept 2: Relationship Type

How is a field related to another entity?

```mermaid
flowchart TD
    subgraph "Relationship Type (EntityField Level)"
        A[Field Analyzed] --> B{Has DB FK Constraint?}
        B -->|Yes| C[RelationshipType = 'Hard']
        B -->|No| D{Marked in Metadata?}
        D -->|Yes| E[RelationshipType = 'Soft']
        D -->|No| F[RelationshipType = 'None']

        E --> G{EntityIDFieldName set?}
        G -->|Yes| H[Polymorphic Soft Key]
        G -->|No| I[Standard Soft Key]
    end

    style C fill:#90EE90
    style E fill:#87CEEB
    style H fill:#DDA0DD
    style I fill:#87CEEB
    style F fill:#D3D3D3
```

| Value | DB Constraint | Description |
|-------|---------------|-------------|
| **None** | N/A | No relationship |
| **Hard** | Yes | Database FK constraint exists and enforces integrity |
| **Soft** | No | Relationship known via metadata, not enforced by DB |

### Concept 3: Polymorphic Relationships

When a single field can point to records in different entities based on a discriminator column:

```mermaid
erDiagram
    FileEntityRecordLink {
        uniqueidentifier ID PK
        uniqueidentifier FileID FK
        uniqueidentifier EntityID FK
        nvarchar RecordID "Polymorphic Soft Key"
    }

    Files {
        uniqueidentifier ID PK
        nvarchar Name
    }

    Entity {
        uniqueidentifier ID PK
        nvarchar Name
    }

    Customers {
        uniqueidentifier ID PK
        nvarchar Name
    }

    Orders {
        uniqueidentifier ID PK
        nvarchar OrderNumber
    }

    FileEntityRecordLink ||--|| Files : "FileID (Hard)"
    FileEntityRecordLink ||--|| Entity : "EntityID (Hard)"
    FileEntityRecordLink }|..|| Customers : "RecordID → when EntityID=Customers"
    FileEntityRecordLink }|..|| Orders : "RecordID → when EntityID=Orders"
```

The `RecordID` field has `EntityIDFieldName = "EntityID"`, telling MJ to look at the EntityID column to determine which entity RecordID references.

---

## Relationship Types Comparison

```mermaid
flowchart LR
    subgraph "Hard Relationship"
        H1[Orders.CustomerID] -->|FK Constraint| H2[Customers.ID]
    end

    subgraph "Soft Relationship"
        S1[LegacyOrders.CustCode] -.->|Metadata Only| S2[Customers.Code]
    end

    subgraph "Polymorphic Soft"
        P1[FileLinks.RecordID] -.->|Via EntityID| P2[Any Entity]
    end

    style H1 fill:#90EE90
    style H2 fill:#90EE90
    style S1 fill:#87CEEB
    style S2 fill:#87CEEB
    style P1 fill:#DDA0DD
    style P2 fill:#DDA0DD
```

### Behavior Differences

| Aspect | Hard | Soft |
|--------|------|------|
| **DB Constraint** | FK exists | None |
| **Orphan Prevention** | Database enforces | Application warns |
| **Cascade Delete** | DB can cascade | App awareness only |
| **Save Validation** | Error if target missing | Warning, allows save |
| **GraphQL Resolution** | Always resolves or errors | May return null (orphan) |
| **UI Display** | Solid lines/icons | Dashed lines + confidence badge |
| **Discovery** | Automatic from schema | Manual or AI-discovered |

---

## Auto-Generated Primary Key Flow

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant CG as CodeGen
    participant DB as Database
    participant Meta as MJ Metadata

    Dev->>CG: Run CodeGen
    CG->>DB: Query sys.tables for tables
    CG->>DB: Query sys.indexes for PKs

    alt Table has PK
        CG->>Meta: Create Entity (PrimaryKeySource='Schema')
        CG->>Meta: Create EntityFields with IsPrimaryKey=1
    else Table lacks PK AND autoAddPK=true
        CG->>DB: ALTER TABLE ADD __mj_ID UNIQUEIDENTIFIER
        CG->>DB: UPDATE SET __mj_ID = NEWID()
        CG->>DB: ADD CONSTRAINT PK_xxx PRIMARY KEY
        CG->>Meta: Create Entity (PrimaryKeySource='Generated')
        CG->>Meta: Create EntityField __mj_ID (IsPrimaryKey=1)
    else Table lacks PK AND autoAddPK=false
        CG-->>Dev: Skip table (logged)
    end
```

### Generated Migration Example

```sql
-- Auto-generated by MJ CodeGen
-- Adding primary key to PK-less table: [imported].[LegacyOrders]

ALTER TABLE [imported].[LegacyOrders]
ADD [__mj_ID] UNIQUEIDENTIFIER NOT NULL
    CONSTRAINT [DF_imported_LegacyOrders___mj_ID] DEFAULT NEWID();
GO

-- Populate existing rows
UPDATE [imported].[LegacyOrders]
SET [__mj_ID] = NEWID()
WHERE [__mj_ID] = '00000000-0000-0000-0000-000000000000';
GO

-- Add primary key constraint
ALTER TABLE [imported].[LegacyOrders]
ADD CONSTRAINT [PK_imported_LegacyOrders___mj_ID] PRIMARY KEY ([__mj_ID]);
GO
```

---

## Schema Changes

### Entity Table

```sql
ALTER TABLE __mj.Entity ADD
    PrimaryKeySource VARCHAR(20) NOT NULL
        CONSTRAINT DF_Entity_PrimaryKeySource DEFAULT 'Schema'
        CONSTRAINT CK_Entity_PrimaryKeySource
            CHECK (PrimaryKeySource IN ('Schema', 'Generated'));
```

### EntityField Table

```sql
ALTER TABLE __mj.EntityField ADD
    -- Relationship classification
    RelationshipType VARCHAR(20) NOT NULL
        CONSTRAINT DF_EntityField_RelationshipType DEFAULT 'None'
        CONSTRAINT CK_EntityField_RelationshipType
            CHECK (RelationshipType IN ('None', 'Hard', 'Soft')),

    -- Discovery metadata
    RelationshipDiscoverySource VARCHAR(20) NULL
        CONSTRAINT CK_EntityField_RelationshipDiscoverySource
            CHECK (RelationshipDiscoverySource IN ('Schema', 'Manual', 'AIDiscovered')),

    RelationshipConfidence DECIMAL(5,4) NULL,  -- 0.0000 to 1.0000

    -- LLM/Human reasoning for why relationship exists
    RelationshipDiscoveryNotes NVARCHAR(MAX) NULL,

    -- Data quality tracking
    LastIntegrityCheckAt DATETIME NULL,
    OrphanCount INT NULL;  -- Records with no match in target entity
```

### Entity Relationship Diagram

```mermaid
erDiagram
    Entity {
        uniqueidentifier ID PK
        nvarchar Name
        nvarchar SchemaName
        nvarchar BaseTable
        varchar PrimaryKeySource "NEW: Schema|Generated"
    }

    EntityField {
        uniqueidentifier ID PK
        uniqueidentifier EntityID FK
        nvarchar Name
        uniqueidentifier RelatedEntityID FK "nullable"
        nvarchar RelatedEntityFieldName "nullable"
        nvarchar EntityIDFieldName "nullable - for polymorphic"
        varchar RelationshipType "NEW: None|Hard|Soft"
        varchar RelationshipDiscoverySource "NEW: Schema|Manual|AIDiscovered"
        decimal RelationshipConfidence "NEW: 0.0-1.0"
        nvarchar RelationshipDiscoveryNotes "NEW: LLM reasoning"
        int OrphanCount "NEW: data quality"
    }

    Entity ||--o{ EntityField : "has"
    EntityField }o--o| Entity : "RelatedEntityID"
```

---

## Layer-by-Layer Implementation

### Layer 1: Database / Metadata

```mermaid
flowchart TD
    subgraph "Schema Changes"
        A[Entity.PrimaryKeySource]
        B[EntityField.RelationshipType]
        C[EntityField.RelationshipDiscoverySource]
        D[EntityField.RelationshipConfidence]
        E[EntityField.RelationshipDiscoveryNotes]
        F[EntityField.OrphanCount]
    end

    subgraph "Migration Scripts"
        G[Add columns to Entity]
        H[Add columns to EntityField]
        I[Update existing FKs to Hard]
        J[Update views/sprocs]
    end

    A & B & C & D & E & F --> G & H & I & J
```

### Layer 2: CodeGen

```mermaid
flowchart TD
    subgraph "manage-metadata.ts Changes"
        A[Detect PK-less tables]
        B{Config: autoAddPK?}
        B -->|Yes| C[Generate ALTER TABLE script]
        C --> D[Create Entity with Generated source]
        B -->|No| E[Skip with log message]
    end

    subgraph "Field Processing"
        F[For each FK in schema]
        F --> G[Set RelationshipType = 'Hard']
        F --> H[Set DiscoverySource = 'Schema']
    end

    subgraph "New Config"
        I["primaryKeyGeneration.enabled"]
        J["primaryKeyGeneration.columnName"]
        K["primaryKeyGeneration.excludeSchemas"]
    end
```

### Layer 3: MJCore / BaseEntity

```mermaid
flowchart TD
    subgraph "EntityFieldInfo Enhancements"
        A[RelationshipType property]
        B[HasRelationship getter]
        C[IsHardRelationship getter]
        D[IsSoftRelationship getter]
        E[IsPolymorphic getter]
        F[RelationshipConfidence property]
    end

    subgraph "BaseEntity Changes"
        G[validateRelationships method]
        H[Hard: Error if orphan]
        I[Soft: Warning if orphan]
        J[GetRecordDependencies includes type]
    end

    A & B & C & D & E & F --> G
    G --> H & I & J
```

### Layer 4: GraphQL / MJServer

```mermaid
flowchart TD
    subgraph "Schema Generation"
        A[Field resolver generated]
        B{RelationshipType?}
        B -->|Hard| C[Standard resolution]
        B -->|Soft| D[Null-tolerant resolution]
    end

    subgraph "Introspection"
        E[FieldRelationshipInfo type]
        F[type: NONE|HARD|SOFT]
        G[confidence: Float]
        H[isPolymorphic: Boolean]
    end

    subgraph "Runtime"
        I[Soft relationship returns null if orphan]
        J[No error, graceful degradation]
    end
```

### Layer 5: Angular UI

```mermaid
flowchart TD
    subgraph "Visual Differentiation"
        A[Hard: Solid border]
        B[Soft: Dashed border + badge]
        C[Confidence indicator]
        D[Discovery source icon]
    end

    subgraph "Form Behavior"
        E[Hard orphan: Blocks save]
        F[Soft orphan: Warning only]
        G[Shows data quality indicator]
    end

    subgraph "Entity Diagrams"
        H["─────── Hard FK"]
        I["╌╌╌╌╌╌╌ Soft Key (92%)"]
    end

    subgraph "Admin UI"
        J[Mark relationships manually]
        K[Review AI-discovered relationships]
        L[Run integrity checks]
    end
```

---

## DBAutoDoc Integration

### Current State

DBAutoDoc already discovers:
- Missing primary keys (statistical uniqueness analysis)
- Missing foreign keys (value overlap, naming patterns)
- Confidence scores with evidence

### Enhancement: MJ Metadata Export

```mermaid
sequenceDiagram
    participant DBA as DBAutoDoc
    participant AI as LLM Analysis
    participant Export as MJ Export
    participant MJ as MJ Metadata
    participant Review as Admin UI

    DBA->>AI: Analyze schema + statistics
    AI->>DBA: Discovered relationships with confidence
    DBA->>Export: Generate MJ migration file

    Export->>MJ: Extended properties (descriptions)
    Export->>MJ: EntityField updates (soft keys)

    Note over Export,MJ: Single migration file contains both

    MJ->>Review: Surface for human review
    Review->>MJ: Accept/Reject/Edit
```

### DBAutoDoc Output Format

```sql
-- =====================================================
-- MJ Metadata Migration - Generated by DBAutoDoc
-- Database: LegacySystem
-- Generated: 2024-12-02T10:30:00Z
-- =====================================================

-- SECTION 1: Extended Properties (Descriptions)
EXEC sp_addextendedproperty
    @name = N'MS_Description',
    @value = N'Legacy customer orders imported from AS400 system',
    @level0type = N'SCHEMA', @level0name = N'imported',
    @level1type = N'TABLE',  @level1name = N'LegacyOrders';

EXEC sp_addextendedproperty
    @name = N'MS_Description',
    @value = N'Customer code linking to Customers.Code',
    @level0type = N'SCHEMA', @level0name = N'imported',
    @level1type = N'TABLE',  @level1name = N'LegacyOrders',
    @level2type = N'COLUMN', @level2name = N'CustCode';

-- SECTION 2: Soft Relationship Metadata
-- Discovered: LegacyOrders.CustCode → Customers.Code (confidence: 0.92)

UPDATE ef SET
    RelationshipType = 'Soft',
    RelatedEntityID = re.ID,
    RelatedEntityFieldName = 'Code',
    RelationshipDiscoverySource = 'AIDiscovered',
    RelationshipConfidence = 0.9200,
    RelationshipDiscoveryNotes = N'DBAutoDoc Discovery (2024-12-02)
Evidence:
- Value overlap: 97.3% of CustCode values exist in Customers.Code
- Naming similarity: 0.85 (CustCode → Customer + Code)
- Orphan rate: 2.7% (acceptable for legacy data)
- Cardinality: Many-to-one confirmed

LLM Reasoning:
Column naming pattern "CustCode" strongly suggests customer reference.
The 97% value overlap confirms the relationship despite lack of FK.
Orphan records likely represent deleted customers in source system.'
FROM __mj.EntityField ef
INNER JOIN __mj.Entity e ON ef.EntityID = e.ID
INNER JOIN __mj.Entity re ON re.Name = 'Customers'
WHERE e.SchemaName = 'imported'
  AND e.BaseTable = 'LegacyOrders'
  AND ef.Name = 'CustCode';
```

### DBAutoDoc Configuration

```javascript
// dbautodoc.config.js
module.exports = {
  export: {
    mjMetadata: {
      enabled: true,
      outputPath: './migrations/dbautodoc/',
      fileNamePattern: 'DBAutoDoc__{database}__{timestamp}.sql',

      includeExtendedProperties: true,
      includeSoftRelationships: true,

      // Confidence thresholds
      autoAcceptThreshold: 0.95,    // Auto-mark as accepted
      includeThreshold: 0.70,       // Include in migration

      // What to include in discovery notes
      includeEvidence: true,
      includeLLMReasoning: true,
    }
  }
};
```

---

## Configuration

### CodeGen Configuration

```javascript
// mj.config.cjs
module.exports = {
  codeGenSettings: {
    // Auto-add __mj_ID to tables without primary keys
    primaryKeyGeneration: {
      enabled: true,
      columnName: '__mj_ID',
      columnType: 'uniqueidentifier',
      defaultValue: 'NEWID()',

      // Exclusions
      excludeSchemas: ['sys', 'INFORMATION_SCHEMA', '__mj'],
      excludeTables: ['sysdiagrams', 'dtproperties'],
      excludePatterns: ['*_log', '*_audit', '*_history'],  // Wildcards
    },

    // Relationship handling
    relationships: {
      // Populate RelationshipType='Hard' for existing FKs
      populateRelationshipType: true,

      // Mark existing EntityIDFieldName relationships as Soft
      markPolymorphicAsSoft: true,
    }
  }
};
```

---

## Packages to Modify

### Core Framework

| Package | Files | Changes |
|---------|-------|---------|
| **MJCore** | `src/generic/entityInfo.ts` | Add RelationshipType, confidence, helpers |
| **MJCore** | `src/generic/baseEntity.ts` | Relationship validation (warn vs error) |
| **MJCoreEntities** | `src/generated/entity_subclasses.ts` | Regenerate with new fields |

### CodeGen

| Package | Files | Changes |
|---------|-------|---------|
| **CodeGenLib** | `src/Database/manage-metadata.ts` | PK generation, populate RelationshipType |
| **CodeGenLib** | `src/Database/sql_codegen.ts` | Generate __mj_ID migration scripts |
| **CodeGenLib** | `src/Config/config.ts` | New configuration options |

### Server

| Package | Files | Changes |
|---------|-------|---------|
| **MJServer** | `src/generated/generated.ts` | Relationship type in resolvers |
| **MJServer** | `src/resolvers/` | Null-tolerant soft relationship resolution |

### Angular UI

| Package | Files | Changes |
|---------|-------|---------|
| **ng-shared-generic** | `src/lib/components/` | Relationship type visual indicators |
| **Explorer** | `core-entity-forms/` | Soft key display, confidence badges |
| **Explorer** | `entity-browser/` | Relationship diagrams (solid vs dashed) |
| **Explorer** | `admin/` | Manual soft key marking UI |

### DBAutoDoc

| Package | Files | Changes |
|---------|-------|---------|
| **DBAutoDoc** | `src/export/` | New MJ metadata export format |
| **DBAutoDoc** | `src/discovery/` | Include discovery notes in output |
| **DBAutoDoc** | `src/types/` | MJ export types |

---

## Implementation Phases

### Phase 1: Schema Foundation

```mermaid
gantt
    title Phase 1: Schema Foundation
    dateFormat  YYYY-MM-DD
    section Database
    Add Entity.PrimaryKeySource           :p1a, 2024-01-01, 1d
    Add EntityField relationship columns  :p1b, after p1a, 1d
    Update views and sprocs               :p1c, after p1b, 1d
    section CodeGen
    Populate RelationshipType=Hard        :p1d, after p1c, 2d
    Update MJCoreEntities generation      :p1e, after p1d, 1d
```

**Deliverables:**
- Migration script adding new columns
- CodeGen populates `RelationshipType='Hard'` for existing FKs
- All existing behavior unchanged

### Phase 2: Auto-Generate Primary Keys

```mermaid
gantt
    title Phase 2: Auto-Generate Primary Keys
    dateFormat  YYYY-MM-DD
    section CodeGen
    Config for PK generation              :p2a, 2024-01-07, 1d
    Detect PK-less tables                 :p2b, after p2a, 2d
    Generate __mj_ID migration            :p2c, after p2b, 2d
    Set PrimaryKeySource=Generated        :p2d, after p2c, 1d
    section Testing
    Test with legacy database             :p2e, after p2d, 2d
```

**Deliverables:**
- Tables without PKs get `__mj_ID` automatically
- Full entity support for previously-skipped tables
- Configuration to enable/disable per-schema

### Phase 3: Soft Relationship Support

```mermaid
gantt
    title Phase 3: Soft Relationship Support
    dateFormat  YYYY-MM-DD
    section MJCore
    EntityFieldInfo enhancements          :p3a, 2024-01-14, 2d
    BaseEntity validation changes         :p3b, after p3a, 2d
    section GraphQL
    Null-tolerant resolution              :p3c, after p3b, 2d
    section UI
    Visual differentiation                :p3d, after p3c, 3d
    Manual marking UI                     :p3e, after p3d, 3d
```

**Deliverables:**
- Soft relationships functional across all layers
- UI shows relationship type visually
- Admin can manually mark soft relationships

### Phase 4: DBAutoDoc Integration

```mermaid
gantt
    title Phase 4: DBAutoDoc Integration
    dateFormat  YYYY-MM-DD
    section DBAutoDoc
    MJ export format design               :p4a, 2024-01-28, 2d
    Export implementation                 :p4b, after p4a, 3d
    Include discovery notes               :p4c, after p4b, 2d
    section UI
    Review workflow for discoveries       :p4d, after p4c, 3d
    Accept/reject UI                      :p4e, after p4d, 2d
```

**Deliverables:**
- DBAutoDoc generates MJ migration files
- Single file contains descriptions AND soft key metadata
- Admin UI for reviewing AI-discovered relationships

### Phase 5: Data Quality

```mermaid
gantt
    title Phase 5: Data Quality
    dateFormat  YYYY-MM-DD
    section Backend
    Orphan detection job                  :p5a, 2024-02-14, 3d
    Update OrphanCount in metadata        :p5b, after p5a, 2d
    section UI
    Quality indicators in forms           :p5c, after p5b, 2d
    Integrity dashboard                   :p5d, after p5c, 3d
```

**Deliverables:**
- Scheduled job checks soft relationship integrity
- UI shows orphan counts and quality indicators
- Dashboard for overall data quality

---

## End-to-End User Flow

```mermaid
sequenceDiagram
    participant User
    participant DB as Legacy Database
    participant CG as CodeGen
    participant DBA as DBAutoDoc
    participant MJ as MemberJunction
    participant UI as Explorer UI

    User->>DB: Import legacy data
    Note over DB: Tables have no PKs or FKs

    User->>CG: Run CodeGen
    CG->>DB: Add __mj_ID to PK-less tables
    CG->>MJ: Create entities (PrimaryKeySource='Generated')
    Note over MJ: Tables now accessible as entities!

    User->>DBA: Run DBAutoDoc analysis
    DBA->>DBA: AI analyzes relationships
    DBA->>MJ: Generate migration with soft keys
    Note over MJ: Relationships discoverable now

    User->>UI: Open entity browser
    UI->>User: See relationships (solid=hard, dashed=soft)

    User->>UI: Review AI-discovered relationships
    UI->>User: Show confidence, evidence, reasoning
    User->>MJ: Accept/reject relationships

    User->>UI: Query data with relationships
    UI->>User: Soft relationships work in joins
    Note over UI: Orphans shown with warning, not error
```

---

## Success Criteria

| Metric | Target |
|--------|--------|
| PK-less tables supported | 100% (with `__mj_ID`) |
| Soft relationships functional | All layers |
| DBAutoDoc integration | Single migration file output |
| AI discovery accuracy | >90% precision with notes |
| User can mark relationships | Admin UI complete |
| Orphan visibility | Count + percentage in UI |

---

## Risks and Mitigations

| Risk | Mitigation |
|------|------------|
| Schema modification rejected | Make `__mj_ID` generation opt-in per schema |
| Soft relationship confusion | Clear visual differentiation + tooltips |
| Orphan data quality issues | Proactive tracking + warnings, not errors |
| DBAutoDoc false positives | Human review workflow, confidence thresholds |
| Performance with large tables | Batch orphan checks, background jobs |

---

## Open Questions

1. **Orphan Handling Strategy**: When saving a record with a soft FK pointing to non-existent target:
   - Option A: Warn and allow save (current proposal)
   - Option B: Configurable per-relationship
   - Option C: Block like hard FK (defeats purpose?)

2. **DBAutoDoc Triggering**: Should DBAutoDoc run automatically on new tables or always manual?

3. **Confidence Thresholds**: What confidence level should auto-accept vs. require review?
   - Proposed: >0.95 auto-accept, >0.70 include for review, <0.70 skip

4. **UI for Polymorphic**: How to visualize polymorphic soft keys in relationship diagrams?

---

## Appendix: Terminology

| Term | Definition |
|------|------------|
| **Hard Key** | Foreign key with database constraint enforcing referential integrity |
| **Soft Key** | Relationship defined in metadata only, no database constraint |
| **Polymorphic Key** | Soft key where target entity is determined by another column (EntityIDFieldName) |
| **Orphan** | Record with FK/soft key value that doesn't exist in target entity |
| **Generated PK** | Primary key column (`__mj_ID`) added by MJ to tables that lacked one |
| **Discovery Notes** | LLM reasoning and evidence for why a soft relationship is believed to exist |
