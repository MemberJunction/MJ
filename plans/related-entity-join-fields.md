# Related Entity Join Fields Enhancement

## Overview

This document describes the design for extending CodeGenLib's base view generation to allow any number of fields from related entities to be joined into a base view, not just the NameField.

## Problem Statement

Currently, when an EntityField has a foreign key relationship (`RelatedEntityID`), CodeGenLib automatically joins **only** the related entity's NameField into the base view. This is controlled by the `IncludeRelatedEntityNameFieldInBaseView` flag.

**Limitation**: Users cannot:
1. Include additional fields from related entities (e.g., Email, Status, Phone from a User FK)
2. Override the default NameField selection
3. Exclude the NameField while including other fields
4. Customize aliases for joined fields

## Solution Design

### New Column: `RelatedEntityJoinFields`

Add a nullable JSON column to the `EntityField` table that specifies which fields to join from the related entity.

### JSON Schema

```typescript
interface RelatedEntityJoinFieldConfig {
  /**
   * Controls how this config interacts with default NameField behavior.
   * - "extend": Include the default NameField PLUS the specified fields (default)
   * - "override": ONLY include the specified fields, ignore NameField
   * - "disable": Don't join ANY fields from this related entity
   */
  mode?: 'extend' | 'override' | 'disable';

  /**
   * Fields to join from the related entity.
   * Ignored when mode is 'disable'.
   */
  fields?: RelatedEntityJoinField[];
}

interface RelatedEntityJoinField {
  /**
   * Name of the field on the related entity to join.
   * Must be a valid field name on the related entity.
   */
  field: string;

  /**
   * Optional custom alias for the column in the view.
   * If not provided, auto-generated as: {StrippedFKName}{FieldName}
   * Example: UserID + Email -> UserEmail
   */
  alias?: string;
}
```

### Example Configurations

#### Extend Default (Add Fields)
```json
{
  "mode": "extend",
  "fields": [
    { "field": "Email" },
    { "field": "Phone", "alias": "UserPhone" }
  ]
}
```
Result: Joins NameField (default) + Email + Phone

#### Override Default (Replace NameField)
```json
{
  "mode": "override",
  "fields": [
    { "field": "Email", "alias": "UserEmail" },
    { "field": "FirstName" },
    { "field": "LastName" }
  ]
}
```
Result: Joins ONLY Email, FirstName, LastName (no NameField)

#### Disable All Joins
```json
{
  "mode": "disable"
}
```
Result: No fields joined from this related entity (even if `IncludeRelatedEntityNameFieldInBaseView` is true)

#### Simple Extend (Shorthand)
```json
{
  "fields": [
    { "field": "Status" }
  ]
}
```
Result: Joins NameField (default) + Status (mode defaults to "extend")

---

## Database Migration

### Migration File
`migrations/v2/V202601270001__v2.x_Add_RelatedEntityJoinFields_Column.sql`

```sql
/*
  Migration: Add RelatedEntityJoinFields column to EntityField table

  Purpose: Enables configuration of additional fields to join from related entities
  into base views, extending or overriding the default NameField behavior.

  JSON Schema:
  {
    "mode": "extend" | "override" | "disable",
    "fields": [
      { "field": "FieldName", "alias": "OptionalAlias" }
    ]
  }
*/

-- Add the new column
ALTER TABLE ${flyway:defaultSchema}.EntityField
ADD RelatedEntityJoinFields NVARCHAR(MAX) NULL;
GO

-- Add extended property documentation
EXEC sp_addextendedproperty
    @name = N'MS_Description',
    @value = N'JSON configuration for additional fields to join from the related entity into this entity''s base view. Supports modes: extend (add to NameField), override (replace NameField), disable (no joins). Schema: { mode?: string, fields?: [{ field: string, alias?: string }] }',
    @level0type = N'SCHEMA', @level0name = ${flyway:defaultSchema},
    @level1type = N'TABLE',  @level1name = N'EntityField',
    @level2type = N'COLUMN', @level2name = N'RelatedEntityJoinFields';
GO
```

---

## CodeGenLib Changes

### Files to Modify

1. **`packages/CodeGenLib/src/Database/sql_codegen.ts`**
   - `generateBaseViewRelatedFieldsString()` - Add logic to parse JSON and include additional fields
   - `generateBaseViewJoins()` - Ensure joins are created for entities with additional fields

2. **`packages/MJCore/src/generic/entityInfo.ts`**
   - Add `RelatedEntityJoinFields` property to `EntityFieldInfo` class
   - Add TypeScript interface for the JSON schema

3. **`packages/MJCoreEntities/src/generated/entity_subclasses.ts`**
   - Will be auto-generated by CodeGen after migration

### Implementation Logic

#### Updated `generateBaseViewRelatedFieldsString()` Pseudocode

```typescript
generateBaseViewRelatedFieldsString(entity: EntityInfo, entityFields: EntityFieldInfo[]): string {
    let output = '';

    // Get all FK fields that might contribute joined columns
    const fkFields = entityFields.filter(f => f.RelatedEntityID);

    for (const ef of fkFields) {
        const config = this.parseRelatedEntityJoinFields(ef.RelatedEntityJoinFields);

        // Handle disable mode - skip entirely
        if (config.mode === 'disable') {
            continue;
        }

        const fieldsToJoin: Array<{field: string, alias: string}> = [];

        // Handle default NameField (unless override mode)
        if (config.mode !== 'override' && ef.IncludeRelatedEntityNameFieldInBaseView) {
            const { nameField } = this.getIsNameFieldForSingleEntity(ef.RelatedEntity);
            if (nameField) {
                const defaultAlias = this.generateDefaultAlias(ef.Name, nameField);
                fieldsToJoin.push({ field: nameField, alias: defaultAlias });
            }
        }

        // Add configured additional fields
        if (config.fields) {
            for (const fieldConfig of config.fields) {
                const alias = fieldConfig.alias ||
                              this.generateDefaultAlias(ef.Name, fieldConfig.field);

                // Validate field exists on related entity
                if (!this.validateFieldExists(ef.RelatedEntity, fieldConfig.field)) {
                    LogError(`RelatedEntityJoinFields: Field '${fieldConfig.field}' not found on entity '${ef.RelatedEntity}'`);
                    continue;
                }

                // Check for duplicate aliases
                if (this.hasAliasCollision(entity, alias, fieldsToJoin)) {
                    LogError(`RelatedEntityJoinFields: Alias '${alias}' would collide with existing field`);
                    continue;
                }

                fieldsToJoin.push({ field: fieldConfig.field, alias });
            }
        }

        // Generate SQL for each field
        for (const { field, alias } of fieldsToJoin) {
            output += `${ef._RelatedEntityTableAlias}.[${field}] AS [${alias}],\n`;
        }
    }

    return output;
}

generateDefaultAlias(fkFieldName: string, relatedFieldName: string): string {
    // Strip 'ID' suffix from FK field name
    const baseName = this.stripID(fkFieldName);

    // If the related field is the NameField and matches existing pattern, use simple alias
    // Otherwise, combine: UserID + Email -> UserEmail
    return baseName + relatedFieldName;
}
```

#### Validation Requirements

1. **Field Existence**: Verify each configured field exists on the related entity
2. **Alias Uniqueness**: Ensure no alias collides with:
   - Existing real fields on the entity
   - Other joined field aliases
   - System fields (__mj_CreatedAt, etc.)
3. **Virtual Field Handling**: If a configured field is virtual, use BaseView instead of BaseTable for the join
4. **Circular Reference Protection**: Handle cases where additional fields themselves have FK relationships

---

## EntityInfo Class Updates

### New Interface in `entityInfo.ts`

```typescript
export interface RelatedEntityJoinFieldConfig {
    mode?: 'extend' | 'override' | 'disable';
    fields?: RelatedEntityJoinField[];
}

export interface RelatedEntityJoinField {
    field: string;
    alias?: string;
}
```

### New Property on EntityFieldInfo

```typescript
/**
 * JSON configuration for additional fields to join from the related entity.
 * Parsed from the RelatedEntityJoinFields column.
 */
get RelatedEntityJoinFieldsConfig(): RelatedEntityJoinFieldConfig | null {
    if (!this.RelatedEntityJoinFields) return null;
    try {
        return JSON.parse(this.RelatedEntityJoinFields);
    } catch {
        return null;
    }
}
```

---

## Interaction with Existing Fields

### `IncludeRelatedEntityNameFieldInBaseView`

This existing boolean flag continues to work as before, but is now superseded by `RelatedEntityJoinFields` when present:

| RelatedEntityJoinFields | IncludeRelatedEntityNameFieldInBaseView | Result |
|------------------------|----------------------------------------|--------|
| null | true | NameField joined (current behavior) |
| null | false | No fields joined (current behavior) |
| { mode: "extend", fields: [...] } | true | NameField + configured fields |
| { mode: "extend", fields: [...] } | false | Only configured fields (extend has nothing to extend) |
| { mode: "override", fields: [...] } | (ignored) | Only configured fields |
| { mode: "disable" } | (ignored) | No fields joined |

### `_RelatedEntityNameFieldMap`

This internal property currently stores the alias for the NameField. With multiple fields, we'll need a collection:

```typescript
// New property to store all joined field mappings
_RelatedEntityJoinFieldMappings: Array<{
    sourceField: string;
    alias: string;
    isVirtual: boolean;
}>;
```

---

## Example Generated SQL

### Before (Current)
```sql
SELECT
    o.*,
    User_CreatedByUserID.[Name] AS [CreatedByUser],
    User_UpdatedByUserID.[Name] AS [UpdatedByUser]
FROM
    [dbo].[Order] AS o
LEFT OUTER JOIN [dbo].[User] AS User_CreatedByUserID
    ON o.[CreatedByUserID] = User_CreatedByUserID.[ID]
LEFT OUTER JOIN [dbo].[User] AS User_UpdatedByUserID
    ON o.[UpdatedByUserID] = User_UpdatedByUserID.[ID]
```

### After (With Additional Fields)

Configuration on `CreatedByUserID`:
```json
{
  "mode": "extend",
  "fields": [
    { "field": "Email" },
    { "field": "Department", "alias": "CreatedByDepartment" }
  ]
}
```

Generated SQL:
```sql
SELECT
    o.*,
    User_CreatedByUserID.[Name] AS [CreatedByUser],
    User_CreatedByUserID.[Email] AS [CreatedByUserEmail],
    User_CreatedByUserID.[Department] AS [CreatedByDepartment],
    User_UpdatedByUserID.[Name] AS [UpdatedByUser]
FROM
    [dbo].[Order] AS o
LEFT OUTER JOIN [dbo].[User] AS User_CreatedByUserID
    ON o.[CreatedByUserID] = User_CreatedByUserID.[ID]
LEFT OUTER JOIN [dbo].[User] AS User_UpdatedByUserID
    ON o.[UpdatedByUserID] = User_UpdatedByUserID.[ID]
```

---

## Testing Checklist

- [ ] Migration runs successfully
- [ ] CodeGen regenerates entity classes with new property
- [ ] Null/empty `RelatedEntityJoinFields` maintains current behavior
- [ ] Mode "extend" adds fields while keeping NameField
- [ ] Mode "override" replaces NameField with specified fields
- [ ] Mode "disable" prevents all field joins
- [ ] Custom aliases are applied correctly
- [ ] Auto-generated aliases follow `{FKBase}{FieldName}` pattern
- [ ] Invalid field names log errors and are skipped
- [ ] Alias collisions are detected and reported
- [ ] Virtual fields on related entity trigger BaseView join
- [ ] Multiple FK fields to same entity work correctly with different configs

---

## Future Considerations

1. **UI for Configuration**: Admin UI to configure these settings without writing JSON
2. **Metadata Sync Support**: Ensure mj-sync can push/pull this configuration
3. **Performance**: Many additional joins could impact view performance - consider guidance/limits
4. **Cascading Virtual Fields**: If an additional field is itself virtual and depends on another related entity, ensure the join chain is correct
