import { BaseAgent } from './base-agent';
import { UserInfo, Metadata, RunView, LogError, LogStatus } from '@memberjunction/core';
import { MJAIAgentNoteEntity, MJAIAgentExampleEntity } from '@memberjunction/core-entities';
import { ExecuteAgentParams, AIAgentEntityExtended, AgentConfiguration, BaseAgentNextStep } from '@memberjunction/ai-core-plus';
import { AIEngine } from '@memberjunction/aiengine';

/**
 * Result of a cleanup operation
 */
interface CleanupResult {
    notesArchived: number;
    examplesArchived: number;
    notesExpired: number;
    examplesExpired: number;
    errors: string[];
}

/**
 * Memory Cleanup Agent - archives stale notes and examples based on retention policies.
 *
 * This agent runs on a daily schedule and:
 * 1. Archives notes not accessed within NoteRetentionDays (per agent config, default 90)
 * 2. Archives examples with SuccessScore < 50 after ExampleRetentionDays (default 180)
 * 3. Archives any items past their ExpiresAt timestamp
 *
 * Only processes auto-generated items (IsAutoGenerated = true) to preserve manual entries.
 */
export class MemoryCleanupAgent extends BaseAgent {
    private readonly DEFAULT_NOTE_RETENTION_DAYS = 90;
    private readonly DEFAULT_EXAMPLE_RETENTION_DAYS = 180;
    private readonly LOW_SUCCESS_SCORE_THRESHOLD = 50;

    /**
     * Main entry point for the cleanup agent
     */
    protected override async executeAgentInternal<P = any>(
        params: ExecuteAgentParams,
        config: AgentConfiguration
    ): Promise<{finalStep: BaseAgentNextStep<P>, stepCount: number}> {
        LogStatus('MemoryCleanupAgent: Starting cleanup process');

        const contextUser = params.contextUser!;
        const result: CleanupResult = {
            notesArchived: 0,
            examplesArchived: 0,
            notesExpired: 0,
            examplesExpired: 0,
            errors: []
        };

        try {
            // Process expired items first (these have explicit ExpiresAt timestamps)
            await this.archiveExpiredItems(result, contextUser);

            // Then process stale items based on retention policies
            await this.archiveStaleItems(result, contextUser);

            const summary = this.buildSummary(result);
            LogStatus(`MemoryCleanupAgent: Cleanup completed - ${summary}`);

            const finalStep: BaseAgentNextStep<P> = {
                terminate: true,
                step: 'Success',
                message: summary
            };
            return { finalStep, stepCount: 1 };
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            LogError('MemoryCleanupAgent: Cleanup failed', undefined, error);

            const finalStep: BaseAgentNextStep<P> = {
                terminate: true,
                step: 'Failed',
                message: `Cleanup failed: ${errorMessage}`
            };
            return { finalStep, stepCount: 1 };
        }
    }

    /**
     * Archive items that have passed their ExpiresAt timestamp
     */
    private async archiveExpiredItems(result: CleanupResult, contextUser: UserInfo): Promise<void> {
        const now = new Date().toISOString();

        // Archive expired notes
        const expiredNotes = await this.queryExpiredNotes(now, contextUser);
        for (const note of expiredNotes) {
            const archived = await this.archiveNote(note, 'Expired', contextUser);
            if (archived) {
                result.notesExpired++;
            } else {
                result.errors.push(`Failed to archive expired note ${note.ID}`);
            }
        }

        // Archive expired examples
        const expiredExamples = await this.queryExpiredExamples(now, contextUser);
        for (const example of expiredExamples) {
            const archived = await this.archiveExample(example, 'Expired', contextUser);
            if (archived) {
                result.examplesExpired++;
            } else {
                result.errors.push(`Failed to archive expired example ${example.ID}`);
            }
        }
    }

    /**
     * Archive items based on per-agent retention policies
     */
    private async archiveStaleItems(result: CleanupResult, contextUser: UserInfo): Promise<void> {
        // Get all agents with auto-archive enabled
        const agents = AIEngine.Instance.Agents.filter(a =>
            a.Status === 'Active' &&
            this.getAutoArchiveEnabled(a)
        );

        for (const agent of agents) {
            const noteRetentionDays = this.getNoteRetentionDays(agent);
            const exampleRetentionDays = this.getExampleRetentionDays(agent);

            // Archive stale notes for this agent
            const staleNotes = await this.queryStaleNotes(agent.ID, noteRetentionDays, contextUser);
            for (const note of staleNotes) {
                const archived = await this.archiveNote(note, `Stale (${noteRetentionDays} days)`, contextUser);
                if (archived) {
                    result.notesArchived++;
                } else {
                    result.errors.push(`Failed to archive stale note ${note.ID}`);
                }
            }

            // Archive stale low-scoring examples for this agent
            const staleExamples = await this.queryStaleExamples(agent.ID, exampleRetentionDays, contextUser);
            for (const example of staleExamples) {
                const archived = await this.archiveExample(example, `Stale low-score (${exampleRetentionDays} days)`, contextUser);
                if (archived) {
                    result.examplesArchived++;
                } else {
                    result.errors.push(`Failed to archive stale example ${example.ID}`);
                }
            }
        }
    }

    /**
     * Query for notes past their ExpiresAt timestamp
     */
    private async queryExpiredNotes(now: string, contextUser: UserInfo): Promise<MJAIAgentNoteEntity[]> {
        const rv = new RunView();
        const result = await rv.RunView<MJAIAgentNoteEntity>({
            EntityName: 'MJ: AI Agent Notes',
            ExtraFilter: `Status = 'Active' AND ExpiresAt IS NOT NULL AND ExpiresAt < '${now}'`,
            MaxRows: 1000,
            ResultType: 'entity_object'
        }, contextUser);

        return result.Success ? result.Results : [];
    }

    /**
     * Query for examples past their ExpiresAt timestamp
     */
    private async queryExpiredExamples(now: string, contextUser: UserInfo): Promise<MJAIAgentExampleEntity[]> {
        const rv = new RunView();
        const result = await rv.RunView<MJAIAgentExampleEntity>({
            EntityName: 'AI Agent Examples',
            ExtraFilter: `Status = 'Active' AND ExpiresAt IS NOT NULL AND ExpiresAt < '${now}'`,
            MaxRows: 1000,
            ResultType: 'entity_object'
        }, contextUser);

        return result.Success ? result.Results : [];
    }

    /**
     * Query for stale auto-generated notes (not accessed within retention period)
     */
    private async queryStaleNotes(
        agentId: string,
        retentionDays: number,
        contextUser: UserInfo
    ): Promise<MJAIAgentNoteEntity[]> {
        const cutoffDate = this.getCutoffDate(retentionDays);
        const rv = new RunView();

        // Query notes that are:
        // - For this agent
        // - Auto-generated (don't archive manual notes)
        // - Active status
        // - Last accessed before cutoff (or never accessed and created before cutoff)
        const result = await rv.RunView<MJAIAgentNoteEntity>({
            EntityName: 'MJ: AI Agent Notes',
            ExtraFilter: `
                AgentID = '${agentId}'
                AND IsAutoGenerated = 1
                AND Status = 'Active'
                AND (
                    (LastAccessedAt IS NOT NULL AND LastAccessedAt < '${cutoffDate}')
                    OR (LastAccessedAt IS NULL AND __mj_CreatedAt < '${cutoffDate}')
                )
            `,
            MaxRows: 500,
            ResultType: 'entity_object'
        }, contextUser);

        return result.Success ? result.Results : [];
    }

    /**
     * Query for stale auto-generated examples with low success scores
     */
    private async queryStaleExamples(
        agentId: string,
        retentionDays: number,
        contextUser: UserInfo
    ): Promise<MJAIAgentExampleEntity[]> {
        const cutoffDate = this.getCutoffDate(retentionDays);
        const rv = new RunView();

        // Query examples that are:
        // - For this agent
        // - Auto-generated
        // - Active status
        // - Low success score (< 50)
        // - Last accessed before cutoff (or never accessed and created before cutoff)
        const result = await rv.RunView<MJAIAgentExampleEntity>({
            EntityName: 'AI Agent Examples',
            ExtraFilter: `
                AgentID = '${agentId}'
                AND IsAutoGenerated = 1
                AND Status = 'Active'
                AND SuccessScore < ${this.LOW_SUCCESS_SCORE_THRESHOLD}
                AND (
                    (LastAccessedAt IS NOT NULL AND LastAccessedAt < '${cutoffDate}')
                    OR (LastAccessedAt IS NULL AND __mj_CreatedAt < '${cutoffDate}')
                )
            `,
            MaxRows: 500,
            ResultType: 'entity_object'
        }, contextUser);

        return result.Success ? result.Results : [];
    }

    /**
     * Archive a note by setting its status to 'Archived'
     */
    private async archiveNote(
        note: MJAIAgentNoteEntity,
        reason: string,
        contextUser: UserInfo
    ): Promise<boolean> {
        try {
            note.Status = 'Archived' as 'Active' | 'Pending' | 'Revoked'; // TypeScript doesn't know about new status yet
            note.Comments = `${note.Comments ? note.Comments + '\n' : ''}[Archived by Memory Cleanup Agent: ${reason} on ${new Date().toISOString()}]`;

            const saved = await note.Save();
            if (saved) {
                LogStatus(`MemoryCleanupAgent: Archived note ${note.ID} - ${reason}`);
            }
            return saved;
        } catch (error) {
            LogError(`MemoryCleanupAgent: Failed to archive note ${note.ID}`, undefined, error);
            return false;
        }
    }

    /**
     * Archive an example by setting its status to 'Archived'
     */
    private async archiveExample(
        example: MJAIAgentExampleEntity,
        reason: string,
        contextUser: UserInfo
    ): Promise<boolean> {
        try {
            example.Status = 'Archived' as 'Active' | 'Pending' | 'Revoked';
            example.Comments = `${example.Comments ? example.Comments + '\n' : ''}[Archived by Memory Cleanup Agent: ${reason} on ${new Date().toISOString()}]`;

            const saved = await example.Save();
            if (saved) {
                LogStatus(`MemoryCleanupAgent: Archived example ${example.ID} - ${reason}`);
            }
            return saved;
        } catch (error) {
            LogError(`MemoryCleanupAgent: Failed to archive example ${example.ID}`, undefined, error);
            return false;
        }
    }

    /**
     * Get note retention days for an agent (uses agent config or default)
     */
    private getNoteRetentionDays(agent: AIAgentEntityExtended): number {
        // Check if agent has NoteRetentionDays property using GetAll() for plain object access
        const agentData = agent.GetAll();
        const retention = agentData['NoteRetentionDays'];
        if (typeof retention === 'number' && retention > 0) {
            return retention;
        }
        return this.DEFAULT_NOTE_RETENTION_DAYS;
    }

    /**
     * Get example retention days for an agent (uses agent config or default)
     */
    private getExampleRetentionDays(agent: AIAgentEntityExtended): number {
        const agentData = agent.GetAll();
        const retention = agentData['ExampleRetentionDays'];
        if (typeof retention === 'number' && retention > 0) {
            return retention;
        }
        return this.DEFAULT_EXAMPLE_RETENTION_DAYS;
    }

    /**
     * Check if auto-archive is enabled for an agent
     */
    private getAutoArchiveEnabled(agent: AIAgentEntityExtended): boolean {
        const agentData = agent.GetAll();
        const enabled = agentData['AutoArchiveEnabled'];
        // Default to true if not explicitly set to false
        return enabled !== false;
    }

    /**
     * Calculate cutoff date (now - retentionDays)
     */
    private getCutoffDate(retentionDays: number): string {
        const cutoff = new Date();
        cutoff.setDate(cutoff.getDate() - retentionDays);
        return cutoff.toISOString();
    }

    /**
     * Build summary message for cleanup results
     */
    private buildSummary(result: CleanupResult): string {
        const parts: string[] = [];

        if (result.notesArchived > 0) {
            parts.push(`${result.notesArchived} stale notes archived`);
        }
        if (result.examplesArchived > 0) {
            parts.push(`${result.examplesArchived} stale examples archived`);
        }
        if (result.notesExpired > 0) {
            parts.push(`${result.notesExpired} expired notes archived`);
        }
        if (result.examplesExpired > 0) {
            parts.push(`${result.examplesExpired} expired examples archived`);
        }

        if (parts.length === 0) {
            parts.push('No items needed archiving');
        }

        if (result.errors.length > 0) {
            parts.push(`${result.errors.length} errors encountered`);
        }

        return parts.join(', ');
    }
}
