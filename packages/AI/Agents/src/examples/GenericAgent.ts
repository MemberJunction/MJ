import { RegisterClass } from '@memberjunction/global';
import { BaseAgent, AgentExecutionContext, AgentExecutionResult, IAgentFactory } from '../base-agent';
import { AIAgentEntityExtended } from '@memberjunction/core-entities';
import { UserInfo } from '@memberjunction/core';

/**
 * Generic agent implementation that demonstrates the standard agent pattern.
 * 
 * This agent uses the default BaseAgent behavior, which automatically:
 * 1. Executes associated prompts in sequence
 * 2. Coordinates with child agents if they exist  
 * 3. Aggregates results from both prompts and child agents
 * 
 * This serves as a good fallback for agents that don't need specialized implementations.
 * 
 * Register this agent for any agent name that doesn't have a more specific implementation:
 * ```typescript
 * @RegisterClass(BaseAgent, "Generic")
 * export class GenericAgent extends BaseAgent {
 *   // Uses default BaseAgent behavior - no custom implementation needed
 * }
 * ```
 */
@RegisterClass(BaseAgent, "Generic")
export class GenericAgent extends BaseAgent {
  constructor(agentEntity: AIAgentEntityExtended, agentFactory: IAgentFactory, contextUser?: UserInfo) {
    super(agentEntity, agentFactory, contextUser);
  }

  // This agent uses the default executeCore implementation from BaseAgent
  // No custom logic needed - it will automatically execute prompts and child agents
}

/**
 * Example of a specialized agent that extends the generic functionality.
 * 
 * This shows how developers can create task-specific agents while still
 * leveraging the base infrastructure.
 */
@RegisterClass(BaseAgent, "CodeGenerator")
export class CodeGeneratorAgent extends BaseAgent {
  constructor(agentEntity: AIAgentEntityExtended, agentFactory: IAgentFactory, contextUser?: UserInfo) {
    super(agentEntity, agentFactory, contextUser);
  }

  protected async executeCore(context: AgentExecutionContext): Promise<AgentExecutionResult> {
    try {
      // Add code generation specific context data
      const enhancedContext = {
        ...context,
        data: {
          ...context.data,
          timestamp: new Date().toISOString(),
          agentType: 'CodeGenerator',
          // Add any code generation specific data here
        }
      };

      // Execute prompts with enhanced context
      const promptResult = await this.executePromptSequence(enhancedContext);

      // Post-process results for code generation
      if (promptResult.success && promptResult.result) {
        // Could add code validation, formatting, etc. here
        console.log(`Code generated by agent '${this.Name}': ${JSON.stringify(promptResult.result).substring(0, 100)}...`);
      }

      return {
        ...promptResult,
        metadata: {
          ...promptResult.metadata,
          agentType: 'CodeGenerator',
          codeGenerated: promptResult.success,
          resultLength: promptResult.result ? JSON.stringify(promptResult.result).length : 0
        }
      };

    } catch (error) {
      return {
        success: false,
        errorMessage: error.message,
        metadata: {
          agentType: 'CodeGenerator',
          errorStep: 'executeCore'
        }
      };
    }
  }
}

export function LoadExampleAgents() {
  // This function ensures the classes aren't tree-shaken
  // The @RegisterClass decorators will automatically register the agents
}