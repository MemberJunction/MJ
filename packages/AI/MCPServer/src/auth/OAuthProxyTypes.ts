/**
 * @fileoverview OAuth Proxy Authorization Server Types
 *
 * Type definitions for the OAuth proxy that enables dynamic client registration
 * and proxies OAuth flows to upstream providers (Azure AD, Auth0, etc.).
 *
 * This allows MCP clients like Claude Code to use OAuth without requiring
 * manual client registration in Azure AD.
 *
 * @module @memberjunction/ai-mcp-server/auth/OAuthProxyTypes
 */

/**
 * RFC 7591 Dynamic Client Registration Request
 * @see https://datatracker.ietf.org/doc/html/rfc7591#section-2
 */
export interface ClientRegistrationRequest {
  /** Array of redirect URIs for the client */
  redirect_uris: string[];
  /** Human-readable name of the client */
  client_name?: string;
  /** URL of the client's home page */
  client_uri?: string;
  /** URL of the client's logo */
  logo_uri?: string;
  /** Array of OAuth grant types the client will use */
  grant_types?: string[];
  /** Array of OAuth response types the client will use */
  response_types?: string[];
  /** Token endpoint authentication method */
  token_endpoint_auth_method?: 'none' | 'client_secret_post' | 'client_secret_basic';
  /** Array of scopes the client will request */
  scope?: string;
  /** Software statement (JWT) */
  software_statement?: string;
  /** Software ID */
  software_id?: string;
  /** Software version */
  software_version?: string;
}

/**
 * RFC 7591 Dynamic Client Registration Response
 * @see https://datatracker.ietf.org/doc/html/rfc7591#section-3.2.1
 */
export interface ClientRegistrationResponse {
  /** Unique client identifier */
  client_id: string;
  /** Client secret (for confidential clients) */
  client_secret?: string;
  /** Timestamp when client_id was issued */
  client_id_issued_at?: number;
  /** Timestamp when client_secret expires (0 = never) */
  client_secret_expires_at?: number;
  /** All fields from the registration request are echoed back */
  redirect_uris: string[];
  client_name?: string;
  client_uri?: string;
  logo_uri?: string;
  grant_types: string[];
  response_types: string[];
  token_endpoint_auth_method: string;
  scope?: string;
}

/**
 * Registered client information stored in the registry
 */
export interface RegisteredClient {
  /** Unique client identifier */
  clientId: string;
  /** Client secret (for confidential clients, hashed) */
  clientSecretHash?: string;
  /** Plain client secret (only returned once at registration) */
  clientSecret?: string;
  /** Timestamp when client was registered */
  registeredAt: number;
  /** Timestamp when client_secret expires (0 = never) */
  secretExpiresAt: number;
  /** Array of allowed redirect URIs */
  redirectUris: string[];
  /** Human-readable name */
  clientName?: string;
  /** Home page URL */
  clientUri?: string;
  /** Logo URL */
  logoUri?: string;
  /** Allowed grant types */
  grantTypes: string[];
  /** Allowed response types */
  responseTypes: string[];
  /** Token endpoint auth method */
  tokenEndpointAuthMethod: string;
  /** Requested scopes */
  scope?: string;
}

/**
 * OAuth Authorization Server Metadata per RFC 8414
 * @see https://datatracker.ietf.org/doc/html/rfc8414
 */
export interface AuthorizationServerMetadata {
  /** Authorization server's issuer identifier (URL) */
  issuer: string;
  /** URL of the authorization endpoint */
  authorization_endpoint: string;
  /** URL of the token endpoint */
  token_endpoint: string;
  /** URL of the dynamic client registration endpoint */
  registration_endpoint?: string;
  /** URL of the JWKS endpoint */
  jwks_uri?: string;
  /** Array of supported response types */
  response_types_supported: string[];
  /** Array of supported grant types */
  grant_types_supported?: string[];
  /** Array of supported scopes */
  scopes_supported?: string[];
  /** Array of supported token endpoint auth methods */
  token_endpoint_auth_methods_supported?: string[];
  /** Array of supported PKCE code challenge methods */
  code_challenge_methods_supported?: string[];
  /** URL of the service documentation */
  service_documentation?: string;
}

/**
 * State stored during authorization flow
 */
export interface AuthorizationState {
  /** State parameter from the original request */
  originalState?: string;
  /** Client ID that initiated the flow */
  clientId: string;
  /** Redirect URI to send the user back to */
  redirectUri: string;
  /** PKCE code verifier (if provided) */
  codeVerifier?: string;
  /** PKCE code challenge (if provided) */
  codeChallenge?: string;
  /** PKCE code challenge method */
  codeChallengeMethod?: string;
  /** Requested scopes */
  scope?: string;
  /** Timestamp when this state was created */
  createdAt: number;
  /** Nonce for OpenID Connect */
  nonce?: string;
  /** PKCE code verifier for upstream provider (generated by proxy) */
  upstreamCodeVerifier?: string;
}

/**
 * Token request parameters
 */
export interface TokenRequest {
  /** Grant type (authorization_code, refresh_token) */
  grant_type: string;
  /** Authorization code (for authorization_code grant) */
  code?: string;
  /** Redirect URI (must match the one used in authorization) */
  redirect_uri?: string;
  /** Client ID */
  client_id?: string;
  /** Client secret (for confidential clients) */
  client_secret?: string;
  /** PKCE code verifier */
  code_verifier?: string;
  /** Refresh token (for refresh_token grant) */
  refresh_token?: string;
  /** Requested scopes (for refresh_token grant) */
  scope?: string;
}

/**
 * Token response
 */
export interface TokenResponse {
  /** Access token */
  access_token: string;
  /** Token type (usually "Bearer") */
  token_type: string;
  /** Seconds until access token expires */
  expires_in?: number;
  /** Refresh token */
  refresh_token?: string;
  /** Granted scopes */
  scope?: string;
  /** ID token (for OpenID Connect) */
  id_token?: string;
}

/**
 * Token error response per RFC 6749
 */
export interface TokenErrorResponse {
  /** Error code */
  error: string;
  /** Human-readable error description */
  error_description?: string;
  /** URI with more information about the error */
  error_uri?: string;
}

/**
 * Configuration for the OAuth proxy
 */
export interface OAuthProxyConfig {
  /** Base URL of the MCP Server (e.g., http://localhost:3100) */
  baseUrl: string;
  /** Upstream OAuth provider configuration */
  upstream: {
    /** Authorization endpoint of the upstream provider */
    authorizationEndpoint: string;
    /** Token endpoint of the upstream provider */
    tokenEndpoint: string;
    /** Client ID registered with the upstream provider */
    clientId: string;
    /** Client secret (if confidential client) */
    clientSecret?: string;
    /** Scopes to request from upstream */
    scopes: string[];
    /** Provider name (for audit logging) */
    providerName?: string;
  };
  /** Whether to enable dynamic client registration */
  enableDynamicRegistration: boolean;
  /** TTL for authorization states in milliseconds (default: 10 minutes) */
  stateTtlMs?: number;
  /**
   * JWT signing configuration for proxy-issued tokens.
   * If not provided, upstream tokens are passed through instead.
   */
  jwt?: {
    /** HS256 signing secret */
    signingSecret: string;
    /** Token expiration (e.g., '1h') */
    expiresIn: string;
    /** Issuer claim */
    issuer: string;
  };
  /**
   * Enable the consent screen for users to select scopes.
   * When enabled, users will see a UI to approve/deny scope requests.
   * When disabled, all available scopes are granted automatically.
   * @default false
   */
  enableConsentScreen?: boolean;
}

/**
 * Authorization code stored temporarily
 */
export interface StoredAuthorizationCode {
  /** The authorization code */
  code: string;
  /** Client ID that owns this code */
  clientId: string;
  /** Redirect URI used */
  redirectUri: string;
  /** Scopes granted */
  scope?: string;
  /** PKCE code challenge */
  codeChallenge?: string;
  /** PKCE code challenge method */
  codeChallengeMethod?: string;
  /** The actual tokens from upstream */
  upstreamTokens: TokenResponse;
  /** Timestamp when code was created */
  createdAt: number;
  /** Timestamp when code expires */
  expiresAt: number;
  /**
   * Validated user information (populated if JWT signing is enabled).
   * Used to issue proxy-signed JWTs at the token endpoint.
   */
  validatedUser?: {
    /** MemberJunction User ID */
    mjUserId: string;
    /** User email */
    email: string;
    /** Upstream provider name */
    upstreamProvider: string;
    /** Subject claim from upstream token */
    upstreamSub: string;
  };
}
