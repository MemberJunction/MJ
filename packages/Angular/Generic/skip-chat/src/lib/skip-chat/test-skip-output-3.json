{
  "componentType": "report",
  "title": "Simple Entity List",
  "userExplanation": "Displays a simple, no-frills list of all entities.",
  "componentName": "SimpleEntityList",
  "functionalRequirements": "## Entity Listing Requirements\n\nThe component must display a minimalistic UI that shows:\n1. A vertically scrolled list of all registered entities\n2. Each entity entry shall show: \n   - Official entity name\n   - Entity ID (system identifier)\n3. No sorting, filtering, or search functionality\n4. No interactive elements (no clickable items, buttons, etc)\n5. No styling beyond basic separation lines\n\nUser Experience Priorities:\n- Instant visibility of full entity list\n- Clear identification of entries\n- Predictable static layout\n- Accessibility compliant (ARIA requirements)\n- Loading indicator when data is pending\n\nImplementation Notes:\n- Entities should be retrieved in single data call\n- Display in natural alphabetical order\n- System must handle >10,000 entity scenarios\n- Maintain keyboard navigation accessibility",
  "dataRequirements": {
    "dynamic": {
      "entities": [
        {
          "entity": "Entities",
          "mode": "live",
          "callbacks": false,
          "fields": [
            {
              "name": "EntityId",
              "field": "ID"
            },
            {
              "name": "EntityName",
              "field": "Name"
            }
          ]
        }
      ],
      "cache": {
        "strategy": "none"
      }
    }
  },
  "technicalDesign": "## Technical Design: SimpleEntityList\n\n### Component Architecture\n- **Root Component:** `SimpleEntityList` manages high-level loading, fetch, state, and accessibility scaffolding.\n- **Child Components:**\n  - `EntityListRow`: Renders a single entity’s name and ID, non-interactive, accessible.\n  - `LoadingIndicator`: Shows visual accessibility-compliant loading (while data is pending).\n- **No interactivity/sorting/search:** Static display; visual separation only.\n\n### Data Access & Performance Strategy\n- **Data fetching:**\n  - Utilizes the provided dynamic data requirement, querying all entities (EntityId, EntityName) in a single request.\n  - The root component initiates this fetch on mount.\n- **Performance (large lists >10,000):**\n  - **Initial state management:** Data is loaded and the loading indicator is shown until fully retrieved.\n  - **Virtualization consideration:** Given the >10,000 entity expectation, list virtualization (e.g., windowing) is recommended to ensure React does not render the entire DOM tree at once, vastly improving performance and preventing browser UI jank.\n  - **Rendering order:** Entries are displayed in natural (case-insensitive) alphabetical order by EntityName after fetch.\n  - **Minimal DOM complexity:** Each child renders minimal markup—no interactive elements—further reducing reflow cost.\n\n### State Management\n- **State shape:**\n  - `isLoading: boolean` — true while data is loading, false after.\n  - `entities: Array<{EntityId: string, EntityName: string}>` — the full retrieved and sorted entity list.\n  - No interaction-related state required.\n\n### ARIA & Accessibility Compliance\n- **Role usage:**\n  - The list uses `role=\"list\"`.\n  - Each row uses `role=\"listitem\"` and is rendered as a semantic `<div>` or similar non-interactive container.\n- **Keyboard navigation:**\n  - Since the component is not interactive, keyboard navigation is limited to standard document navigation (Tab skips, but arrow keys do not need to be supported unless rows are focusable, which they are not per explicit requirements). However, all screen readers will be able to enumerate the list and its contents via ARIA roles.\n- **Loading indicator:**\n  - Uses `aria-busy=\"true\"` on the root node while loading.\n  - The loading indicator itself should have `role=\"status\"` and a screen-reader-friendly text node (e.g., \"Loading entities...\").\n- **Contrast & separation:**\n  - Visual separation between rows is achieved with simple border rules (e.g., 1px solid lines), ensuring clarity for all users without decorative styling.\n- **Labeling:**\n  - Each row clearly presents EntityName followed by EntityId, ensuring screen reader clarity.\n  - No actions/interactive controls, so no ARIA labeling for controls is necessary\n- **Tab order:**\n  - The only tab stop is the list container itself if made focusable for screen readers; rows are not focusable.\n\n### Error Handling\n- If data fetch fails, fallback messaging is shown to screen readers in place of the list, announced via `role=\"status\"` for accessibility.\n\n### Child Component Breakdown\n1. **EntityListRow**\n   - **Props:** `{ entity: { EntityId: string, EntityName: string } }`\n   - **Example usage:** `<EntityListRow entity={entity} />`\n   - **Does:** Renders a line with the entity’s name and ID, wrapped in a role=\"listitem\" block with an optional separator.\n   - **State:** No internal state beyond props.\n2. **LoadingIndicator**\n   - **Props:** `{}`\n   - **Example usage:** `<LoadingIndicator />`\n   - **Does:** Shows a progress bar or spinner with textual “Loading entities…” message for screen readers, `role=\"status\"`.\n   - **State:** Stateless.\n\n### Integration With Data Requirements\n- The component receives no initial static data; instead, it uses the provided dynamic mode to query the Entities collection, retrieving all EntityId and EntityName fields. Fetch is performed on mount.\n- Sorting happens client-side after fetch if sort is not guaranteed by the API, else sorted in the query.\n- No caching or search supported (per requirements).\n\n### Summary Table\n| Feature                 | Implementation Approach                    |\n|------------------------|--------------------------------------------|\n| >10,000 entities       | List virtualization, minimal markup         |\n| Accessibility & ARIA   | role=\"list\"/\"listitem\", aria-busy, status |\n| Keyboard navigation    | Standard flow (not tabbable rows)          |\n| Visual separation      | 1px solid separation lines, no extra style  |\n| Loading state          | isLoading, LoadingIndicator                 |\n| Error/Fallback         | Screenreader alert in place of list         |",
  "childComponents": [
    {
      "componentName": "EntityListRow",
      "description": "Displays a single entity’s name and ID in a visually separated row for large, static lists.",
      "exampleUsage": "<EntityListRow entity={{ EntityId: '123', EntityName: 'My Entity' }} />",
      "properties": [
        {
          "name": "entity",
          "type": "{ EntityId: string, EntityName: string }",
          "description": "The entity object to display, containing both the unique ID and the official entity name."
        }
      ],
      "functionalRequirements": "Displays a single entity row with the following:\n- EntityName (primary text)\n- EntityId (secondary text, e.g. in smaller font or on the same line)\n- Visual separation (border below or between rows)\n- Uses role=\"listitem\" for accessibility\n- No interactivity; row is static and not tabbable\n- Content order and layout accessible to screen readers\n- No internal state; all data is via props",
      "dataRequirements": {
        "mode": "static",
        "description": "Requires a single entity with EntityId and EntityName as props. Does not perform data fetching."
      },
      "technicalDesign": "Renders as a div (or li if in <ul>) with role=\"listitem\". Displays the entity name and ID clearly, separated by a simple layout. Visual line/border follows the row for readability. No internal state or event handling. Accessible labeling for screen readers is inherent to content order. Does not use any extra styling beyond separator and structure.",
      "statePath": "entities[n]",
      "componentCode": "function EntityListRow({ entity, styles, statePath, onEvent, userState, callbacks, utilities }) {\n  return (\n    <div\n      role=\"listitem\"\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        width: '100%',\n        padding: `${styles?.spacing?.sm} ${styles?.spacing?.md}`,\n        borderBottom: `1px solid ${styles?.colors?.border}`,\n        background: styles?.colors?.surface,\n        fontFamily: styles?.typography?.fontFamily,\n        minHeight: '44px'\n      }}\n    >\n      <span\n        style={{\n          fontSize: styles?.typography?.fontSize?.md,\n          color: styles?.colors?.text,\n          fontWeight: styles?.typography?.fontWeight?.medium || 500,\n          whiteSpace: 'nowrap',\n          overflow: 'hidden',\n          textOverflow: 'ellipsis',\n          flex: 1\n        }}\n        aria-label=\"Entity Name\"\n      >\n        {entity.EntityName}\n      </span>\n      <span\n        style={{\n          fontSize: styles?.typography?.fontSize?.sm,\n          color: styles?.colors?.textSecondary,\n          marginLeft: styles?.spacing?.md,\n          flexShrink: 0\n        }}\n        aria-label=\"Entity ID\"\n      >\n        {entity.EntityId}\n      </span>\n    </div>\n  );\n}\n"
    },
    {
      "componentName": "LoadingIndicator",
      "description": "Displays a screen-reader-accessible spinner or message when entity data is loading.",
      "exampleUsage": "<LoadingIndicator />",
      "functionalRequirements": "Shows a loading visual and an accessible status message (e.g., \"Loading entities...\") when data is loading. Uses role=\"status\" for screen readers. No interactivity or user input.",
      "dataRequirements": {
        "mode": "static",
        "description": "Displays only a loading message, does not consume external data."
      },
      "technicalDesign": "Renders a spinner or text element with role=\"status\" and an accessible label. Stateless. Visible only when isLoading is true in the parent component.",
      "statePath": "isLoading",
      "componentCode": "function LoadingIndicator({ styles, userState, statePath, onEvent }) {\n    // Stateless: visibility is controlled by parent via isLoading state\n    // Defensive for styles, but trust that is provided\n    return (\n        <div\n            aria-live=\"polite\"\n            role=\"status\"\n            style={{\n                display: 'flex',\n                flexDirection: 'column',\n                alignItems: 'center',\n                justifyContent: 'center',\n                padding: styles.spacing.xl,\n                width: '100%',\n                color: styles.colors.textSecondary,\n                fontSize: styles.typography.fontSize.lg,\n                background: styles.colors.surface,\n                minHeight: '120px',\n            }}\n        >\n            {/* Simple animated spinner using a CSS animation (no imports) */}\n            <span\n                style={{\n                    display: 'inline-block',\n                    width: '40px',\n                    height: '40px',\n                    marginBottom: styles.spacing.md,\n                    border: `4px solid ${styles.colors.borderLight || '#e0e0e0'}`,\n                    borderTop: `4px solid ${styles.colors.primary}`,\n                    borderRadius: '50%',\n                    animation: 'spin 1s linear infinite',\n                }}\n            />\n            <span style={{fontFamily: styles.typography.fontFamily}}>\n                Loading entities...\n            </span>\n            {/* Spinner animation keyframes in a <style> block */}\n            <style>{`\n                @keyframes spin {\n                  0% { transform: rotate(0deg); }\n                  100% { transform: rotate(360deg); }\n                }\n            `}</style>\n        </div>\n    );\n}\n"
    }
  ],
  "techExplanation": "The SimpleEntityList leverages React best practices for rendering large, static data sets as required. List virtualization is called out as a high-priority optimization to allow rendering of lists with tens of thousands of items without overwhelming the browser’s DOM. Accessibility is achieved by using ARIA roles and properties, ensuring that assistive technologies can interpret the static list. All state (loading and entity data) is held in the root, minimizing prop-drilling. EntityListRow is highly performant due to stateless, prop-driven rendering. LoadingIndicator is always present but conditionally rendered for accessibility compliance.",
  "componentCode": "function SimpleEntityList({ data, utilities, userState, callbacks, styles, components }) {\n  const { EntityListRow, LoadingIndicator } = components;\n  const [state, setState] = React.useState({\n    isLoading: true,\n    error: null,\n    entities: [],\n    ...userState\n  });\n\n  // Always update parent state when changed\n  const updateUserState = (updates) => {\n    const newState = { ...state, ...updates };\n    setState(newState);\n    if (callbacks && callbacks.UpdateUserState) {\n      callbacks.UpdateUserState(newState);\n    }\n  };\n\n  // Handle events (none expected, but compliance/forwarding for child pattern)\n  const handleComponentEvent = createStandardEventHandler(updateUserState, callbacks);\n\n  // Virtualization settings\n  const ROW_HEIGHT = 40; // px, simple estimate for separation and text\n  const OVERSCAN_COUNT = 10; // Render a few extra rows for smoother scroll\n  const listContainerRef = React.useRef(null);\n  const [scrollState, setScrollState] = React.useState({\n    scrollTop: 0,\n    containerHeight: 400 // default, will measure on mount\n  });\n\n  // Data fetch on mount only (dynamic mode)\n  React.useEffect(() => {\n    let isMounted = true;\n    updateUserState({ isLoading: true, error: null });\n    utilities.rv\n      .runView({\n        EntityName: 'Entities',\n        Fields: ['ID', 'Name'],\n        OrderBy: '',\n        // No filter, all entities\n        IgnoreMaxRows: true\n      })\n      .then((result) => {\n        if (!isMounted) return;\n        if (!result.Success) {\n          updateUserState({ isLoading: false, error: 'Failed to load entities', entities: [] });\n          return;\n        }\n        // Ensure case-insensitive/natural sort on EntityName; array guaranteed\n        let entities = result.Results ? result.Results.map((row) => ({\n          EntityId: row.ID,\n          EntityName: row.Name\n        })) : [];\n        entities.sort((a, b) =>\n          a.EntityName.localeCompare(b.EntityName, undefined, { sensitivity: 'base', numeric: true })\n        );\n        updateUserState({ isLoading: false, error: null, entities });\n      })\n      .catch(() => {\n        if (!isMounted) return;\n        updateUserState({ isLoading: false, error: 'Failed to load entities', entities: [] });\n      });\n    return () => {\n      isMounted = false;\n    };\n    // eslint-disable-next-line\n  }, []);\n\n  // Virtualization: track container dimensions & scroll\n  React.useEffect(() => {\n    const container = listContainerRef.current;\n    if (!container) return;\n    const updateDimensions = () => {\n      setScrollState((old) => ({ ...old, containerHeight: container.clientHeight }));\n    };\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, []);\n\n  // onScroll updates visible row range\n  const handleScroll = (e) => {\n    setScrollState((old) => ({ ...old, scrollTop: e.target.scrollTop }));\n  };\n\n  // Calculate rows to render (only if not loading/error)\n  const { entities, isLoading, error } = state;\n  const total = entities.length;\n  let firstRow = 0, lastRow = 0;\n  if (!isLoading && !error) {\n    const visibleCount = Math.ceil(scrollState.containerHeight / ROW_HEIGHT);\n    firstRow = Math.max(0, Math.floor(scrollState.scrollTop / ROW_HEIGHT) - OVERSCAN_COUNT);\n    lastRow = Math.min(\n      total,\n      Math.ceil((scrollState.scrollTop + scrollState.containerHeight) / ROW_HEIGHT) + OVERSCAN_COUNT\n    );\n  }\n  const visibleEntities = (!isLoading && !error)\n    ? entities.slice(firstRow, lastRow)\n    : [];\n\n  // Loading or Error state rendering\n  if (isLoading) {\n    return (\n      <div\n        role=\"list\"\n        aria-busy=\"true\"\n        style={{height: '100%', minHeight: 240, display: 'flex', alignItems: 'center', justifyContent: 'center'}}\n      >\n        <LoadingIndicator styles={styles} />\n      </div>\n    );\n  }\n  if (error) {\n    return (\n      <div\n        role=\"status\"\n        aria-live=\"polite\"\n        style={{padding: styles?.spacing?.xl || 32, textAlign: 'center', color: styles?.colors?.error || '#d32f2f'}}\n      >\n        {error}\n      </div>\n    );\n  }\n\n  return (\n    <div\n      ref={listContainerRef}\n      onScroll={handleScroll}\n      role=\"list\"\n      aria-busy=\"false\"\n      tabIndex={0}\n      style={{\n        height: '100%',\n        minHeight: 320,\n        maxHeight: '100%',\n        overflowY: 'auto',\n        background: styles?.colors?.background || '#fff',\n        outline: 'none',\n        WebkitOverflowScrolling: 'touch',\n        // minimal layout, slight left/right space\n        padding: styles?.spacing?.sm || 8\n      }}\n    >\n      {/* Spacer for scrolled out rows above (virtualization) */}\n      <div style={{ height: firstRow * ROW_HEIGHT }} aria-hidden=\"true\"></div>\n      {visibleEntities.map((entity, idx) => (\n        <EntityListRow\n          key={entity.EntityId}\n          entity={entity}\n          styles={styles}\n          onEvent={handleComponentEvent}\n          statePath={`entities[${firstRow + idx}]`}\n        />\n      ))}\n      {/* Spacer for rows below */}\n      <div style={{ height: (total - lastRow) * ROW_HEIGHT }} aria-hidden=\"true\"></div>\n    </div>\n  );\n}\n"
}