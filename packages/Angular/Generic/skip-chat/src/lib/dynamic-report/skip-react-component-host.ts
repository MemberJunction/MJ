import { SimpleChanges, EventEmitter, ElementRef } from '@angular/core';
import { SkipComponentCallbacks, SkipComponentStyles, SkipComponentUtilities } from '@memberjunction/skip-types';
import { LogError } from '@memberjunction/core';

/**
 * Configuration for a React component to be hosted in Angular
 */
export interface ReactComponentConfig {
  /** The generated component code that includes the createComponent function */
  componentCode: string;
  
  /** The HTML container element where the React component will be rendered */
  container: HTMLElement;
  
  /** Callbacks for component lifecycle events */
  callbacks?: SkipComponentCallbacks;
  
  /** Initial state for the component */
  initialState?: any;
  
  /** Utilities to pass to the component */
  utilities?: SkipComponentUtilities;
  
  /** Styles to pass to the component */
  styles?: SkipComponentStyles;
}

/**
 * Interface for component factory function that's generated by Skip
 */
export interface ComponentFactoryResult {
  component: any; // React component
  print?: () => void;
  refresh?: (data?: any) => void;
}

/**
 * Default styles that match the Skip design system
 */
const DEFAULT_STYLES: SkipComponentStyles = {
  colors: {
    primary: '#2196f3',
    primaryHover: '#1976d2',
    secondary: '#757575',
    success: '#4caf50',
    background: '#ffffff',
    surface: '#f8f9fa',
    text: '#333333',
    textSecondary: '#656565',
    border: '#e2e8f0',
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
  },
  typography: {
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    fontSize: {
      sm: '14px',
      md: '16px',
      lg: '18px',
      xl: '24px'
    },
  },
  borders: {
    radius: '4px',
    width: '1px'
  },
  overflow: 'auto'
};

/**
 * Host class for integrating Skip-generated React components into Angular applications.
 * This class handles the lifecycle management, state synchronization, and communication
 * between React components and their Angular host containers.
 */
export class SkipReactComponentHost {
  private componentResult: ComponentFactoryResult | null = null;
  private reactRoot: any = null;
  private componentContainer: HTMLElement | null = null;
  private destroyed = false;
  private currentState: any = {};

  // React and ReactDOM references (will be loaded dynamically)
  private React: any;
  private ReactDOM: any;

  constructor(private config: ReactComponentConfig) {
    this.loadReactLibraries();
  }

  /**
   * Load React and ReactDOM dynamically
   */
  private async loadReactLibraries(): Promise<void> {
    // Check if React is already loaded globally
    if ((window as any).React && (window as any).ReactDOM) {
      this.React = (window as any).React;
      this.ReactDOM = (window as any).ReactDOM;
      return;
    }

    // Otherwise, we need to load React dynamically
    // This is a simplified approach - in production, you might want to use a proper module loader
    try {
      // Try to use ES modules if available
      const [ReactModule, ReactDOMModule] = await Promise.all([
        import('react'),
        import('react-dom/client')
      ]);
      this.React = ReactModule;
      this.ReactDOM = ReactDOMModule;
    } catch (error) {
      // Fallback to assuming React is available globally
      if ((window as any).React && (window as any).ReactDOM) {
        this.React = (window as any).React;
        this.ReactDOM = (window as any).ReactDOM;
      } else {
        throw new Error('React and ReactDOM must be available either as ES modules or global variables');
      }
    }
  }

  /**
   * Initialize the React component
   */
  public async initialize(): Promise<void> {
    try {
      await this.loadReactLibraries();

      // Create utility functions
      const createStateUpdater = this.createStateUpdaterFunction();
      const createStandardEventHandler = this.createStandardEventHandlerFunction();
      
      // Create the style system globally available
      const styles = this.config.styles || this.createStyleSystem();
      (window as any).styles = styles;

      // Create the component factory function from the generated code
      const componentFactory = new Function(
        'React', 'ReactDOM', 'useState', 'useEffect', 'useCallback',
        'createStateUpdater', 'createStandardEventHandler',
        `${this.config.componentCode}; return createComponent;`
      )(
        this.React, 
        this.ReactDOM, 
        this.React.useState, 
        this.React.useEffect,
        this.React.useCallback,
        createStateUpdater,
        createStandardEventHandler
      );

      // Execute the factory to get the component object
      this.componentResult = componentFactory();

      // Create container if it doesn't exist
      if (!this.componentContainer) {
        this.componentContainer = document.createElement('div');
        this.componentContainer.className = 'react-component-container';
        this.componentContainer.style.width = '100%';
        this.componentContainer.style.height = '100%';
        this.config.container.appendChild(this.componentContainer);
      }

      // Store initial state
      this.currentState = this.config.initialState || {};
      
      // Render the component
      this.render();
    } catch (error) {
      LogError(error);
      if (this.config.callbacks?.NotifyEvent) {
        this.config.callbacks.NotifyEvent('error', error);
      }
    }
  }

  /**
   * Render or re-render the React component with new props
   */
  public render(): void {
    if (!this.componentResult || !this.componentResult.component || this.destroyed) {
      return;
    }

    const Component = this.componentResult.component;
    const componentProps = {
      data: this.currentState,
      utilities: this.config.utilities || {},
      userState: {},
      callbacks: this.createCallbacks(),
      styles: this.config.styles || this.createStyleSystem()
    };

    if (!this.reactRoot && this.componentContainer) {
      this.reactRoot = this.ReactDOM.createRoot(this.componentContainer);
    }

    if (this.reactRoot) {
      this.reactRoot.render(this.React.createElement(Component, componentProps));
    }
  }

  /**
   * Update the component state
   */
  public updateState(path: string, value: any): void {
    // Update the current state
    this.currentState = {
      ...this.currentState,
      [path]: value
    };
    
    // Re-render with new state
    this.render();
  }

  /**
   * Refresh the component with optional new data
   */
  public refresh(newData?: any): void {
    if (newData) {
      this.currentState = {
        ...this.currentState,
        ...newData
      };
    }
    
    if (this.componentResult && this.componentResult.refresh) {
      this.componentResult.refresh(this.currentState);
    } else {
      // Re-render the component if no refresh method is available
      this.render();
    }
  }

  /**
   * Print the component
   */
  public print(): void {
    if (this.componentResult && this.componentResult.print) {
      this.componentResult.print();
    } else {
      window.print();
    }
  }

  /**
   * Clean up resources
   */
  public destroy(): void {
    this.destroyed = true;
    if (this.reactRoot) {
      this.reactRoot.unmount();
      this.reactRoot = null;
    }
    if (this.componentContainer && this.componentContainer.parentNode) {
      this.componentContainer.parentNode.removeChild(this.componentContainer);
    }
    this.componentContainer = null;
    this.componentResult = null;
  }

  /**
   * Create the callbacks object to pass to the React component
   */
  private createCallbacks(): SkipComponentCallbacks {
    return this.config.callbacks || {
      RefreshData: () => {},
      OpenEntityRecord: () => {},
      UpdateUserState: () => {},
      NotifyEvent: () => {}
    };
  }

  /**
   * Create a unified style system for the component
   */
  private createStyleSystem(baseStyles?: Partial<SkipComponentStyles>): SkipComponentStyles {
    return {
      ...DEFAULT_STYLES,
      ...baseStyles
    };
  }

  /**
   * Create the state updater utility function for the React component
   */
  private createStateUpdaterFunction(): any {
    return function createStateUpdater(statePath: string) {
      return (updater: any) => {
        // This is simplified - in the full implementation, you'd handle nested paths
        if (typeof updater === 'function') {
          // Handle function updater
          console.log(`State update for ${statePath} with function updater`);
        } else {
          // Handle direct value update
          console.log(`State update for ${statePath}:`, updater);
        }
      };
    };
  }

  /**
   * Create the standard event handler utility function for the React component
   */
  private createStandardEventHandlerFunction(): any {
    const callbacks = this.config.callbacks;
    
    return function createStandardEventHandler(eventType: string, componentPath: string) {
      return (event: any, data?: any) => {
        console.log(`Event ${eventType} from ${componentPath}:`, data || event);
        
        // Route events to appropriate callbacks
        switch (eventType) {
          case 'navigation':
            if (callbacks?.OpenEntityRecord && data?.entity && data?.key) {
              callbacks.OpenEntityRecord(data.entity, data.key);
            }
            break;
          case 'refresh':
            if (callbacks?.RefreshData) {
              callbacks.RefreshData();
            }
            break;
          default:
            if (callbacks?.NotifyEvent) {
              callbacks.NotifyEvent(eventType, data || event);
            }
        }
      };
    };
  }
}