import { SimpleChanges, EventEmitter, ElementRef } from '@angular/core';
import { SkipComponentCallbacks, SkipComponentStyles, SkipComponentUtilities } from '@memberjunction/skip-types';
import { LogError } from '@memberjunction/core';

/**
 * CDN URLs for external dependencies
 * These can be configured via environment variables in the future
 */
const BABEL_STANDALONE_CDN_URL = 'https://unpkg.com/@babel/standalone@7/babel.min.js';
const REACT_CDN_URL = 'https://unpkg.com/react@18/umd/react.production.min.js';
const REACT_DOM_CDN_URL = 'https://unpkg.com/react-dom@18/umd/react-dom.production.min.js';

/**
 * Configuration for a React component to be hosted in Angular
 */
export interface ReactComponentConfig {
  /** The generated component code that includes the createComponent function */
  componentCode: string;
  
  /** The HTML container element where the React component will be rendered */
  container: HTMLElement;
  
  /** Data to pass to the component (e.g., entities, lists, etc.) */
  data?: any;
  
  /** Callbacks for component lifecycle events */
  callbacks?: SkipComponentCallbacks;
  
  /** Initial state for the component */
  initialState?: any;
  
  /** Utilities to pass to the component */
  utilities?: SkipComponentUtilities;
  
  /** Styles to pass to the component */
  styles?: SkipComponentStyles;
}

/**
 * Interface for component factory function that's generated by Skip
 */
export interface ComponentFactoryResult {
  component: any; // React component
  print?: () => void;
  refresh?: (data?: any) => void;
}

/**
 * Default styles that match the Skip design system
 */
const DEFAULT_STYLES: SkipComponentStyles = {
  colors: {
    primary: '#2196f3',
    primaryHover: '#1976d2',
    secondary: '#757575',
    success: '#4caf50',
    background: '#ffffff',
    surface: '#f8f9fa',
    text: '#333333',
    textSecondary: '#656565',
    border: '#e2e8f0',
  },
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
  },
  typography: {
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    fontSize: {
      sm: '14px',
      md: '16px',
      lg: '18px',
      xl: '24px'
    },
  },
  borders: {
    radius: '4px',
    width: '1px'
  },
  overflow: 'auto'
};

/**
 * Host class for integrating Skip-generated React components into Angular applications.
 * This class handles the lifecycle management, state synchronization, and communication
 * between React components and their Angular host containers.
 */
export class SkipReactComponentHost {
  private componentResult: ComponentFactoryResult | null = null;
  private reactRoot: any = null;
  private componentContainer: HTMLElement | null = null;
  private destroyed = false;
  private currentState: any = {};

  // React and ReactDOM references (will be loaded dynamically)
  private React: any;
  private ReactDOM: any;

  // Static style system that's created once and reused
  private static cachedStyleSystem: SkipComponentStyles | null = null;

  constructor(private config: ReactComponentConfig) {
    this.loadReactLibraries();
  }

  /**
   * Load React and ReactDOM dynamically
   */
  private async loadReactLibraries(): Promise<void> {
    // Check if React is already loaded globally
    if ((window as any).React && (window as any).ReactDOM) {
      this.React = (window as any).React;
      this.ReactDOM = (window as any).ReactDOM;
      return;
    }

    // Otherwise, we need to load React dynamically
    // This is a simplified approach - in production, you might want to use a proper module loader
    try {
      // Try to use ES modules if available
      const [ReactModule, ReactDOMModule] = await Promise.all([
        import('react'),
        import('react-dom/client')
      ]);
      this.React = ReactModule;
      this.ReactDOM = ReactDOMModule;
    } catch (error) {
      // Fallback to assuming React is available globally
      if ((window as any).React && (window as any).ReactDOM) {
        this.React = (window as any).React;
        this.ReactDOM = (window as any).ReactDOM;
      } else {
        throw new Error('React and ReactDOM must be available either as ES modules or global variables');
      }
    }
  }

  /**
   * Generic method to load a script from CDN
   */
  private loadScriptFromCDN(url: string, globalName: string): Promise<any> {
    return new Promise((resolve, reject) => {
      // Check if already loaded
      if ((window as any)[globalName]) {
        resolve((window as any)[globalName]);
        return;
      }

      // Check if script is already in DOM
      const existingScript = document.querySelector(`script[src="${url}"]`);
      if (existingScript) {
        // Wait for it to load
        existingScript.addEventListener('load', () => {
          if ((window as any)[globalName]) {
            resolve((window as any)[globalName]);
          } else {
            reject(new Error(`${globalName} not found after script load`));
          }
        });
        return;
      }

      // Load new script
      const script = document.createElement('script');
      script.src = url;
      script.onload = () => {
        if ((window as any)[globalName]) {
          resolve((window as any)[globalName]);
        } else {
          reject(new Error(`${globalName} not found after script load`));
        }
      };
      script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
      document.head.appendChild(script);
    });
  }

  /**
   * Load Babel standalone for JSX transpilation
   */
  private async loadBabel(): Promise<any> {
    return this.loadScriptFromCDN(BABEL_STANDALONE_CDN_URL, 'Babel');
  }

  /**
   * Initialize the React component
   */
  public async initialize(): Promise<void> {
    try {
      await this.loadReactLibraries();
      const Babel = await this.loadBabel();

      // Create utility functions
      const createStateUpdater = this.createStateUpdaterFunction();
      const createStandardEventHandler = this.createStandardEventHandlerFunction();
      
      // Get or create the style system
      const styles = this.getOrCreateStyleSystem();

      // Transpile the JSX code to JavaScript
      let transpiledCode: string;
      try {
        const result = Babel.transform(this.config.componentCode, {
          presets: ['react'],
          filename: 'component.jsx'
        });
        transpiledCode = result.code;
      } catch (transpileError) {
        LogError(`Failed to transpile JSX: ${transpileError}`);
        throw new Error(`JSX transpilation failed: ${transpileError}`);
      }

      // Create the component factory function from the transpiled code
      // Evaluate the code with React and styles in scope to get the createComponent function
      const createComponent = new Function(
        'React', 'styles', 'console',
        `${transpiledCode}; return createComponent;`
      )(this.React, styles, console);

      // Debug: Check if React hooks are available
      if (!this.React.useState) {
        console.error('React.useState is not available. React object:', this.React);
        throw new Error('React hooks are not available. Make sure React is loaded correctly.');
      }

      // Then call createComponent with all the necessary dependencies
      this.componentResult = createComponent(
        this.React, 
        this.ReactDOM, 
        this.React.useState, 
        this.React.useEffect,
        this.React.useCallback,
        createStateUpdater,
        createStandardEventHandler
      );

      // Create container if it doesn't exist
      if (!this.componentContainer) {
        this.componentContainer = document.createElement('div');
        this.componentContainer.className = 'react-component-container';
        this.componentContainer.style.width = '100%';
        this.componentContainer.style.height = '100%';
        this.config.container.appendChild(this.componentContainer);
      }

      // Store initial state
      this.currentState = this.config.initialState || {};
      
      // Render the component
      this.render();
    } catch (error) {
      LogError(error);
      if (this.config.callbacks?.NotifyEvent) {
        this.config.callbacks.NotifyEvent('error', error);
      }
    }
  }

  /**
   * Render or re-render the React component with new props
   */
  public render(): void {
    if (!this.componentResult || !this.componentResult.component || this.destroyed) {
      return;
    }

    const Component = this.componentResult.component;
    
    // Ensure utilities and callbacks are available
    const utilities = this.config.utilities || {};
    const callbacks = this.createCallbacks();
    const styles = this.getOrCreateStyleSystem();
    
    const componentProps = {
      data: this.config.data || {},
      utilities: utilities,
      userState: this.currentState,
      callbacks: callbacks,
      styles: styles
    };
    
    // Debug: Log the data being passed to the component
    console.log('=== SkipReactComponentHost: Rendering component ===');
    console.log('Data:', componentProps.data);
    console.log('User state:', componentProps.userState);
    if (componentProps.data?.data_item_0) {
      console.log('First entity:', componentProps.data.data_item_0[0]);
      console.log('Entity count:', componentProps.data.data_item_0.length);
    } else {
      console.log('WARNING: No data_item_0 found in data');
    }
    console.log('=== End component props debug ===');

    if (!this.reactRoot && this.componentContainer) {
      this.reactRoot = this.ReactDOM.createRoot(this.componentContainer);
    }

    if (this.reactRoot) {
      this.reactRoot.render(this.React.createElement(Component, componentProps));
    }
  }

  /**
   * Update the component state
   */
  public updateState(path: string, value: any): void {
    // Update the current state
    this.currentState = {
      ...this.currentState,
      [path]: value
    };
    
    // Re-render with new state
    this.render();
  }

  /**
   * Update the component data
   */
  public updateData(newData: any): void {
    this.config.data = {
      ...this.config.data,
      ...newData
    };
    
    // Re-render with new data
    this.render();
  }

  /**
   * Refresh the component with optional new data
   */
  public refresh(newData?: any): void {
    if (newData) {
      this.updateData(newData);
    }
    
    if (this.componentResult && this.componentResult.refresh) {
      this.componentResult.refresh(this.config.data);
    } else {
      // Re-render the component if no refresh method is available
      this.render();
    }
  }

  /**
   * Print the component
   */
  public print(): void {
    if (this.componentResult && this.componentResult.print) {
      this.componentResult.print();
    } else {
      window.print();
    }
  }

  /**
   * Clean up resources
   */
  public destroy(): void {
    this.destroyed = true;
    if (this.reactRoot) {
      this.reactRoot.unmount();
      this.reactRoot = null;
    }
    if (this.componentContainer && this.componentContainer.parentNode) {
      this.componentContainer.parentNode.removeChild(this.componentContainer);
    }
    this.componentContainer = null;
    this.componentResult = null;
  }

  /**
   * Create the callbacks object to pass to the React component
   */
  private createCallbacks(): SkipComponentCallbacks {
    return this.config.callbacks || {
      RefreshData: () => {},
      OpenEntityRecord: () => {},
      UpdateUserState: () => {},
      NotifyEvent: () => {}
    };
  }

  /**
   * Get or create the cached style system
   */
  private getOrCreateStyleSystem(): SkipComponentStyles {
    // If we already have a cached style system, return it
    if (SkipReactComponentHost.cachedStyleSystem) {
      return SkipReactComponentHost.cachedStyleSystem;
    }

    // Create the style system by merging defaults with config
    SkipReactComponentHost.cachedStyleSystem = this.createStyleSystem(this.config.styles);
    
    return SkipReactComponentHost.cachedStyleSystem;
  }

  /**
   * Create a unified style system for the component
   */
  private createStyleSystem(baseStyles?: Partial<SkipComponentStyles>): SkipComponentStyles {
    return {
      ...DEFAULT_STYLES,
      ...baseStyles
    };
  }



  /**
   * Create the state updater utility function for the React component
   */
  private createStateUpdaterFunction(): any {
    return function createStateUpdater(statePath: string, parentStateUpdater: Function) {
      return (componentStateUpdate: any) => {
        if (!statePath) {
          // Root component - call container callback directly
          parentStateUpdater(componentStateUpdate);
        } else {
          // Sub-component - bubble up with path context
          const pathParts = statePath.split('.');
          const componentKey = pathParts[pathParts.length - 1];
          
          parentStateUpdater({
            [componentKey]: {
              ...componentStateUpdate
            }
          });
        }
      };
    };
  }

  /**
   * Create the standard event handler utility function for the React component
   */
  private createStandardEventHandlerFunction(): any {
    return function createStandardEventHandler(updateUserState: Function, callbacksParam: any) {
      return (event: any) => {
        switch (event.type) {
          case 'stateChanged':
            if (event.payload?.statePath && event.payload?.newState) {
              const update: any = {};
              update[event.payload.statePath] = event.payload.newState;
              updateUserState(update);
            }
            break;
          case 'navigate':
            if (callbacksParam?.OpenEntityRecord && event.payload) {
              callbacksParam.OpenEntityRecord(event.payload.entityName, event.payload.key);
            }
            break;
          default:
            if (callbacksParam?.NotifyEvent) {
              callbacksParam.NotifyEvent(event.type, event.payload);
            }
        }
      };
    };
  }
}