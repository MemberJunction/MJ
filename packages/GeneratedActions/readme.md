# @memberjunction/generated-actions

This package contains automatically generated BaseAction subclasses for actions defined in the MemberJunction framework outside of the core MJ framework. These classes are maintained by the MemberJunction CodeGen tool and provide a foundation for implementing custom business logic through the MJ Actions system.

## Overview

The MemberJunction Actions framework provides a flexible system for executing business logic in response to various triggers. This package contains the generated action classes that extend the base `BaseAction` class from `@memberjunction/actions`, allowing developers to implement custom behavior while leveraging MJ's metadata-driven architecture.

## Purpose

- **Code Generation**: All classes in this package are automatically generated by the MJ CodeGen tool based on action metadata stored in the database
- **Type Safety**: Provides strongly-typed action implementations with proper TypeScript support
- **Extensibility**: Generated classes can be further subclassed to add custom business logic
- **Server-Side Only**: These actions are designed to run exclusively on the server side for security and performance

## Installation

This package is typically included as part of a MemberJunction server-side application. Since it's marked as private, it's not published to npm and should be used within the MJ monorepo:

```bash
# From the MJ monorepo root
npm install

# Build the package
npm run build --filter=mj_generatedactions
```

## Usage

### Basic Usage

Import the generated actions in your server-side code:

```typescript
import { LoadGeneratedActions } from 'mj_generatedactions';

// Load all generated actions to ensure they're registered with the ClassFactory
LoadGeneratedActions();
```

### Extending Generated Actions

While the generated action classes provide the base implementation, you can create custom subclasses to add specific business logic:

```typescript
import { RegisterClass } from '@memberjunction/global';
import { ActionResultSimple, RunActionParams } from '@memberjunction/actions-base';
import { YourGeneratedAction } from 'mj_generatedactions';

@RegisterClass(YourCustomAction, 'YourActionName')
export class YourCustomAction extends YourGeneratedAction {
    protected async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        // Add your custom logic here
        const result = await super.InternalRunAction(params);
        
        // Additional processing
        console.log('Custom action executed:', params);
        
        return result;
    }
}
```

### Action Execution

Actions are typically executed through the MemberJunction ActionEngine:

```typescript
import { ActionEngine } from '@memberjunction/actions';

const engine = new ActionEngine();
const result = await engine.RunAction({
    ActionName: 'YourActionName',
    Params: {
        // Your action parameters
    }
});

if (result.Success) {
    console.log('Action completed successfully:', result.ResultCode);
} else {
    console.error('Action failed:', result.Message);
}
```

## API Documentation

### LoadGeneratedActions()

A utility function that ensures all generated action classes are loaded and registered with the MemberJunction ClassFactory. This prevents tree-shaking from removing the generated classes during bundling.

**Usage:**
```typescript
LoadGeneratedActions();
```

**Note:** This function should be called during application initialization to ensure all actions are available for use.

## Dependencies

- `@memberjunction/actions`: Base action framework and utilities
- `@memberjunction/global`: Global utilities including ClassFactory for registration
- `@memberjunction/core`: Core MJ functionality
- `@memberjunction/core-entities`: Entity definitions and metadata
- `@memberjunction/ai`: AI-related functionality
- `@memberjunction/aiengine`: AI engine implementation
- `zod`: Schema validation library

## Integration with MJ Framework

This package integrates seamlessly with other MemberJunction packages:

1. **Metadata-Driven**: Actions are defined in the MJ metadata database and generated automatically
2. **Entity Actions**: Can be triggered by entity events (create, update, delete)
3. **Scheduled Actions**: Can be scheduled for periodic execution
4. **AI Integration**: Can leverage AI capabilities through the AI packages

## Build and Development

### Building

```bash
# Build the package
cd packages/GeneratedActions
npm run build
```

### Generated Code

All generated code is placed in `src/generated/` and should not be manually modified. The CodeGen tool will overwrite these files during regeneration.

### Development Workflow

1. Define actions in the MJ metadata database
2. Run the CodeGen tool to generate/update action classes
3. Create custom subclasses as needed for specific business logic
4. Register custom classes with appropriate action names
5. Deploy and test on the server

## Important Notes

- **Server-Side Only**: This library must only be imported and used on the server side for security reasons
- **Do Not Modify Generated Code**: Files in `src/generated/` are automatically maintained and will be overwritten
- **Custom Logic**: Always extend generated classes rather than modifying them directly
- **Registration**: Ensure custom action classes are properly registered with `@RegisterClass` decorator
- **Type Safety**: Leverage TypeScript's type system for compile-time safety

## Troubleshooting

### Actions Not Found

If actions are not being recognized:
1. Ensure `LoadGeneratedActions()` is called during initialization
2. Verify the action is defined in the metadata database
3. Check that CodeGen has been run recently
4. Confirm custom classes are properly registered

### Build Issues

If experiencing build problems:
1. Ensure all dependencies are installed at the monorepo root
2. Run `npm run build` from the package directory
3. Check for TypeScript compilation errors
4. Verify the generated code is up to date

## License

ISC - See LICENSE file in the repository root for details. 