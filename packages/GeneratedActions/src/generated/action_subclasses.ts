/*************************************************
* GENERATED CODE - DO NOT MODIFY
* Generated by MemberJunction CodeGen at 6/2/2024, 8:09:12 AM
**************************************************/
import { ActionResultSimple, BaseAction, RunActionParams } from "@memberjunction/actions";
import { RegisterClass } from "@memberjunction/global";
import { BaseEntity, Metadata, RunView, UserInfo } from "@memberjunction/core";

            
/**
 * Validate Accounts
 * Generated Class
 * User Prompt: For the provided entity object, if it is a weekend day, check to see if the Name property has a length of > 18. If it is a weekday, check if it is >20. If first criteria met, then make sure that it has a first letter of A, C, X, or Y. oh and finally, if the name is <= 10 in length then it can start only with O, P, or a number. 
 */
@RegisterClass(BaseAction, "Validate Accounts")
export class Validate_Accounts_Action extends BaseAction {
    /*
		* The code starts by extracting the 'EntityObject' from the action parameters.
		* Two helper functions are defined: `isWeekend` to check if a given date is a weekend day, and `startsWith` to check if the first letter of a string is within a set of valid characters.
		* It then gets the current date and the `Name` property of the `EntityObject`.
		* Depending on whether the current day is a weekend or a weekday, it checks the length of the `Name` against the specified criteria (> 18 for weekends, > 20 for weekdays).
		* If the `Name` meets the length criteria and starts with one of the specified letters ('A', 'C', 'X', 'Y'), it returns a success with a message indicating that the validation passed.
		* If the `Name` is less than or equal to 10 characters, it checks if it starts with 'O', 'P', or a number. If it does, it returns a success with a message saying the name is valid.
		* If none of these conditions are met, it returns a failure with a message indicating that the name did not meet the validation criteria.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const entityObj = params.Params.find(param => param.Name === 'EntityObject').Value;
		// Helper function to check if a given date is a weekend day
		function isWeekend(date: Date): boolean {
		    const day = date.getDay();
		    return day === 0 || day === 6; // 0 = Sunday, 6 = Saturday
		}
		// Helper function to check if the first letter is one of the specified characters
		function startsWith(validChars: string[], letter: string): boolean {
		    return validChars.includes(letter);
		}
		const today = new Date();
		const name = entityObj.Name;
		const nameLength = name.length;
		
		if (isWeekend(today)) {
		    if (nameLength > 18 && startsWith(['A', 'C', 'X', 'Y'], name.charAt(0))) {
		        return { Success: true, ResultCode: 'ValidationPassed', Message: 'Weekend: Name is valid.' };
		    }
		} else {
		    if (nameLength > 20 && startsWith(['A', 'C', 'X', 'Y'], name.charAt(0))) {
		        return { Success: true, ResultCode: 'ValidationPassed', Message: 'Weekday: Name is valid.' };
		    }
		}
		if (nameLength <= 10 && startsWith(['O', 'P', ...'0123456789'], name.charAt(0))) {
		    return { Success: true, ResultCode: 'ValidationPassed', Message: 'Name is valid with less than or equal to 10 characters.' };
		}
		return { Success: false, ResultCode: 'ValidationFailed', Message: 'Name did not meet the validation criteria.' };
    }
}        
            
            
/**
 * Create New Action Category
 * Generated Class
 * User Prompt: When this action executes I want to create a new Action Category with a randomly selected name that is a combination of a color, an animal and an Australian state, eh?
 */
@RegisterClass(BaseAction, "Create New Action Category")
export class Create_New_Action_Category_Action extends BaseAction {
    /*
		The code performs the following actions:
		
		* Defines three arrays for colors, animals, and Australian states, which will be used to generate a random name.
		
		* Implements a helper function, `getRandomElement`, to select a random element from an array.
		
		* Combines a random color, animal, and Australian state into a variable `randomName`.
		
		* Creates an instance of the `Metadata` class and fetches a new entity object for 'Action Categories'.
		
		* Sets the `Name` field of the new action category with the generated random name.
		
		* Attempts to save the new action category. If the save is successful, it returns a success message with the new category name.
		
		* If there is an error during saving, it catches the error and returns a failure message with the error details.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const colors = ['Red', 'Blue', 'Green', 'Yellow', 'Purple'];
		const animals = ['Kangaroo', 'Koala', 'Emu', 'Dingo', 'Wombat'];
		const australianStates = ['Queensland', 'New South Wales', 'Victoria', 'Western Australia', 'South Australia'];
		
		// Helper function to get a random element from an array
		function getRandomElement(array) {
		 return array[Math.floor(Math.random() * array.length)];
		}
		
		// Generate the random name
		const randomName = `${getRandomElement(colors)} ${getRandomElement(animals)} ${getRandomElement(australianStates)}`;
		
		// Create a new Metadata instance to interact with entities
		const metadata = new Metadata();
		const newActionCategory = await metadata.GetEntityObject('Action Categories', params.ContextUser);
		
		// Set the new category's name
		newActionCategory.Set('Name', randomName);
		
		// Save the new category
		try {
		 const saveResult = await newActionCategory.Save();
		
		 if (!saveResult) {
		   throw new Error('Failed to save the new Action Category.');
		 }
		
		 return {
		   Success: true,
		   ResultCode: 'ACTION_CATEGORY_CREATED',
		   Message: `New Action Category created successfully with name: ${randomName}`
		 };
		} catch (error) {
		 return {
		   Success: false,
		   ResultCode: 'ACTION_CATEGORY_CREATION_FAILED',
		   Message: `Error: ${error.message}`
		 };
		}
    }
}        
            
            
/**
 * Create new User View record
 * Generated Class
 * User Prompt: Whenever this action is run, we're going to create a new User View record. We'll provide an input param with the name and another with desrcription. I want to have this action simply create a new User View. Then, after saving the view, run the view. We want to run this view by its ViewID which we can get after we create the new record. Then, return the results of the view in an output param called ViewResults
 */
@RegisterClass(BaseAction, "Create new User View record")
export class Create_new_User_View_record_Action extends BaseAction {
    /*
		The following code performs two main tasks: it creates a new 'User View' record using the provided name and description, then runs the new User View to get the results.
		
		* **Input Validation:**
		  - Retrieves the `name` and `description` parameters from the input.
		  - Validates that these parameters are present.
		  - Returns an error if the required input parameters are missing.
		
		* **Creating User View Record:**
		  - Uses `Metadata` to get an entity object for 'User Views'.
		  - Sets this objectâ€™s `Name` and `Description` fields using the retrieved `name` and `description` parameters.
		  - Saves the new entity.
		  - Returns an error if saving the record fails.
		
		* **Running the User View:**
		  - Retrieves the `ViewID` of the newly created `User View` record.
		  - Utilizes `RunView` to run the `User View` with the `ViewID` as a filter.
		  - Returns an error if running the view fails.
		
		* **Returning Results:**
		  - Constructs the success response, including the view results fetched by running the User View.
		
		In summary, the code ensures the creation and immediate execution of a 'User View' record, finally returning the results obtained from running the newly created view.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const nameParam = params.Params.find(param => param.Name === 'name');
		const descriptionParam = params.Params.find(param => param.Name === 'description');
		
		if (!nameParam || !descriptionParam) {
		    return {
		        Success: false,
		        ResultCode: 'MISSING_INPUT_PARAMS',
		        Message: 'Required input parameters not provided.'
		    };
		}
		
		const md = new Metadata();
		const userViewRecord = await md.GetEntityObject('User Views', params.ContextUser);
		
		userViewRecord.Set('Name', nameParam.Value);
		userViewRecord.Set('Description', descriptionParam.Value);
		
		const saveResult = await userViewRecord.Save();
		if (!saveResult) {
		    return {
		        Success: false,
		        ResultCode: 'SAVE_FAILED',
		        Message: 'Failed to save the User View record.'
		    };
		}
		
		const viewID = userViewRecord.Get('ViewID');
		const rv = new RunView();
		const runResult = await rv.RunView({
		    EntityName: 'User Views',
		    Filters: [{ Name: 'ViewID', Value: viewID }]
		}, params.ContextUser);
		
		if (!runResult.Success) {
		    return {
		        Success: false,
		        ResultCode: 'RUN_VIEW_FAILED',
		        Message: 'Failed to run the User View.'
		    };
		}
		
		return {
		    Success: true,
		    ResultCode: 'SUCCESS',
		    Message: 'User View created and run successfully.',
		    Outputs: [{
		        Name: 'ViewResults',
		        Value: runResult.Results
		    }]
		};
    }
}        
            
            
export function LoadGeneratedActions() {
    // this function is a stub that is used to force the bundler to include the generated action classes in the final bundle and not tree shake them out
}
