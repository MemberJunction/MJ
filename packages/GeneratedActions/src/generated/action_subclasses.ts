/*************************************************
* GENERATED CODE - DO NOT MODIFY
* Generated by MemberJunction CodeGen at 6/1/2024, 9:03:35 AM
**************************************************/
import { ActionResultSimple, BaseAction, RunActionParams } from "@memberjunction/actions";
import { RegisterClass } from "@memberjunction/global";
import { BaseEntity, Metadata, RunView, UserInfo } from "@memberjunction/core";

            
/**
 * Validate Accounts
 * Generated Class
 * User Prompt: For the provided entity object, check to see if the Name property has a length of > 10. If it does, then make sure that it has a first letter of A, C, X, or Y. If the name is <= 10 in length then it can start only with O, P, or a number. 
 */
@RegisterClass(BaseAction, "Validate Accounts")
export class Validate_Accounts_Action extends BaseAction {
    /*
		This code performs the following steps:
		
		1. Retrieves the entity object from the action parameters.
		2. Checks if the entity object is present. If not, it returns an error.
		3. Extracts the `Name` property from the entity object.
		4. Determines the length of the name.
		5. Defines valid starting characters based on the name's length:
		    - For names longer than 10 characters, valid starting characters are 'A', 'C', 'X', or 'Y'.
		    - For names 10 characters or shorter, valid starting characters are 'O', 'P', or any number.
		6. Validates the starting character based on the above rules.
		7. Returns an error if the name does not meet the criteria, otherwise returns a success message.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const entityObject = params.Params.find(param => param.Name === 'EntityObject')?.Value;
		
		if (!entityObject) {
		    return {
		        Success: false,
		        ResultCode: 'ENTITY_NOT_FOUND',
		        Message: 'Entity object not provided.'
		    };
		}
		
		const name = entityObject.Name;
		const nameLength = name.length;
		const validLongNamesStart = ['A', 'C', 'X', 'Y'];
		const validShortNamesStart = ['O', 'P', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
		
		if (nameLength > 10) {
		    if (!validLongNamesStart.includes(name.charAt(0))) {
		        return {
		            Success: false,
		            ResultCode: 'INVALID_NAME_FORMAT',
		            Message: 'The name of the entity is too long and does not start with A, C, X, or Y.'
		        };
		    }
		} else {
		    if (!validShortNamesStart.includes(name.charAt(0))) {
		        return {
		            Success: false,
		            ResultCode: 'INVALID_NAME_FORMAT',
		            Message: 'The name of the entity is too short and does not start with O, P, or a number.'
		        };
		    }
		}
		
		return {
		    Success: true,
		    ResultCode: 'VALID_NAME',
		    Message: 'The name of the entity is valid.'
		};
    }
}        
            
            
/**
 * Create New Action Category.
 * Generated Class
 * User Prompt: When this action executes I want to create a new Action Category with a randomly selected name that is a combination of a color, an animal and an Australian state, eh?
 */
@RegisterClass(BaseAction, "Create New Action Category.")
export class Create_New_Action_Category__Action extends BaseAction {
    /*
		1. Define three arrays, `colors`, `animals`, and `australianStates`, each containing a set of strings for colors, animals, and Australian states, respectively.
		
		2. Create a utility function `getRandomElement` to select a random element from a given array.
		
		3. Use `getRandomElement` to select random values for `randomColor`, `randomAnimal`, and `randomAustralianState`.
		
		4. Combine these random values into a single string `categoryName` which will be the name of the new action category.
		
		5. Use the `Metadata` class to create a new instance for interacting with the 'Action Categories' entity.
		
		6. Use the `Set` method on the `actionCategory` object to set the Name field with `categoryName`.
		
		7. Save the `actionCategory` object using the `Save` method.
		
		8. If saving fails, return an ActionResultSimple object indicating failure.
		
		9. If saving is successful, return an ActionResultSimple object indicating success.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const colors = ['Red', 'Blue', 'Green', 'Yellow', 'Purple'];
		
		const animals = ['Kangaroo', 'Koala', 'Wallaby', 'Dingo', 'Emu'];
		
		const australianStates = ['New South Wales', 'Victoria', 'Queensland', 'Western Australia', 'Tasmania'];
		
		function getRandomElement(arr: string[]): string {
		    return arr[Math.floor(Math.random() * arr.length)];
		}
		
		const randomColor = getRandomElement(colors);
		const randomAnimal = getRandomElement(animals);
		const randomAustralianState = getRandomElement(australianStates);
		const categoryName = `${randomColor} ${randomAnimal} from ${randomAustralianState}`;
		
		const md = new Metadata();
		const actionCategory = await md.GetEntityObject('Action Categories', params.ContextUser);
		actionCategory.Set('Name', categoryName);
		const saveResult = await actionCategory.Save();
		
		if (!saveResult) {
		    return {
		        Success: false,
		        ResultCode: 'Failed',
		        Message: 'Failed to save the new Action Category'
		    };
		}
		
		return {
		    Success: true,
		    ResultCode: 'Success',
		    Message: `Action Category '${categoryName}' created successfully!`
		};
    }
}        
            
            
/**
 * Create new User View record
 * Generated Class
 * User Prompt: Whenever this action is run, we're going to create a new User View record. We'll provide an input param with the name and another with desrcription. I want to have this action simply create a new User View. Then, after saving the view, run the view. We want to run this view by its ViewID which we can get after we create the new record. Then, return the results of the view in an output param called ViewResults
 */
@RegisterClass(BaseAction, "Create new User View record")
export class Create_new_User_View_record_Action extends BaseAction {
    /*
		The following code performs two main tasks: it creates a new 'User View' record using the provided name and description, then runs the new User View to get the results.
		
		* **Input Validation:**
		  - Retrieves the `name` and `description` parameters from the input.
		  - Validates that these parameters are present.
		  - Returns an error if the required input parameters are missing.
		
		* **Creating User View Record:**
		  - Uses `Metadata` to get an entity object for 'User Views'.
		  - Sets this objectâ€™s `Name` and `Description` fields using the retrieved `name` and `description` parameters.
		  - Saves the new entity.
		  - Returns an error if saving the record fails.
		
		* **Running the User View:**
		  - Retrieves the `ViewID` of the newly created `User View` record.
		  - Utilizes `RunView` to run the `User View` with the `ViewID` as a filter.
		  - Returns an error if running the view fails.
		
		* **Returning Results:**
		  - Constructs the success response, including the view results fetched by running the User View.
		
		In summary, the code ensures the creation and immediate execution of a 'User View' record, finally returning the results obtained from running the newly created view.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const nameParam = params.Params.find(param => param.Name === 'name');
		const descriptionParam = params.Params.find(param => param.Name === 'description');
		
		if (!nameParam || !descriptionParam) {
		    return {
		        Success: false,
		        ResultCode: 'MISSING_INPUT_PARAMS',
		        Message: 'Required input parameters not provided.'
		    };
		}
		
		const md = new Metadata();
		const userViewRecord = await md.GetEntityObject('User Views', params.ContextUser);
		
		userViewRecord.Set('Name', nameParam.Value);
		userViewRecord.Set('Description', descriptionParam.Value);
		
		const saveResult = await userViewRecord.Save();
		if (!saveResult) {
		    return {
		        Success: false,
		        ResultCode: 'SAVE_FAILED',
		        Message: 'Failed to save the User View record.'
		    };
		}
		
		const viewID = userViewRecord.Get('ViewID');
		const rv = new RunView();
		const runResult = await rv.RunView({
		    EntityName: 'User Views',
		    Filters: [{ Name: 'ViewID', Value: viewID }]
		}, params.ContextUser);
		
		if (!runResult.Success) {
		    return {
		        Success: false,
		        ResultCode: 'RUN_VIEW_FAILED',
		        Message: 'Failed to run the User View.'
		    };
		}
		
		return {
		    Success: true,
		    ResultCode: 'SUCCESS',
		    Message: 'User View created and run successfully.',
		    Outputs: [{
		        Name: 'ViewResults',
		        Value: runResult.Results
		    }]
		};
    }
}        
            
            
export function LoadGeneratedActions() {
    // this function is a stub that is used to force the bundler to include the generated action classes in the final bundle and not tree shake them out
}
