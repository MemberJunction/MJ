/*************************************************
* GENERATED CODE - DO NOT MODIFY
* Generated by MemberJunction CodeGen at 6/2/2024, 11:34:03 PM
**************************************************/
import { ActionResultSimple, BaseAction, RunActionParams } from "@memberjunction/actions";
import { RegisterClass } from "@memberjunction/global";
import { BaseEntity, Metadata, RunView, UserInfo } from "@memberjunction/core";

            
/**
 * Validate Record
 * Generated Class
 * User Prompt: For the provided record, if it is a weekend day, check to see if the Name property has a length of > 18. If it is a weekday, check if it is >20. If first criteria met, then make sure that it has a first letter of A, C, X, or Y. oh and finally, if the name is <= 10 in length then it can start only with O, P, or a number. 
 */
@RegisterClass(BaseAction, "Validate Record")
export class Validate_Record_Action extends BaseAction {
    /*
		1. Fetch the entity object from the params and store it in a variable.
		
		2. Define a function to check if the current date is a weekend (Saturday or Sunday).
		
		3. Get the name from the entity object and its length.
		
		4. Get the current date and check if it is a weekend.
		
		5. Initialize boolean variables for length and start checks.
		
		6. Check the conditions provided:
		   * If the name length is <= 10, verify if it starts with O, P, or a number.
		   * If it is a weekend, verify if the name length is > 18 and the name starts with A, C, X, or Y.
		   * If it is a weekday, verify if the name length is > 20 and the name starts with A, C, X, or Y.
		
		7. If the name does not meet any of the conditions, return a validation failure result.
		
		8. If the name meets the conditions, return a validation success result.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const entityObject = params.Params.find(p => p.Name === 'EntityObject').Value;
		
		function isWeekend(date) {
		    const day = date.getDay();
		    return day === 0 || day === 6;
		}
		
		const entityName = entityObject.Name;
		const nameLength = entityName.length;
		
		const now = new Date();
		const isWeekendDay = isWeekend(now);
		
		let lengthCheck = false;
		let startCheck = false;
		
		if (nameLength <= 10) {
		    startCheck = /^[OP0-9]/.test(entityName);
		} else if (isWeekendDay) {
		    lengthCheck = nameLength > 18;
		    startCheck = /^[ACXY]/i.test(entityName);
		} else {
		    lengthCheck = nameLength > 20;
		    startCheck = /^[ACXY]/i.test(entityName);
		}
		
		if (!lengthCheck && !startCheck) {
		    return {
		        Success: false,
		        ResultCode: 'Validation_Failed',
		        Message: 'The validation conditions are not met.'
		    };
		}
		
		return {
		    Success: true,
		    ResultCode: 'Validation_Success',
		    Message: 'The validation was successful.'
		};
    }
}        
            
            
/**
 * Create New Action Category
 * Generated Class
 * User Prompt: When this action executes I want to create a new Action Category with a randomly selected name that is a combination of a color, an animal and an Australian state, eh?
 */
@RegisterClass(BaseAction, "Create New Action Category")
export class Create_New_Action_Category_Action extends BaseAction {
    /*
		The code performs the following actions:
		
		* Defines three arrays for colors, animals, and Australian states, which will be used to generate a random name.
		
		* Implements a helper function, `getRandomElement`, to select a random element from an array.
		
		* Combines a random color, animal, and Australian state into a variable `randomName`.
		
		* Creates an instance of the `Metadata` class and fetches a new entity object for 'Action Categories'.
		
		* Sets the `Name` field of the new action category with the generated random name.
		
		* Attempts to save the new action category. If the save is successful, it returns a success message with the new category name.
		
		* If there is an error during saving, it catches the error and returns a failure message with the error details.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const colors = ['Red', 'Blue', 'Green', 'Yellow', 'Purple'];
		const animals = ['Kangaroo', 'Koala', 'Emu', 'Dingo', 'Wombat'];
		const australianStates = ['Queensland', 'New South Wales', 'Victoria', 'Western Australia', 'South Australia'];
		
		// Helper function to get a random element from an array
		function getRandomElement(array) {
		 return array[Math.floor(Math.random() * array.length)];
		}
		
		// Generate the random name
		const randomName = `${getRandomElement(colors)} ${getRandomElement(animals)} ${getRandomElement(australianStates)}`;
		
		// Create a new Metadata instance to interact with entities
		const metadata = new Metadata();
		const newActionCategory = await metadata.GetEntityObject('Action Categories', params.ContextUser);
		
		// Set the new category's name
		newActionCategory.Set('Name', randomName);
		
		// Save the new category
		try {
		 const saveResult = await newActionCategory.Save();
		
		 if (!saveResult) {
		   throw new Error('Failed to save the new Action Category.');
		 }
		
		 return {
		   Success: true,
		   ResultCode: 'ACTION_CATEGORY_CREATED',
		   Message: `New Action Category created successfully with name: ${randomName}`
		 };
		} catch (error) {
		 return {
		   Success: false,
		   ResultCode: 'ACTION_CATEGORY_CREATION_FAILED',
		   Message: `Error: ${error.message}`
		 };
		}
    }
}        
            
            
/**
 * Create new User View record
 * Generated Class
 * User Prompt: Whenever this action is run, we're going to create a new User View record. We'll provide an input param with the name and another with desrcription. I want to have this action simply create a new User View. Then, after saving the view, run the view. We want to run this view by its ViewID which we can get after we create the new record. Then, return the results of the view in an output param called ViewResults
 */
@RegisterClass(BaseAction, "Create new User View record")
export class Create_new_User_View_record_Action extends BaseAction {
    /*
		The following code performs two main tasks: it creates a new 'User View' record using the provided name and description, then runs the new User View to get the results.
		
		* **Input Validation:**
		  - Retrieves the `name` and `description` parameters from the input.
		  - Validates that these parameters are present.
		  - Returns an error if the required input parameters are missing.
		
		* **Creating User View Record:**
		  - Uses `Metadata` to get an entity object for 'User Views'.
		  - Sets this objectâ€™s `Name` and `Description` fields using the retrieved `name` and `description` parameters.
		  - Saves the new entity.
		  - Returns an error if saving the record fails.
		
		* **Running the User View:**
		  - Retrieves the `ViewID` of the newly created `User View` record.
		  - Utilizes `RunView` to run the `User View` with the `ViewID` as a filter.
		  - Returns an error if running the view fails.
		
		* **Returning Results:**
		  - Constructs the success response, including the view results fetched by running the User View.
		
		In summary, the code ensures the creation and immediate execution of a 'User View' record, finally returning the results obtained from running the newly created view.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const nameParam = params.Params.find(param => param.Name === 'name');
		const descriptionParam = params.Params.find(param => param.Name === 'description');
		
		if (!nameParam || !descriptionParam) {
		    return {
		        Success: false,
		        ResultCode: 'MISSING_INPUT_PARAMS',
		        Message: 'Required input parameters not provided.'
		    };
		}
		
		const md = new Metadata();
		const userViewRecord = await md.GetEntityObject('User Views', params.ContextUser);
		
		userViewRecord.Set('Name', nameParam.Value);
		userViewRecord.Set('Description', descriptionParam.Value);
		
		const saveResult = await userViewRecord.Save();
		if (!saveResult) {
		    return {
		        Success: false,
		        ResultCode: 'SAVE_FAILED',
		        Message: 'Failed to save the User View record.'
		    };
		}
		
		const viewID = userViewRecord.Get('ViewID');
		const rv = new RunView();
		const runResult = await rv.RunView({
		    EntityName: 'User Views',
		    Filters: [{ Name: 'ViewID', Value: viewID }]
		}, params.ContextUser);
		
		if (!runResult.Success) {
		    return {
		        Success: false,
		        ResultCode: 'RUN_VIEW_FAILED',
		        Message: 'Failed to run the User View.'
		    };
		}
		
		return {
		    Success: true,
		    ResultCode: 'SUCCESS',
		    Message: 'User View created and run successfully.',
		    Outputs: [{
		        Name: 'ViewResults',
		        Value: runResult.Results
		    }]
		};
    }
}        
            
            
/**
 * Loop and Sum
 * Generated Class
 * User Prompt: Loop through the provided parameter of ViewResults and create two summary fields. The first is the count of records. The second one is the sum of the value of the OrderTotal field.
 */
@RegisterClass(BaseAction, "Loop and Sum")
export class Loop_and_Sum_Action extends BaseAction {
    /*
		The provided TypeScript code performs the following actions:
		
		* Initializes two variables, `recordCount` and `orderTotalSum`, to hold the count of records and the total sum of the `OrderTotal` field respectively.
		* Loops through the provided parameters using `params.Params` to find the one named 'ViewResults' which is expected to be an array of records.
		* If the 'ViewResults' array is found:
		  * The `recordCount` is set to the length of this array.
		  * Loops through each record in the 'ViewResults' array to:
		    * Increment the `orderTotalSum` by the value of the `OrderTotal` field if it exists.
		* Adds two new ActionParam objects to params.Params:
		  * One for the `RecordCount` with the calculated number of records.
		  * One for the `OrderTotalSum` with the calculated sum of the `OrderTotal` field.
		* Returns an object indicating success with a message and the output parameters included.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        // Initialize variables to hold the count of records and the total sum of OrderTotal field
		let recordCount = 0;
		let orderTotalSum = 0;
		
		// Loop through the provided ViewResults parameter
		for (const param of params.Params) {
		    if (param.Name === 'ViewResults' && Array.isArray(param.Value)) {
		        recordCount = param.Value.length;
		
		        for (const record of param.Value) {
		            if (record.OrderTotal != null) {
		                orderTotalSum += record.OrderTotal;
		            }
		        }
		    }
		}
		
		// Prepare the output parameters to be added to params.Params
		params.Params.push(new ActionParam({
		    Name: 'RecordCount',
		    Value: recordCount
		}));
		params.Params.push(new ActionParam({
		    Name: 'OrderTotalSum',
		    Value: orderTotalSum
		}));
		
		// Return success
		return {
		    Success: true,
		    ResultCode: 'SUCCESS',
		    Message: 'Calculated record count and sum of OrderTotal field.',
		    Outputs: params.Params
		};
    }
}        
            
            
/**
 * Test12
 * Generated Class
 * User Prompt: Simple test of the value provided in the EntityObject. If the Name field in that object is provided, return true in a single variable called TestResult otherwise return false
 */
@RegisterClass(BaseAction, "Test12")
export class Test12_Action extends BaseAction {
    /*
		The code does the following:
		
		1. Extracts the value of the 'Name' field from the 'EntityObject' parameter provided.
		2. Checks if the 'Name' field exists and is not null.
		3. Stores the result of this check in a variable called 'testResult'.
		4. Returns an ActionResultSimple object with:
		    * Success: true
		    * ResultCode: 'Completed'
		    * A message indicating whether the 'Name' field is present or not.
		    * Outputs: An array with a single ActionParam object containing 'TestResult' and the result of the check.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const entityName = params.Params.find(p => p.Name === 'EntityObject')?.Value?.Name;
		const testResult = !!entityName;
		
		return {
		    Success: true,
		    ResultCode: 'Completed',
		    Message: testResult ? 'Name field is present' : 'Name field is not present',
		    Outputs: [
		        { Name: 'TestResult', Value: testResult }
		    ]
		};
    }
}        
            
            
/**
 * Test 2
 * Generated Class
 * User Prompt: Simple test of the value provided in the EntityObject. If the Name field in that object is provided, return true in a single variable called TestResult otherwise return false


 */
@RegisterClass(BaseAction, "Test 2")
export class Test_2_Action extends BaseAction {
    /*
		1. Initialize a Metadata object to work with entity data.
		
		2. Define a helper function `getParamValue` to find specific parameter values by name from the params array.
		
		3. Retrieve the `EntityName` and `EntityKey` parameters from the input. If either is missing, return an error result.
		
		4. Create a `CompositeKey` using the provided `EntityKey`.
		
		5. Attempt to load the specified entity object using the Metadata class.
		
		6. Check if the `Name` field in the entity object is present and store the result in the `testResult` variable.
		
		7. Add the `TestResult` output parameter to the params array, with the result of the check.
		
		8. Return a successful result if the `Name` field is found; otherwise, return a failure result.
		
		9. If an exception occurs during the process, return an error result with the exception message.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const md = new Metadata();
		
		// Create a function to find parameter values by name
		const getParamValue = (params, name) => {
		    const param = params.find(p => p.Name === name);
		    return param ? param.Value : null;
		};
		
		// Get the entity object with the provided name
		const entityName = getParamValue(params.Params, 'EntityName');
		const entityNameKey = getParamValue(params.Params, 'EntityKey');
		
		if (!entityName || !entityNameKey) {
		    return {
		        Success: false,
		        ResultCode: 'ERROR_MISSING_PARAMETERS',
		        Message: 'Entity name or key not provided.'
		    };
		}
		
		try {
		    const key = new CompositeKey([{Name: 'ID', Value: entityNameKey}]);
		    const entity = await md.GetEntityObject(entityName, params.ContextUser);
		    await entity.InnerLoad(key);
		    const testResult = !!entity.Get('Name');
		
		    // Set the output parameter
		    params.Params.push({Name: 'TestResult', Value: testResult});
		
		    return {
		        Success: true,
		        ResultCode: 'SUCCESS',
		        Message: testResult ? 'Name field is present.' : 'Name field is missing.',
		    };
		} catch (error) {
		    return {
		        Success: false,
		        ResultCode: 'ERROR_EXCEPTION',
		        Message: error.message
		    };
		}
    }
}        
            
            
/**
 * Test15
 * Generated Class
 * User Prompt: Simple test of the value provided in the EntityObject. If the Name field in that object is provided, return true in a single variable called TestResult otherwise return false


 */
@RegisterClass(BaseAction, "Test15")
export class Test15_Action extends BaseAction {
    /*
		1. The code initializes a Metadata object.
		2. It attempts to retrieve the EntityObject specified by the first parameter in the Params array using the context user.
		3. The code then checks if this entityObject was retrieved successfully.
		   - If the entityObject exists, it checks if the 'Name' field exists and initializes a boolean variable `nameFieldExists` accordingly.
		4. The result of this check is returned as an output parameter named 'TestResult'.
		5. If the entityObject is not found, it returns with a failure status and a specific message.
		6. If any error occurs during execution, it catches the error and returns a failure status with the error message.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const md = new Metadata();
		
		try {
		    // Get the EntityObject from Metadata
		    const entityObject = await md.GetEntityObject(params.Params[0]?.Value, params.ContextUser);
		    
		    if (entityObject) {
		        // Test if the 'Name' field exists in the EntityObject
		        const nameFieldExists = !!entityObject.Get('Name');
		
		        // Return the result as 'TestResult'
		        return {
		            Success: true,
		            ResultCode: 'OK',
		            Message: 'Test completed',
		            Outputs: [
		                {
		                    Name: 'TestResult',
		                    Value: nameFieldExists
		                }
		            ]
		        };
		    } else {
		        return {
		            Success: false,
		            ResultCode: 'EntityNotFound',
		            Message: 'Entity not found'
		        };
		    }
		} catch (error) {
		    return {
		        Success: false,
		        ResultCode: 'Error',
		        Message: `An error occurred: ${error.message}`
		    };
		}
    }
}        
            
            
/**
 * Record Saved
 * Generated Class
 * User Prompt: Simple test of the value provided in the EntityObject. If the Name field in that object is provided, return true in a single variable called TestResult otherwise return false


 */
@RegisterClass(BaseAction, "Record Saved")
export class Record_Saved_Action extends BaseAction {
    /*
		This code performs the following steps:
		
		1. Creates a new Metadata instance to interact with the MemberJunction platform.
		2. Retrieves an EntityObject for the 'Entities' entity using the GetEntityObject method.
		3. Fetches the value of the 'Name' field from the retrieved EntityObject.
		4. Evaluates if the 'Name' field is provided (i.e., not null or undefined).
		5. Creates an output parameter 'TestResult' with the value of the evaluation (true or false) and appends it to the Params array.
		6. Returns a success response with the result code 'TEST_RESULT_EVALUATED' and a success message.
		7. Catches any errors that occur during the process and returns a failure response with the result code 'ERROR_OCCURRED' and an error message.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const md = new Metadata();
		
		try {
		    // Assume we retrieve an EntityObject from an entity, 'Entities' as an example
		    const entityObject = await md.GetEntityObject('Entities', params.ContextUser);
		    
		    // Retrieve the 'Name' field's value
		    const nameFieldValue = entityObject.Get('Name');
		    
		    // Determine if 'Name' field is provided
		    const testResult = !!nameFieldValue;
		    
		    // Setup the output parameter
		    params.Params.push(new ActionParam('TestResult', testResult));
		    
		    // Return success response
		    return {
		        Success: true,
		        ResultCode: 'TEST_RESULT_EVALUATED',
		        Message: 'TestResult evaluated successfully'
		    };
		} catch (error) {
		    return {
		        Success: false,
		        ResultCode: 'ERROR_OCCURRED',
		        Message: `An error occurred: ${error.message}`
		    };
		}
    }
}        
            
            
/**
 * Create Random Code
 * Generated Class
 * User Prompt: I want you to create a random program that illustrates the power of Actions and the MJ framework. Do whatever you want in it to illsutrate capabilities.
 */
@RegisterClass(BaseAction, "Create Random Code")
export class Create_Random_Code_Action extends BaseAction {
    /*
		This TypeScript code provides an illustration of the power of Actions in the MemberJunction (MJ) framework by demonstrating how to:
		
		* Query multiple records from the 'Employees' entity.
		* Process the results to extract relevant information (employee names in this case).
		* Output the processed data back to the user.
		
		Here is a step-by-step breakdown:
		
		1. Retrieve multiple records from the 'Employees' entity:
		    * It utilizes the 'Metadata' class to get metadata.
		    * It uses the 'RunView' class to run a view query on the 'Employees' entity, fetching the result as 'entity_object'.
		2. Check the success of the query and the presence of results. If no employees are found, it returns an action result indicating failure.
		3. Process the results by mapping through them to extract employee names.
		4. Output the list of employee names back to the 'Params' array, creating a new 'Params' item with the name 'EmployeeNames'.
		5. Finally, return an action result indicating success along with the extracted employee names.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const md = new Metadata();
		
		// Get multiple records from the 'Employees' entity
		const rv = new RunView();
		const result = await rv.RunView({
		    EntityName: 'Employees',
		    ResultType: 'entity_object'
		}, params.ContextUser);
		
		// Check if the query was successful
		if (!result.Success || !result.Results.length) {
		    return {
		        Success: false,
		        ResultCode: 'NO_EMPLOYEES_FOUND',
		        Message: 'No employees found in the system.'
		    };
		}
		
		// Process the results to extract employee names
		const employeeNames = result.Results.map((employee) => employee.Get('Name'));
		
		// Output the list of employee names
		params.Params.push({
		    Name: 'EmployeeNames',
		    Value: employeeNames
		});
		
		return {
		    Success: true,
		    ResultCode: 'EMPLOYEE_NAMES_EXTRACTED',
		    Message: 'Employee names have been successfully extracted.',
		    Outputs: params.Params
		};
    }
}        
            
            
/**
 * Random 4
 * Generated Class
 * User Prompt: I want you to create a random program that illustrates the power of Actions and the MJ framework. Do whatever you want in it to illsutrate capabilities.


 */
@RegisterClass(BaseAction, "Random 4")
export class Random_4_Action extends BaseAction {
    /*
		This code illustrates the capabilities of the Actions and the MemberJunction (MJ) framework by completing a series of operations:
		
		* It retrieves the current user details from the provided params.
		* Loads a specific demo account record using the Metadata class to get entity objects.
		* Updates the 'Name' field of the loaded demo account.
		* Saves the updated demo account back to the database, providing feedback on success or failure.
		
		This example showcases how you can interact with entities, modify their fields, and persist these changes within the MJ framework.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        /*
		 This code demonstrates the power of Actions and the MemberJunction (MJ) framework by performing a series of operations. The steps include:
		
		 1. Retrieving user details.
		 2. Loading a specific demo account.
		 3. Updating a field in the demo account.
		 4. Saving changes back to the database.
		*/
		
		// Step 1: Retrieve user details
		const contextUser = params.ContextUser;
		
		// Step 2: Load a specific demo account
		const md = new Metadata();
		const demoAccountRecord = await md.GetEntityObject('Demo Accounts', contextUser);
		const key = new CompositeKey([{Name: 'ID', Value: 1234}]);
		await demoAccountRecord.InnerLoad(key);
		
		// Step 3: Update a field in the demo account
		const accountName = demoAccountRecord.Get('Name');
		demoAccountRecord.Set('Name', accountName + ' - Updated');
		
		// Step 4: Save changes back to the database
		const result = await demoAccountRecord.Save();
		
		if (!result) {
		    return {
		        Success: false,
		        ResultCode: 'ErrorSavingRecord',
		        Message: 'Failed to save changes to the demo account record.'
		    };
		} else {
		    // If successful, return an updated message
		    return {
		        Success: true,
		        ResultCode: 'Success',
		        Message: 'Demo account record updated successfully. New Name: ' + demoAccountRecord.Get('Name')
		    };
		}
    }
}        
            
            
/**
 * Test 1000
 * Generated Class
 * User Prompt: Show me waht you can do by generating some random code that showcases power of actions, pls
 */
@RegisterClass(BaseAction, "Test 1000")
export class Test_1000_Action extends BaseAction {
    /*
		* The code starts by logging the beginning of the action execution.
		* The code defines a sample data array with random values to demonstrate the action's capability.
		* It assumes fetching data from the 'Demo Accounts' entity using the RunView library.
		* The fetched records are checked for success, and if failed, an error is thrown.
		* Each fetched record is then modified by a mock update (updating the 'Name' field) and saved back to the database.
		* It logs the random sample data values to showcase the complexity and power.
		* If everything executes successfully, it returns a success result with a message.
		* If any error occurs during the execution, it catches the error, logs it, and returns a failure result with the error message.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        try {
		    // Log the beginning of the action
		    console.log('Action started');
		
		    // Define some random data to showcase action capabilities
		    const sampleData = [
		        { id: 1, name: 'Item 1', value: Math.random() * 100 },
		        { id: 2, name: 'Item 2', value: Math.random() * 100 },
		        { id: 3, name: 'Item 3', value: Math.random() * 100 }
		    ];
		
		    // Assume we fetch data from 'Demo Accounts' entity for more operations
		    const rv = new RunView();
		    const result = await rv.RunView({
		        EntityName: 'Demo Accounts',
		        ResultType: 'entity_object'
		    }, params.ContextUser);
		
		    if (!result.Success) throw new Error('Failed to fetch demo account records.');
		
		    // Modify the fetched records as needed
		    for (const record of result.Results) {
		        // Performing a mock modification
		        record.Set('Name', `Updated_${record.Get('Name')}`);
		        await record.Save();
		    }
		
		    // Log random data to showcase power and complexity
		    sampleData.forEach(data => {
		        console.log(`ID: ${data.id}, Name: ${data.name}, Value: ${data.value}`);
		    });
		
		    // Action successful, return appropriate results
		    return {
		        Success: true,
		        ResultCode: 'Action completed successfully',
		        Message: 'Data has been processed and updated successfully!'
		    };
		} catch (error) {
		    // Handle any errors that occurred during the action execution
		    console.error('An error occurred:', error.message);
		    return {
		        Success: false,
		        ResultCode: 'Action failed',
		        Message: error.message
		    };
		}
    }
}        
            
            
/**
 * Test 2c
 * Generated Class
 * User Prompt: Show me waht you can do by generating some random code that showcases power of actions, pls..


 */
@RegisterClass(BaseAction, "Test 2c")
export class Test_2c_Action extends BaseAction {
    /*
		This code demonstrates several capabilities of the MemberJunction actions framework:
		
		* Fetching records from an entity, in this case, 'Employees', using the RunView method.
		* Handling the retrieved records: checking if records are fetched successfully and if there are any employees present.
		* Modifying a field for one of the fetched employee records and saving the changes back to the database.
		* Creating a new record in a different entity, in this case, 'Roles', and setting its field values before saving it.
		* Returning a success response with detailed messages and output parameters that include IDs of the updated and newly created records.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        /* Example action showcasing various capabilities of the MemberJunction actions framework */
		
		// Extract the necessary information from the params
		const contextUser = params.ContextUser;
		
		// 1. Fetch some records from the 'Employees' entity
		const rv = new RunView();
		const fetchResult = await rv.RunView({
		 EntityName: 'Employees',
		 ResultType: 'entity_object'
		}, contextUser);
		
		if (!fetchResult.Success) {
		 return {
		 Success: false,
		 ResultCode: 'FetchError',
		 Message: 'Failed to fetch employee records.'
		 };
		}
		
		// 2. Modify one of the fetched records
		const employees = fetchResult.Results;
		if (employees.length === 0) {
		 return {
		 Success: false,
		 ResultCode: 'NoEmployees',
		 Message: 'No employees found.'
		 };
		}
		const employeeToUpdate = employees[0];
		employeeToUpdate.Set('LastName', 'UpdatedLastName');
		const saveResult = await employeeToUpdate.Save();
		
		if (!saveResult) {
		 return {
		 Success: false,
		 ResultCode: 'SaveError',
		 Message: 'Failed to save employee record.'
		 };
		}
		
		// 3. Create a new record in the 'Roles' entity
		const newRole = new Metadata().GetBaseEntity('Roles');
		newRole.Set('RoleName', 'NewRole');
		const createResult = await newRole.Save();
		
		if (!createResult) {
		 return {
		 Success: false,
		 ResultCode: 'CreateError',
		 Message: 'Failed to create a new role.'
		 };
		}
		
		// 4. Returning success with messages and output parameters
		return {
		 Success: true,
		 ResultCode: 'Success',
		 Message: 'Action executed successfully. Updated an employee and created a new role.',
		 Outputs: [
		 { Name: 'UpdatedEmployeeID', Value: employeeToUpdate.Get('ID') },
		 { Name: 'NewRoleID', Value: newRole.Get('ID') }
		 ]
		};
    }
}        
            
            
/**
 * Test 300
 * Generated Class
 * User Prompt: Show me waht you can do by generating some random code that showcases power of actions, pls
 */
@RegisterClass(BaseAction, "Test 300")
export class Test_300_Action extends BaseAction {
    /*
		This code demonstrates the power and flexibility of MemberJunction actions by performing the following steps:
		
		* **Step 1**: Initialize Metadata to access the entities within the system. This sets up the necessary context to interact with entity data.
		* **Step 2**: Utilize the RunView function to fetch all records from the 'Employees' entity. RunView is configured to return results as simple objects for lightweight processing.
		* **Step 3**: Process each employee record retrieved from the 'Employees' entity. This showcases how you might iterate over a set of records and apply custom logic to each one (e.g., logging the employee's name).
		
		The code includes error handling to catch any issues that arise during these operations and report them back as part of the action's return value. This ensures robustness and clear feedback to the user regarding the action's success or failure.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const entityName = 'Employees';
		const viewName = 'vwEmployees';
		
		try {
		
		    // Step 1: Initialize Metadata to access Entities
		    const metadata = new Metadata();
		
		    // Step 2: Get all Employees using RunView
		    const runView = new RunView();
		    const result = await runView.RunView({
		        EntityName: entityName,
		        ResultType: 'simple_object'
		    }, params.ContextUser);
		
		    if (!result.Success) {
		        throw new Error('Failed to retrieve employees.');
		    }
		
		    // Step 3: Process each Employee
		    const employees = result.Results;
		    for (const employee of employees) {
		        const employeeName = employee['Name'];
		        // A placeholder for actual logic you might want to apply
		        console.log(`Processing employee: ${employeeName}`);
		    }
		
		    // Return success result
		    return {
		        Success: true,
		        ResultCode: 'ProcessedEmployeesSuccessfully',
		        Message: 'All employees have been processed successfully.'
		    };
		} catch (error) {
		    // Log and return error
		    console.error('Error:', error);
		    return {
		        Success: false,
		        ResultCode: 'EmployeeProcessingFailed',
		        Message: error.message
		    };
		}
    }
}        
            
            
/**
 * Test 5001
 * Generated Class
 * User Prompt: Create a program that illustrates the power of Actions, make sure to use loops, conditionals, switches and structurd exeption handling
 */
@RegisterClass(BaseAction, "Test 5001")
export class Test_5001_Action extends BaseAction {
    /*
		This code is a comprehensive demonstration of the capabilities of Actions within the MemberJunction framework using various programming constructs. Here's a breakdown of what the code does:
		
		* **Loops**: A `for` loop is used to iterate over a range of numbers (0 to 9) and classify each number as either even or odd using conditionals.
		* **Conditionals**: Inside the loop, an `if` statement is used to check if the current number is even or odd, and appropriate messages are appended to the `message` string.
		* **Switch Statement**: A `switch` statement is demonstrated to handle different cases based on the value of an example input parameter (`SampleValue`). If `SampleValue` matches 'A', 'B', or any other value, corresponding messages are appended to the `message` string.
		* **Error Handling**: The code includes structured exception handling using a `try-catch` block. If any error occurs, it sets the `success` flag to `false` and updates the `message` with the error details.
		* **Parameter Handling**: The code retrieves an example input parameter (`Input`) and processes its value if found. If the parameter is not found, it throws an error.
		
		Finally, the `ActionResultSimple` object is returned with the success status, result code, final message, and output parameters.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const outputParams: ActionParam[] = [];
		let message = '';
		let success = true;
		const resultCode = 'RESULT_SUCCESS';
		
		try {
		    // Sample loop demonstrating iteration over an example dataset
		    for (let i = 0; i < 10; i++) {
		        if (i % 2 === 0) {
		            // Use of conditionals to check if 'i' is even
		            message += `Even number: ${i}\n`;
		        } else {
		            message += `Odd number: ${i}\n`;
		        }
		    }
		
		    // Sample switch statement demonstrating different cases
		    const sampleValue = params.Params.find(p => p.Name === 'SampleValue');
		    if (sampleValue) {
		        switch (sampleValue.Value) {
		            case 'A':
		                message += 'Case A executed.\n';
		                break;
		            case 'B':
		                message += 'Case B executed.\n';
		                break;
		            default:
		                message += 'Default case executed.\n';
		        }
		    }
		
		    // Example input parameter
		    const inputParam = params.Params.find(p => p.Name === 'Input');
		    if (!inputParam) {
		        throw new Error('Input parameter not found');
		    }
		
		    // Process inputParam value
		    if (inputParam.Value) {
		        message += `Input provided: ${inputParam.Value}\n`;
		    }
		
		} catch (error) {
		    // Structured exception handling
		    success = false;
		    message = `An error occurred: ${error.message}`;
		}
		
		return {
		    Success: success,
		    ResultCode: resultCode,
		    Message: message,
		    Outputs: outputParams
		};
    }
}        
            
            
/**
 * Test 600
 * Generated Class
 * User Prompt: Create a program that illustrates the power of Actions, make sure to use loops, conditionals, switches and structurd exeption handling


 */
@RegisterClass(BaseAction, "Test 600")
export class Test_600_Action extends BaseAction {
    /*
		This code demonstrates the power of Actions by using loops, conditionals, switches, and structured exception handling to process a variety of data types:
		
		* **Loop:** The code iterates through each item in the `data` array using a `for...of` loop.
		
		* **Switch:** A `switch` statement is used to handle different data types (`string`, `number`, `object`, and others).
		
		* **Conditionals:** The code uses `if...else` structures within the `switch` cases to handle specific logic based on the content and value of the data.
		
		* **Structured Exception Handling:** A `try...catch` block ensures that any errors during execution are caught and handled gracefully. If an error occurs, the action returns an error message indicating failure.
		
		For each processed item, an action output (`ActionParam`) is appended to the `outputs` array. The final output is returned, including the success status, result code, message, and collected outputs.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const outputs = [];
		
		// Example data of different types
		const data = ['loop', 42, { type: 'conditional', value: true }, 'unknown', null];
		
		try {
		    // Loop through each item in the data array
		    for (const item of data) {
		        switch (typeof item) {
		            case 'string':
		                if (item === 'loop') {
		                    outputs.push(new ActionParam({ Name: 'LoopOutput', Value: 'Executed loop action' }));
		                } else {
		                    outputs.push(new ActionParam({ Name: 'UnknownStringOutput', Value: `Unknown string: ${item}` }));
		                }
		                break;
		            case 'number':
		                // Simple conditional
		                if (item > 40) {
		                    outputs.push(new ActionParam({ Name: 'ConditionalOutput', Value: 'Number is greater than 40' }));
		                } else {
		                    outputs.push(new ActionParam({ Name: 'ConditionalOutput', Value: 'Number is 40 or less' }));
		                }
		                break;
		            case 'object':
		                if (item && item.type === 'conditional' && item.value) {
		                    outputs.push(new ActionParam({ Name: 'ObjectOutput', Value: 'Conditional object with true value' }));
		                } else {
		                    outputs.push(new ActionParam({ Name: 'ObjectOutput', Value: 'Conditional object with false or non-matching value' }));
		                }
		                break;
		            default:
		                outputs.push(new ActionParam({ Name: 'DefaultOutput', Value: 'Unrecognized data type' }));
		                break;
		        }
		    }
		
		    // Final success message
		    return {
		        Success: true,
		        ResultCode: 'Executed successfully',
		        Message: 'All actions executed as per the provided data.',
		        Outputs: outputs
		    };
		} catch (error) {
		    // Handle any exceptions
		    return {
		        Success: false,
		        ResultCode: 'Execution failed',
		        Message: `An error occurred: ${error.message}`
		    };
		}
    }
}        
            
            
/**
 * Demo Iteration2
 * Generated Class
 * User Prompt: Iterate through the resultObject parameter which is an array of BaseEntity objects and set the Sequence field = to its value +1. Also, keep a running total of the sum of all prior and final sequences and return the count of records modified as well as both tallies in the output
 */
@RegisterClass(BaseAction, "Demo Iteration2")
export class Demo_Iteration2_Action extends BaseAction {
    /*
		The code performs the following steps:
		
		1. Initializes three variables to keep track of counts and sums: `countModified`, `sumOfPriorSequences`, and `sumOfFinalSequences`.
		
		2. Iterates through each BaseEntity object in the `resultObject` array using a for loop.
		
		3. For each entity, retrieves the current value of the `Sequence` field.
		
		4. Increments this `Sequence` value by 1 and updates the entity's `Sequence` field with the new value.
		
		5. Keeps running totals of the prior and final `Sequence` values.
		
		6. Increments the count of modified records.
		
		7. Constructs and returns an `ActionResultSimple` object containing:
		  * `Success` indicating the action succeeded.
		  * `ResultCode` set to 'SUCCESS'.
		  * A `Message` stating 'Records modified successfully'.
		  * An `Outputs` array with the number of records modified, the sum of prior `Sequence` values, and the sum of final `Sequence` values.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        let countModified = 0;
		let sumOfPriorSequences = 0;
		let sumOfFinalSequences = 0;
		
		for (const entity of resultObject) {
		    // Get the current Sequence value
		    const priorSequence = entity.Get('Sequence');
		    
		    // Increase the Sequence value by 1 and set it back
		    const finalSequence = priorSequence + 1;
		    entity.Set('Sequence', finalSequence);
		    
		    // Keep track of the sums of prior and final sequences
		    sumOfPriorSequences += priorSequence;
		    sumOfFinalSequences += finalSequence;
		    
		    // Increment the modified records counter
		    countModified++;
		}
		
		// Return the ActionResultSimple object with the required results
		return {
		    Success: true,
		    ResultCode: 'SUCCESS',
		    Message: 'Records modified successfully',
		    Outputs: [
		        { Name: 'CountModified', Value: countModified },
		        { Name: 'SumOfPriorSequences', Value: sumOfPriorSequences },
		        { Name: 'SumOfFinalSequences', Value: sumOfFinalSequences }
		    ]
		};
    }
}        
            
            
/**
 * Test
 * Generated Class
 * User Prompt: This is a test, generate a simple code snippet that returns the current date and time into an output param
 */
@RegisterClass(BaseAction, "Test")
export class Test_Action extends BaseAction {
    /*
		This code snippet performs the following tasks:
		
		* Retrieves the current date and time using `new Date()` object.
		* Creates a new `ActionParam` object to store the current date and time.
		* Sets the `Name` property of the `ActionParam` object to 'CurrentDateTime'.
		* Sets the `Value` property of the `ActionParam` object to the string representation of the current date and time.
		* Creates a new `ActionResultSimple` object to indicate the success of the action.
		* Sets the `Success` property of the `ActionResultSimple` object to `true`.
		* Sets the `ResultCode` property of the `ActionResultSimple` object to 'DateRetrieved'.
		* Sets the `Message` property of the `ActionResultSimple` object to 'The current date and time have been retrieved.'.
		* Assigns the created `ActionParam` object to the `Outputs` array of the `ActionResultSimple` object.
		* Returns the `ActionResultSimple` object as the result of the action.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const currentDate = new Date();
		const outputParam = new ActionParam();
		outputParam.Name = 'CurrentDateTime';
		outputParam.Value = currentDate.toString();
		
		const result = new ActionResultSimple();
		result.Success = true;
		result.ResultCode = 'DateRetrieved';
		result.Message = 'The current date and time have been retrieved.';
		
		result.Outputs = [outputParam];
		return result;
    }
}        
            
            
/**
 * Another Test eh
 * Generated Class
 * User Prompt: Do some sample code to calc the current date and time in Egypt and California and put those as variables in output params
 */
@RegisterClass(BaseAction, "Another Test eh")
export class Another_Test_eh_Action extends BaseAction {
    /*
		The code calculates the current date and time in two different time zones: Egypt and California. It then adds these calculated date and time values as output parameters.
		
		Steps followed:
		
		* The `luxon` library is used to handle date and time calculations.
		* The current date and time in Egypt is calculated using the `Africa/Cairo` time zone.
		* The current date and time in California is calculated using the `America/Los_Angeles` time zone.
		* The calculated values are added as output parameters (`EgyptDateTime` and `CaliforniaDateTime`).
		* These parameters are then added to the `params.Params` array.
		* Finally, the method returns an action result indicating success along with the output parameters.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const { DateTime } = require('luxon');
		
		// Calculate current date and time in Egypt
		const egyptDateTime = DateTime.now().setZone('Africa/Cairo');
		
		// Calculate current date and time in California
		const californiaDateTime = DateTime.now().setZone('America/Los_Angeles');
		
		// Prepare output parameters
		const outputParams = [
		    new ActionParam({ Name: 'EgyptDateTime', Value: egyptDateTime.toISO() }),
		    new ActionParam({ Name: 'CaliforniaDateTime', Value: californiaDateTime.toISO() })
		];
		
		// Set the outputs to params
		params.Params.push(...outputParams);
		
		return {
		    Success: true,
		    ResultCode: 'Success',
		    Message: 'Current date and time in Egypt and California have been calculated successfully.',
		    Outputs: outputParams
		};
    }
}        
            
            
/**
 * abcdef
 * Generated Class
 * User Prompt: Just return true in the params as "Result"
 */
@RegisterClass(BaseAction, "abcdef")
export class abcdef_Action extends BaseAction {
    /*
		This code performs the following steps:
		
		* Creates a new ActionParam object named `resultParam`.
		* Sets the `Name` property of `resultParam` to "Result".
		* Sets the `Value` property of `resultParam` to `true`.
		* Adds the `resultParam` object to the `Params` array in the `params` object.
		* Returns an `ActionResultSimple` object indicating the action was successful with the ResultCode set to "SUCCESS" and a message saying "Action executed successfully".
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const resultParam = new ActionParam();
		resultParam.Name = "Result";
		resultParam.Value = true;
		params.Params.push(resultParam);
		
		return {
		    Success: true,
		    ResultCode: "SUCCESS",
		    Message: "Action executed successfully"
		};
    }
}        
            
            
/**
 * xfr
 * Generated Class
 * User Prompt: Just return true in the params as "Result"


 */
@RegisterClass(BaseAction, "xfr")
export class xfr_Action extends BaseAction {
    /*
		This code simply returns a JSON object with three properties:
		
		* `Success`: Indicates the action was successful and is set to `true`.
		* `ResultCode`: A string indicating the result of the action, here it is set to `'100'`.
		* `Message`: A message providing additional information about the action result, set to `'Action executed successfully'`.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        return { Success: true, ResultCode: '100', Message: 'Action executed successfully' };
    }
}        
            
            
/**
 * 90213
 * Generated Class
 * User Prompt: Just return true in the params as "Result"
 */
@RegisterClass(BaseAction, "90213")
export class _90213_Action extends BaseAction {
    /*
		This code creates an ActionResultSimple object and sets its properties to indicate a successful action execution. The 'Outputs' array contains a single ActionParam object with the 'Result' parameter set to true. Finally, the ActionResultSimple object is returned.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const actionResult = new ActionResultSimple();
		actionResult.Success = true;
		actionResult.ResultCode = "Success";
		actionResult.Message = "Action completed successfully";
		actionResult.Outputs = [
		    { Name: "Result", Value: true }
		];
		
		return actionResult;
    }
}        
            
            
/**
 * asdfasdfasdfa
 * Generated Class
 * User Prompt: Just return true in the params as "Result"


 */
@RegisterClass(BaseAction, "asdfasdfasdfa")
export class asdfasdfasdfa_Action extends BaseAction {
    /*
		The code creates a new ActionParam object, sets its Name to 'Result', and its Value to true.
		* This ActionParam is then pushed into the Params array of the params object.
		* Finally, it returns an ActionResultSimple object with Success set to true, ResultCode set to 'SUCCESS', and a message indicating the action executed successfully.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const resultParam = new ActionParam();
		resultParam.Name = 'Result';
		resultParam.Value = true;
		
		params.Params.push(resultParam);
		
		return {
		    Success: true,
		    ResultCode: 'SUCCESS',
		    Message: 'The action executed successfully.'
		};
    }
}        
            
            
/**
 * asdf3264wagafsaf
 * Generated Class
 * User Prompt: Just return true in the params as "Result"


 */
@RegisterClass(BaseAction, "asdf3264wagafsaf")
export class asdf3264wagafsaf_Action extends BaseAction {
    /*
		This code creates a new output parameter with the name 'Result' and sets its value to true. It then adds this output parameter to the Params array and returns a successful ActionResultSimple object.
		
		1. An `ActionParam` object is created for the output.
		2. The name of the parameter is set to 'Result'.
		3. The value of the parameter is set to `true`.
		4. This output parameter is pushed into the `Params` array.
		5. Finally, the method returns an `ActionResultSimple` object indicating success, with a result code of 'SUCCESS' and a message saying 'Successfully set Result to true.'.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const output = new ActionParam();
		output.Name = 'Result';
		output.Value = true;
		params.Params.push(output);
		
		return {
		    Success: true,
		    ResultCode: 'SUCCESS',
		    Message: 'Successfully set Result to true.'
		};
    }
}        
            
            
/**
 * 56645q3regfasfdasdf
 * Generated Class
 * User Prompt: Just return true in the params as "Result"


 */
@RegisterClass(BaseAction, "56645q3regfasfdasdf")
export class _56645q3regfasfdasdf_Action extends BaseAction {
    /*
		The code defines an action that simply returns a successful action result with the parameter 'Result' set to true.
		
		The response object has the following properties:
		
		* `Success`: A boolean indicating the action succeeded.
		* `ResultCode`: A string indicating the action's result code, set to 'SUCCESS'.
		* `Message`: A string containing a success message 'Action executed successfully'.
		* `Params`: An array with a single parameter object having a `Name` set to 'Result' and `Value` set to true.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        return { Success: true, ResultCode: 'SUCCESS', Message: 'Action executed successfully', Params: [{ Name: 'Result', Value: true }] };
    }
}        
            
            
/**
 * Test asbasdfasdfasfd
 * Generated Class
 * User Prompt: For the provided record, if it is a weekend day, check to see if the Name property has a length of > 18. If it is a weekday, check if it is >20. If first criteria met, then make sure that it has a first letter of A, C, X, or Y. oh and finally, if the name is <= 10 in length then it can start only with O, P, or a number.


 */
@RegisterClass(BaseAction, "Test asbasdfasdfasfd")
export class Test_asbasdfasdfasfd_Action extends BaseAction {
    /*
		The code performs the following steps:
		
		* Retrieves the 'Demo Accounts' entity record for the context user.
		* Extracts the 'Name' property and its length.
		* Determines if the current day is a weekend (Saturday or Sunday).
		* Sets conditional validation criteria based on whether it's a weekend or weekday:
		  - If it's a weekend, it checks if the 'Name' length is greater than 18 and the first letter is either 'A', 'C', 'X', or 'Y'.
		  - If it's a weekday, it checks if the 'Name' length is greater than 20 and the first letter is either 'A', 'C', 'X', or 'Y'.
		* Additionally, if the 'Name' length is 10 or less, it verifies if the first letter starts with either 'O', 'P', or a number.
		* If any of the conditions are met, it sets the validation success status.
		* Returns the appropriate success or failure message based on the validation result.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const md = new Metadata();
		const entityRecord = await md.GetEntityObject('Demo Accounts', params.ContextUser);
		const name = entityRecord.Get('Name');
		const nameLength = name.length;
		const firstChar = name.charAt(0);
		const today = new Date();
		const isWeekend = (today.getDay() === 0 || today.getDay() === 6);
		let isValid = false;
		
		if (isWeekend) {
		    if (nameLength > 18 && ['A', 'C', 'X', 'Y'].includes(firstChar)) {
		        isValid = true;
		    }
		} else {
		    if (nameLength > 20 && ['A', 'C', 'X', 'Y'].includes(firstChar)) {
		        isValid = true;
		    }
		}
		
		if (nameLength <= 10 && !isValid) {
		    if (['O', 'P'].includes(firstChar) || !isNaN(parseInt(firstChar))) {
		        isValid = true;
		    }
		}
		
		let resultMessage = isValid ? 'Name property validation succeeded' : 'Name property validation failed';
		return { Success: isValid, ResultCode: '000', Message: resultMessage };
    }
}        
            
            
/**
 * Tesq234wqefasdf
 * Generated Class
 * User Prompt: Write a sample script that just tests the day of week and if it isMonday return true in the Params outputVal property and otherwise return false
 */
@RegisterClass(BaseAction, "Tesq234wqefasdf")
export class Tesq234wqefasdf_Action extends BaseAction {
    /*
		The provided code snippet performs the following steps:
		
		1. **Creates an ActionParam object:** This will be used to store the output value.
		2. **Sets the name of the output parameter:** The name is set to "outputVal" which will be used in the Params array.
		3. **Calculates the day of the week:** Using JavaScript's built-in Date object, the code checks if today's day is Monday. In JavaScript, `getDay()` returns 1 for Monday.
		4. **Sets the output value:** The output value is set to `true` if today is Monday and `false` otherwise.
		5. **Returns the result:** The result object includes Success, ResultCode, Message, and the Outputs array containing the outputVal parameter.
		
		This code effectively checks if today is Monday and returns the result accordingly.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const outputVal = new ActionParam();
		outputVal.Name = "outputVal";
		outputVal.Value = (new Date().getDay() === 1);
		
		return {
		    Success: true,
		    ResultCode: "DAY_CHECKED",
		    Message: "Day of the week evaluated",
		    Outputs: [outputVal]
		};
    }
}        
            
            
/**
 * asdfasdas
 * Generated Class
 * User Prompt: Give me a demo of what you can do with Actions
 */
@RegisterClass(BaseAction, "asdfasdas")
export class asdfasdas_Action extends BaseAction {
    /*
		This code demonstrates a simple action that retrieves a list of companies from the 'Companies' entity. Here's what it does step-by-step:
		
		1. Initializes two variables: `success` to track if the action was successful, and `message` to store a user-readable message about the result.
		2. Uses a try-catch block to handle any potential errors during the execution of the action.
		3. Inside the try block:
		   a. Creates an instance of the `RunView` class.
		   b. Calls the `RunView` method with parameters to retrieve simple objects from the 'Companies' entity, using the current user context (`params.ContextUser`).
		   c. Checks if the result was successful. If successful, it retrieves the list of companies and sets the success flag and message accordingly. If not, it sets a failure message.
		4. In case of an error, the catch block sets the failure message and success flag.
		5. Returns an object containing the success status, result code, and message to indicate the outcome of the action.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        let success: boolean;
		let message: string;
		
		try {
		    // Perform a simple action: Retrieve a list of companies
		    const rv = new RunView();
		    const result = await rv.RunView({
		        EntityName: 'Companies',
		        ResultType: 'simple_object'
		    }, params.ContextUser);
		
		    if (result.Success) {
		        const companies = result.Results;
		        message = `Retrieved ${companies.length} companies.`;
		        success = true;
		    } else {
		        message = 'Failed to retrieve companies.';
		        success = false;
		    }
		} catch (error) {
		    message = 'An error occurred: ' + error.message;
		    success = false;
		}
		
		return {
		    Success: success,
		    ResultCode: success ? 'SUCCESS' : 'FAILURE',
		    Message: message
		};
    }
}        
            
            
/**
 * Test12312q34567qawef
 * Generated Class
 * User Prompt: Create a new action that showcases the true power of actions!
 */
@RegisterClass(BaseAction, "Test12312q34567qawef")
export class Test12312q34567qawef_Action extends BaseAction {
    /*
		This action demonstrates powerful capabilities by showcasing:
		* Fetching a single 'Companies' record and updating its 'Name' field.
		* Fetching multiple 'Employees' records and listing their names.
		* Exception handling to manage any errors that occur during execution.
		
		Steps in the code:
		1. Create an instance of Metadata.
		2. Fetch a single record from the 'Companies' entity with ID=1.
		3. Modify the 'Name' field of the fetched company record to 'New Company Name'.
		4. Save the updated company record.
		5. Run a view to fetch multiple records from the 'Employees' entity.
		6. Extract names of the fetched employees and return them as part of the success message.
		7. Exception handling is in place to capture and report any errors that occur during the action.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const md = new Metadata();
		
		try {
		    // Fetch a single record from the 'Companies' entity
		    const companyRecord = await md.GetEntityObject('Companies', params.ContextUser);
		    const key = new CompositeKey([{Name: 'ID', Value: 1}]); // Assuming we want the record with ID=1
		    await companyRecord.InnerLoad(key);
		    const companyName = companyRecord.Get('Name');
		
		    // Modify the company's 'Name' field
		    companyRecord.Set('Name', 'New Company Name');
		    const saveResult = await companyRecord.Save();
		
		    if (!saveResult) 
		        throw new Error('Failed to save the company record');
		
		    // Run a view to fetch multiple 'Employees' records
		    const rv = new RunView();
		    const employeeResults = await rv.RunView({
		        EntityName: 'Employees',
		        ResultType: 'entity_object'
		    }, params.ContextUser);
		
		    if (!employeeResults.Success) 
		        throw new Error('Failed to fetch employees');
		
		    const employeeNames = employeeResults.Results.map(employee => employee.Get('Name'));
		
		    return {
		        Success: true,
		        ResultCode: 'SUCCESS',
		        Message: `Company name updated to 'New Company Name'. Retrieved employees: ${employeeNames.join(', ')}`
		    };
		} catch (error) {
		    return {
		        Success: false,
		        ResultCode: 'ERROR',
		        Message: `Action failed: ${error.message}`
		    };
		}
    }
}        
            
            
/**
 * 0986i865
 * Generated Class
 * User Prompt: Create a new action that showcases the true power of actions!


 */
@RegisterClass(BaseAction, "0986i865")
export class _0986i865_Action extends BaseAction {
    /*
		This action demonstrates the full power of MemberJunction actions by performing several different tasks:
		
		* Fetching a list of all companies using the RunView method and returning the results.
		* Fetching a specific employee record by ID using the Metadata object.
		* Updating a field in the fetched employee record and saving it back to the database.
		* Running a user-defined query to fetch contacts linked to a specific company ID.
		* Fetching multiple user views that are linked to a specific category using filters in RunView.
		* Each step checks for success and returns appropriate result codes and messages if any step fails.
		* Returns the results of companies, employee, query result, and user views to the caller.
		* Uses try-catch for error handling to provide detailed error messages in case of failures.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const { ContextUser } = params;
		const md = new Metadata();
		
		try {
		    // Example: Fetch a list of all Companies
		    const companiesView = new RunView();
		    const companiesResult = await companiesView.RunView({
		        EntityName: 'Companies',
		        ResultType: 'simple_object'
		    }, ContextUser);
		
		    // Check if companies were fetched successfully
		    if (!companiesResult.Success) {
		        return {
		            Success: false,
		            ResultCode: 'COMPANIES_FETCH_FAILED',
		            Message: 'Failed to fetch companies'
		        };
		    }
		
		    // Example: Fetch a specific Employee by ID
		    const employeeRecord = await md.GetEntityObject('Employees', ContextUser);
		    const employeeKey = new CompositeKey([{ Name: 'ID', Value: 1234 }]);
		    await employeeRecord.InnerLoad(employeeKey);
		
		    // Check if employee record was loaded successfully
		    if (!employeeRecord) {
		        return {
		            Success: false,
		            ResultCode: 'EMPLOYEE_FETCH_FAILED',
		            Message: 'Failed to fetch employee'
		        };
		    }
		
		    // Example: Update a field in the employee record
		    employeeRecord.Set('Name', 'John Doe');
		    const saveResult = await employeeRecord.Save();
		
		    // Check if employee record was saved successfully
		    if (!saveResult) {
		        return {
		            Success: false,
		            ResultCode: 'EMPLOYEE_SAVE_FAILED',
		            Message: 'Failed to save employee'
		        };
		    }
		
		    // Example: Run a user-defined query
		    const queryResult = await md.RunQuery('SELECT * FROM vwContacts WHERE CompanyID = 1234', ContextUser);
		
		    // Check if query executed successfully
		    if (!queryResult.Success) {
		        return {
		            Success: false,
		            ResultCode: 'QUERY_EXECUTION_FAILED',
		            Message: 'Failed to execute query'
		        };
		    }
		
		    // Example: Fetch multiple user views linked to a category
		    const userViewsView = new RunView();
		    const userViewsResult = await userViewsView.RunView({
		        EntityName: 'User Views',
		        ResultType: 'simple_object',
		        Filters: [{ Name: 'CategoryID', Value: 5678 }]
		    }, ContextUser);
		
		    // Check if user views were fetched successfully
		    if (!userViewsResult.Success) {
		        return {
		            Success: false,
		            ResultCode: 'USER_VIEWS_FETCH_FAILED',
		            Message: 'Failed to fetch user views'
		        };
		    }
		
		    return {
		        Success: true,
		        ResultCode: 'ACTION_COMPLETED',
		        Message: 'Action executed successfully',
		        Outputs: [
		            new ActionParam({ Name: 'Companies', Value: companiesResult.Results }),
		            new ActionParam({ Name: 'Employee', Value: employeeRecord }),
		            new ActionParam({ Name: 'QueryResult', Value: queryResult.Results }),
		            new ActionParam({ Name: 'UserViews', Value: userViewsResult.Results })
		        ]
		    };
		} catch (error) {
		    // Log the error (optional)
		    console.error('Action execution failed:', error);
		    return {
		        Success: false,
		        ResultCode: 'ACTION_FAILED',
		        Message: error.message
		    };
		}
    }
}        
            
            
export function LoadGeneratedActions() {
    // this function is a stub that is used to force the bundler to include the generated action classes in the final bundle and not tree shake them out
}
