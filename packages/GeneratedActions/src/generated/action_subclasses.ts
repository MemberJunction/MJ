/*************************************************
* GENERATED CODE - DO NOT MODIFY
* Generated by MemberJunction CodeGen at 5/31/2024, 8:56:40 PM
**************************************************/
import { ActionResultSimple, BaseAction, RunActionParams } from "@memberjunction/actions";
import { RegisterClass } from "@memberjunction/global";
import { Metadata, RunView, UserInfo, BaseEntity } from "@memberjunction/core";

            
/**
 * Validate Accounts
 * Generated Class
 * User Prompt: For the provided entity object, check to see if the Name property has a length of > 10. If it does, then make sure that it has a first letter of A, C, X, or Y. If the name is <= 10 in length then it can start only with O, P, or a number. 
 */
@RegisterClass(BaseAction, "Validate Accounts")
export class Validate_Accounts_Action extends BaseAction {
    /*
		The provided TypeScript code performs the following actions:
		
		1. Define a type `EntityObject` with a single property `Name` of type string.
		
		2. Extract the 'EntityObject' parameter from the input `params.Params` array.
		
		3. Check if the 'EntityObject' parameter is present and valid.
		
		4. Retrieve the name value from the 'EntityObject'.
		
		5. Validate the 'Name' property based on its length:
		
		    * If the length is greater than 10, ensure the name starts with 'A', 'C', 'X', or 'Y'.
		    * If the length is less than or equal to 10, ensure the name starts with 'O', 'P', or a numerical digit.
		
		6. If the validation fails, return an object indicating the failure along with an appropriate message.
		
		7. If the validation passes, return an object indicating success.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        type EntityObject = { Name: string };
		
		// Extract the 'EntityObject' from params array
		const entityParam = params.Params.find(p => p.Name === "EntityObject");
		
		if (!entityParam || !entityParam.Value) {
		    return {
		        Success: false,
		        ResultCode: "INVALID_PARAMETER",
		        Message: "EntityObject parameter missing or invalid"
		    };
		}
		
		const entityObject = entityParam.Value as EntityObject;
		const name = entityObject.Name || "";
		
		// Validate the 'Name' property
		const isNameLengthValid = name.length > 10;
		const startsWithAllowedLetter = isNameLengthValid
		    ? /^[ACXY].*/.test(name)
		    : /^[OP0-9].*/.test(name);
		
		if (!startsWithAllowedLetter) {
		    return {
		        Success: false,
		        ResultCode: "NAME_VALIDATION_FAILED",
		        Message: isNameLengthValid ? "Name must start with A, C, X, or Y for names longer than 10 characters" : "Name must start with O, P, or a number for names equal to or shorter than 10 characters"
		    };
		}
		
		return {
		    Success: true,
		    ResultCode: "NAME_VALIDATION_SUCCESS",
		    Message: "Name validation passed"
		};
    }
}        
            
            
/**
 * Create New Action Category
 * Generated Class
 * User Prompt: When this action executes I want to create a new Action Category with a randomly selected name that is a combination of a color, an animal and a Canadian province
 */
@RegisterClass(BaseAction, "Create New Action Category")
export class Create_New_Action_Category_Action extends BaseAction {
    /*
		The provided code performs the following steps:
		
		* Defines three arrays containing lists of colors, animals, and Canadian provinces.
		
		* Defines a function `getRandomElement` to select a random element from an array.
		
		* Uses the `getRandomElement` function to randomly pick one color, one animal, and one province.
		
		* Combines the randomly selected elements into a string `randomCategoryName` with the format `'<Color> <Animal> of <Province>'`.
		
		* Creates a new action category using the `Metadata` object and setting the 'Name' and 'Description' fields of the new category entity.
		
		* Attempts to save the new category and checks if the save operation was successful.
		
		* Returns an appropriate success or failure response depending on the result of the save operation.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const colors = ['Red', 'Green', 'Blue', 'Yellow', 'Purple', 'Orange', 'Pink', 'Brown', 'Black', 'White'];
		const animals = ['Bear', 'Wolf', 'Eagle', 'Hawk', 'Salmon', 'Beaver', 'Fox', 'Moose', 'Lynx', 'Bison'];
		const provinces = ['Ontario', 'Quebec', 'British Columbia', 'Alberta', 'Manitoba', 'Saskatchewan', 'Nova Scotia', 'New Brunswick', 'Newfoundland and Labrador', 'Prince Edward Island'];
		
		function getRandomElement(arr: string[]): string {
		    return arr[Math.floor(Math.random() * arr.length)];
		}
		
		const randomColor = getRandomElement(colors);
		const randomAnimal = getRandomElement(animals);
		const randomProvince = getRandomElement(provinces);
		
		const randomCategoryName = `${randomColor} ${randomAnimal} of ${randomProvince}`;
		
		const metadata = new Metadata();
		const newCategory = await metadata.GetEntityObject('Action Categories', params.ContextUser);
		
		newCategory.Set('Name', randomCategoryName);
		newCategory.Set('Description', `Category created with random name: ${randomCategoryName}`);
		
		const saveResult = await newCategory.Save();
		
		if (!saveResult) {
		    return {
		        Success: false,
		        ResultCode: 'ERROR_SAVING_CATEGORY',
		        Message: 'Failed to save the new action category.'
		    };
		}
		
		return {
		    Success: true,
		    ResultCode: 'CATEGORY_CREATED',
		    Message: `New Action Category created: ${randomCategoryName}`
		};
    }
}        
            
            
/**
 * Create new User View record
 * Generated Class
 * User Prompt: Whenever this action is run, we're going to create a new User View record. We'll provide an input param with the name and another with desrcription. I want to have this action simply create a new User View. Then, after saving the view, run the view. We want to run this view by its ViewID which we can get after we create the new record. Then, return the results of the view in an output param called ViewResults
 */
@RegisterClass(BaseAction, "Create new User View record")
export class Create_new_User_View_record_Action extends BaseAction {
    /*
		The following code performs two main tasks: it creates a new 'User View' record using the provided name and description, then runs the new User View to get the results.
		
		* **Input Validation:**
		  - Retrieves the `name` and `description` parameters from the input.
		  - Validates that these parameters are present.
		  - Returns an error if the required input parameters are missing.
		
		* **Creating User View Record:**
		  - Uses `Metadata` to get an entity object for 'User Views'.
		  - Sets this objectâ€™s `Name` and `Description` fields using the retrieved `name` and `description` parameters.
		  - Saves the new entity.
		  - Returns an error if saving the record fails.
		
		* **Running the User View:**
		  - Retrieves the `ViewID` of the newly created `User View` record.
		  - Utilizes `RunView` to run the `User View` with the `ViewID` as a filter.
		  - Returns an error if running the view fails.
		
		* **Returning Results:**
		  - Constructs the success response, including the view results fetched by running the User View.
		
		In summary, the code ensures the creation and immediate execution of a 'User View' record, finally returning the results obtained from running the newly created view.
	*/
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        const nameParam = params.Params.find(param => param.Name === 'name');
		const descriptionParam = params.Params.find(param => param.Name === 'description');
		
		if (!nameParam || !descriptionParam) {
		    return {
		        Success: false,
		        ResultCode: 'MISSING_INPUT_PARAMS',
		        Message: 'Required input parameters not provided.'
		    };
		}
		
		const md = new Metadata();
		const userViewRecord = await md.GetEntityObject('User Views', params.ContextUser);
		
		userViewRecord.Set('Name', nameParam.Value);
		userViewRecord.Set('Description', descriptionParam.Value);
		
		const saveResult = await userViewRecord.Save();
		if (!saveResult) {
		    return {
		        Success: false,
		        ResultCode: 'SAVE_FAILED',
		        Message: 'Failed to save the User View record.'
		    };
		}
		
		const viewID = userViewRecord.Get('ViewID');
		const rv = new RunView();
		const runResult = await rv.RunView({
		    EntityName: 'User Views',
		    Filters: [{ Name: 'ViewID', Value: viewID }]
		}, params.ContextUser);
		
		if (!runResult.Success) {
		    return {
		        Success: false,
		        ResultCode: 'RUN_VIEW_FAILED',
		        Message: 'Failed to run the User View.'
		    };
		}
		
		return {
		    Success: true,
		    ResultCode: 'SUCCESS',
		    Message: 'User View created and run successfully.',
		    Outputs: [{
		        Name: 'ViewResults',
		        Value: runResult.Results
		    }]
		};
    }
}        
            
            
export function LoadGeneratedActions() {
    // this function is a stub that is used to force the bundler to include the generated action classes in the final bundle and not tree shake them out
}
