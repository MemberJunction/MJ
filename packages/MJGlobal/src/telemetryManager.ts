/**
 * TelemetryManager - Lightweight instrumentation system for tracking operation performance,
 * detecting patterns, and surfacing optimization opportunities.
 *
 * Features:
 * - Session-level event tracking for RunView, RunQuery, Engine, AI, Cache operations
 * - Pattern detection for identifying duplicate calls and optimization opportunities
 * - Pluggable analyzer system for custom analysis rules
 * - WarningManager integration for debounced console output
 * - Configurable via local storage for per-client settings
 *
 * @example
 * ```typescript
 * const tm = TelemetryManager.Instance;
 *
 * // Enable telemetry
 * tm.SetEnabled(true);
 *
 * // Track an operation
 * const eventId = tm.StartEvent('RunView', 'RunView.Execute', { EntityName: 'Users' });
 * // ... perform operation
 * tm.EndEvent(eventId);
 *
 * // Get patterns for analysis
 * const patterns = tm.GetPatterns({ category: 'RunView', minCount: 2 });
 * ```
 */

import { BaseSingleton, GetGlobalObjectStore } from '.';
import { WarningManager } from './warningManager';

// ============================================================================
// TYPES - Using union types per MJ style guide
// ============================================================================

/**
 * Telemetry detail levels - controls what information is captured
 */
export type TelemetryLevel = 'off' | 'basic' | 'standard' | 'verbose' | 'debug';

/**
 * Numeric mapping for level comparisons
 */
export const TelemetryLevelValue: Record<TelemetryLevel, number> = {
    'off': 0,
    'basic': 1,        // Timing only (operation, elapsed ms)
    'standard': 2,     // Timing + key params (entity, filter, etc.)
    'verbose': 3,      // + stack traces (cleaned)
    'debug': 4         // + memory snapshots before/after
};

/**
 * Categories of operations that can be tracked
 */
export type TelemetryCategory =
    | 'RunView'
    | 'RunQuery'
    | 'Engine'
    | 'Network'
    | 'AI'
    | 'Cache'
    | 'Custom';

/**
 * Severity levels for telemetry insights
 */
export type TelemetryInsightSeverity = 'info' | 'warning' | 'optimization';

// ============================================================================
// INTERFACES
// ============================================================================

/**
 * Configuration for the telemetry system
 */
export interface TelemetrySettings {
    /** Global on/off switch */
    enabled: boolean;
    /** Default detail level for all categories */
    level: TelemetryLevel;
    /** Per-category overrides */
    categoryOverrides: Partial<Record<TelemetryCategory, {
        enabled: boolean;
        level?: TelemetryLevel;
    }>>;
    /** Auto-trim settings for memory management */
    autoTrim: {
        enabled: boolean;
        maxEvents?: number;
        maxAgeMs?: number;
    };
    /** Duplicate detection settings */
    duplicateDetection: {
        enabled: boolean;
        windowMs: number;
    };
    /** Analyzer settings */
    analyzers: {
        enabled: boolean;
        dedupeWindowMs: number;
    };
}

/**
 * Memory snapshot for detailed tracking
 */
export interface MemorySnapshot {
    heapUsed: number;
    heapTotal: number;
    timestamp: number;
}

/**
 * A single telemetry event
 */
export interface TelemetryEvent {
    /** Unique event ID */
    id: string;
    /** Category of operation */
    category: TelemetryCategory;
    /** Specific operation name (e.g., 'RunView.Execute') */
    operation: string;
    /** Hash for duplicate detection */
    fingerprint: string;

    // Timing
    startTime: number;
    endTime?: number;
    elapsedMs?: number;

    // Context
    userId?: string;
    params: Record<string, unknown>;
    tags?: string[];

    // Optional detailed info (based on level)
    stackTrace?: string;
    memoryBefore?: MemorySnapshot;
    memoryAfter?: MemorySnapshot;

    // Hierarchy
    parentEventId?: string;
}

/**
 * Aggregated pattern for a specific operation fingerprint
 */
export interface TelemetryPattern {
    fingerprint: string;
    category: TelemetryCategory;
    operation: string;
    sampleParams: Record<string, unknown>;

    // Aggregates
    count: number;
    totalElapsedMs: number;
    avgElapsedMs: number;
    minElapsedMs: number;
    maxElapsedMs: number;

    // Call site tracking
    callerLocations: Map<string, number>;

    // Timing
    firstSeen: number;
    lastSeen: number;
    windowStartTime: number;
}

/**
 * Insight generated by an analyzer
 */
export interface TelemetryInsight {
    id: string;
    severity: TelemetryInsightSeverity;
    analyzerName: string;
    category: string;
    title: string;
    message: string;
    suggestion: string;
    relatedEventIds: string[];
    entityName?: string;
    metadata?: Record<string, unknown>;
    timestamp: number;
}

/**
 * Context provided to analyzers
 */
export interface TelemetryAnalyzerContext {
    /** Recent events (last N or time window) */
    recentEvents: TelemetryEvent[];
    /** Aggregated patterns */
    patterns: Map<string, TelemetryPattern>;
    /** Access to engine registry for cross-referencing */
    getEngineLoadedEntities(): Map<string, string[]>;
}

/**
 * Interface for pluggable analyzers
 */
export interface TelemetryAnalyzer {
    /** Unique name for this analyzer */
    name: string;
    /** Category for grouping warnings in UI */
    category: string;
    /** Analyze an event and optionally return an insight */
    analyze(event: TelemetryEvent, context: TelemetryAnalyzerContext): TelemetryInsight | null;
}

// ============================================================================
// BUILT-IN ANALYZERS
// ============================================================================

/**
 * Detects when RunView is called for an entity already loaded by an engine.
 * Suggests using the engine's cached data instead.
 *
 * Note: Skips RunView calls marked with _fromEngine=true, as these are
 * engine-initiated calls (e.g., BaseEngine loading its config entities).
 */
class EngineOverlapAnalyzer implements TelemetryAnalyzer {
    name = 'EngineOverlapAnalyzer';
    category = 'Optimization';

    analyze(event: TelemetryEvent, context: TelemetryAnalyzerContext): TelemetryInsight | null {
        if (event.category !== 'RunView') return null;

        // Skip engine-initiated RunView calls to avoid false positives
        // When an engine loads its entities, it uses RunView internally
        if (event.params._fromEngine) return null;

        const entityName = event.params.EntityName as string;
        if (!entityName) return null;

        const loadedEntities = context.getEngineLoadedEntities();
        const engines = loadedEntities.get(entityName);

        if (engines && engines.length > 0) {
            return {
                id: `engine-overlap-${event.id}`,
                severity: 'optimization',
                analyzerName: this.name,
                category: this.category,
                title: 'Entity Already in Engine',
                entityName,
                message: `RunView for "${entityName}" called, but this entity is already loaded by: ${engines.join(', ')}`,
                suggestion: `Consider using ${engines[0]} cached data instead of a separate RunView call`,
                relatedEventIds: [event.id],
                timestamp: Date.now()
            };
        }
        return null;
    }
}

/**
 * Detects when the same entity is queried multiple times with different filters.
 * Suggests creating an engine to centralize access.
 */
class SameEntityMultipleCallsAnalyzer implements TelemetryAnalyzer {
    name = 'SameEntityMultipleCallsAnalyzer';
    category = 'Optimization';

    analyze(event: TelemetryEvent, context: TelemetryAnalyzerContext): TelemetryInsight | null {
        if (event.category !== 'RunView') return null;

        const entityName = event.params.EntityName as string;
        if (!entityName) return null;

        // Count distinct RunViews for same entity in recent events
        const entityEvents = context.recentEvents.filter(
            e => e.category === 'RunView' && e.params.EntityName === entityName
        );

        // Get unique fingerprints (different filter/orderBy combinations)
        const uniqueFingerprints = new Set(entityEvents.map(e => e.fingerprint));

        if (uniqueFingerprints.size >= 3) {
            return {
                id: `multi-call-${entityName}-${Date.now()}`,
                severity: 'optimization',
                analyzerName: this.name,
                category: this.category,
                title: 'Multiple Queries for Same Entity',
                entityName,
                message: `Entity "${entityName}" queried ${entityEvents.length} times with ${uniqueFingerprints.size} different filter combinations`,
                suggestion: `Consider creating a dedicated engine to load and cache ${entityName} data centrally`,
                relatedEventIds: entityEvents.map(e => e.id),
                metadata: {
                    totalCalls: entityEvents.length,
                    uniqueVariations: uniqueFingerprints.size
                },
                timestamp: Date.now()
            };
        }
        return null;
    }
}

/**
 * Detects sequential RunView calls that could be batched with RunViews.
 */
class ParallelizationOpportunityAnalyzer implements TelemetryAnalyzer {
    name = 'ParallelizationOpportunityAnalyzer';
    category = 'Performance';

    private readonly SEQUENCE_THRESHOLD_MS = 100;

    analyze(event: TelemetryEvent, context: TelemetryAnalyzerContext): TelemetryInsight | null {
        if (event.category !== 'RunView') return null;

        // Find RunView events that completed just before this one started
        const recentSequential = context.recentEvents.filter(e => {
            if (e.category !== 'RunView') return false;
            if (e.id === event.id) return false;
            if (!e.endTime) return false;
            // Check if previous event ended shortly before this one started
            const gap = event.startTime - e.endTime;
            return gap >= 0 && gap < this.SEQUENCE_THRESHOLD_MS;
        });

        if (recentSequential.length >= 2) {
            const allEvents = [...recentSequential, event];
            return {
                id: `parallel-${event.id}`,
                severity: 'optimization',
                analyzerName: this.name,
                category: this.category,
                title: 'Sequential Queries Could Be Parallelized',
                message: `${allEvents.length} RunView calls executed sequentially`,
                suggestion: `Use RunViews (batch) to execute these queries in parallel for better performance`,
                relatedEventIds: allEvents.map(e => e.id),
                metadata: {
                    entities: allEvents.map(e => e.params.EntityName)
                },
                timestamp: Date.now()
            };
        }
        return null;
    }
}

/**
 * Detects exact duplicate RunView calls (same fingerprint).
 */
class DuplicateRunViewAnalyzer implements TelemetryAnalyzer {
    name = 'DuplicateRunViewAnalyzer';
    category = 'Redundancy';

    analyze(event: TelemetryEvent, context: TelemetryAnalyzerContext): TelemetryInsight | null {
        if (event.category !== 'RunView') return null;

        const pattern = context.patterns.get(event.fingerprint);
        if (pattern && pattern.count >= 2) {
            return {
                id: `duplicate-${event.fingerprint}-${Date.now()}`,
                severity: 'warning',
                analyzerName: this.name,
                category: this.category,
                title: 'Duplicate RunView Detected',
                entityName: event.params.EntityName as string,
                message: `Identical RunView (${event.params.EntityName}, same filter/orderBy) called ${pattern.count} times`,
                suggestion: `Cache the result or use an engine to avoid redundant database queries`,
                relatedEventIds: [event.id],
                metadata: {
                    callCount: pattern.count,
                    totalTimeMs: pattern.totalElapsedMs,
                    avgTimeMs: pattern.avgElapsedMs
                },
                timestamp: Date.now()
            };
        }
        return null;
    }
}

// ============================================================================
// CONSTANTS
// ============================================================================

const TELEMETRY_SETTINGS_KEY = '__MJ_TELEMETRY_SETTINGS__';

const DEFAULT_SETTINGS: TelemetrySettings = {
    enabled: false,
    level: 'standard',
    categoryOverrides: {},
    autoTrim: {
        enabled: true,
        maxEvents: 10000,
        maxAgeMs: 30 * 60 * 1000  // 30 minutes
    },
    duplicateDetection: {
        enabled: true,
        windowMs: 60 * 1000  // 1 minute
    },
    analyzers: {
        enabled: true,
        dedupeWindowMs: 30000  // 30 seconds
    }
};

// ============================================================================
// TELEMETRY MANAGER
// ============================================================================

/**
 * Singleton manager for telemetry tracking and analysis.
 *
 * Provides:
 * - Event recording for various operation types
 * - Pattern detection for identifying optimization opportunities
 * - Pluggable analyzer system for custom rules
 * - Integration with WarningManager for console output
 */
export class TelemetryManager extends BaseSingleton<TelemetryManager> {
    private _settings: TelemetrySettings;
    private _events: TelemetryEvent[] = [];
    private _patterns: Map<string, TelemetryPattern> = new Map();
    private _activeEvents: Map<string, TelemetryEvent> = new Map();

    // Analyzer infrastructure
    private _analyzers: TelemetryAnalyzer[] = [];
    private _insights: TelemetryInsight[] = [];
    private _insightDedupeWindow: Map<string, number> = new Map();

    /**
     * Returns the singleton instance of TelemetryManager
     */
    public static get Instance(): TelemetryManager {
        return super.getInstance<TelemetryManager>();
    }

    protected constructor() {
        super();
        this._settings = this.loadSettings();
        this.registerBuiltInAnalyzers();
    }

    // ========== CONFIGURATION ==========

    /**
     * Get a copy of current settings
     */
    public get Settings(): TelemetrySettings {
        return { ...this._settings };
    }

    /**
     * Update telemetry settings
     */
    public UpdateSettings(settings: Partial<TelemetrySettings>): void {
        this._settings = { ...this._settings, ...settings };
        this.saveSettings();
    }

    /**
     * Check if telemetry is globally enabled
     */
    public get IsEnabled(): boolean {
        return this._settings.enabled;
    }

    /**
     * Enable or disable telemetry globally
     */
    public SetEnabled(enabled: boolean): void {
        this._settings.enabled = enabled;
        this.saveSettings();
    }

    /**
     * Check if a specific category is enabled
     */
    public IsCategoryEnabled(category: TelemetryCategory): boolean {
        if (!this._settings.enabled) return false;
        const override = this._settings.categoryOverrides[category];
        return override?.enabled ?? true;
    }

    /**
     * Get the telemetry level for a specific category
     */
    public GetLevelForCategory(category: TelemetryCategory): TelemetryLevel {
        const override = this._settings.categoryOverrides[category];
        return override?.level ?? this._settings.level;
    }

    /**
     * Get the numeric value for a telemetry level
     */
    public GetLevelValue(level: TelemetryLevel): number {
        return TelemetryLevelValue[level];
    }

    // ========== EVENT RECORDING ==========

    /**
     * Start tracking an event. Returns event ID for later completion, or null if disabled.
     */
    public StartEvent(
        category: TelemetryCategory,
        operation: string,
        params: Record<string, unknown>,
        userId?: string
    ): string | null {
        if (!this.IsCategoryEnabled(category)) return null;

        const level = this.GetLevelForCategory(category);
        const levelValue = this.GetLevelValue(level);

        const event: TelemetryEvent = {
            id: this.generateId(),
            category,
            operation,
            fingerprint: this.generateFingerprint(category, operation, params),
            startTime: this.getTimestamp(),
            userId,
            params: levelValue >= TelemetryLevelValue['standard'] ? params : {},
            stackTrace: levelValue >= TelemetryLevelValue['verbose'] ? this.captureStackTrace() : undefined,
            memoryBefore: levelValue >= TelemetryLevelValue['debug'] ? this.captureMemory() : undefined
        };

        this._activeEvents.set(event.id, event);
        return event.id;
    }

    /**
     * Complete an event that was started with StartEvent
     */
    public EndEvent(eventId: string | null): TelemetryEvent | null {
        if (!eventId) return null;

        const event = this._activeEvents.get(eventId);
        if (!event) return null;

        this._activeEvents.delete(eventId);

        event.endTime = this.getTimestamp();
        event.elapsedMs = event.endTime - event.startTime;

        const level = this.GetLevelForCategory(event.category);
        if (this.GetLevelValue(level) >= TelemetryLevelValue['debug']) {
            event.memoryAfter = this.captureMemory();
        }

        this._events.push(event);
        this.updatePattern(event);
        this.runAnalyzers(event);
        this.trimIfNeeded();

        return event;
    }

    /**
     * Convenience method for recording a completed event directly
     */
    public RecordEvent(
        category: TelemetryCategory,
        operation: string,
        params: Record<string, unknown>,
        elapsedMs: number,
        userId?: string
    ): void {
        if (!this.IsCategoryEnabled(category)) return;

        const level = this.GetLevelForCategory(category);
        const levelValue = this.GetLevelValue(level);
        const now = this.getTimestamp();

        const event: TelemetryEvent = {
            id: this.generateId(),
            category,
            operation,
            fingerprint: this.generateFingerprint(category, operation, params),
            startTime: now - elapsedMs,
            endTime: now,
            elapsedMs,
            userId,
            params: levelValue >= TelemetryLevelValue['standard'] ? params : {},
            stackTrace: levelValue >= TelemetryLevelValue['verbose'] ? this.captureStackTrace() : undefined
        };

        this._events.push(event);
        this.updatePattern(event);
        this.runAnalyzers(event);
        this.trimIfNeeded();
    }

    // ========== PATTERN DETECTION ==========

    private updatePattern(event: TelemetryEvent): void {
        if (!this._settings.duplicateDetection.enabled) return;

        let pattern = this._patterns.get(event.fingerprint);
        const now = this.getTimestamp();

        if (!pattern) {
            pattern = {
                fingerprint: event.fingerprint,
                category: event.category,
                operation: event.operation,
                sampleParams: event.params,
                count: 0,
                totalElapsedMs: 0,
                avgElapsedMs: 0,
                minElapsedMs: Infinity,
                maxElapsedMs: 0,
                callerLocations: new Map(),
                firstSeen: now,
                lastSeen: now,
                windowStartTime: now
            };
            this._patterns.set(event.fingerprint, pattern);
        }

        // Reset window if expired
        if (now - pattern.windowStartTime > this._settings.duplicateDetection.windowMs) {
            pattern.count = 0;
            pattern.totalElapsedMs = 0;
            pattern.callerLocations.clear();
            pattern.windowStartTime = now;
        }

        // Update stats
        pattern.count++;
        pattern.lastSeen = now;
        if (event.elapsedMs != null) {
            pattern.totalElapsedMs += event.elapsedMs;
            pattern.avgElapsedMs = pattern.totalElapsedMs / pattern.count;
            pattern.minElapsedMs = Math.min(pattern.minElapsedMs, event.elapsedMs);
            pattern.maxElapsedMs = Math.max(pattern.maxElapsedMs, event.elapsedMs);
        }

        // Track call sites
        if (event.stackTrace) {
            const location = this.extractCallerLocation(event.stackTrace);
            pattern.callerLocations.set(
                location,
                (pattern.callerLocations.get(location) || 0) + 1
            );
        }
    }

    // ========== QUERIES ==========

    /**
     * Get events matching the filter criteria
     */
    public GetEvents(filter?: {
        category?: TelemetryCategory;
        operation?: string;
        minElapsedMs?: number;
        since?: number;
        limit?: number;
    }): TelemetryEvent[] {
        let results = [...this._events];

        if (filter?.category) {
            results = results.filter(e => e.category === filter.category);
        }
        if (filter?.operation) {
            results = results.filter(e => e.operation === filter.operation);
        }
        if (filter?.minElapsedMs != null) {
            results = results.filter(e => (e.elapsedMs ?? 0) >= filter.minElapsedMs!);
        }
        if (filter?.since != null) {
            results = results.filter(e => e.startTime >= filter.since!);
        }
        if (filter?.limit) {
            results = results.slice(-filter.limit);
        }

        return results;
    }

    /**
     * Get patterns matching the filter criteria
     */
    public GetPatterns(filter?: {
        category?: TelemetryCategory;
        minCount?: number;
        sortBy?: 'count' | 'totalTime' | 'avgTime';
    }): TelemetryPattern[] {
        let results = [...this._patterns.values()];

        if (filter?.category) {
            results = results.filter(p => p.category === filter.category);
        }
        if (filter?.minCount != null) {
            results = results.filter(p => p.count >= filter.minCount!);
        }

        const sortBy = filter?.sortBy ?? 'count';
        results.sort((a, b) => {
            switch (sortBy) {
                case 'count': return b.count - a.count;
                case 'totalTime': return b.totalElapsedMs - a.totalElapsedMs;
                case 'avgTime': return b.avgElapsedMs - a.avgElapsedMs;
            }
        });

        return results;
    }

    /**
     * Get patterns with duplicate calls (count >= minCount)
     */
    public GetDuplicates(minCount: number = 2): TelemetryPattern[] {
        return this.GetPatterns({ minCount, sortBy: 'count' });
    }

    /**
     * Get active events that haven't completed yet
     */
    public GetActiveEvents(): TelemetryEvent[] {
        return [...this._activeEvents.values()];
    }

    // ========== ANALYZER SYSTEM ==========

    private registerBuiltInAnalyzers(): void {
        this.RegisterAnalyzer(new EngineOverlapAnalyzer());
        this.RegisterAnalyzer(new SameEntityMultipleCallsAnalyzer());
        this.RegisterAnalyzer(new ParallelizationOpportunityAnalyzer());
        this.RegisterAnalyzer(new DuplicateRunViewAnalyzer());
    }

    /**
     * Register a custom analyzer
     */
    public RegisterAnalyzer(analyzer: TelemetryAnalyzer): void {
        this._analyzers.push(analyzer);
    }

    /**
     * Unregister an analyzer by name
     */
    public UnregisterAnalyzer(name: string): void {
        this._analyzers = this._analyzers.filter(a => a.name !== name);
    }

    /**
     * Get all registered analyzers
     */
    public GetAnalyzers(): TelemetryAnalyzer[] {
        return [...this._analyzers];
    }

    /**
     * Get insights matching the filter criteria
     */
    public GetInsights(filter?: {
        severity?: TelemetryInsightSeverity;
        category?: string;
        entityName?: string;
        limit?: number;
    }): TelemetryInsight[] {
        let results = [...this._insights];

        if (filter?.severity) {
            results = results.filter(i => i.severity === filter.severity);
        }
        if (filter?.category) {
            results = results.filter(i => i.category === filter.category);
        }
        if (filter?.entityName) {
            results = results.filter(i => i.entityName === filter.entityName);
        }
        if (filter?.limit) {
            results = results.slice(-filter.limit);
        }

        return results;
    }

    private runAnalyzers(event: TelemetryEvent): void {
        if (!this._settings.analyzers.enabled) return;

        const context = this.buildAnalyzerContext();

        for (const analyzer of this._analyzers) {
            try {
                const insight = analyzer.analyze(event, context);
                if (insight && this.shouldEmitInsight(insight)) {
                    this._insights.push(insight);
                    this.emitInsightWarning(insight);
                }
            } catch (error) {
                // Don't let analyzer errors break telemetry
                console.warn(`Telemetry analyzer ${analyzer.name} error:`, error);
            }
        }
    }

    private buildAnalyzerContext(): TelemetryAnalyzerContext {
        return {
            recentEvents: this._events.slice(-1000),
            patterns: this._patterns,
            getEngineLoadedEntities: () => {
                // Integration with BaseEngineRegistry
                const g = GetGlobalObjectStore();
                if (g && g.__MJ_ENGINE_REGISTRY__) {
                    return g.__MJ_ENGINE_REGISTRY__.GetEntityLoadTracking?.() || new Map();
                }
                return new Map();
            }
        };
    }

    private shouldEmitInsight(insight: TelemetryInsight): boolean {
        // Dedupe similar insights within a time window
        const dedupeKey = `${insight.analyzerName}:${insight.entityName || ''}:${insight.title}`;
        const lastEmit = this._insightDedupeWindow.get(dedupeKey);
        const now = Date.now();

        if (lastEmit && now - lastEmit < this._settings.analyzers.dedupeWindowMs) {
            return false;
        }

        this._insightDedupeWindow.set(dedupeKey, now);
        return true;
    }

    private emitInsightWarning(insight: TelemetryInsight): void {
        // Emit through WarningManager for console output
        this.recordTelemetryInsightToWarningManager(insight);
    }

    /**
     * Record a telemetry insight to the warning manager for debounced output
     */
    private recordTelemetryInsightToWarningManager(insight: TelemetryInsight): void {
        const config = WarningManager.Instance.GetConfig();
        if (config.DisableWarnings) return;

        const severityIcon = {
            'info': 'â„¹ï¸',
            'warning': 'âš ï¸',
            'optimization': 'ðŸ’¡'
        }[insight.severity];

        const message = `${severityIcon} [Telemetry/${insight.category}] ${insight.title}\n` +
            `   ${insight.message}\n` +
            `   ðŸ’¡ ${insight.suggestion}`;

        // Use console.info for telemetry insights to distinguish from warnings
        console.info(message);
    }

    // ========== UTILITIES ==========

    private generateId(): string {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }

    private generateFingerprint(
        category: TelemetryCategory,
        operation: string,
        params: Record<string, unknown>
    ): string {
        // Category-specific fingerprinting
        let keyParams: Record<string, unknown>;

        switch (category) {
            case 'RunView':
                keyParams = {
                    entity: (params.EntityName as string)?.toLowerCase().trim(),
                    filter: (params.ExtraFilter as string)?.toLowerCase().trim(),
                    orderBy: (params.OrderBy as string)?.toLowerCase().trim(),
                    resultType: params.ResultType
                };
                break;
            case 'RunQuery':
                keyParams = {
                    query: (params.SQL as string)?.toLowerCase().trim()
                };
                break;
            case 'Engine':
                keyParams = {
                    engine: params.engineClass,
                    operation: params.operation
                };
                break;
            default:
                keyParams = params;
        }

        return `${category}:${operation}:${JSON.stringify(keyParams)}`;
    }

    private captureStackTrace(): string {
        const stack = new Error().stack || '';
        return this.cleanStackTrace(stack);
    }

    private cleanStackTrace(stack: string): string {
        const lines = stack.split('\n');
        return lines
            .filter(line => {
                // Filter out noise
                if (line.includes('TelemetryManager')) return false;
                if (line.includes('node_modules')) return false;
                if (line.includes('webpack')) return false;
                if (line.includes('zone.js')) return false;
                if (line.includes('<anonymous>')) return false;
                return true;
            })
            .slice(0, 10)  // Limit depth
            .join('\n');
    }

    private extractCallerLocation(stack: string): string {
        const lines = stack.split('\n');
        // Return first meaningful line
        return lines[0] || 'unknown';
    }

    private captureMemory(): MemorySnapshot {
        // Node.js
        if (typeof process !== 'undefined' && process.memoryUsage) {
            const mem = process.memoryUsage();
            return {
                heapUsed: mem.heapUsed,
                heapTotal: mem.heapTotal,
                timestamp: Date.now()
            };
        }

        // Browser (Chrome only)
        if (typeof performance !== 'undefined') {
            const perfWithMemory = performance as Performance & { memory?: { usedJSHeapSize: number; totalJSHeapSize: number } };
            if (perfWithMemory.memory) {
                return {
                    heapUsed: perfWithMemory.memory.usedJSHeapSize,
                    heapTotal: perfWithMemory.memory.totalJSHeapSize,
                    timestamp: Date.now()
                };
            }
        }

        return { heapUsed: 0, heapTotal: 0, timestamp: Date.now() };
    }

    private getTimestamp(): number {
        // Use performance.now() if available for better precision
        if (typeof performance !== 'undefined' && performance.now) {
            return performance.now();
        }
        return Date.now();
    }

    private trimIfNeeded(): void {
        if (!this._settings.autoTrim.enabled) return;

        const { maxEvents, maxAgeMs } = this._settings.autoTrim;
        const now = this.getTimestamp();

        // Trim by age
        if (maxAgeMs) {
            this._events = this._events.filter(e => now - e.startTime < maxAgeMs);
        }

        // Trim by count
        if (maxEvents && this._events.length > maxEvents) {
            this._events = this._events.slice(-maxEvents);
        }
    }

    private loadSettings(): TelemetrySettings {
        try {
            // Use localStorage if available (browser), otherwise use global store
            if (typeof localStorage !== 'undefined') {
                const stored = localStorage.getItem(TELEMETRY_SETTINGS_KEY);
                if (stored) {
                    return { ...DEFAULT_SETTINGS, ...JSON.parse(stored) };
                }
            }
        } catch {
            // Ignore storage errors
        }
        return { ...DEFAULT_SETTINGS };
    }

    private saveSettings(): void {
        try {
            if (typeof localStorage !== 'undefined') {
                localStorage.setItem(TELEMETRY_SETTINGS_KEY, JSON.stringify(this._settings));
            }
        } catch {
            // Ignore storage errors
        }
    }

    // ========== CLEAR / RESET ==========

    /**
     * Clear all recorded events and patterns
     */
    public Clear(): void {
        this._events = [];
        this._patterns.clear();
        this._activeEvents.clear();
    }

    /**
     * Clear only patterns (keeps events)
     */
    public ClearPatterns(): void {
        this._patterns.clear();
    }

    /**
     * Clear insights
     */
    public ClearInsights(): void {
        this._insights = [];
        this._insightDedupeWindow.clear();
    }

    /**
     * Reset everything including settings
     */
    public Reset(): void {
        this.Clear();
        this.ClearInsights();
        this._settings = { ...DEFAULT_SETTINGS };
        this.saveSettings();
    }

    // ========== STATISTICS ==========

    /**
     * Get summary statistics
     */
    public GetStats(): {
        totalEvents: number;
        totalPatterns: number;
        totalInsights: number;
        activeEvents: number;
        byCategory: Record<TelemetryCategory, { events: number; avgMs: number }>;
    } {
        const byCategory: Record<TelemetryCategory, { events: number; totalMs: number }> = {
            RunView: { events: 0, totalMs: 0 },
            RunQuery: { events: 0, totalMs: 0 },
            Engine: { events: 0, totalMs: 0 },
            Network: { events: 0, totalMs: 0 },
            AI: { events: 0, totalMs: 0 },
            Cache: { events: 0, totalMs: 0 },
            Custom: { events: 0, totalMs: 0 }
        };

        for (const event of this._events) {
            byCategory[event.category].events++;
            byCategory[event.category].totalMs += event.elapsedMs || 0;
        }

        const byCategoryWithAvg: Record<TelemetryCategory, { events: number; avgMs: number }> = {} as Record<TelemetryCategory, { events: number; avgMs: number }>;
        for (const cat of Object.keys(byCategory) as TelemetryCategory[]) {
            const data = byCategory[cat];
            byCategoryWithAvg[cat] = {
                events: data.events,
                avgMs: data.events > 0 ? data.totalMs / data.events : 0
            };
        }

        return {
            totalEvents: this._events.length,
            totalPatterns: this._patterns.size,
            totalInsights: this._insights.length,
            activeEvents: this._activeEvents.size,
            byCategory: byCategoryWithAvg
        };
    }
}
