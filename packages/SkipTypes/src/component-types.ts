/**
 * @fileoverview Component interface types for Skip API
 * 
 * This file contains types that define the interface between Skip-generated components
 * and their container applications. These types enable rich, interactive components that
 * can communicate with the host MemberJunction environment. The types define:
 * 
 * - Component callback interfaces for parent-child communication (SkipComponentCallbacks)
 * - Component object interfaces that Skip components must implement (SkipComponentObject)
 * - Initialization parameters and utility interfaces (SkipComponentInitParams, SkipComponentUtilities)
 * - Styling and theming interfaces (SkipComponentStyles)
 * - Simplified metadata and data access interfaces (SimpleMetadata, SimpleRunView, SimpleRunQuery)
 * 
 * Components generated by Skip implement the SkipComponentObject interface and expose
 * themselves globally on the window object, allowing container applications to initialize,
 * refresh, and print them. The components can call back to the container through the provided
 * callback functions to refresh data, open records, update user state, and send custom events.
 * 
 * The utility interfaces provide Skip components with controlled access to the MemberJunction
 * system for dynamic data access, metadata queries, and view execution without requiring
 * full access to the underlying MJ APIs.
 * 
 * @author MemberJunction
 * @since 2.0.0
 */

import { CompositeKey } from "@memberjunction/core";
import { SimpleDataContext } from "./shared";
import { SimpleMetadata, SimpleRunQuery, SimpleRunView } from "./shared";

/**
 * This interface defines the available callback functions that a Skip component might call in the parent.
 */
export interface SkipComponentCallbacks {
    /**
     * The component can invoke this method in the callbacks object, when provided, to refresh the data context 
     * and that will in turn result in the component's init function being called again with the new data context.
     * @returns 
     */
    RefreshData: () => void;

    /**
     * If an action occurs inside a component where it would be desirable for the containing UI to open a specific 
     * record, if supported, this event can be listened to and the container UI can then open the record.
     * @param entityName - this is the Entity NAME from the Entity metadata, not the table name or base view name. Use Entity Metadata to provide the entity name here
     * @param key - this is an array of key/value pairs representing the primary key. The format of a Composite Key is an array of KeyValuePair objects and KeyValuePair objects simply have FieldName and Value properties. In most cases entities have single-valued primary keys but this structure is here for complex entity types that have composite primary keys
     * @returns 
     */
    OpenEntityRecord: (entityName: string, key: CompositeKey) => void;

    /**
     * This event should be raised by the HTML component whenever something changes within the component that should be tracked as a change in state
     * that will persist. userState is any valid, simple JavaScript object, meaning it can have scalars, arrays, objects, etc, it must be an object that 
     * can be serialized to JSON, but otherwise has no special requirements. The parent component will be responsible for tracking the user-specific states
     * and passing them back to the HTML component each time it is loaded or if the user changes via the init function.
     * @param userState 
     * @returns 
     */
    UpdateUserState: (userState: any) => void;

    /**
     * Used for any other type of event notification that a component might want to send to the parent component.
     * @param eventName 
     * @param eventData 
     * @returns 
     */
    NotifyEvent: (eventName: string, eventData: any) => void;
}

/**
 * This is the function signature for the initialization function provided by each Skip component via the SkipComponentObject so that a container can interact with it.
 * This function is called when the component is loaded by its container. The function receives the data context, an optional userState property, and a set of callbacks that can be used to interact with the parent component.
 * userState is an optional parameter that can be used to pass in any state information that the parent component wants to provide to the component that is specific
 * to the CURRENT user. If the component modifies the userState, it should notify the parent component via the UserStateChanged event in the callbacks object so that the parent component can handle storage.
 */
export type SkipComponentInitFunction = (params: SkipComponentInitParams) => void;

/**
 * This is the function signature for the print function that is provided by the component via the SkipComponentObject
 */
export type SkipComponentPrintFunction = () => void;
/**
 * This is the function signature for the refresh function that is provided by the component via the SkipComponentObject
 */
export type SkipComponentRefreshFunction = () => void;

/**
 * Parameters that are passed to the SkipComponentInitFunction when it is called by the parent component.
 */
export interface SkipComponentInitParams {
    data: SimpleDataContext;
    utilities?: SkipComponentUtilities;
    userState?: any;
    callbacks?: SkipComponentCallbacks;
    styles?: SkipComponentStyles;
}

/**
 * This interface defines styles that can be applied to the component. The container can provide
 * styles to the top level component. The top level component can alter these styles based on
 * the prompting of the user, learned notes, etc, and adjust the styles of the component accordingly. In addition
 * the top level component will pass in its computed styles to each sub-component so that the sub-components
 * can do the same recursively down to any level of depth. This allows sub-components to inherit styles but
 * also make adjustments as required based on functional needs and user input.
 */
export interface SkipComponentStyles {
    colors: {
        primary: string// '#2196f3',
        primaryHover: string // '#1976d2',
        secondary: string // '#757575',
        success: string // '#4caf50',
        background: string // '#ffffff',
        surface: string // '#f8f9fa',
        text: string //'#333333',
        textSecondary: string // '#656565',
        border: string // '#e2e8f0',
    };
    spacing: {
        xs: string // '4px',
        sm: string // '8px',
        md: string // '16px',
        lg: string // '24px',
        xl: string // '32px',
    };
    typography: {
        fontFamily: string //'-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
        fontSize: {
          sm: string // '14px',
          md: string // '16px',
          lg: string // '18px',
          xl: string // '24px'
        },
    };
    borders: {
        radius: string // '4px';
        width: string // '1px';
    }
    overflow: string
}

/**
 * This is the interface that each Skip component will expose to the parent component and assign it a name globally on the window object so that the parent component can call it.
 * The component will create this object and it will include the members defined in this interface.
 */
export interface SkipComponentObject {
    /**
     * The React component that Angular will render directly using ReactDOM.
     * This component receives props including data, userState, callbacks, utilities, and styles.
     */
    component: any; // really a React.ComponentType<RootComponentProps>;

    /**
     * The optional print function that is called when the user clicks on the print button in the parent of the component. This function will never be called by the parent before the init function so the print function
     * can assume the component has been initialized;
     */
    print?: SkipComponentPrintFunction;

    /**
     * The optional refresh function that is called when the user clicks on the refresh button in the parent of the component. This function will never be called by the parent before the init function so the refresh function
     */
    refresh?: SkipComponentRefreshFunction;
}

/**
 * This interface defines the utilities that are available to the Skip component. These utilities are used to interact with the host MemberJunction system to 
 * retrieve metadata, run views, and run queries. The utilities are passed into the SkipComponentInitFunction by the container.
 */
export interface SkipComponentUtilities {
    md: SimpleMetadata,
    rv: SimpleRunView,
    rq: SimpleRunQuery
}

/**
 * Defines a given option for a generated component that the user can choose. The code/componentObjectName properties are used to render the component in the UI.
 */
export type SkipComponentOption = {
    /**
     * Full details of the generated component option including functional, technical, code, and child componentry.
     */
    option: SkipComponentRootSpec;

    /**
     * If multiple component options are provided for a given @interface SkipAPIAnalysisCompleteResponse, a "judge" AI will evaluate all the functional
     * responses and will rank order them with an explanation of why they were each ranked that way. Rankings are not absolute, they are relative to the
     * # of components contained within an array of SkipComponentOption types.  
     */
    AIRank: number | undefined;
    /**
     * The AI's explanation of why it ranked the component the way it did. This is useful for understanding the AI's reasoning and can be used to improve future components 
     * as well as provide context to the user about why a particular component was chosen as the best option.
     */
    AIRankExplanation: string | undefined;
    /**
     * The user's provided feedback on the component option. Unlike the AIRank, this is a subjective rating provided by the user and is 
     * a number between 1 and 10, where 1 is the lowest rating and 10 is the highest rating.
     */
    UserRank: number | undefined;
    /**
     * If the host application provides a way for the user to provide feedback on the component option, 
     * this is the explanation of why the user rated the component the way they did if they provided feedback.
     */
    UserRankExplanation: string | undefined;
}

/**
 * Represents a complete specification for a generated Skip component, including its structure,
 * requirements, code, and nested component hierarchy
 */
export type SkipComponentRootSpec = {
    /**
     * A description of what the component should do from a functional perspective
     */
    functionalRequirements: string;
    
    /**
     * A technical description of how the component is designed and implemented
     */
    technicalDesign: string;
    
    /**
     * The actual code for the main component, typically wrapped in an IIFE that returns
     * the component object with component, print, and refresh properties
     */
    componentCode: string;
    
    /**
     * The name of the main component
     */
    componentName: string;
    
    /**
     * The type of component: report, dashboard, form, chart, table, or other. Over time this list
     * might grow to include more types as Skip evolves and new component types are needed.  
     */
    componentType: "report" | "dashboard" | "form" | "other",

    /**
     * The type of data access this component uses, static means that the data is provided to the component as static data during the initialization
     * process described in the @interface SkipComponentObject interface, dynamic means that the component will use capabilities provided by 
     * the SkipComponentObject interface to dynamically access data from the MemberJunction instance that it is running within. 'both' means
     * that the component can use both static and dynamic data access methods, and 'none' means that the component does not use any data (rare, but possible for example if
     * a component does something other than show data or if it uses 3rd party data sources via API that are not related to the MJ instance it is running within).
     */
    dataAccessType: 'static' | 'dynamic' | 'both' | 'none';    

    /**
     * A description of what this component does
     */
    description: string;
    
    /**
     * The callback strategy used by this component (e.g., "hybrid", "direct", "none")
     */
    callbackStrategy: string;
    
    /**
     * Describes the state structure managed by this component
     */
    stateStructure: Record<string, string>;
    
    /**
     * An array of child component specifications
     */
    childComponents: SkipComponentChildSpec[];
    
    /**
     * The title of the component
     */
    title: string;
    
    /**
     * A user-friendly explanation of what the component does
     */
    userExplanation: string;
    
    /**
     * A technical explanation of how the component works
     */
    techExplanation: string;
};
 

/**
 * Represents a child component within a component hierarchy
 */
export interface SkipComponentChildSpec {
    /**
     * The placeholder text used to identify where this component should be inserted
     */
    placeholder: string;
    
    /**
     * The programmatic name of the component
     */
    componentName: string;
 
    /**
     * The code for the child component. This is generated LATER by a separate process after the parent
     * component generation is complete. When the parent component generates this is undefined.
     */
    componentCode?: string;

    /**
     * A detailed description of what this child component does
     */
    description: string;
    
    /**
     * The path in the state tree where this component's state is stored
     */
    statePath: string;
    
    /**
     * An array of sub-components (recursive structure)
     */
    components: SkipComponentChildSpec[];
}