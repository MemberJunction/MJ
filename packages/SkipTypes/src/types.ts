import { CompositeKey } from '@memberjunction/core';
import { DataContext } from '@memberjunction/data-context';

/**
 * This type defines the shape of data that is passed back from the MJ API server to callers, typically the MJ Explorer UI
 */
export class MJAPISkipResult {
    /**
     * Indicates if the API request was successful or not, true if successful, false if not
     */
    Success: boolean;
  
    /**
     * Contains a more detailed status of the API request. This is typically used to provide additional information about the request, such as an error message if the request was not successful
     */
    Status: string; // required
  
    /**
     * The phase of the conversation, defined in the SkipResponsePhase type
     */
    ResponsePhase: SkipResponsePhase;

    /**
     * Contains the JSON data that is returned from the Skip API server. 
     * This can be a SkipAPIAnalysisCompleteResponse, SkipAPIClarifyingQuestionResponse, or SkipAPIDataRequestResponse.
     * To determine which type it is and to access the properties of the response, you will need to typecast 
     * this property to the appropriate type. For example:
     * 
     * if (result.ResponsePhase === 'analysis_complete') {
     *    // typecast the MJAPISkipResult object Result property
     *    const resultData = <SkipAPIAnalysisCompleteResponse>JSON.parse(result.Result);
     *    // now you can access the properties of the SkipAPIAnalysisCompleteResponse type in a strongly typed manner
     *    // and do whatever you want to do.
     * }
     */
    Result: string;
  
    /**
     * The MemberJunction Conversation ID assigned to this conversation. This is used to track the 
     * conversation in the database, used for conversation history, and will be generated by the MJ API server if
     * no existing Conversation ID was passed in with the request.
     */
    ConversationId: string;
  
    /**
     * The Conversation Detail ID for the inbound user message that was passed in with the request. 
     */
    UserMessageConversationDetailId: string;
  
    /**
     * The Conversation Detail ID for the outbound system message that was generated by the Skip API server, stored in the database by the MJ API server, 
     * and is being passed back here.
     */
    AIMessageConversationDetailId: string;
}


/**
 * Whenever Skip executes it's analysis phase, it uses a sandboxed sub-process to execute code securely and
 * this shape of data is used to communicate the results of that sub-process back to the Skip API server. 
 * This data type is in turn used within the SkipAPIAnalysisCompleteResponse type.
 */
export class SkipSubProcessResponse {
    status: "success" | "error";
    /**
     * For result types of data, this is the data that was returned from the sub-process to show in the table
     */
    tableData: any[] | null; // any array of objects
    /**
     * For result type of plot, this is the data that was returned from the sub-process to show in the plot
     */
    plotData: { data: any[]; layout: any } | null; // Compatible with Plotly
    /**
     * If the request failed, this is the error message that was returned from the sub-process.
     */
    errorMessage: string | null;
}


/**
 * Defines the shape of the conversations that can be passed back and forth with the Skip API Server - primarily used for the learning cycle process
 */
export class SkipConversation {
    /**
     * The unique identifier for the conversation
     */
    id: string;
    /**
     * The user-friendly name for the conversation
     */
    name: string;
    /**
     * The unique identifier for the user that the conversation is associated with
     */
    userId?: string;
    /**
     * The name of the user that the conversation is associated with
     */
    user?: string;

    /**
     * Optional, more detailed description of the conversation
     */
    description?: string;
    
    /**
     * Array of messages that make up the conversation in chronological order, showing the earliest messages first and the more recents messages last
     */
    messages: SkipMessage[];

    /**
     * Optional, this is an array of artifacts that are associated with the conversation. The AI Agent can request to add new artifacts during a response, this array is provided by the caller to ensure that the agent 
     * knows about existing artifacts/versions
     */
    artifacts?: SkipAPIArtifact[];

    /**
     * When the conversation was created 
     */
    createdAt: Date;
    /**
     * The date the conversation header record was last updated - this is NOT the same as the most recent conversation detail, for that interrogate the conversation details
     */
    updatedAt: Date;
}


/**
 * Defines the shape of the individual message that makes up the messages array that is passed back and 
 * forth with the Skip API Server
 */
export class SkipMessage {
    /**
     * The role of the message, either "user" or "system"
     */
    role: "user" | "system";
    /**
     * The content of the message, either the user's input or the system's response
     */
    content: string;
    /**
     * The conversation detail ID for the message, used to track the message
     */
    conversationDetailID: string;

    /**
     * If the message reflects an error message the information is provided here
     */
    error?: string;

    /**
     * hiddenToUser - this is true if a message is only for internal system puprose and not shown to a user
     */
    hiddenToUser?: boolean;

    /**
     * Rating scale between 1 and 10, 1 reflecting the lowest rating and 10 reflecting the highest rating from the user in terms of their satisfaction with the response
     */
    userRating?: number;
    
    /**
     * Optional, text feedback from the user reflecting their satisfaction with the response. Of course the subsequent messages can contain this, but this is an element that the UI will
     * surface that allows a user to specifically provide feedback on each message.
     */
    userFeedback?: string;

    /**
     * Optional, this text is from Skip during the generation of a particular response and represents the step-wise reasoning Skip went through to get to a particular response. This information along with the preceding messages, User Rating and User Feedback can
     * be very helpful during a learning cycle to build notes and other artifacts that can train Skip to learn more about the user/organization's preferences and the context of the conversation.
     */
    reflectionInsights?: string;

    /**
     * Optional, this text contains an AI generated summary of the prior messages in the conversation going back in time through the last such summary. This allows "compression" of a longer conversation to preserve space in a context window, improve performance and simplify
     * inference.
     */
    summaryOfEarlierConveration?: string;

    /**
     * The date and time the message was created
     */
    createdAt?: Date;
    /**
     * The date and time the message was last updated
     */
    updatedAt?: Date;
}



/**
 * For each Skip API Analysis result, it is possible for Skip to provide a set of tableDataColumns that describe the data that is being returned in this shape.
 */
export class SkipColumnInfo {
    fieldName: string;
    displayName: string;
    simpleDataType: 'string' | 'number' | 'date' | 'boolean';
    description: string;
}


/**
 * Describes the different request phases that are used to communicate with the Skip API Server
 * The phase of the conversation, defined as follows:
 * * initial_request: The initial request from the user - when a new conversation gets started or after a report is created, pass in this value
 * * clarify_question_response: Sometimes the Skip API server responds back to your request with a responsePhase of 'clarifying_question' - in this situation, the MJAPI server needs to communicate with the UI to ask the follow up question to the user. When you have that feedback from the user gathered and are providing the response to the clarifying question back to Skip API, use this requestPhase
 * * data_gathering_response: Sometimes the Skip API server responds back to your request with a responsePhase of 'data_request' - in this situation, the MJAPI server needs to process the data request, gather whatever additional data the Skip API has asked for, and then return it in the dataContext property of the SkipAPIRequest object. When you are finished gathering data and returning it to the Skip API server, use this requestPhase
 * * data_gathering_failure: When you send an API request to the Skip API server saying there was a data_gathering_failure that means that you attempted to retrieve data Skip requested but there was (typically) an error in the SQL statement that Skip generated and it needs to be regenerated. The MJAPI server code handles this scenario automatically.
 * * run_existing_script: Use this to run an existing script that was already processed. When this option is used, the script provided is run and the results are provided in the response.
 * * chat_with_a_record: This is used for the simple record chatting feature that is separate from other Skip API features. This is used for having a chat conversation with Skip about a specific record in the database that the user is typically looking at in a UI.
 */
export const SkipRequestPhase = {
    initial_request: 'initial_request',
    clarify_question_response: 'clarify_question_response',
    data_gathering_response: 'data_gathering_response',
    data_gathering_failure: 'data_gathering_failure',
    run_existing_script: 'run_existing_script',
    chat_with_a_record: 'chat_with_a_record'
} as const;
export type SkipRequestPhase = typeof SkipRequestPhase[keyof typeof SkipRequestPhase];

/**
 * Enumerates the possible values for a given field  
 */
export class SkipEntityFieldValueInfo {
    /**
     * Actual value for the possible value for the field
     */
    value: string;
    /**
     * Optional, the display value for the field value
     */
    displayValue?: string;
}

export class SkipEntityFieldInfo {
    entityID: string;
    sequence: number;
    name: string;
    displayName?: string;
    description?: string;
    isPrimaryKey: boolean;
    isUnique: boolean;
    category?: string;
    type: string;
    length: number;
    precision: number;
    scale: number;
    sqlFullType: string;
    allowsNull: boolean;
    defaultValue: string;
    autoIncrement: boolean;
    valueListType?: string;
    extendedType?: string;
    defaultInView: boolean;
    defaultColumnWidth: number;
    isVirtual: boolean;
    isNameField: boolean;
    relatedEntityID?: string;
    relatedEntityFieldName?: string;
    relatedEntity?: string;
    relatedEntitySchemaName?: string;
    relatedEntityBaseView?: string;

    possibleValues?: SkipEntityFieldValueInfo[];
}

export class SkipEntityRelationshipInfo {
    entityID: string;
    relatedEntityID: string;
    type: string;
    entityKeyField: string;
    relatedEntityJoinField: string;
    joinView: string;
    joinEntityJoinField: string;
    joinEntityInverseJoinField: string;
    entity: string;
    entityBaseView: string;
    relatedEntity: string;
    relatedEntityBaseView: string;
}

export class SkipEntityInfo {
    id: string;
    name!: string;
    description?: string;
    schemaName!: string;
    baseView!: string;
    fields: SkipEntityFieldInfo[] =[];
    relatedEntities: SkipEntityRelationshipInfo[] = [];

    /**
     * If rows packed is set to anything other than none, the data is provided in the rows property.
     */
    rowsPacked?: 'None' | 'Sample' | 'All' = 'None';
    /**
     * If rowsPacked === 'Sample', this additional property is used to indicate the method used to sample the rows
     */
    rowsSampleMethod?: 'random' | 'top n' | 'bottom n' = 'random';
    /**
     * Optional, the metadata can include an array of rows that can be used to provide context to Skip for the data that is being passed in. 
     */
    rows?: any[] = [];
}

export class SkipQueryInfo {
    id: string;
    name: string;
    description: string;
    categoryID: string;
    sql: string;
    originalSQL: string;
    feedback: string;
    status: 'Pending' | 'In-Review' | 'Approved' | 'Rejected' | 'Obsolete';
    qualityRank: number;
    createdAt: Date;
    updatedAt: Date;
    category: string;
    fields: SkipQueryFieldInfo[];
}

export class SkipLearningCycleQueryChange {
    query: SkipQueryInfo;
    changeType: 'add' | 'update' | 'delete';
}

export class SkipLearningCycleRequestChange {
    request: SkipAPIAgentRequest;
    changeType: 'add' | 'update' | 'delete';
}

export class SkipLearningCycleNoteChange {
    note: SkipAPIAgentNote;
    changeType: 'add' | 'update' | 'delete';
}

export class SkipQueryFieldInfo {
    name: string;
    queryID: string;
    description: string;
    sequence: number;
    /**
     * The base type, not including parameters, in SQL. For example this field would be nvarchar or decimal, and wouldn't include type parameters. The SQLFullType field provides that information.
     */
    sqlBaseType: string;
    /**
     * The full SQL type for the field, for example datetime or nvarchar(10) etc.
     */
    sqlFullType: string;
    sourceEntityID: string;
    sourceFieldName: string;
    isComputed: boolean;
    computationDescription: string;
    isSummary: boolean;
    summaryDescription: string;
    createdAt: Date;
    updatedAt: Date;
    sourceEntity: string;
}


export class SkipAPIRequestAPIKey {
    /**
     * These are the supported LLM vendors that Skip can use. These driver names map to the
     * registered classes in the MemberJunction AI namespace for example the @memberjunction/ai-openai package includes
     * a class called OpenAILLM that is registered with the MemberJunction AI system as a valid sub-class of BaseLLM
     */
    vendorDriverName: 'OpenAILLM' | 'MistralLLM' | 'GeminiLLM' | 'AnthropicLLM' | 'GroqLLM';
    /**
     * This is the actual API key for the specified vendor. 
     * NOTE: Skip NEVER stores this information, it is only used to make requests to the AI vendor of choice
     */
    apiKey: string;
}

/**
 * Defines the shape of the data that is expected by the Skip API Server when making a request
 */
export class SkipAPIRequest {
    /**
     * An array of 1 or more messages that are part of the conversation. The Skip API server will use these messages to understand the context of the conversation. 
     * When Skip responds to a request, he provides a messages array as well that will include the input messages as well as additional messages that he has generated as part of the conversation.
     * In future requests for the same conversation it is important to include ALL of the messages that have been part of the conversation so far, so that Skip can understand the full context of the conversation.
     */
    messages: SkipMessage[];

    /**
     * This is an optional string parameter where you can tell Skip anything you'd like to share about your organization, structure, database schema, and anything else
     * that might be helpful for him to be aware of. Keep in mind that this organizationInfo will be incorprorated into every request Skip makes to the underlying AI
     * services which can add cost and processing time to your requests. Including this information is extremely helpful as a very simple method of 
     * contextualizing Skip for your organization. In the Pro and above Skip plans, there are far more granular and effect methods of training Skip beyond this organizationInfo parameter, contact
     * the team at MemberJunction.com for more information if you're interested.
     */
    organizationInfo?: string;
    
    /**
     * The data context, use this to provide all of the data you have in a data context to Skip. You should provide this from cache or refreshed based on the parameters provided by the user.
     */
    dataContext: DataContext;
    /**
     * Summary entity metadata that is passed into the Skip Server so that Skip has knowledge of the schema of the calling MJAPI environment
     */
    entities: SkipEntityInfo[];
    /**
     * Stored queries in the MJ metadata that Skip can use and learn from
     */
    queries: SkipQueryInfo[];

    /**
     * The conversation ID
     */
    conversationID: string;
    /**
     * The organization ID - this is part of the Skip API Authentication Request, along with the bearer token in the header (the bearer token is not yet implemented, To-Do!)
     */
    organizationID: string;

    /**
     * The request phase, defined within the SkipRequestPhase type
     */
    requestPhase: SkipRequestPhase;

    /**
     * One or more API keys that are used for AI systems that Skip will access on behalf of the API caller
     * NOTE: This is not where you put in the bearer token for the Skip API server itself, that goes in the header of the request
     */
    apiKeys: SkipAPIRequestAPIKey[];

    /**
     * Optional, array of artifacts that already exist for the given conversation. 
     */
    artifacts?: SkipAPIArtifact[];

    /**
     * Optional notes that can be passed to Skip for additional context
     */
    notes?: SkipAPIAgentNote[];

    /**
     * Optional, list of the possible types of notes that an agent can store in the source MJ system
     */
    noteTypes?: SkipAPIAgentNoteType[];

    /**
     * Optional, if the calling server wants to enable the AI agent to call back to interact and request data or otherwise, this is the URL that the AI agent can use to call back to the source server
     */
    callingServerURL?: string

    /**
     * Optional, if the calling server wants to enable the AI agent to call back to interact and request data or otherwise, this is the API key that the AI agent can use to call back to the source server
     */
    callingServerAPIKey?: string

    /**
     * Optional, if the calling server requires the use of an additional short-lived access token beyond the API key, this is the token that the AI agent can use to call back to the source server during the lifecycle
     * of the request
     */
    callingServerAccessToken?: string
}


/**
 * Type that defines a possible note type from the source system that invoked Skip
 */
export class SkipAPIAgentNoteType {
    id: string;
    name: string;
    description: string;
}


/**
 * Whenever an agent is interested in getting human-in-the-loop style feedback/approval, this type is used
 */
export class SkipAPIAgentRequest {
    /**
     * The unique identifier for the request
     */
    id: string;

    /**
     * The unique identifier for the agent that made the request
     */
    agentId: string;
    /**
     * The name of the agent that made the request
     */
    agent: string;
    /**
     * The date and time the request was made
     */
    requestedAt: Date;
    /**
     * Optional, the unique identifier for the user that the request was made for by the Agent
     */
    requestForUserId?: string;
    /**
     * Only populated if the request was made for a user, the name of the user that the request was made for
     */
    requestForUser?: string;
    /**
     * Status of the request: 'Requested' | 'Approved' | 'Rejected' | 'Canceled'
     */
    status: 'Requested' | 'Approved' | 'Rejected' | 'Canceled';
    /**
     * Text body of the request the AI Agent is making
     */
    request: string;
    /**
     * Text body of the response that is being sent back to the AI Agent
     */
    response: string;
    /**
     * The unique identifier for the user that responded to the request
     */
    responseByUserId: string;
    /**
     * The name of the user that responded to the request
     */
    responseByUser: string;
    /**
     * The date and time the user responded to the request
     */
    respondedAt: Date;
    /**
     * Internal comments that are not intended to be shared with the AI Agent
     */
    comments: string;
    /**
     * The date and time the request record was created in the database
     */
    createdAt: Date;
    /**
     * The date and time the request record was last updated in the database
     */
    updatedAt: Date;
}

/**
 * Defines the shape of an individual Agent note that is stored in MJ that can be passed to Skip for additional context.
 */
export class SkipAPIAgentNote {
    /**
     * Unique identifier for the note
     */
    id: string;
    /**
     * Unique type id (UUID) for the note type, maps to a SkipAPIAgentNoteType that was passed in the SkipAPIRequest
     */
    agentNoteTypeId: string;
    /**
     * Text name for the note type
     */
    agentNoteType: string;
    /**
     * Date/Time the note was initially created
     */
    createdAt: Date;
    /**
     * Date/Time the note was last updated
     */
    updatedAt: Date;
    /**
     * The text of the note
     */
    note: string; 
    /**
     * This type field contains the scope of the note, either Global or User
     */
    type: 'User' | 'Global';
    /**
     * The unique identifier for the user that the note is associated with, only populated if type === 'User'
     */
    userId: string | null;
    /**
     * The name of the user that the note is associated with, only populated if type === 'User'
     */
    user: string | null;
}

export class SkipAPIRunScriptRequest extends SkipAPIRequest {
    /**
     * The script text to run
     */
    scriptText: string;
}

/**
 * Describes the different response phases that are used by the Skip API Server to respond back to the caller (usually the MJAPI server but can be anyone)
 * The response phase indicates if the Skip API server is asking for additional data, a clarifying question, or if the analysis is complete and the information has been provided
 * * clarifying_question: The Skip API server is asking for a clarifying question to be asked to the user - typecast the response to SkipAPIClarifyingQuestionResponse for all of the additional properties that are available in this response phase
 * * data_request: The Skip API server is asking for additional data to be gathered - typecast the response to SkipAPIDataRequestResponse for all of the additional properties that are available in this response phase
 * * analysis_complete: The Skip API server has completed the analysis and is providing the results - typecast the response to SkipAPIAnalysisCompleteResponse for all of the additional properties that are available in this response phase
 * * chat_with_a_record_complete: The Skip API server has completed the chat with a record and is providing the results - typecast the response to SkipAPIChatWithRecordResponse for all of the additional properties that are available in this response phase
 */
export const SkipResponsePhase = {
    status_update: "status_update",
    clarifying_question: "clarifying_question",
    data_request: "data_request",
    analysis_complete: "analysis_complete",
    chat_with_a_record_complete: "chat_with_a_record_complete"
} as const;
export type SkipResponsePhase = typeof SkipResponsePhase[keyof typeof SkipResponsePhase];


/**
 * Defines the shape of the data that is returned by the Skip API Server
 */
export class SkipAPIResponse {
    /**
     * Used for all response phases, to indicate if the API request was successful or not
     */
    success: boolean;
    /**
     * This property is only used if success is false, and contains an error message that describes the reason for the failure
     */
    error: string; 
    /**
     * The Skip API server response phase, defined within the SkipResponsePhase type
     */
    responsePhase: SkipResponsePhase;
    /**
     * An array of messages including the messaged passed in with the SkipAPIRequest object as well as 
     * any additional messages that Skip generates as part of the conversation.
     */
    messages: SkipMessage[];
}

/**
 * Defines an individual filter that will be used to filter the data in the view to the specific row or rows that the user clicked on for a drill down
 */
export class SkipAPIAnalysisDrillDownFilter {
    reportFieldName: string
    viewFieldName: string
}

/**
 * Defines the filtering information necessary for a reporting UI to enable behavior to drill down when a user clicks on a portion of a report like an element of a chart or a row in a table
 */
export class SkipAPIAnalysisDrillDown {
    /**
     * The name of the view in the database that we should drill into whenever a user clicks on an element in the report
     */
    viewName: string;
    /**
     * If the data context that was provided to Skip for generating a report had filtered data related to the drill down view noted in viewName property, then this
     * baseFilter value will be populated with a SQL filter that can be added to a WHERE clause with an AND statement to ensure that the filtering is inclusive of the 
     * data context's in-built filters.
     */
    baseFilter: string;
    /**
     * One or more filters that are used to filter the data in the view to the specific row or rows that the user clicked on
     */
    filters: SkipAPIAnalysisDrillDownFilter[];
}


/**
 * Defines the shape of the data that is returned by the Skip API Server when the responsePhase is 'chat_with_a_record_complete'
 */
export class SkipAPIChatWithRecordResponse extends SkipAPIResponse {
    /**
     * The response from the AI model regarding the user request
     */
    response: string
}

/**
 * Defines the shape of the data that is returned by the Skip API Server when the responsePhase is 'analysis_complete'
 */
export class SkipAPIAnalysisCompleteResponse extends SkipAPIResponse {
    /**
     * The data context that was passed in with the request, this is used to know the source data at the time the process was executed and for simple persistence.
     */
    dataContext: SimpleDataContext;
    /**
     * The type of report generated, data is a simple table, plot is a chart and html is a custom HTML report
     * For data/plot types, the results will be server-generated and available in the executionResults property
     * For html type, the executionResults will be null because the server generates an HTML report that is intended to run on the client.
     */
    resultType: "data" | "plot" | "html" | null;
    /**
     * The results of the execution of the sub-process to run the server-side script
     */
    executionResults?: SkipSubProcessResponse | null;
    /**
     * A user-friendly explanation of what the report does
     */
    userExplanation?: string;
    /**
     * A more detailed technical explanation of what the report does and how it works
     */
    techExplanation?: string;
    /**
     * Describes each column in the report's computed data output that is what is displayed in either a table or a chart
     */
    tableDataColumns?: SkipColumnInfo[];
    /**
     * Zero or more suggested questions that the AI engine suggests might be good follow up questions to ask after reviewing the provided report
     */
    suggestedQuestions?: string[] | null;
    /**
     * The title of the report
     */
    reportTitle?: string | null;
    /**
     * An analysis of the report, the data and the formatted report output.
     */
    analysis?: string | null;
    /**
     * Information that will support a drill-down experience in the reporting UI
     */
    drillDown?: SkipAPIAnalysisDrillDown | null;
    /**
     * The script text that was used to generated the report and can be saved to be run again later
     */
    scriptText?: string | null;
    /**
     * When provided, this array of data requests indicate to the caller of the Skip API that Skip was able to retrieve, on his own, additional data
     * BEYOND what was provided in the SkipAPIRequest object. The caller of the Skip API should update its internal representation of its data context
     * to include these new data items so that they will be run and provided to Skip for future iterations/requests and for re-running reports as well.
     */
    newDataItems?: SkipDataRequest[];

    /**
     * For result type of html, this is the HTML that was returned from the sub-process to show in the HTML report
     * This HTML is typically a combination of HTML, CSS and JavaScript all contained within a single DIV tag and 
     * designed to be embedded as a shadow DOM element within the container application's UI in the desired location
     * as chosen by the container application.
     * @deprecated - this is now part of an entry in the htmlReportOptions array, this property is deprecated and will be removed in a future version.
     */
    htmlReport: string | null;
    /**
     * For HTML Reports, the generation process must return not only the HTML itself stored in htmlReport, but also a globally unique
     * object name that is used to communicate with the HTML Report. This name will be a globally unique name that is used to identify the object
     * agains the global memory of the browser (e.g. the window object) and is used to communicate with the HTML report. The object will comply with the
     * @interface SkipHTMLReportObject interface and will be used to communicate with the HTML report.
     * 
     * Generally speaking, this object name will be provided to the AI system generating the code and use a UUIDv4 or similar approach that is 
     * modified to be a valid JavaScript function name. The AI generates the object within its HTML with this name. 
     * The object name is provided here in this property so that the container application for the custom HTML report can invoke it as needed.
     * @deprecated - this is now part of an entry in the htmlReportOptions array, this property is deprecated and will be removed in a future version.
     */
    htmlReportObjectName: string | null;

    /**
     * Contains a list of all the possible HTML reports that were generated (1 or more) for the given request.
     */
    htmlReportOptions?: SkipHTMLReportOption[];

    /**
     * If the AI Agent decides it would be best to display the result in an artifact, this information can be used by the calling application to properly
     * associate this specific response with the artifact that is being created. This is typically used for output that is likely to have iterations where 
     * artifacts are a clean way of managing a UI in the calling application where you can show multiple versions/etc.
     */
    artifactRequest?: SkipAPIArtifactRequest;
}

/**
 * Defines a given option for an HTML report that the user can choose. The htmlReport/htmlReportObjectName properties are used to render the HTML report in the UI.
 */
export type SkipHTMLReportOption = {
    /**
     * This code is typically a combination of HTML, CSS and JavaScript all contained within a single DIV tag and 
     * designed to be embedded within the container application's UI in the desired location
     * as chosen by the container application.
     */
    reportCode: string;

    /**
     * For HTML Reports, the generation process must return not only the HTML itself stored in htmlReport, but also a globally unique
     * object name that is used to communicate with the HTML Report. This name will be a globally unique name that is used to identify the object
     * agains the global memory of the browser (e.g. the window object) and is used to communicate with the HTML report. The object will comply with the
     * @interface SkipHTMLReportObject interface and will be used to communicate with the HTML report.
     * 
     * Generally speaking, this object name will be provided to the AI system generating the code and use a UUIDv4 or similar approach that is 
     * modified to be a valid JavaScript function name. The AI generates the object within its HTML with this name. 
     * The object name is provided here in this property so that the container application for the custom HTML report can invoke it as needed.
     */
    reportObjectName: string;

    /**
     * The type of data access this report uses, static means that the data is provided to the report as static data during the initialization
     * process described in the @interface SkipHTMLReportObject interface, dynamic means that the report will use capabilities provided by 
     * the SkipHTMLReportObject interface to dynamically access data from the MemberJunction instance that it is running within. 'both' means
     * that the report can use both static and dynamic data access methods, and 'none' means that the report does not use any data (rare, but possible for example if
     * a report does something other than show data or if it is uses 3rd party data sources via API that are not related to the MJ instance it is running within).
     */
    dataAccessType: 'static' | 'dynamic' | 'both' | 'none';

    /**
     * If multiple report options are provided for a given @interface SkipAPIAnalysisCompleteResponse, a "judge" AI will evaluate all the functional
     * responses and will rank order them with an explanation of why they were each ranked that way. Rankings are not absolute, they are relative to the
     * # of reports contained within an array of SkipHTMLReportOption types.  
     */
    AIRank: number | undefined;
    /**
     * The AI's explanation of why it ranked the report the way it did. This is useful for understanding the AI's reasoning and can be used to improve future reports 
     * as well as provide context to the user about why a particular report was chosen as the best option.
     */
    AIRankExplanation: string | undefined;
    /**
     * The user's provided feedback on the report option. Unlike the AIRank, this is a subjective rating provided by the user and is 
     * a number between 1 and 10, where 1 is the lowest rating and 10 is the highest rating.
     */
    UserRank: number | undefined;
    /**
     * If the host application provides a way for the user to provide feedback on the report option, 
     * this is the explanation of why the user rated the report the way they did if they provided feedback.
     */
    UserRankExplanation: string | undefined;
}

/**
 * Defines the shape of the data that is used to request an artifact from the Skip API Server
 */
export type SkipAPIArtifactRequest = {
    /**
     * The agent should request new_artifact if an entirely new artifact should be created. This should be selected if there are no existing artifacts in the 
     * conversation, OR if the user has asked for something that is not logically related to existing artifacts for the given conversation and it makes more
     * sense to create a new artifact entirely.
     * 
     * new_artifact_version, on the other hand, should be used when the user has asked for something that is logically related to an existing artifact and it is
     * most logical to add a new version to that existing artifact for example iterating on various versions of a report over time.
     */
    action: "new_artifact" | "new_artifact_version";

    /**
     * This is only provided when action === 'new_artifact_version' and is used to indicate the artifact that a new version is being added to. When action == 'new_artifact'
     * this property is not used.
     */
    artifactId?: string;
    
    /**
     * The name of the artifact or artifact version that is being created. Generated by the AI agent.
     */
    name: string;
    /**
     * The description of the artifact or artifact version that is being created. Generated by the AI agent.
     */
    description: string;
}

/**
 * Defines the shape of the data that is returned by the Skip API Server when the responsePhase is 'clarifying_question'
 */
export class SkipAPIClarifyingQuestionResponse extends SkipAPIResponse {
    /**
     * The question to display to the user from the AI model after a request is made to the AI when the AI needs more information to process the request
     */
    clarifyingQuestion: string;
    /**
     * Zero or more suggested answers that the AI model suggests might be good responses to the clarifying question
     */
    suggestedAnswers: string[];
}

/**
 * Defines the shape of the data that is returned by the Skip API Server when the responsePhase is 'data_request'
 */
export class SkipAPIDataRequestResponse extends SkipAPIResponse {
    dataRequest: SkipDataRequest[];
}


/**
 * Describes the different types of data requests the Skip API server can make for additional data.
 * * sql: The Skip API server is asking for additional data to be gathered using a fully executable SQL statement
 * * stored_query: The Skip API server is asking for additional data to be gathered using a stored query that is defined in the system within the Queries entity.
 */
export const SkipDataRequestType = {
    sql: "sql",
    stored_query: "stored_query"
} as const;
export type SkipDataRequestType = typeof SkipDataRequestType[keyof typeof SkipDataRequestType];

  
/**
 * This type is used to define the requested data whenever the Skip API server asks for additional data to be gathered
 */
export class SkipDataRequest {
    /**
     * The type of request, as defined in the `SkipDataRequestType` type
     */
    type!: SkipDataRequestType;
    /**
     * The text of the request - either a fully executable SQL statement or the name of a stored query
     */
    text!: string;
    /**
     * A description of the request, why it was requested, and what it is expected to provide
     */
    description?: string;
}


/**
 * API Request shape to ask the /learn end point to learn from conversation history and pass back "notes" that can be stored in the database for future requests
 */
export class SkipAPILearningCycleRequest {
    /**
     * OrganizationID for Skip to identify the organization
     */
    organizationId: string

    /**
     * This is an optional string parameter where you can tell Skip anything you'd like to share about your organization, structure, database schema, and anything else
     * that might be helpful for him to be aware of. Keep in mind that this organizationInfo will be incorprorated into every request Skip makes to the underlying AI
     * services which can add cost and processing time to your requests. Including this information is extremely helpful as a very simple method of 
     * contextualizing Skip for your organization. In the Pro and above Skip plans, there are far more granular and effect methods of training Skip beyond this organizationInfo parameter, contact
     * the team at MemberJunction.com for more information if you're interested.
     */
    organizationInfo?: string;

     /**
     * Learning Cycle ID is a unique identifier from the MJ AI Agent Learning Cycles table that will track the details of the API calls and the results for logging purposes and 
     * also to track the timestamps for each run to batch the conversations that are being sent
     */
    learningCycleId: string;

    /**
     * An array of conversations that have taken place since the last learning cycle
     */
    newConversations: SkipConversation[];

    /**
     * Summary entity metadata that is passed into the Skip Server so that Skip has knowledge of the schema of the calling MJAPI environment
     */
    entities: SkipEntityInfo[];

    /**
     * Stored queries in the MJ metadata that Skip can use and learn from
     */
    queries: SkipQueryInfo[];

    /**
     * An array of notes that have been generated by the Skip API server during the learning cycle process in the past
     */
    notes: SkipAPIAgentNote[];

    /**
     * An array of the possible note types that can be stored in the source MJ system
     */
    noteTypes: SkipAPIAgentNoteType[];

    /**
     * An array of the requests that Skip has previously made. Full history provided including requests of all status conditions.
     */
    requests: SkipAPIAgentRequest[];

    /**
     * Optional, the date/time of the last learning cycle performed on this dataset
     */
    lastLearningCycleDate: Date;

    /**
     * One or more API keys that are used for AI systems that Skip will access on behalf of the API caller
     * NOTE: This is not where you put in the bearer token for the Skip API server itself, that goes in the header of the request
     */
    apiKeys: SkipAPIRequestAPIKey[];
}

/**
 * API Response shape to ask the /learn end point to learn from conversation history and pass back "notes", an array of notes are provided that should be stored in the database
 * to then be passed into future Skip API requests for analysis/etc.
 */
export class SkipAPILearningCycleResponse {
    /**
     * Indicates if the learning cycle was successful or not
     */
    success: boolean;

    /**
     * If a learning cycle is skipped because there is no new conversation data to learn from, this property will be set to true
     */
    learningCycleSkipped?: boolean;

    /** 
     * If the learning cycle was not successful, this property will contain an error message that describes the reason for the failure
     */
    error?: string;
 
    /**
     * The number of milliseconds that have elapsed since the learning cycle process started
     */
    elapsedTime: number;
    
    /**
     * The notes that were generated by the Skip API server during the learning cycle process
     */
    noteChanges: SkipLearningCycleNoteChange[];

    /**
     * This provides an array of changes requested by Skip to the MJ database for queries, adding, updating and/or deleting.
     */
    queryChanges: SkipLearningCycleQueryChange[];

    /**
     * This array should be populated by the agent with any changes to requests - deleting existing requests that have not been responded to yet and for whatever reason are not relevant anymore, updating existing requests that haven't yet been responded to, and adding new requests to help the agent learn.
     */
    requestChanges: SkipLearningCycleRequestChange[];
}



/**
 * This interface defines the available callback functions that a Skip HTML report might call in the parent.
 */
export interface SkipHTMLReportCallbacks {
    /**
     * The HTML Report can invoke this method in the callbacks object, when provided, to refresh the data context 
     * and that will in turn result in the HTML Report's init function being called again with the new data context.
     * @returns 
     */
    RefreshData: () => void;

    /**
     * If an action occurs inside an HTML Report where it would be desirable for the containing UI to open a specific 
     * record, if supported, this event can be listened to and the container UI can then open the record.
     * @param entityName - this is the Entity NAME from the Entity metadata, not the table name or base view name. Use Entity Metadata to provide the entity name here
     * @param key - this is an array of key/value pairs representing the primary key. The format of a Composite Key is an array of KeyValuePair objects and KeyValuePair objects simply have FieldName and Value properties. In most cases entities have single-valued primary keys but this structure is here for complex entity types that have composite primary keys
     * @returns 
     */
    OpenEntityRecord: (entityName: string, key: CompositeKey) => void;

    /**
     * This event should be raised by the HTML component whenever something changes within the component that should be tracked as a change in state
     * that will persist. userState is any valid, simple JavaScript object, meaning it can have scalars, arrays, objects, etc, it must be an object that 
     * can be serialized to JSON, but otherwise has no special requirements. The parent component will be responsible for tracking the user-specific states
     * and passing them back to the HTML component each time it is loaded or if the user changes via the init function.
     * @param userState 
     * @returns 
     */
    UpdateUserState: (userState: any) => void;

    /**
     * Used for any other type of event notification that an HTML Report might want to send to the parent component.
     * @param eventName 
     * @param eventData 
     * @returns 
     */
    NotifyEvent: (eventName: string, eventData: any) => void;
}

/**
 * This is the function signature for the initialization function provided by each HTML report via the SkipHTMLReportObject so that a container can interact with it.
 * This function is called when the HTML report is loaded by its container. The function receives the data context, an optional userState property, and a set of callbacks that can be used to interact with the parent component.
 * userState is an optional parameter that can be used to pass in any state information that the parent component wants to provide to the HTML report that is specific
 * to the CURRENT user. If the component modifies the userState, it should notify the parent component via the UserStateChanged event in the callbacks object so that the parent component can handle storage.
 */
export type SkipHTMLReportInitFunction = (data: SimpleDataContext, userState?: any, callbacks?: SkipHTMLReportCallbacks) => void;

/**
 * This is the function signature for the print function that is provided by the HTML report via the SkipHTMLReportObject
 */
export type SkipHTMLReportPrintFunction = () => void;
/**
 * This is the function signature for the refresh function that is provided by the HTML report via the SkipHTMLReportObject
 */
export type SkipHTMLReportRefreshFunction = () => void;

/**
 * This is the interface that each HTML report will expose to the parent component and assign it a name globally on the window object so that the parent component can call it.
 * The HTML report will create this object and it will include the members defined in this interface.
 */
export interface SkipHTMLReportObject {
    /**
     * The required init function that is called when the HTML report is loaded. This function is passed the data context and a set of callbacks that can be used to interact with the parent component.
     */
    init: SkipHTMLReportInitFunction;

    /**
     * The optional print function that is called when the user clicks on the print button in the parent of the HTML report. This function will never be called by the parent before the init function so the print function
     * can assume the report has been initialized;
     */
    print?: SkipHTMLReportPrintFunction;

    /**
     * The optional refresh function that is called when the user clicks on the refresh button in the parent of the HTML report. This function will never be called by the parent before the init function so the refresh function
     */
    refresh?: SkipHTMLReportRefreshFunction;
}
/**
 * This is a simple data context object that is passed into the SkipHTMLReportInitFunction, it contains a property for each of the data context items and typically are named
 * data_item_1, data_item_2, etc. The data context is a simple JavaScript object that contains properties that are in turn data objects which are typically arrays of things, but can be anything.
 */
export type SimpleDataContext = {
    [key: string]: any;
}


/**
 * Defines information about a single artifact type
 */
export type SkipAPIArtifactType = {
    id: string;
    name: string;
    description: string;
    /**
     * MIME type or content identifier for this artifact type
     */
    contentType: string;
    enabled: boolean;
    createdAt: Date;
    updatedAt: Date;
}

export type SkipAPIArtifactVersion = {
    /**
     * Primary key for the artifact version - globally unique
     */
    id: string;
    /**
     * Foreign key to the related artifact - not using a link to the object here to avoid circular references
     */
    artifactId: string; 
    /**
     * Auto increment sequential version, start with 1 for each artifact
     */
    version: number;
    /**
     * The contents of this field are dependent on the artifact type, in some cases it might be unused, in others it might be JSON, plain text, or even base-64 encoded binary data for something like an image
     */
    configuration: string;
    /**
     * The contents of this field are dependent on the artifact type, in some cases it might be unused, in others it might be JSON, plain text, or even base-64 encoded binary data for something like an image
     */
    content: string;
    /**
     * User comments for this specific version of the artifact, used for user's own purposes and can be used as feedback loop for AI to learn from and improve future versions/responses.
     */
    comments: string;
    createdAt: Date;
    updatedAt: Date;
}

export type SkipAPIArtifact = {
    /**
     * Primary key for the artifact
     */
    id: string;
    /**
     * AI generated name for the artifact
     */
    name: string;
    /**
     * AI generated description for the artifact
     * This is a short description of the artifact that is generated by the AI system and is used to provide context for the artifact
     */
    description: string;
    /**
     * Foreign key to the related conversation
     */
    conversationId: string;

    /**
     * Related artifact type
     */
    artifactType: SkipAPIArtifactType;

    /**
     * Defines the level of sharing the owner of this artifact (which is the owner of the related conversation) has selected for this artifact
     */
    sharingScope: 'None' |'SpecificUsers' |'Everyone' |'Public';

    /**
     * Comments from the user about the artifact
     */
    comments: string;

    /**
     * Array of versions of this artifact
     * This is a one-to-many relationship, where each artifact can have multiple versions
     */
    versions: SkipAPIArtifactVersion[];

    createdAt: Date;
    updatedAt: Date;
}