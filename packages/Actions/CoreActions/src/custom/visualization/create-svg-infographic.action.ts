import { ActionResultSimple, RunActionParams } from '@memberjunction/actions-base';
import { BaseAction } from '@memberjunction/actions';
import { RegisterClass } from '@memberjunction/global';
import { JSDOM } from 'jsdom';
import { SVGActionResult, ViewBox, Branding } from './shared/svg-types';
import { SVGUtils } from './shared/svg-utils';
import { getPalette, generateCSS, getFontSpec } from './shared/svg-theming';

/**
 * Panel specification for infographic composition
 */
interface PanelSpec {
    /** SVG content to embed */
    svg: string;
    /** Column span (1-12) */
    colSpan?: number;
    /** Row span */
    rowSpan?: number;
    /** Panel title (optional) */
    title?: string;
}

/**
 * Infographic specification
 */
interface InfographicSpec {
    /** Array of SVG panels */
    panels: PanelSpec[];
    /** Number of columns in grid (default: 2) */
    columns?: number;
    /** Infographic title (optional) */
    title?: string;
    /** Infographic subtitle/description (optional) */
    subtitle?: string;
    /** Footer text (optional) */
    footer?: string;
    /** Width of final infographic */
    width?: number;
    /** Color palette */
    palette?: string;
}

/**
 * Action that composes multiple SVG visualizations into a single infographic.
 *
 * This action takes multiple SVG panels and arranges them in a grid layout with
 * optional header, footer, and styling. Designed for AI agents to create comprehensive
 * visual reports combining multiple charts, diagrams, and networks.
 *
 * @example
 * ```typescript
 * await runAction({
 *   ActionName: 'Create SVG Infographic',
 *   Params: [
 *     {
 *       Name: 'Spec',
 *       Value: JSON.stringify({
 *         title: 'Q4 2024 Analysis Report',
 *         subtitle: 'Performance Metrics and Trends',
 *         columns: 2,
 *         panels: [
 *           {
 *             svg: '<svg>...</svg>',  // From Create SVG Chart action
 *             title: 'Revenue by Quarter',
 *             colSpan: 1
 *           },
 *           {
 *             svg: '<svg>...</svg>',  // From Create SVG Diagram action
 *             title: 'Organization Structure',
 *             colSpan: 1
 *           }
 *         ],
 *         footer: 'Generated by MemberJunction Infographic System'
 *       })
 *     }
 *   ]
 * });
 * ```
 */
@RegisterClass(BaseAction, '__CreateSVGInfographic')
export class CreateSVGInfographicAction extends BaseAction {
    /**
     * Generates an SVG infographic from multiple panels
     *
     * @param params - The action parameters containing:
     *   - Spec: JSON specification of the infographic (InfographicSpec)
     *
     * @returns A promise resolving to an SVGActionResult
     */
    protected async InternalRunAction(params: RunActionParams): Promise<SVGActionResult> {
        try {
            const specParam = this.getParamValue(params, 'Spec');

            if (!specParam) {
                return {
                    Success: false,
                    Message: 'Spec parameter is required',
                    ResultCode: 'MISSING_PARAMETERS',
                };
            }

            const spec: InfographicSpec = this.parseJSON<InfographicSpec>(specParam, 'Spec');

            if (!spec.panels || spec.panels.length === 0) {
                return {
                    Success: false,
                    Message: 'Spec must contain at least one panel',
                    ResultCode: 'MISSING_PANELS',
                };
            }

            const columns = spec.columns || 2;
            const width = spec.width || 1200;
            const paletteName = spec.palette || 'mjDefault';

            // Create branding configuration
            const branding: Branding = {
                palette: { type: 'named', name: paletteName as any },
            };

            // Calculate layout
            const gutterSize = 20;
            const headerHeight = spec.title ? (spec.subtitle ? 100 : 60) : 0;
            const footerHeight = spec.footer ? 40 : 0;
            const panelTitleHeight = 30;

            // Calculate panel dimensions
            const availableWidth = width - gutterSize * (columns + 1);
            const panelWidth = availableWidth / columns;

            // Arrange panels in grid
            const rows: PanelSpec[][] = [];
            let currentRow: PanelSpec[] = [];
            let currentRowCols = 0;

            for (const panel of spec.panels) {
                const colSpan = Math.min(panel.colSpan || 1, columns);

                if (currentRowCols + colSpan > columns) {
                    // Start new row
                    rows.push(currentRow);
                    currentRow = [];
                    currentRowCols = 0;
                }

                currentRow.push({ ...panel, colSpan });
                currentRowCols += colSpan;
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            // Calculate total height
            let currentY = gutterSize + headerHeight;
            const rowHeights: number[] = [];

            for (const row of rows) {
                // Find max height in row (assume 400px per panel as default)
                const maxPanelHeight = Math.max(...row.map((p) => this.extractSVGHeight(p.svg) || 400));
                const rowHeight = maxPanelHeight + panelTitleHeight;
                rowHeights.push(rowHeight);
            }

            const totalHeight = currentY + rowHeights.reduce((sum, h) => sum + h + gutterSize, 0) + footerHeight + gutterSize;

            // Create master SVG
            const doc = SVGUtils.createSVG(width, totalHeight, 'infographic');
            const svg = doc.querySelector('svg')!;

            // Add styles
            const css = generateCSS(branding);
            SVGUtils.addStyles(svg, css);

            // Get palette
            const palette = getPalette(branding.palette);
            const font = getFontSpec(branding.font);
            const ns = svg.namespaceURI!;

            // Add background
            const bg = doc.createElementNS(ns, 'rect');
            bg.setAttribute('width', String(width));
            bg.setAttribute('height', String(totalHeight));
            bg.setAttribute('fill', palette.background);
            svg.appendChild(bg);

            // Add header
            if (spec.title) {
                const titleText = doc.createElementNS(ns, 'text');
                titleText.setAttribute('x', String(width / 2));
                titleText.setAttribute('y', '40');
                titleText.setAttribute('text-anchor', 'middle');
                titleText.setAttribute('font-family', font.family);
                titleText.setAttribute('font-size', '28');
                titleText.setAttribute('font-weight', 'bold');
                titleText.setAttribute('fill', palette.foreground);
                titleText.textContent = spec.title;
                svg.appendChild(titleText);

                if (spec.subtitle) {
                    const subtitleText = doc.createElementNS(ns, 'text');
                    subtitleText.setAttribute('x', String(width / 2));
                    subtitleText.setAttribute('y', '70');
                    subtitleText.setAttribute('text-anchor', 'middle');
                    subtitleText.setAttribute('font-family', font.family);
                    subtitleText.setAttribute('font-size', '16');
                    subtitleText.setAttribute('fill', palette.foreground);
                    subtitleText.setAttribute('opacity', '0.8');
                    subtitleText.textContent = spec.subtitle;
                    svg.appendChild(subtitleText);
                }

                // Separator line
                const line = doc.createElementNS(ns, 'line');
                line.setAttribute('x1', String(gutterSize));
                line.setAttribute('y1', String(headerHeight - 10));
                line.setAttribute('x2', String(width - gutterSize));
                line.setAttribute('y2', String(headerHeight - 10));
                line.setAttribute('stroke', palette.foreground);
                line.setAttribute('stroke-width', '2');
                line.setAttribute('opacity', '0.3');
                svg.appendChild(line);
            }

            // Render panels
            currentY = gutterSize + headerHeight;

            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                const row = rows[rowIndex];
                const rowHeight = rowHeights[rowIndex];
                let currentX = gutterSize;

                for (const panel of row) {
                    const colSpan = panel.colSpan || 1;
                    const panelActualWidth = panelWidth * colSpan + gutterSize * (colSpan - 1);

                    // Create panel group
                    const panelGroup = doc.createElementNS(ns, 'g');
                    panelGroup.setAttribute('transform', `translate(${currentX}, ${currentY})`);

                    // Add panel title if present
                    if (panel.title) {
                        const panelTitleText = doc.createElementNS(ns, 'text');
                        panelTitleText.setAttribute('x', String(panelActualWidth / 2));
                        panelTitleText.setAttribute('y', '18');
                        panelTitleText.setAttribute('text-anchor', 'middle');
                        panelTitleText.setAttribute('font-family', font.family);
                        panelTitleText.setAttribute('font-size', '14');
                        panelTitleText.setAttribute('font-weight', 'bold');
                        panelTitleText.setAttribute('fill', palette.foreground);
                        panelTitleText.textContent = panel.title;
                        panelGroup.appendChild(panelTitleText);
                    }

                    // Embed SVG panel
                    const panelSVGGroup = doc.createElementNS(ns, 'g');
                    panelSVGGroup.setAttribute('transform', `translate(0, ${panelTitleHeight})`);

                    // Parse and embed the panel SVG
                    try {
                        const panelContent = this.embedSVG(panel.svg, panelActualWidth, rowHeight - panelTitleHeight, doc);
                        panelSVGGroup.appendChild(panelContent);
                    } catch (error) {
                        // If embedding fails, show error placeholder
                        const errorText = doc.createElementNS(ns, 'text');
                        errorText.setAttribute('x', String(panelActualWidth / 2));
                        errorText.setAttribute('y', String((rowHeight - panelTitleHeight) / 2));
                        errorText.setAttribute('text-anchor', 'middle');
                        errorText.setAttribute('fill', '#C62828');
                        errorText.textContent = `Error loading panel: ${error instanceof Error ? error.message : 'Unknown error'}`;
                        panelSVGGroup.appendChild(errorText);
                    }

                    panelGroup.appendChild(panelSVGGroup);
                    svg.appendChild(panelGroup);

                    currentX += panelActualWidth + gutterSize;
                }

                currentY += rowHeight + gutterSize;
            }

            // Add footer
            if (spec.footer) {
                const footerText = doc.createElementNS(ns, 'text');
                footerText.setAttribute('x', String(width / 2));
                footerText.setAttribute('y', String(totalHeight - 15));
                footerText.setAttribute('text-anchor', 'middle');
                footerText.setAttribute('font-family', font.family);
                footerText.setAttribute('font-size', '12');
                footerText.setAttribute('fill', palette.foreground);
                footerText.setAttribute('opacity', '0.6');
                footerText.textContent = spec.footer;
                svg.appendChild(footerText);
            }

            // Sanitize and return
            const svgString = SVGUtils.sanitizeSVG(svg.outerHTML);

            return {
                Success: true,
                ResultCode: 'SUCCESS',
                Message: svgString,
                svg: svgString,
                width,
                height: totalHeight,
                diagnostics: {
                    panelCount: spec.panels.length,
                    rows: rows.length,
                    columns,
                },
            };
        } catch (error) {
            return {
                Success: false,
                Message: `Failed to generate infographic: ${error instanceof Error ? error.message : String(error)}`,
                ResultCode: 'INFOGRAPHIC_GENERATION_FAILED',
            };
        }
    }

    /**
     * Extracts height from SVG string
     */
    private extractSVGHeight(svgString: string): number | null {
        const heightMatch = svgString.match(/height="(\d+)"/);
        return heightMatch ? parseInt(heightMatch[1]) : null;
    }

    /**
     * Embeds an SVG string into the master document
     */
    private embedSVG(svgString: string, maxWidth: number, maxHeight: number, doc: Document): Element {
        // Parse the SVG
        const tempDOM = new JSDOM(svgString);
        const tempSVG = tempDOM.window.document.querySelector('svg');

        if (!tempSVG) {
            throw new Error('Invalid SVG content');
        }

        // Extract width and height
        const width = parseFloat(tempSVG.getAttribute('width') || '400');
        const height = parseFloat(tempSVG.getAttribute('height') || '300');

        // Calculate scale to fit
        const scaleX = maxWidth / width;
        const scaleY = maxHeight / height;
        const scale = Math.min(scaleX, scaleY, 1); // Don't scale up

        const scaledWidth = width * scale;
        const scaledHeight = height * scale;

        // Create group to hold the embedded SVG
        const ns = 'http://www.w3.org/2000/svg';
        const group = doc.createElementNS(ns, 'g');

        // Center the SVG if it's smaller than the available space
        const offsetX = (maxWidth - scaledWidth) / 2;
        const offsetY = (maxHeight - scaledHeight) / 2;

        group.setAttribute('transform', `translate(${offsetX}, ${offsetY}) scale(${scale})`);

        // Import all children from the temp SVG
        for (const child of Array.from(tempSVG.children)) {
            const importedNode = doc.importNode(child as Node, true);
            group.appendChild(importedNode);
        }

        return group;
    }

    /**
     * Helper to safely parse JSON that might already be an object
     */
    private parseJSON<T>(value: any, paramName: string): T {
        // If it's already an object/array, return it
        if (typeof value === 'object' && value !== null) {
            return value as T;
        }

        // If it's a string, parse it
        if (typeof value === 'string') {
            try {
                return JSON.parse(value) as T;
            } catch (error) {
                throw new Error(
                    `Parameter '${paramName}' contains invalid JSON: ${error instanceof Error ? error.message : String(error)}`
                );
            }
        }

        // For other types, error
        throw new Error(
            `Parameter '${paramName}' must be a JSON string or object. Received ${typeof value}.`
        );
    }

    /**
     * Helper to get parameter value by name (case-insensitive)
     */
    private getParamValue(params: RunActionParams, paramName: string): string | null {
        const param = params.Params.find((p) => p.Name.trim().toLowerCase() === paramName.toLowerCase());
        if (param?.Value && typeof param.Value === 'string') {
            return param?.Value?.trim() || null;
        } else {
            return param?.Value || null;
        }
    }
}