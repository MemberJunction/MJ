import { EntityFieldValueListType, EntityInfo, TypeScriptTypeFromSQLType } from '@memberjunction/core';
import fs from 'fs';
import path from 'path';
import { makeDir } from './Misc/util';
import { RegisterClass } from '@memberjunction/global';
import { logStatus } from './Misc/logging';

/**
 * Base class for generating schemas and type definitions for entity sub-classes, you can sub-class this class to modify/extend your own entity sub-class generator logic
 */
@RegisterClass(EntityTypeGeneratorBase)
export class EntityTypeGeneratorBase {
    public GenerateAllEntitySchemasAndTypes(entities: EntityInfo[], directory: string): boolean {
        try {   
            const sortedEntities: EntityInfo[] = entities.sort((a, b) => a.Name.localeCompare(b.Name));
            const sContent: string = this.generateTypeDefinitionHeader() + sortedEntities.map((entity: EntityInfo) => this.GenerateSchemaAndType(entity)).join('');
            makeDir(directory);
            fs.writeFileSync(path.join(directory, 'entity_schemas_and_types.ts'), sContent);
    
            return true;
        } catch (err) {
            console.error(err);
            return false;
        }
    }

    public generateTypeDefinitionHeader(): string {
        return `/*************************************************
* GENERATED CODE - DO NOT MODIFY
* Generated by MemberJunction CodeGen at ${new Date().toLocaleString()}
**************************************************/

import { z } from "zod";

`
    }
    
    /**
     * 
     * @param entity 
     * @param includeFileHeader 
     */
    public GenerateSchemaAndType(entity: EntityInfo) : string { 
        let content: string = "";
        if (entity.PrimaryKeys.length === 0) {
            logStatus(`Entity ${entity.Name} has no primary keys.  Skipping.`);
        }
        else {
            const fields: string = entity.Fields.map(e => {
                let values: string = '';
                let valueList: string = '';
                if (e.ValueListType && 
                    e.ValueListType.length > 0 && 
                    e.ValueListType.trim().toLowerCase() !== 'none') {
                    values = e.EntityFieldValues.map(v => `\n    *   * ${v.Value}${v.Description && v.Description.length > 0 ? ' - ' + v.Description : ''}`).join('');
                    valueList = `\n    * * Value List Type: ${e.ValueListType}\n    * * Possible Values `+ values  
                }
                let typeString: string = `${TypeScriptTypeFromSQLType(e.Type).toLowerCase()}()` + (e.AllowsNull ? '.nullish()' : '');
                if (e.ValueListTypeEnum !== EntityFieldValueListType.None && e.EntityFieldValues && e.EntityFieldValues.length > 0) {
                    // construct a typeString that is a union of the possible values
                    const quotes = e.NeedsQuotes ? "'" : '';
                    typeString = `union([${e.EntityFieldValues.map(v => `z.literal(${quotes}${v.Value}${quotes})`).join(', ')}])`;
                    if (e.ValueListTypeEnum === EntityFieldValueListType.ListOrUserEntry) {
                        // special case becuase a user can enter whatever they want
                        typeString += `.or(z.${TypeScriptTypeFromSQLType(e.Type)}()) `;
                    }

                    // finally, add the null type if it allows null
                    if (e.AllowsNull) {
                        typeString += '.nullish()';
                    }
                }
                let sRet: string = `    /**
    * * Field Name: ${e.Name}${e.DisplayName && e.DisplayName.length > 0 ? '\n    * * Display Name: ' + e.DisplayName : ''}
    * * SQL Data Type: ${e.SQLFullType}${e.RelatedEntity ? '\n    * * Related Entity/Foreign Key: ' +  e.RelatedEntity + ' (' + e.RelatedEntityBaseView + '.' + e.RelatedEntityFieldName + ')' : ''}${e.DefaultValue && e.DefaultValue.length > 0 ? '\n    * * Default Value: ' + e.DefaultValue : ''}${valueList}${e.Description && e.Description.length > 0 ? '\n    * * Description: ' + e.Description : ''}
    */
    ${e.CodeName}: z.${typeString},`;
                return sRet;
            }).join('\n');
    
            const schemaName: string = `${entity.ClassName}Schema`;
            content = `       
/**
 * zod schema definition for the entity ${entity.Name}
 * * Schema: ${entity.SchemaName}
 * * Base Table: ${entity.BaseTable}
 * * Base View: ${entity.BaseView}${entity.Description && entity.Description.length > 0 ? '\n * * @description ' + entity.Description : ''}
 * * Primary Key${entity.PrimaryKeys.length > 1 ? 's' : ''}: ${entity.PrimaryKeys.map(f => f.Name).join(', ')}
 */
export const ${schemaName} = z.object({
${fields}
});

export type ${entity.ClassName}EntityType = z.infer<typeof ${schemaName}>;
`;
        }

        return content;
    }
}

