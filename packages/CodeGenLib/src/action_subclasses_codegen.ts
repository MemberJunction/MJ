import { CodeNameFromString, EntityFieldValueListType, EntityInfo, TypeScriptTypeFromSQLType } from '@memberjunction/core';
import fs from 'fs';
import path from 'path';
import { makeDir } from './util';
import { RegisterClass } from '@memberjunction/global';
import { ActionEntity } from '@memberjunction/core-entities';
import { logError } from './logging';
import { mkdirSync } from 'fs-extra';
import { ActionEngine, GlobalActionLibraries } from '@memberjunction/actions';

/**
 * Base class for generating entity sub-classes, you can sub-class this class to modify/extend your own entity sub-class generator logic
 */
@RegisterClass(ActionSubClassGeneratorBase)
export class ActionSubClassGeneratorBase {

    public async generateActions(actions: ActionEntity[], directory: string): Promise<boolean> {
        try {
            const actionFilePath = path.join(directory, 'action_subclasses.ts');
            const actionHeader = `/*************************************************
* GENERATED CODE - DO NOT MODIFY
* Generated by MemberJunction CodeGen at ${new Date().toLocaleString()}
**************************************************/
import { ActionResultSimple, BaseAction, RunActionParams } from "@memberjunction/actions";
import { RegisterClass } from "@memberjunction/global";
${GlobalActionLibraries.map(lib => `import { ${lib.ImportedItems.map(item => item).join(', ')} } from "${lib.ImportAs ? lib.ImportAs : lib.Name}";`).join('\n')}
`;
            let sCode: string = "";
            for (const action of actions) {
                sCode += await this.generateSingleAction(action, directory);
            }
            const actionCode = actionHeader + sCode;
            mkdirSync(directory, { recursive: true });
            fs.writeFileSync(actionFilePath, actionCode);
            return true;    
        }
        catch (e) {
            logError(`Error generating actions`, e);
            return false;
        }
    }

    /**
     * 
     * description: Generate a single Action
     * @description
     * @param action 
     * @param directory 
     * @returns 
     */
    public async generateSingleAction(action: ActionEntity, directory: string): Promise<string> {
        try {
            const codeName = CodeNameFromString(action.Name);
            const actionClassName = codeName + '_Action';
            // replace all \n with \t\t\n
            const generatedCode = action.Code.replace(/\n/g, '\n\t\t')
            const codeComments = action.CodeComments ? action.CodeComments.replace(/\n/g, '\n\t\t') : '';
            const codeCommentsInserted = codeComments ? `/*\n\t\t${codeComments}\n\t*/` : '';
            const actionCode = `
            
/**
 * ${action.Name}
 * Generated Class
 * User Prompt: ${action.UserPrompt}${action.UserComments ? "\n * User Comments: " + action.UserComments : ""}
 */
@RegisterClass(BaseAction, "${action.Name}")
export class ${actionClassName} extends BaseAction {
    ${codeCommentsInserted}
    protected override async InternalRunAction(params: RunActionParams): Promise<ActionResultSimple> {
        ${generatedCode}
    }
}        
            `
            return actionCode;
        }
        catch (e) {
            logError(`Error generating action ${action.Name}`, e);
            throw e
        }
    }
}