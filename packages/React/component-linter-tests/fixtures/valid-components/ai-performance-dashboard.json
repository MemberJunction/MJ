{
  "name": "AIPerformanceDashboard",
  "location": "embedded",
  "title": "AI Performance Dashboard",
  "description": "Comprehensive dashboard for analyzing AI agent and prompt performance with time-series charts, cost analysis, and drill-down capabilities",
  "type": "dashboard",
  "functionalRequirements": "## AI Performance Dashboard Requirements\n\n### Core Functionality\n- Display multi-line time series charts showing total runs, tokens, and costs over time\n- Support multiple time groupings: day, week, month, quarter\n- Dual Y-axis display (tokens on left, runs/costs on right)\n- Click-to-drill-down on any chart point to see details for that period\n- Show distribution charts (pie/bar) for selected time period\n- Separate tabs for Agent Runs and Prompt Runs analysis\n- Real-time data refresh capabilities\n- Export functionality for charts and data\n\n### Analytics Features\n- Time series trends with moving averages\n- Cost breakdown by agent/prompt\n- Token usage distribution\n- Success/failure rate analysis\n- Performance comparisons across periods\n- Top consumers identification\n- Anomaly detection and alerts\n\n### UX Considerations\n- Responsive layout adapting to container size\n- Interactive tooltips on hover\n- Smooth chart animations\n- Loading states during data fetch\n- Clear visual hierarchy\n- Consistent color coding across charts\n- Mobile-responsive design",
  "dataRequirements": {
    "mode": "views",
    "description": "Loads AI performance data including agent runs, prompt runs, and aggregated metrics",
    "entities": [
      {
        "name": "MJ: AI Agent Runs",
        "description": "Historical agent execution data for performance analysis",
        "displayFields": [
          "ID",
          "AgentID",
          "Agent",
          "StartedAt",
          "CompletedAt",
          "Success",
          "TotalTokensUsed",
          "TotalCost"
        ],
        "filterFields": [
          "StartedAt",
          "Success",
          "AgentID"
        ],
        "sortFields": [
          "StartedAt"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "type": "uniqueidentifier",
            "isPrimaryKey": true,
            "allowsNull": false,
            "description": "Unique run identifier"
          },
          {
            "name": "AgentID",
            "type": "uniqueidentifier",
            "allowsNull": false,
            "description": "Reference to AI Agent"
          },
          {
            "name": "Agent",
            "type": "nvarchar",
            "allowsNull": true,
            "description": "Agent name (denormalized)"
          },
          {
            "name": "StartedAt",
            "type": "datetime",
            "allowsNull": false,
            "description": "Execution start timestamp"
          },
          {
            "name": "TotalTokensUsed",
            "type": "int",
            "allowsNull": true,
            "description": "Total tokens consumed"
          },
          {
            "name": "TotalCost",
            "type": "decimal",
            "allowsNull": true,
            "description": "Total cost in USD"
          }
        ],
        "permissionLevelNeeded": [
          "read"
        ]
      },
      {
        "name": "MJ: AI Prompt Runs",
        "description": "Historical prompt execution data for performance analysis",
        "displayFields": [
          "ID",
          "PromptID",
          "Prompt",
          "ModelID",
          "Model",
          "RunAt",
          "CompletedAt",
          "Success",
          "TokensUsed",
          "TotalCost"
        ],
        "filterFields": [
          "RunAt",
          "Success",
          "PromptID",
          "ModelID"
        ],
        "sortFields": [
          "RunAt"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "type": "uniqueidentifier",
            "isPrimaryKey": true,
            "allowsNull": false,
            "description": "Unique run identifier"
          },
          {
            "name": "PromptID",
            "type": "uniqueidentifier",
            "allowsNull": false,
            "description": "Reference to AI Prompt"
          },
          {
            "name": "Prompt",
            "type": "nvarchar",
            "allowsNull": true,
            "description": "Prompt name (denormalized)"
          },
          {
            "name": "RunAt",
            "type": "datetime",
            "allowsNull": false,
            "description": "Execution timestamp"
          },
          {
            "name": "TokensUsed",
            "type": "int",
            "allowsNull": true,
            "description": "Total tokens consumed"
          },
          {
            "name": "TotalCost",
            "type": "decimal",
            "allowsNull": true,
            "description": "Total cost in USD"
          }
        ],
        "permissionLevelNeeded": [
          "read"
        ]
      }
    ],
    "queries": []
  },
  "technicalDesign": "## Component Architecture\n\n### Root Component (AIPerformanceDashboard)\n- Manages overall dashboard state and data loading\n- Handles time range selection and grouping\n- Coordinates drill-down state between components\n- Manages tab switching between Agent and Prompt views\n\n### Child Components\n1. **AITimeSeriesChart**: Multi-line chart with dual Y-axes for runs/tokens/costs\n2. **AIDistributionChart**: Pie/bar charts showing breakdown by agent or prompt\n3. **AIDetailTable**: Detailed table view for drill-down data\n4. **AIMetricsSummary**: Key metrics cards for selected period\n\n### Data Flow\n- Root component loads data based on selected time range\n- Aggregates data by selected grouping (day/week/month/quarter)\n- Passes aggregated data to chart components\n- Handles drill-down events and updates detail views\n- Manages state persistence through savedUserSettings\n\n### State Management\n- Selected time range and grouping\n- Active tab (agents vs prompts)\n- Drill-down selection (selected date/period)\n- Chart view preferences\n- Filter states",
  "properties": [],
  "events": [],
  "exampleUsage": "<AIPerformanceDashboard />",
  "code": "function AIPerformanceDashboard({ utilities, styles, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  console.log('[AIPerformanceDashboard] Initializing with settings:', savedUserSettings);\n  console.log('[AIPerformanceDashboard] Available components:', components ? Object.keys(components) : 'none');\n  \n  // Extract child components with fallbacks\n  const AITimeSeriesChart = components?.AITimeSeriesChart;\n  const AIDistributionChart = components?.AIDistributionChart;\n  const AIDetailTable = components?.AIDetailTable;\n  const AIMetricsSummary = components?.AIMetricsSummary;\n  const AIInsightsPanel = components?.AIInsightsPanel;\n  const DataExportPanel = components?.DataExportPanel;\n  \n  // Check if required components are available\n  if (!AITimeSeriesChart || !AIDistributionChart || !AIDetailTable || !AIMetricsSummary || !AIInsightsPanel) {\n    return (\n      <div style={{\n        padding: styles?.spacing?.lg || '20px',\n        color: styles?.colors?.error || 'red',\n        textAlign: 'center'\n      }}>\n        Error: Required child components are not available. Please ensure all dashboard components are loaded.\n        <br />\n        Missing: {[\n          !AITimeSeriesChart && 'AITimeSeriesChart',\n          !AIDistributionChart && 'AIDistributionChart',\n          !AIDetailTable && 'AIDetailTable',\n          !AIMetricsSummary && 'AIMetricsSummary',\n          !AIInsightsPanel && 'AIInsightsPanel'\n        ].filter(Boolean).join(', ')}\n      </div>\n    );\n  }\n  \n  // Initialize state from saved settings\n  const [timeRange, setTimeRange] = useState(savedUserSettings?.timeRange || '30d');\n  const [groupBy, setGroupBy] = useState(savedUserSettings?.groupBy || 'day');\n  const [activeTab, setActiveTab] = useState(savedUserSettings?.activeTab || 'agents');\n  const [selectedPoint, setSelectedPoint] = useState(null);\n  \n  // Data state\n  const [agentRuns, setAgentRuns] = useState([]);\n  const [promptRuns, setPromptRuns] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  // AI Insights state\n  const [aiInsights, setAiInsights] = useState(null);\n  const [loadingInsights, setLoadingInsights] = useState(false);\n  const [insightsError, setInsightsError] = useState(null);\n  \n  // Calculate date range\n  const getDateRange = useCallback(() => {\n    const end = new Date();\n    const start = new Date();\n    \n    switch(timeRange) {\n      case '7d':\n        start.setDate(end.getDate() - 7);\n        break;\n      case '30d':\n        start.setDate(end.getDate() - 30);\n        break;\n      case '90d':\n        start.setDate(end.getDate() - 90);\n        break;\n      case '1y':\n        start.setFullYear(end.getFullYear() - 1);\n        break;\n      default:\n        start.setDate(end.getDate() - 30);\n    }\n    \n    return { start, end };\n  }, [timeRange]);\n  \n  // Load data\n  useEffect(() => {\n    const loadData = async () => {\n      console.log('[AIPerformanceDashboard] Loading data for range:', timeRange);\n      setLoading(true);\n      setError(null);\n      \n      const { start, end } = getDateRange();\n      \n      try {\n        // Load agent runs\n        const agentFilter = `StartedAt >= '${start.toISOString()}' AND StartedAt <= '${end.toISOString()}'`;\n        console.log('[AIPerformanceDashboard] Loading agent runs with filter:', agentFilter);\n        \n        const agentResult = await utilities.rv.RunView({\n          EntityName: 'MJ: AI Agent Runs',\n          ExtraFilter: agentFilter,\n          OrderBy: 'StartedAt ASC',\n          Fields: ['ID', 'AgentID', 'Agent', 'StartedAt', 'CompletedAt', 'Success', 'TotalTokensUsed', 'TotalCost'],\n          MaxRows: 10000\n        });\n        \n        console.log('[AIPerformanceDashboard] Agent runs loaded:', {\n          success: agentResult?.Success,\n          count: agentResult?.Results?.length,\n          error: agentResult?.ErrorMessage\n        });\n        \n        if (agentResult?.Success) {\n          setAgentRuns(agentResult.Results || []);\n        } else {\n          console.error('[AIPerformanceDashboard] Failed to load agent runs:', agentResult?.ErrorMessage);\n        }\n        \n        // Load prompt runs\n        const promptFilter = `RunAt >= '${start.toISOString()}' AND RunAt <= '${end.toISOString()}'`;\n        console.log('[AIPerformanceDashboard] Loading prompt runs with filter:', promptFilter);\n        \n        const promptResult = await utilities.rv.RunView({\n          EntityName: 'MJ: AI Prompt Runs',\n          ExtraFilter: promptFilter,\n          OrderBy: 'RunAt ASC',\n          Fields: ['ID', 'PromptID', 'Prompt', 'ModelID', 'Model', 'RunAt', 'CompletedAt', 'Success', 'TokensUsed', 'TotalCost'],\n          MaxRows: 10000\n        });\n        \n        console.log('[AIPerformanceDashboard] Prompt runs loaded:', {\n          success: promptResult?.Success,\n          count: promptResult?.Results?.length,\n          error: promptResult?.ErrorMessage\n        });\n        \n        if (promptResult?.Success) {\n          setPromptRuns(promptResult.Results || []);\n        } else {\n          console.error('[AIPerformanceDashboard] Failed to load prompt runs:', promptResult?.ErrorMessage);\n        }\n        \n      } catch (error) {\n        console.error('[AIPerformanceDashboard] Error loading data:', error);\n        setError(error.message || 'Failed to load data');\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadData();\n  }, [timeRange, utilities.rv, getDateRange]);\n  \n  // Aggregate data by time period\n  const aggregateData = useCallback((data, dateField, grouping) => {\n    console.log(`[AIPerformanceDashboard] Aggregating ${data.length} records by ${grouping}`);\n    \n    const grouped = {};\n    \n    data.forEach(item => {\n      const date = new Date(item[dateField]);\n      let key;\n      \n      switch(grouping) {\n        case 'day':\n          key = date.toISOString().split('T')[0];\n          break;\n        case 'week':\n          const weekStart = new Date(date);\n          weekStart.setDate(date.getDate() - date.getDay());\n          key = weekStart.toISOString().split('T')[0];\n          break;\n        case 'month':\n          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n          break;\n        case 'quarter':\n          const quarter = Math.floor(date.getMonth() / 3) + 1;\n          key = `${date.getFullYear()}-Q${quarter}`;\n          break;\n        default:\n          key = date.toISOString().split('T')[0];\n      }\n      \n      if (!grouped[key]) {\n        grouped[key] = {\n          date: key,\n          runs: 0,\n          tokens: 0,\n          cost: 0,\n          items: []\n        };\n      }\n      \n      grouped[key].runs++;\n      grouped[key].tokens += (item.TotalTokensUsed || item.TokensUsed || 0);\n      grouped[key].cost += (item.TotalCost || 0);\n      grouped[key].items.push(item);\n    });\n    \n    const result = Object.values(grouped).sort((a, b) => a.date.localeCompare(b.date));\n    console.log(`[AIPerformanceDashboard] Aggregated into ${result.length} groups`);\n    return result;\n  }, []);\n  \n  // Get aggregated data for current view\n  const chartData = useMemo(() => {\n    const data = activeTab === 'agents' ? agentRuns : promptRuns;\n    const dateField = activeTab === 'agents' ? 'StartedAt' : 'RunAt';\n    return aggregateData(data, dateField, groupBy);\n  }, [activeTab, agentRuns, promptRuns, groupBy, aggregateData]);\n  \n  // Handle drill-down\n  const handleChartClick = useCallback((dataPoint) => {\n    console.log('[AIPerformanceDashboard] Chart clicked:', dataPoint);\n    setSelectedPoint(dataPoint);\n  }, []);\n  \n  // Handle time range change\n  const handleTimeRangeChange = useCallback((range) => {\n    console.log('[AIPerformanceDashboard] Time range changed to:', range);\n    setTimeRange(range);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      timeRange: range\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Handle grouping change\n  const handleGroupByChange = useCallback((grouping) => {\n    console.log('[AIPerformanceDashboard] Grouping changed to:', grouping);\n    setGroupBy(grouping);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      groupBy: grouping\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Handle tab change\n  const handleTabChange = useCallback((tab) => {\n    console.log('[AIPerformanceDashboard] Tab changed to:', tab);\n    setActiveTab(tab);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      activeTab: tab\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Calculate summary metrics\n  const metrics = useMemo(() => {\n    const data = activeTab === 'agents' ? agentRuns : promptRuns;\n    return {\n      totalRuns: data.length,\n      totalTokens: data.reduce((sum, item) => sum + (item.TotalTokensUsed || item.TokensUsed || 0), 0),\n      totalCost: data.reduce((sum, item) => sum + (item.TotalCost || 0), 0),\n      avgTokensPerRun: data.length > 0 ? Math.round(data.reduce((sum, item) => sum + (item.TotalTokensUsed || item.TokensUsed || 0), 0) / data.length) : 0,\n      avgCostPerRun: data.length > 0 ? data.reduce((sum, item) => sum + (item.TotalCost || 0), 0) / data.length : 0\n    };\n  }, [activeTab, agentRuns, promptRuns]);\n\n  // Prepare data for export - memoized to prevent re-computation\n  const prepareExportData = React.useMemo(() => {\n    const currentData = activeTab === 'agents' ? agentRuns : promptRuns;\n    const dateField = activeTab === 'agents' ? 'StartedAt' : 'RunAt';\n\n    return currentData.map(item => ({\n      ID: item.ID || '',\n      Name: activeTab === 'agents' ? (item.Agent || '') : (item.Prompt || ''),\n      Type: activeTab === 'agents' ? 'Agent Run' : 'Prompt Run',\n      Model: item.Model || '',\n      ExecutionDate: item[dateField] ? new Date(item[dateField]).toLocaleDateString() : '',\n      Success: item.Success ? 'Yes' : 'No',\n      TokensUsed: item.TotalTokensUsed || item.TokensUsed || 0,\n      Cost: item.TotalCost ? `$${item.TotalCost.toFixed(4)}` : '$0.0000',\n      CompletedAt: item.CompletedAt ? new Date(item.CompletedAt).toLocaleDateString() : ''\n    }));\n  }, [activeTab, agentRuns, promptRuns]);\n\n  // Define export columns - memoized to prevent re-creation\n  const getExportColumns = React.useMemo(() => {\n    return [\n      { key: 'ID', label: 'ID' },\n      { key: 'Name', label: activeTab === 'agents' ? 'Agent Name' : 'Prompt Name' },\n      { key: 'Type', label: 'Type' },\n      { key: 'Model', label: 'Model' },\n      { key: 'ExecutionDate', label: 'Execution Date' },\n      { key: 'Success', label: 'Success' },\n      { key: 'TokensUsed', label: 'Tokens Used' },\n      { key: 'Cost', label: 'Cost' },\n      { key: 'CompletedAt', label: 'Completed At' }\n    ];\n  }, [activeTab]);\n  \n\n  // Generate AI Insights - wrap with useCallback\n  const generateAIInsights = React.useCallback(async () => {\n    setLoadingInsights(true);\n    setInsightsError(null);\n    \n    try {\n      const currentData = activeTab === 'agents' ? agentRuns : promptRuns;\n      const dataType = activeTab === 'agents' ? 'AI Agent' : 'AI Prompt';\n      \n      // Calculate additional metrics for deeper analysis\n      const modelDistribution = {};\n      const agentDistribution = {};\n      let successRate = 0;\n      let failureCount = 0;\n      \n      currentData.forEach(run => {\n        // Model distribution\n        const model = run.Model || run.ModelID || 'Unknown';\n        modelDistribution[model] = (modelDistribution[model] || 0) + 1;\n        \n        // Agent/Prompt distribution\n        const name = run.Agent || run.AgentName || run.Prompt || run.PromptName || 'Unknown';\n        agentDistribution[name] = (agentDistribution[name] || 0) + 1;\n        \n        // Success tracking\n        if (run.IsSuccess === true || run.Status === 'Success') {\n          successRate++;\n        } else if (run.IsSuccess === false || run.Status === 'Failed') {\n          failureCount++;\n        }\n      });\n      \n      successRate = currentData.length > 0 ? ((successRate / currentData.length) * 100).toFixed(1) : 0;\n      \n      const prompt = `Analyze this ${dataType} performance data and provide actionable insights:\n\n## Performance Overview\n- **Time Period:** ${timeRange}\n- **Data Grouping:** ${groupBy}\n- **Total Runs:** ${metrics.totalRuns}\n- **Total Tokens Used:** ${metrics.totalTokens.toLocaleString()}\n- **Total Cost:** $${metrics.totalCost.toFixed(2)}\n- **Average Tokens per Run:** ${metrics.avgTokensPerRun.toLocaleString()}\n- **Average Cost per Run:** $${metrics.avgCostPerRun.toFixed(4)}\n- **Success Rate:** ${successRate}%\n- **Failed Runs:** ${failureCount}\n\n## Model Distribution\n${Object.entries(modelDistribution)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 5)\n  .map(([model, count]) => `- **${model}:** ${count} runs (${((count/metrics.totalRuns)*100).toFixed(1)}%)`)\n  .join('\\n')}\n\n## Top ${dataType === 'AI Agent' ? 'Agents' : 'Prompts'}\n${Object.entries(agentDistribution)\n  .sort((a, b) => b[1] - a[1])\n  .slice(0, 5)\n  .map(([name, count]) => `- **${name}:** ${count} runs`)\n  .join('\\n')}\n\n## Recent Performance Trends (Last 5 ${groupBy === 'hour' ? 'Hours' : groupBy === 'day' ? 'Days' : 'Periods'})\n${chartData.slice(-5).map(d => \n  `- **${d.date}:** ${d.runs} runs, ${d.tokens.toLocaleString()} tokens, $${d.cost.toFixed(2)}`\n).join('\\n')}\n\n## Cost Analysis\n- **Highest Cost Period:** ${chartData.reduce((max, d) => d.cost > max.cost ? d : max, chartData[0] || {}).date || 'N/A'}\n- **Most Active Period:** ${chartData.reduce((max, d) => d.runs > max.runs ? d : max, chartData[0] || {}).date || 'N/A'}\n- **Token Efficiency Trend:** ${chartData.length > 1 \n  ? (chartData[chartData.length-1].tokens/chartData[chartData.length-1].runs < chartData[0].tokens/chartData[0].runs \n    ? 'Improving' : 'Declining')\n  : 'Stable'}\n\nBased on this specific data, please provide:\n1. **Key Performance Insights** - What patterns and trends are evident in the data?\n2. **Cost Efficiency Analysis** - Are costs justified by usage patterns? Where can we optimize?\n3. **Token Usage Patterns** - Any unusual spikes or inefficiencies?\n4. **Model Optimization** - Should we adjust model selection based on the distribution?\n5. **Specific Recommendations** - 3-4 actionable steps to improve performance and reduce costs\n6. **Risk Indicators** - Any anomalies or concerns that need immediate attention?\n\nUse markdown formatting with headers (##), bullet points, and **bold** text. Reference the actual numbers in your analysis.`;\n      \n      const result = await utilities.ai.ExecutePrompt({\n        systemPrompt: 'You are an expert AI performance analyst specializing in token usage optimization, cost management, and AI system efficiency. Analyze the specific metrics provided and give actionable recommendations. Always reference the actual numbers and percentages from the data. Format your response in clear markdown.',\n        messages: prompt,\n        preferredModels: ['GPT-OSS-120B', 'Qwen3 32B'],\n        modelPower: 'high',\n        temperature: 0.7,\n        maxTokens: 1500\n      });\n      \n      if (result?.success && result?.result) {\n        setAiInsights(result.result);\n      } else {\n        setInsightsError('Failed to generate insights. Please try again.');\n      }\n    } catch (error) {\n      setInsightsError(error.message || 'Failed to generate AI insights');\n    } finally {\n      setLoadingInsights(false);\n    }\n  }, [activeTab, agentRuns, promptRuns, utilities.ai]);\n  \n  console.log('[AIPerformanceDashboard] Current state:', {\n    timeRange,\n    groupBy,\n    activeTab,\n    agentRunsCount: agentRuns.length,\n    promptRunsCount: promptRuns.length,\n    chartDataPoints: chartData.length,\n    selectedPoint: selectedPoint?.date\n  });\n  \n  if (loading) {\n    return (\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        height: '100%',\n        color: styles.colors.textSecondary\n      }}>\n        Loading performance data...\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        height: '100%',\n        color: styles.colors.error\n      }}>\n        Error: {error}\n      </div>\n    );\n  }\n  \n  return (\n    <div style={{\n      height: '100%',\n      display: 'flex',\n      flexDirection: 'column',\n      backgroundColor: styles.colors.background,\n      padding: styles.spacing.md\n    }}>\n      <style>{`\n        /* Markdown content styling */\n        .markdown-insights h1 { font-size: 20px; font-weight: 600; color: #111827; margin: 16px 0 12px 0; }\n        .markdown-insights h2 { font-size: 18px; font-weight: 600; color: #1F2937; margin: 14px 0 10px 0; }\n        .markdown-insights h3 { font-size: 16px; font-weight: 600; color: #374151; margin: 12px 0 8px 0; }\n        .markdown-insights h4 { font-size: 14px; font-weight: 600; color: #4B5563; margin: 10px 0 6px 0; }\n        .markdown-insights p { margin: 8px 0; color: #374151; line-height: 1.6; }\n        .markdown-insights ul, .markdown-insights ol { margin: 8px 0; padding-left: 24px; color: #374151; }\n        .markdown-insights li { margin: 4px 0; line-height: 1.5; }\n        .markdown-insights strong { font-weight: 600; color: #1F2937; }\n        .markdown-insights em { font-style: italic; }\n        .markdown-insights code { background: #F3F4F6; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em; }\n        .markdown-insights blockquote { border-left: 3px solid #6366F1; padding-left: 12px; margin: 12px 0; color: #4B5563; }\n        .markdown-insights hr { border: none; border-top: 1px solid #E5E7EB; margin: 16px 0; }\n        .markdown-insights a { color: #6366F1; text-decoration: none; }\n        .markdown-insights a:hover { text-decoration: underline; }\n      `}</style>\n      {/* Header Controls */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        marginBottom: styles.spacing.lg,\n        flexWrap: 'wrap',\n        gap: styles.spacing.md\n      }}>\n        {/* Tab Selector */}\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.xs,\n          backgroundColor: styles.colors.surface,\n          padding: styles.spacing.xs,\n          borderRadius: styles.borders?.radius || '4px'\n        }}>\n          <button\n            onClick={() => handleTabChange('agents')}\n            style={{\n              padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n              backgroundColor: activeTab === 'agents' ? styles.colors.primary : 'transparent',\n              color: activeTab === 'agents' ? 'white' : styles.colors.text,\n              border: 'none',\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: 'pointer',\n              fontWeight: activeTab === 'agents' ? '600' : '400'\n            }}\n          >\n            Agent Runs\n          </button>\n          <button\n            onClick={() => handleTabChange('prompts')}\n            style={{\n              padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n              backgroundColor: activeTab === 'prompts' ? styles.colors.primary : 'transparent',\n              color: activeTab === 'prompts' ? 'white' : styles.colors.text,\n              border: 'none',\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: 'pointer',\n              fontWeight: activeTab === 'prompts' ? '600' : '400'\n            }}\n          >\n            Prompt Runs\n          </button>\n        </div>\n        \n        {/* Time Controls */}\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.md,\n          alignItems: 'center'\n        }}>\n          {/* Time Range */}\n          <select\n            value={timeRange}\n            onChange={(e) => handleTimeRangeChange(e.target.value)}\n            style={{\n              padding: styles.spacing.sm,\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              backgroundColor: styles.colors.surface,\n              color: styles.colors.text\n            }}\n          >\n            <option value=\"7d\">Last 7 Days</option>\n            <option value=\"30d\">Last 30 Days</option>\n            <option value=\"90d\">Last 90 Days</option>\n            <option value=\"1y\">Last Year</option>\n          </select>\n          \n          {/* Group By */}\n          <select\n            value={groupBy}\n            onChange={(e) => handleGroupByChange(e.target.value)}\n            style={{\n              padding: styles.spacing.sm,\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              backgroundColor: styles.colors.surface,\n              color: styles.colors.text\n            }}\n          >\n            <option value=\"day\">By Day</option>\n            <option value=\"week\">By Week</option>\n            <option value=\"month\">By Month</option>\n            <option value=\"quarter\">By Quarter</option>\n          </select>\n          \n          {/* Export Button */}\n          {DataExportPanel && (\n            <DataExportPanel\n              key=\"export-panel\"  // Add stable key\n              data={prepareExportData}\n              columns={getExportColumns}\n              filename={`ai-performance-${activeTab}-${new Date().toISOString().split('T')[0]}`}\n              formats={['csv', 'excel', 'pdf']}\n              buttonStyle=\"dropdown\"\n              buttonText=\"Export\"\n              icon=\"fa-download\"\n              customStyles={{\n                button: {\n                  padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n                  backgroundColor: '#10B981',\n                  color: 'white',\n                  border: 'none',\n                  borderRadius: styles.borders?.radius || '4px',\n                  cursor: 'pointer',\n                  fontSize: '14px',\n                  display: 'inline-flex',\n                  alignItems: 'center',\n                  gap: styles.spacing.xs\n                }\n              }}\n              utilities={utilities}\n              styles={styles}\n              components={components}\n              callbacks={callbacks}\n            />\n          )}\n\n          {/* AI Insights Button */}\n          <button\n            onClick={generateAIInsights}\n            disabled={loadingInsights || loading}\n            style={{\n              padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n              backgroundColor: styles.colors.primary,\n              color: 'white',\n              border: 'none',\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: loadingInsights || loading ? 'not-allowed' : 'pointer',\n              display: 'flex',\n              alignItems: 'center',\n              gap: styles.spacing.xs,\n              opacity: loadingInsights || loading ? 0.6 : 1\n            }}\n          >\n            <i className={`fa-solid fa-${loadingInsights ? 'spinner fa-spin' : 'wand-magic-sparkles'}`}></i>\n            {loadingInsights ? 'Analyzing...' : 'Get AI Insights'}\n          </button>\n        </div>\n      </div>\n      \n      {/* AI Insights Panel */}\n      <AIInsightsPanel\n        utilities={utilities}\n        styles={styles}\n        components={components}\n        callbacks={callbacks}\n        savedUserSettings={savedUserSettings?.aiInsights}\n        onSaveUserSettings={(settings) => onSaveUserSettings?.({\n          ...savedUserSettings,\n          aiInsights: settings\n        })}\n        insights={aiInsights}\n        loading={loadingInsights}\n        error={insightsError}\n        onGenerate={generateAIInsights}\n        title=\"AI-Powered Performance Analysis\"\n        icon=\"fa-wand-magic-sparkles\"\n        iconColor={styles.colors.primary}\n        position=\"top\"\n        onClose={() => {\n          setAiInsights(null);\n          setInsightsError(null);\n        }}\n      />\n      \n      {/* Metrics Summary */}\n      <AIMetricsSummary\n        metrics={metrics}\n        styles={styles}\n        utilities={utilities}\n        components={components}\n        callbacks={callbacks}\n        savedUserSettings={savedUserSettings?.metricsSummary}\n        onSaveUserSettings={(settings) => onSaveUserSettings?.({\n          ...savedUserSettings,\n          metricsSummary: settings\n        })}\n      />\n      \n      {/* Main Chart Area */}\n      <div style={{\n        flex: 1,\n        display: 'flex',\n        flexDirection: 'column',\n        gap: styles.spacing.lg,\n        minHeight: 0\n      }}>\n        {/* Time Series Chart */}\n        <div style={{\n          flex: selectedPoint ? '0 0 400px' : '1',\n          minHeight: '300px'\n        }}>\n          <AITimeSeriesChart\n            data={chartData}\n            groupBy={groupBy}\n            activeTab={activeTab}\n            selectedPoint={selectedPoint}\n            onPointClick={handleChartClick}\n            styles={styles}\n            utilities={utilities}\n            components={components}\n            callbacks={callbacks}\n            savedUserSettings={savedUserSettings?.timeSeriesChart}\n            onSaveUserSettings={(settings) => onSaveUserSettings?.({\n              ...savedUserSettings,\n              timeSeriesChart: settings\n            })}\n          />\n        </div>\n        \n        {/* Drill-down Area */}\n        {selectedPoint && (\n          <div style={{\n            flex: 1,\n            display: 'flex',\n            gap: styles.spacing.md,\n            minHeight: 0\n          }}>\n            {/* Distribution Chart */}\n            <div style={{ flex: '0 0 400px' }}>\n              <AIDistributionChart\n                data={selectedPoint.items}\n                activeTab={activeTab}\n                groupBy={groupBy}\n                styles={styles}\n                utilities={utilities}\n                components={components}\n                callbacks={callbacks}\n                savedUserSettings={savedUserSettings?.distributionChart}\n                onSaveUserSettings={(settings) => onSaveUserSettings?.({\n                  ...savedUserSettings,\n                  distributionChart: settings\n                })}\n              />\n            </div>\n            \n            {/* Detail Table */}\n            <div style={{ flex: 1, overflow: 'auto' }}>\n              <AIDetailTable\n                data={selectedPoint.items}\n                activeTab={activeTab}\n                styles={styles}\n                utilities={utilities}\n                components={components}\n                callbacks={callbacks}\n                savedUserSettings={savedUserSettings?.detailTable}\n                onSaveUserSettings={(settings) => onSaveUserSettings?.({\n                  ...savedUserSettings,\n                  detailTable: settings\n                })}\n              />\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
  "dependencies": [
    {
      "name": "AITimeSeriesChart",
      "location": "registry",
      "namespace": "AI/Analytics/Performance",
      "version": "^1.0.0"
    },
    {
      "name": "AIDistributionChart",
      "location": "registry",
      "namespace": "AI/Analytics/Performance",
      "version": "^1.0.0"
    },
    {
      "name": "AIDetailTable",
      "location": "registry",
      "namespace": "AI/Analytics/Performance",
      "version": "^1.0.0"
    },
    {
      "name": "AIMetricsSummary",
      "location": "registry",
      "namespace": "AI/Analytics/Performance",
      "version": "^1.0.0"
    },
    {
      "name": "AIInsightsPanel",
      "location": "registry",
      "namespace": "Generic/UI/AI",
      "version": "^1.0.0"
    },
    {
      "name": "DataExportPanel",
      "location": "registry",
      "namespace": "Generic/UI/Export",
      "version": "^1.0.0"
    }
  ],
  "libraries": []
}