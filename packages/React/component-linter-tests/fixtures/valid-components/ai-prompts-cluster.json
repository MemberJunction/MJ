{
  "name": "AIPromptsCluster",
  "title": "AI Prompts Cluster Visualization",
  "description": "Interactive clustering visualization of AI prompts using semantic embeddings to discover patterns and relationships",
  "type": "dashboard",
  "location": "embedded",
  "code": "function AIPromptsCluster({ \n  utilities, \n  styles, \n  components, \n  callbacks, \n  savedUserSettings, \n  onSaveUserSettings,\n  data \n}) {\n  // Extract AIInsightsPanel from components\n  const AIInsightsPanel = components?.AIInsightsPanel;\n  \n  if (!AIInsightsPanel) {\n    console.warn('AIInsightsPanel component not available');\n  }\n\n  // Load sub-components\n  const ClusterGraph = components['AIPromptsClusterGraph'];\n  const ClusterControls = components['AIPromptsClusterControls'];\n  const ClusterDetails = components['AIPromptsClusterDetails'];\n  const DataExportPanel = components['DataExportPanel'];\n  \n  console.log('ðŸ” [AIPromptsCluster] Component loading check:');\n  console.log('  - ClusterGraph:', !!ClusterGraph);\n  console.log('  - ClusterControls:', !!ClusterControls);\n  console.log('  - ClusterDetails:', !!ClusterDetails);\n  console.log('  - DataExportPanel:', !!DataExportPanel);\n  console.log('  - All components object:', Object.keys(components || {}));\n  console.log('  - DataExportPanel type:', typeof DataExportPanel);\n  \n  // Debug when DataExportPanel changes\n  useEffect(() => {\n    console.log('ðŸ“Œ [AIPromptsCluster] DataExportPanel updated:', !!DataExportPanel);\n    if (DataExportPanel) {\n      console.log('  - DataExportPanel is a:', typeof DataExportPanel);\n      console.log('  - DataExportPanel.toString():', DataExportPanel.toString().substring(0, 100));\n    }\n  }, [DataExportPanel]);\n\n  // State management\n  const [prompts, setPrompts] = useState([]);\n  const [embeddings, setEmbeddings] = useState({});\n  \n  // Ref for cluster visualization\n  const clusterGraphRef = useRef(null);\n  const [clusters, setClusters] = useState([]);\n  const [selectedPrompt, setSelectedPrompt] = useState(null);\n  const [filters, setFilters] = useState({\n    search: '',\n    category: null,\n    type: null,\n    status: 'Active',\n    role: null\n  });\n  const [clusterCount, setClusterCount] = useState(5);\n  const [similarityThreshold, setSimilarityThreshold] = useState(0.7);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState(null);\n  const [highlightCluster, setHighlightCluster] = useState(null);\n  const [clusterNames, setClusterNames] = useState({});\n  \n  // AI Insights state\n  const [aiInsights, setAiInsights] = useState(null);\n  const [loadingInsights, setLoadingInsights] = useState(false);\n  const [insightsError, setInsightsError] = useState(null);\n\n  // Load AI Prompts data on mount\n  useEffect(() => {\n    loadPrompts();\n  }, []);\n\n  // Load prompts from database\n  const loadPrompts = async () => {\n    try {\n      setIsProcessing(true);\n      setError(null);\n      \n      const result = await utilities.rv.RunView({\n        EntityName: 'AI Prompts',\n        OrderBy: 'Name',\n        ResultType: 'entity_object'\n      });\n      \n      if (result.Success && result.Results) {\n        setPrompts(result.Results);\n        // Load saved embeddings if available\n        const savedEmbeddings = savedUserSettings?.embeddings || {};\n        setEmbeddings(savedEmbeddings);\n      } else {\n        setError('Failed to load AI Prompts');\n      }\n    } catch (err) {\n      setError(`Error loading prompts: ${err.message}`);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Generate embeddings for prompts that don't have them\n  const generateEmbeddings = async () => {\n    try {\n      setIsProcessing(true);\n      setError(null);\n      \n      // Filter prompts that need embeddings\n      const promptsNeedingEmbeddings = filteredPrompts.filter(\n        p => !embeddings[p.ID] && p.TemplateText && p.TemplateText.length > 0\n      );\n      \n      if (promptsNeedingEmbeddings.length === 0) {\n        // All prompts already have embeddings\n        performClustering();\n        return;\n      }\n      \n      // Batch process embeddings\n      const batchSize = 10;\n      const newEmbeddings = { ...embeddings };\n      \n      for (let i = 0; i < promptsNeedingEmbeddings.length; i += batchSize) {\n        const batch = promptsNeedingEmbeddings.slice(i, i + batchSize);\n        const texts = batch.map(p => p.TemplateText);\n        \n        try {\n          const result = await utilities.ai.EmbedText({\n            textToEmbed: texts,\n            modelSize: 'small'\n          });\n          \n          // Store embeddings\n          batch.forEach((prompt, idx) => {\n            newEmbeddings[prompt.ID] = result.result[idx];\n          });\n          \n          // Update state incrementally\n          setEmbeddings(newEmbeddings);\n        } catch (err) {\n          console.error('Error generating embeddings for batch:', err);\n        }\n      }\n      \n      // Save embeddings to user settings\n      onSaveUserSettings({\n        ...savedUserSettings,\n        embeddings: newEmbeddings\n      });\n      \n      // Perform clustering with new embeddings\n      performClustering(newEmbeddings);\n      \n    } catch (err) {\n      setError(`Error generating embeddings: ${err.message}`);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Perform clustering on embeddings\n  const performClustering = (embeddingsToUse = embeddings) => {\n    try {\n      const promptsWithEmbeddings = filteredPrompts.filter(\n        p => embeddingsToUse[p.ID]\n      );\n      \n      if (promptsWithEmbeddings.length < 2) {\n        setError('Need at least 2 prompts with embeddings to perform clustering');\n        return;\n      }\n      \n      // Prepare data for clustering\n      const vectors = promptsWithEmbeddings.map(p => embeddingsToUse[p.ID]);\n      const vectorService = utilities.ai.VectorService;\n      \n      // Perform k-means clustering\n      // First load vectors into the service\n      const vectorMap = new Map();\n      promptsWithEmbeddings.forEach((prompt, idx) => {\n        vectorMap.set(prompt.ID, embeddingsToUse[prompt.ID]);\n      });\n      vectorService.LoadVectors(vectorMap);\n      \n      // Then perform clustering\n      const clusterResult = vectorService.KMeansCluster(\n        Math.min(clusterCount, promptsWithEmbeddings.length),\n        100, // max iterations\n        'cosine' // distance metric\n      );\n      \n      // Map cluster assignments back to prompts\n      const clusteredPrompts = promptsWithEmbeddings.map((prompt) => {\n        // Find which cluster this prompt belongs to\n        let assignedCluster = 0;\n        clusterResult.clusters.forEach((members, clusterId) => {\n          if (members.includes(prompt.ID)) {\n            assignedCluster = clusterId;\n          }\n        });\n        \n        // Store the original prompt entity along with cluster data\n        return {\n          entity: prompt,  // Keep the original entity object\n          cluster: assignedCluster,\n          embedding: embeddingsToUse[prompt.ID],\n          // Expose commonly used properties for convenience\n          ID: prompt.ID,\n          Name: prompt.Name,\n          Category: prompt.Category,\n          Type: prompt.Type,\n          Description: prompt.Description,\n          Status: prompt.Status,\n          TemplateText: prompt.TemplateText\n        };\n      });\n      \n      setClusters(clusteredPrompts);\n      \n      // Generate names for clusters\n      generateClusterNames(clusteredPrompts);\n      \n    } catch (err) {\n      setError(`Error performing clustering: ${err.message}`);\n    }\n  };\n  \n  // Generate AI-powered names for clusters\n  const generateClusterNames = async (clusteredPrompts) => {\n    try {\n      // Group prompts by cluster\n      const clusterGroups = {};\n      clusteredPrompts.forEach(prompt => {\n        if (!clusterGroups[prompt.cluster]) {\n          clusterGroups[prompt.cluster] = [];\n        }\n        clusterGroups[prompt.cluster].push(prompt);\n      });\n      \n      // Prepare cluster summaries for AI\n      const clusterSummaries = {};\n      Object.entries(clusterGroups).forEach(([clusterId, prompts]) => {\n        // Get unique categories and types\n        const categories = [...new Set(prompts.map(p => p.Category).filter(Boolean))];\n        const types = [...new Set(prompts.map(p => p.Type).filter(Boolean))];\n        \n        // Sample prompt names (up to 5)\n        const sampleNames = prompts.slice(0, 5).map(p => p.Name);\n        \n        // Sample template texts (first 150 chars, up to 3 prompts)\n        const templateSamples = prompts\n          .slice(0, 3)\n          .map(p => p.TemplateText ? p.TemplateText.substring(0, 150) + '...' : '')\n          .filter(Boolean);\n        \n        clusterSummaries[clusterId] = {\n          promptCount: prompts.length,\n          sampleNames,\n          categories,\n          types,\n          templateSamples\n        };\n      });\n      \n      // Create a single prompt for all clusters\n      const namingPrompt = `Analyze these clusters of AI prompts and generate concise, descriptive names (2-4 words) for each cluster based on their common themes or purposes.\n\n${Object.entries(clusterSummaries).map(([id, summary]) => `\nCluster ${parseInt(id) + 1}:\n- ${summary.promptCount} prompts total\n- Sample names: ${summary.sampleNames.join(', ')}\n- Categories: ${summary.categories.length > 0 ? summary.categories.join(', ') : 'Various'}\n- Types: ${summary.types.length > 0 ? summary.types.join(', ') : 'Various'}\n- Template samples: ${summary.templateSamples.length > 0 ? summary.templateSamples[0].substring(0, 100) : 'N/A'}\n`).join('\\n')}\n\nReturn a JSON object with cluster numbers as keys and descriptive names as values. Example format:\n{\n  \"0\": \"Data Analysis Tools\",\n  \"1\": \"User Communication\",\n  \"2\": \"System Administration\"\n}\n\nOnly return the JSON object, nothing else.`;\n      \n      // Call AI to generate names using ExecutePrompt\n      const result = await utilities.ai.ExecutePrompt({\n        systemPrompt: namingPrompt,\n        modelPower: 'lowest' // This is a simple task, use the cheapest/fastest model\n      });\n      \n      if (result && result.success && result.result) {\n        try {\n          // Parse the JSON response - ExecutePrompt may already parse it for us\n          const names = result.resultObject || JSON.parse(result.result);\n          setClusterNames(names);\n          \n          // Optionally save to user settings\n          if (onSaveUserSettings) {\n            onSaveUserSettings({\n              ...savedUserSettings,\n              clusterNames: names\n            });\n          }\n        } catch (parseErr) {\n          console.error('Failed to parse cluster names:', parseErr);\n          // Fall back to numbered clusters\n          const fallbackNames = {};\n          Object.keys(clusterSummaries).forEach(id => {\n            fallbackNames[id] = `Cluster ${parseInt(id) + 1}`;\n          });\n          setClusterNames(fallbackNames);\n        }\n      }\n    } catch (err) {\n      console.error('Error generating cluster names:', err);\n      // Don't let this break the clustering - just use numbers\n    }\n  };\n\n  // Filter prompts based on current filters\n  const filteredPrompts = useMemo(() => {\n    return prompts.filter(prompt => {\n      // Search filter\n      if (filters.search) {\n        const searchLower = filters.search.toLowerCase();\n        const matchesSearch = \n          prompt.Name?.toLowerCase().includes(searchLower) ||\n          prompt.Description?.toLowerCase().includes(searchLower) ||\n          prompt.TemplateText?.toLowerCase().includes(searchLower);\n        if (!matchesSearch) return false;\n      }\n      \n      // Category filter\n      if (filters.category && prompt.CategoryID !== filters.category) {\n        return false;\n      }\n      \n      // Type filter\n      if (filters.type && prompt.TypeID !== filters.type) {\n        return false;\n      }\n      \n      // Status filter\n      if (filters.status && prompt.Status !== filters.status) {\n        return false;\n      }\n      \n      // Role filter\n      if (filters.role && prompt.PromptRole !== filters.role) {\n        return false;\n      }\n      \n      return true;\n    });\n  }, [prompts, filters]);\n\n  // Get unique categories and types for filters\n  const categories = useMemo(() => {\n    const uniqueCategories = new Map();\n    prompts.forEach(p => {\n      if (p.CategoryID && p.Category) {\n        uniqueCategories.set(p.CategoryID, p.Category);\n      }\n    });\n    return Array.from(uniqueCategories, ([id, name]) => ({ id, name }));\n  }, [prompts]);\n\n  const types = useMemo(() => {\n    const uniqueTypes = new Map();\n    prompts.forEach(p => {\n      if (p.TypeID && p.Type) {\n        uniqueTypes.set(p.TypeID, p.Type);\n      }\n    });\n    return Array.from(uniqueTypes, ([id, name]) => ({ id, name }));\n  }, [prompts]);\n\n  // Format insights text using marked library for proper markdown rendering\n\n  const generateAIInsights = async () => {\n    if (clusters.length === 0) {\n      setInsightsError('Please generate clusters first');\n      return;\n    }\n    \n    setLoadingInsights(true);\n    setInsightsError(null);\n    \n    try {\n      // Prepare cluster analysis data\n      const clusterAnalysis = clusters.map((cluster, idx) => {\n        const clusterPrompts = filteredPrompts.filter(p => \n          embeddings[p.ID] && cluster.members.includes(p.ID)\n        );\n        \n        return {\n          id: idx,\n          name: clusterNames[idx] || `Cluster ${idx + 1}`,\n          size: clusterPrompts.length,\n          prompts: clusterPrompts.slice(0, 3).map(p => p.Name), // Sample prompts\n          categories: [...new Set(clusterPrompts.map(p => p.Category).filter(Boolean))],\n          types: [...new Set(clusterPrompts.map(p => p.Type).filter(Boolean))],\n          roles: [...new Set(clusterPrompts.map(p => p.PromptRole).filter(Boolean))]\n        };\n      });\n      \n      const prompt = `Analyze this AI prompts clustering data and provide insights:\n\nCluster Analysis:\n${JSON.stringify(clusterAnalysis, null, 2)}\n\nTotal Prompts: ${prompts.length}\nFiltered Prompts: ${filteredPrompts.length}\nNumber of Clusters: ${clusters.length}\nSimilarity Threshold: ${similarityThreshold}\n\nPlease provide:\n1. **Cluster Quality Assessment** - How well-defined and coherent are the clusters?\n2. **Thematic Patterns** - What themes or patterns emerge from the clustering?\n3. **Distribution Analysis** - How are prompts distributed across clusters?\n4. **Outliers and Anomalies** - Any unusual patterns or isolated prompts?\n5. **Optimization Suggestions** - How could the clustering be improved?\n6. **Business Insights** - What does this clustering reveal about the prompt library?\n7. **Recommendations** - Specific actions to improve prompt organization\n\nFormat your response in clear markdown with headers and bullet points.`;\n      \n      const result = await utilities.ai.ExecutePrompt({\n        systemPrompt: 'You are an expert in natural language processing, clustering analysis, and prompt engineering. Analyze the clustering results and provide actionable insights about the AI prompt library organization.',\n        messages: prompt,\n        preferredModels: ['GPT-OSS-120B', 'Qwen3 32B'],\n        modelPower: 'high',\n        temperature: 0.7,\n        maxTokens: 1500\n      });\n      \n      if (result?.success && result?.result) {\n        setAiInsights(result.result);\n      } else {\n        setInsightsError('Failed to generate insights. Please try again.');\n      }\n    } catch (error) {\n      setInsightsError(error.message || 'Failed to generate AI insights');\n    } finally {\n      setLoadingInsights(false);\n    }\n  };\n  \n  // Calculate similar prompts for selected prompt\n  const similarPrompts = useMemo(() => {\n    if (!selectedPrompt || !embeddings[selectedPrompt.ID]) return [];\n    \n    const selectedEmbedding = embeddings[selectedPrompt.ID];\n    const vectorService = utilities.ai.VectorService;\n    \n    // Calculate similarities to all other prompts with embeddings\n    const similarities = filteredPrompts\n      .filter(p => p.ID !== selectedPrompt.ID && embeddings[p.ID])\n      .map(prompt => {\n        // Use CalculateDistance with cosine metric and convert to similarity\n        const distance = vectorService.CalculateDistance(\n          selectedEmbedding,\n          embeddings[prompt.ID],\n          'cosine'\n        );\n        return {\n          prompt,\n          similarity: 1 - distance // Convert distance to similarity\n        };\n      })\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, 5); // Top 5 similar prompts\n    \n    return similarities;\n  }, [selectedPrompt, embeddings, filteredPrompts]);\n\n  // Get cluster info for selected prompt\n  const clusterInfo = useMemo(() => {\n    if (!selectedPrompt || clusters.length === 0) return null;\n    \n    const clusteredPrompt = clusters.find(p => p.ID === selectedPrompt.ID);\n    if (!clusteredPrompt) return null;\n    \n    const clusterMembers = clusters.filter(p => p.cluster === clusteredPrompt.cluster);\n    \n    return {\n      clusterIndex: clusteredPrompt.cluster,\n      clusterSize: clusterMembers.length,\n      clusterMembers: clusterMembers.slice(0, 10).map(member => ({\n        ...member,\n        // Ensure entity is available for navigation\n        entity: member.entity\n      }))\n    };\n  }, [selectedPrompt, clusters]);\n\n  // Event handlers\n  const handlePromptSelect = (promptOrClusteredPrompt) => {\n    // If it's a clustered prompt object, extract the entity\n    // Otherwise use the prompt as-is\n    const prompt = promptOrClusteredPrompt?.entity || promptOrClusteredPrompt;\n    setSelectedPrompt(prompt);\n    setHighlightCluster(null);\n  };\n\n  const handleClusterSelect = (clusterIndex) => {\n    setHighlightCluster(clusterIndex);\n    setSelectedPrompt(null);\n  };\n\n  const handleRecalculate = () => {\n    generateEmbeddings();\n  };\n\n  // Prepare export data for DataExportPanel\n  const prepareExportData = () => {\n    console.log('ðŸ” [AIPromptsCluster] prepareExportData called');\n    console.log('ðŸ” [AIPromptsCluster] clusters:', clusters);\n    console.log('ðŸ” [AIPromptsCluster] clusters length:', clusters?.length);\n    console.log('ðŸ” [AIPromptsCluster] clusterNames:', clusterNames);\n    \n    // Return empty array if no clusters\n    if (!clusters || clusters.length === 0) {\n      console.log('âš ï¸ [AIPromptsCluster] No clusters available for export');\n      return [];\n    }\n    \n    const exportData = clusters.map(prompt => ({\n      ID: prompt.ID || '',\n      Name: prompt.Name || '',\n      Category: prompt.Category || '',\n      Type: prompt.Type || '',\n      // Use the LLM-generated cluster name if available, otherwise fall back to numbered cluster\n      ClusterName: clusterNames[prompt.cluster] || `Cluster ${prompt.cluster + 1}`,\n      Status: prompt.Status || '',\n      PromptRole: prompt.PromptRole || '',\n      ResponseFormat: prompt.ResponseFormat || ''\n    }));\n    \n    console.log('ðŸ” [AIPromptsCluster] exportData prepared:', exportData);\n    console.log('ðŸ” [AIPromptsCluster] exportData length:', exportData?.length);\n    console.log('ðŸ” [AIPromptsCluster] Sample export row:', exportData[0]);\n    \n    return exportData;\n  };\n\n  // Define export columns - DataExportPanel expects key/label not field/header\n  const getExportColumns = () => {\n    const columns = [\n      { key: 'ID', label: 'ID' },\n      { key: 'Name', label: 'Name' },\n      { key: 'Category', label: 'Category' },\n      { key: 'Type', label: 'Type' },\n      { key: 'ClusterName', label: 'Cluster' },  // Only export cluster name, not redundant number\n      { key: 'Status', label: 'Status' },\n      { key: 'PromptRole', label: 'Role' },\n      { key: 'ResponseFormat', label: 'Response Format' }\n    ];\n    console.log('ðŸ” [AIPromptsCluster] Export columns defined:', columns);\n    return columns;\n  };\n\n  const handleEditPrompt = (promptId) => {\n    callbacks.OpenEntityRecord('AI Prompts', [\n      { FieldName: 'ID', Value: promptId }\n    ]);\n  };\n  \n  // Function to get the cluster visualization element for PDF export\n  // Using a callback function to ensure we get the element at export time\n  const getClusterVisualization = useCallback(() => {\n    console.log('ðŸŽ¨ [AIPromptsCluster] Getting cluster visualization for PDF export');\n    if (!clusterGraphRef.current) {\n      console.warn('âš ï¸ Cluster graph ref not available');\n      return null;\n    }\n    \n    // Return the container div which html2canvas can handle better\n    // html2canvas has issues with standalone SVG elements from React components\n    console.log('ðŸ“¦ Returning cluster graph container for capture');\n    console.log('  - Container dimensions:', {\n      width: clusterGraphRef.current.offsetWidth,\n      height: clusterGraphRef.current.offsetHeight,\n      hasContent: clusterGraphRef.current.children.length > 0\n    });\n    \n    // Return the container which includes the SVG/canvas in context\n    return clusterGraphRef.current;\n  }, []);\n\n  // Render component\n  return (\n    <div style={{\n      display: 'flex',\n      flexDirection: 'column',\n      height: '100%',\n      padding: styles.spacing?.md || '16px',\n      backgroundColor: styles.colors?.background || '#f5f5f5',\n      fontFamily: styles.fonts?.body || 'system-ui, -apple-system, sans-serif'\n    }}>\n      {/* Header */}\n      <div style={{\n        marginBottom: styles.spacing?.md || '16px'\n      }}>\n        <div style={{\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'flex-start'\n        }}>\n          <div>\n            <h2 style={{\n              fontSize: styles.fonts?.sizes?.xl || '24px',\n              fontWeight: 'bold',\n              color: styles.colors?.text?.primary || '#333',\n              margin: 0\n            }}>\n              AI Prompts Cluster Analysis\n            </h2>\n            <p style={{\n              fontSize: styles.fonts?.sizes?.sm || '14px',\n              color: styles.colors?.text?.secondary || '#666',\n              marginTop: styles.spacing?.xs || '4px'\n            }}>\n              Discover patterns and relationships in your AI prompts through semantic clustering\n            </p>\n          </div>\n          \n          {/* Export and AI Insights buttons */}\n          <div style={{\n            display: 'flex',\n            gap: '12px',\n            alignItems: 'center'\n          }}>\n            {/* Export Button */}\n            {DataExportPanel && clusters.length > 0 && (\n              <DataExportPanel\n                data={prepareExportData()}\n                columns={getExportColumns()}\n                filename={`ai-prompts-clusters-${new Date().toISOString().split('T')[0]}`}\n                formats={['csv', 'excel', 'pdf']}\n                buttonStyle=\"dropdown\"\n                buttonText=\"Export\"\n                icon=\"fa-download\"\n                getHtmlElement={getClusterVisualization}  // Provide cluster viz for PDF\n                pdfOptions={{\n                  orientation: 'landscape',  // Better for wide cluster visualization\n                  pageSize: 'a4',\n                  margins: { top: 60, bottom: 40, left: 40, right: 40 }\n                }}\n                onExportStart={() => {\n                  console.log('ðŸŽ¯ [AIPromptsCluster] Export started!');\n                }}\n                onExportComplete={(format) => {\n                  console.log('âœ… [AIPromptsCluster] Export completed!', format);\n                }}\n                onExportError={(error) => {\n                  console.error('âŒ [AIPromptsCluster] Export error:', error);\n                }}\n                customStyles={{\n                  button: {\n                    padding: '8px 16px',\n                    fontSize: '14px',\n                    fontWeight: '600',\n                    border: '2px solid #e2e8f0',\n                    borderRadius: '8px',\n                    backgroundColor: 'white',\n                    color: '#4a5568',\n                    cursor: 'pointer',\n                    display: 'flex',\n                    alignItems: 'center',\n                    gap: '8px',\n                    transition: 'all 0.2s',\n                    boxShadow: '0 1px 3px rgba(0,0,0,0.1)'\n                  }\n                }}\n                utilities={utilities}\n                styles={styles}\n                components={components}\n                callbacks={callbacks}\n              />\n            )}\n            \n            {/* AI Insights Panel */}\n            <AIInsightsPanel\n              utilities={utilities}\n              styles={styles}\n              components={components}\n              callbacks={callbacks}\n              savedUserSettings={savedUserSettings?.aiInsights}\n              onSaveUserSettings={(settings) => onSaveUserSettings?.({\n                ...savedUserSettings,\n                aiInsights: settings\n              })}\n              insights={aiInsights}\n              loading={loadingInsights}\n              error={insightsError}\n              onGenerate={generateAIInsights}\n              title=\"AI Prompts Cluster Analysis\"\n              icon=\"fa-wand-magic-sparkles\"\n              iconColor={styles?.colors?.primary || '#8B5CF6'}\n              position=\"bottom\"\n              onClose={() => {\n                setAiInsights(null);\n                setInsightsError(null);\n              }}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Error display */}\n      {error && (\n        <div style={{\n          padding: styles.spacing?.sm || '8px',\n          backgroundColor: '#fee',\n          color: '#c00',\n          borderRadius: styles.borders?.radius || '4px',\n          marginBottom: styles.spacing?.md || '16px'\n        }}>\n          {error}\n        </div>\n      )}\n\n      {/* Main content area */}\n      <div style={{\n        display: 'flex',\n        flex: 1,\n        gap: styles.spacing?.md || '16px',\n        overflow: 'hidden'\n      }}>\n        {/* Left panel - Controls */}\n        <div style={{\n          width: '280px',\n          display: 'flex',\n          flexDirection: 'column',\n          gap: styles.spacing?.sm || '8px'\n        }}>\n          <ClusterControls\n            categories={categories}\n            types={types}\n            currentFilters={filters}\n            clusterCount={clusterCount}\n            similarityThreshold={similarityThreshold}\n            isProcessing={isProcessing}\n            onSearchChange={(search) => setFilters({ ...filters, search })}\n            onFilterChange={setFilters}\n            onClusterCountChange={setClusterCount}\n            onSimilarityThresholdChange={setSimilarityThreshold}\n            onRecalculate={handleRecalculate}\n            utilities={utilities}\n            styles={styles}\n            components={components}\n            callbacks={callbacks}\n            savedUserSettings={savedUserSettings}\n            onSaveUserSettings={onSaveUserSettings}\n          />\n        </div>\n\n        {/* Center - Graph */}\n        <div \n          ref={clusterGraphRef}\n          id=\"cluster-graph-container\"\n          style={{\n            flex: 1,\n            backgroundColor: styles.colors?.surface || 'white',\n            borderRadius: styles.borders?.radius || '4px',\n            padding: styles.spacing?.sm || '8px',\n            position: 'relative',\n            // Ensure proper rendering for export\n            minHeight: '400px',\n            overflow: 'visible'\n          }}>\n          {clusters.length > 0 ? (\n            <ClusterGraph\n              prompts={clusters}\n              clusters={clusters}\n              clusterNames={clusterNames}\n              selectedPromptId={selectedPrompt?.ID}\n              similarityThreshold={similarityThreshold}\n              highlightCluster={highlightCluster}\n              onNodeClick={handlePromptSelect}\n              onNodeHover={() => {}}\n              onClusterSelect={handleClusterSelect}\n              utilities={utilities}\n              styles={styles}\n              components={components}\n              callbacks={callbacks}\n              savedUserSettings={savedUserSettings}\n              onSaveUserSettings={onSaveUserSettings}\n            />\n          ) : (\n            <div style={{\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              height: '100%',\n              color: styles.colors?.text?.secondary || '#666'\n            }}>\n              {isProcessing ? (\n                <div>Generating embeddings and clustering...</div>\n              ) : (\n                <div style={{\n                  textAlign: 'center'\n                }}>\n                  <div style={{\n                    marginBottom: styles.spacing?.sm || '8px'\n                  }}>\n                    No clusters generated yet\n                  </div>\n                  <div style={{\n                    fontSize: styles.fonts?.sizes?.sm || '14px'\n                  }}>\n                    Use the \"Generate Clusters\" button in the controls panel to begin\n                  </div>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n\n        {/* Right panel - Details */}\n        <div style={{\n          width: '320px',\n          backgroundColor: styles.colors?.surface || 'white',\n          borderRadius: styles.borders?.radius || '4px',\n          padding: styles.spacing?.md || '16px',\n          overflowY: 'auto'\n        }}>\n          <ClusterDetails\n            selectedPrompt={selectedPrompt}\n            allPrompts={filteredPrompts}\n            clusterInfo={clusterInfo}\n            similarPrompts={similarPrompts}\n            onPromptNavigate={(promptId) => {\n              const prompt = prompts.find(p => p.ID === promptId);\n              if (prompt) handlePromptSelect(prompt);\n            }}\n            onEditPrompt={handleEditPrompt}\n            utilities={utilities}\n            styles={styles}\n            components={components}\n            callbacks={callbacks}\n            savedUserSettings={savedUserSettings}\n            onSaveUserSettings={onSaveUserSettings}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}",
  "functionalRequirements": "Load all AI prompts, generate embeddings from TemplateText, perform clustering analysis, visualize clusters in interactive graph, show prompt details on selection, provide filtering and search capabilities",
  "technicalDesign": "Main orchestrator that loads AI prompts data, manages embeddings generation and caching, coordinates sub-components for visualization and interaction, uses D3.js for graph rendering and SimpleVectorService for clustering",
  "dataRequirements": {
    "mode": "views",
    "entities": [
      {
        "name": "AI Prompts",
        "displayFields": [
          "Name",
          "Description",
          "TemplateText",
          "CategoryID",
          "Category",
          "TypeID",
          "Type",
          "Status",
          "PromptRole",
          "ResponseFormat",
          "Template"
        ],
        "filterFields": [
          "Status",
          "CategoryID",
          "TypeID",
          "PromptRole"
        ],
        "sortFields": [
          "Name",
          "CreatedAt",
          "UpdatedAt"
        ],
        "permissions": [
          "read"
        ]
      }
    ]
  },
  "properties": [],
  "events": [
    {
      "name": "onPromptSelect",
      "description": "Fired when a prompt is selected in the visualization",
      "parameters": [
        {
          "name": "prompt",
          "type": "object",
          "description": "The selected AI prompt entity"
        }
      ]
    }
  ],
  "dependencies": [
    {
      "name": "AIPromptsClusterGraph",
      "location": "registry",
      "namespace": "AI/Analytics",
      "version": "^1.0.0"
    },
    {
      "name": "AIPromptsClusterControls",
      "location": "registry",
      "namespace": "AI/Analytics",
      "version": "^1.0.0"
    },
    {
      "name": "AIPromptsClusterDetails",
      "location": "registry",
      "namespace": "AI/Analytics",
      "version": "^1.0.0"
    },
    {
      "name": "DataExportPanel",
      "location": "registry",
      "namespace": "Generic/UI/Export",
      "version": "^1.0.0"
    },
    {
      "name": "AIInsightsPanel",
      "location": "registry",
      "namespace": "Generic/UI/AI",
      "version": "^1.0.0"
    }
  ],
  "libraries": [
    {
      "name": "d3",
      "version": "7.8.5",
      "globalVariable": "d3"
    },
    {
      "name": "lodash",
      "version": "4.17.21",
      "globalVariable": "_"
    }
  ],
  "usageExample": "<AIPromptsCluster />",
  "version": "1.0.0"
}