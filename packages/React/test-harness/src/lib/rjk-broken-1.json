{
  "title": "Members Joined by Year",
  "type": "chart",
  "name": "MemberJoinLineChart",
  "userExplanation": "A simple line chart that shows how many members joined in each year (2023‑2025), with clear axis labels, tooltips, and a title.",
  "functionalRequirements": "### Business Objective\nDisplay a clear visual of member growth over the years 2023, 2024, and 2025 to help stakeholders quickly assess recruitment trends.\n\n### Functional Requirements\n- **Line Chart** showing the total number of members who joined in each of the three years.\n- **X‑Axis**: Year (2023, 2024, 2025).\n- **Y‑Axis**: Count of members joined.\n- **Data Series Label**: \"Members Joined\".\n- **Tooltip**: Hovering a point displays the exact count for that year.\n- **Chart Title**: \"Members Joined by Year\".\n- **Responsive Layout**: Adjusts to container size.\n- **Optional Simple Filter**: Allow the user to adjust the displayed year range (e.g., show only 2023‑2024).",
  "dataRequirements": {
    "mode": "queries",
    "entities": [
      {
        "name": "Accounts",
        "description": "Stores member (person) accounts with join date and membership status.",
        "displayFields": [
          "Id"
        ],
        "filterFields": [
          "IsPersonAccount"
        ],
        "fieldMetadata": [
          {
            "name": "Id",
            "sequence": 1,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": true,
            "description": "Primary key of the Account record."
          },
          {
            "name": "IsPersonAccount",
            "sequence": 52,
            "defaultInView": false,
            "type": "bit",
            "allowsNull": true,
            "isPrimaryKey": false,
            "description": "Indicates if the account is a person account."
          }
        ],
        "permissionLevelNeeded": [
          "read"
        ]
      }
    ],
    "queries": [
      {
        "name": "MembersJoinedPerYear",
        "categoryPath": "Skip/Membership/Analytics/MembersJoinedPerYear",
        "description": "Returns a list of calendar years with the count of person accounts that joined in each year. Filters on IsPersonAccount = 1 and groups by YEAR(NU__JoinOn__c).",
        "fields": [
          {
            "name": "Year",
            "sequence": 1,
            "defaultInView": true,
            "type": "decimal(18,2)",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Calendar year extracted from NU__JoinOn__c"
          },
          {
            "name": "MemberCount",
            "sequence": 2,
            "defaultInView": true,
            "type": "decimal(18,2)",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Count of person accounts in the given year"
          }
        ],
        "entityNames": [
          "Accounts"
        ]
      }
    ],
    "description": "Data design for a line chart visualizing member growth by year (2023‑2025) using a server‑side query for aggregation."
  },
  "description": "A simple line chart that visualizes the number of members who joined each year (2023‑2025) with optional year range filtering.",
  "technicalDesign": "## Component Architecture\n- **MemberJoinLineChart** (root component)\n  - Receives no direct data; it executes the `MembersJoinedPerYear` query defined in the payload's `dataRequirements`.\n  - Applies an optional year‑range filter (default 2023‑2025) using a small Ant Design `Select` control.\n  - Transforms the query result into the shape required by the **SimpleChart** dependency (array of objects with `Year` and `MemberCount`).\n  - Passes the transformed data to **SimpleChart** via its props: `entityName=\"Accounts\"`, `data`, `groupBy=\"Year\"`, `valueField=\"MemberCount\"`, `aggregateMethod=\"count\"`, `chartType=\"line\"`, `title=\"Members Joined by Year\"`.\n  - Handles `dataPointClick` event from SimpleChart to surface the clicked year and member count to parent via `onYearSelect` callback.\n\n## Data Flow\n1. **Query Execution** – On mount, the component runs the `MembersJoinedPerYear` query (defined in root `dataRequirements`).\n2. **Filtering** – If a user selects a custom year range, the query is re‑executed with a filter on `Year`.\n3. **Transformation** – Query rows are mapped to `{ Year, MemberCount }` objects.\n4. **Rendering** – The transformed array is supplied to the SimpleChart registry component.\n5. **Event Propagation** – When a chart point is clicked, `onYearSelect` is invoked with `{ year, count }`.\n\n## State Management\n- Internal state (`selectedYears`, `queryData`, `loading`, `error`) managed with React `useState`.\n- External state (user preferences, persisted settings) communicated via callbacks: `onSaveUserSettings`, `onYearSelect`.\n\n## Props (Root Component)\n- `userState` – Object containing persisted UI settings.\n- `callbacks` – Contains `onSaveUserSettings` and `onYearSelect`.\n- `utilities` – Provides MJ utilities for query execution.\n- `styles` – Optional styling overrides.\n- `components` – Allows overriding of internal UI components.\n\n## Events (Root Component)\n- `onYearSelect` – Fired when a user clicks a data point, passing `{ year: string, count: number }`.\n- `onError` – Fired if the query fails or chart rendering encounters an error.\n\n## Libraries\n- **antd** – UI library for the year‑range selector.\n- **chart.js** – Already required by SimpleChart dependency (included automatically).\n\n## Dependencies\n- **SimpleChart** – Registry component used to render the line chart.\n\n## Example Usage\n```tsx\n<MemberJoinLineChart\n  utilities={utils}\n  userState={savedSettings}\n  callbacks={{\n    onSaveUserSettings: saveSettings,\n    onYearSelect: handleYearSelect,\n    onError: handleError\n  }}\n/>\n```",
  "libraries": [
    {
      "name": "antd",
      "globalVariable": "antd",
      "version": "^5.20.2"
    }
  ],
  "dependencies": [
    {
      "name": "SimpleChart",
      "title": "Simple Chart",
      "description": "A lightweight chart component that automatically creates common visualizations from entity data with minimal configuration",
      "type": "chart",
      "location": "registry",
      "functionalRequirements": "Lightweight charting from entity data. Groups records by field, aggregates values (count/sum/avg), renders as bar/line/pie/area chart. Auto-selects chart type based on data. Supports click events for drill-down, data export, top-N filtering. Common uses: category distributions, time series trends, metric comparisons.",
      "technicalDesign": "Uses Chart.js (canvas-based) for rendering. Pipeline: group data by field → aggregate (count/sum/avg) → sort/limit → render. Auto-selects chart type: bar for categories, line for dates, pie for distributions. Memoized calculations for performance. Click events return data point details and source records for drill-down.",
      "dataRequirements": {
        "mode": "props",
        "description": "Component receives entity data through props and performs client-side aggregation"
      },
      "properties": [
        {
          "name": "entityName",
          "type": "string",
          "description": "Name of the entity being visualized",
          "required": true
        },
        {
          "name": "data",
          "type": "Array<object>",
          "description": "Array of entity objects to visualize",
          "required": true
        },
        {
          "name": "groupBy",
          "type": "string",
          "description": "Field name to group data by",
          "required": true
        },
        {
          "name": "valueField",
          "type": "string",
          "description": "Field to aggregate for values. If not specified, counts records",
          "required": false
        },
        {
          "name": "aggregateMethod",
          "type": "'count' | 'sum' | 'average' | 'min' | 'max'",
          "description": "How to aggregate values",
          "required": false,
          "defaultValue": "count",
          "possibleValues": [
            "count",
            "sum",
            "average",
            "min",
            "max"
          ]
        },
        {
          "name": "chartType",
          "type": "'auto' | 'bar' | 'line' | 'pie' | 'doughnut' | 'area' | 'scatter'",
          "description": "Chart type to render. 'auto' selects based on data",
          "required": false,
          "defaultValue": "auto",
          "possibleValues": [
            "auto",
            "bar",
            "line",
            "pie",
            "doughnut",
            "area",
            "scatter"
          ]
        },
        {
          "name": "title",
          "type": "string",
          "description": "Chart title. If not provided, generates from entity and groupBy field",
          "required": false
        },
        {
          "name": "height",
          "type": "number",
          "description": "Chart height in pixels",
          "required": false,
          "defaultValue": 400
        },
        {
          "name": "sortBy",
          "type": "'label' | 'value' | 'none'",
          "description": "How to sort the chart data",
          "required": false,
          "defaultValue": "value",
          "possibleValues": [
            "label",
            "value",
            "none"
          ]
        },
        {
          "name": "sortOrder",
          "type": "'asc' | 'desc'",
          "description": "Sort direction",
          "required": false,
          "defaultValue": "desc",
          "possibleValues": [
            "asc",
            "desc"
          ]
        },
        {
          "name": "limit",
          "type": "number",
          "description": "Limit number of data points shown (e.g., top 10)",
          "required": false
        },
        {
          "name": "colors",
          "type": "Array<string>",
          "description": "Custom color palette for the chart",
          "required": false
        },
        {
          "name": "showLegend",
          "type": "boolean",
          "description": "Whether to show the legend",
          "required": false,
          "defaultValue": true
        },
        {
          "name": "legendPosition",
          "type": "'auto' | 'top' | 'bottom' | 'left' | 'right'",
          "description": "Position of the legend. 'auto' uses bottom for pie/doughnut, top for others",
          "required": false,
          "defaultValue": "auto",
          "possibleValues": [
            "auto",
            "top",
            "bottom",
            "left",
            "right"
          ]
        },
        {
          "name": "legendFontSize",
          "type": "number",
          "description": "Font size for legend labels in pixels",
          "required": false,
          "defaultValue": 12
        },
        {
          "name": "showDataLabels",
          "type": "boolean",
          "description": "Whether to show data labels on chart",
          "required": false,
          "defaultValue": false
        },
        {
          "name": "enableExport",
          "type": "boolean",
          "description": "Show export button to download chart as image",
          "required": false,
          "defaultValue": true
        }
      ],
      "events": [
        {
          "name": "dataPointClick",
          "description": "Fired when user clicks on a data point",
          "parameters": [
            {
              "name": "clickData",
              "type": "{ seriesName: string; value: number; label: string; records: Array<object>; chartType: string; percentage?: number }",
              "description": "Object containing series name, data value, label, original records, and chart type"
            }
          ]
        },
        {
          "name": "chartRendered",
          "description": "Fired when chart has finished rendering",
          "parameters": [
            {
              "name": "chartInfo",
              "type": "{ chartType: string; dataPointCount: number; aggregationMethod: string; isEmpty: boolean }",
              "description": "Information about the rendered chart including type, data point count, and aggregation method"
            }
          ]
        }
      ],
      "libraries": [
        {
          "name": "chart.js",
          "version": "4.4.1",
          "globalVariable": "Chart"
        }
      ],
      "dependencies": [],
      "code": "function SimpleChart({\n  entityName,\n  data,\n  groupBy,\n  valueField,\n  aggregateMethod = 'count',\n  chartType = 'auto',\n  title,\n  height = 400,\n  sortBy = 'value',\n  sortOrder = 'desc',\n  limit,\n  colors,\n  showLegend = true,\n  legendPosition = 'auto', // New prop: 'auto', 'top', 'bottom', 'left', 'right'\n  legendFontSize = 12, // New prop for legend font size\n  showDataLabels = false,\n  enableExport = true,\n  onDataPointClick,\n  onChartRendered,\n  utilities,\n  styles,\n  components,\n  callbacks,\n  savedUserSettings,\n  onSaveUserSettings\n}) {\n  // Always use the MJ unwrapLibraryComponents function to get components from global libraries\n  // This ensures that various library build/package formats are handled correctly and transparently\n  // Chart.js is available as a global 'Chart' based on the spec's globalVariable setting\n  // Since Chart.js exports a single constructor function, unwrapLibraryComponents returns it for the requested name\n  const { Chart: ChartJS } = unwrapLibraryComponents(Chart, 'Chart');\n  \n  const canvasRef = React.useRef(null);\n  const chartInstanceRef = React.useRef(null);\n  const [error, setError] = React.useState(null);\n  const [entityInfo, setEntityInfo] = React.useState(null);\n\n  // Default color palette - accessible and visually distinct\n  const defaultColors = [\n    '#1890ff', // Blue\n    '#52c41a', // Green\n    '#fa8c16', // Orange\n    '#f5222d', // Red\n    '#722ed1', // Purple\n    '#13c2c2', // Cyan\n    '#fa541c', // Red-orange\n    '#2f54eb', // Deep blue\n    '#a0d911', // Lime\n    '#eb2f96'  // Magenta\n  ];\n\n  // Load entity metadata\n  React.useEffect(() => {\n    if (!entityName || !utilities?.md?.Entities) {\n      if (!entityName) console.error('Entity name not provided');\n      if (!utilities?.md?.Entities) console.error('Entity metadata not loaded.');\n      return;\n    }\n    \n    const entity = utilities.md.Entities.find(e => e.Name === entityName);\n    if (entity) {\n      setEntityInfo(entity);\n    }\n  }, [entityName, utilities]);\n\n  // Helper function to format values based on type\n  const formatValue = (value, isDate = false, isCurrency = false) => {\n    if (value == null) return 'N/A';\n    \n    if (isDate) {\n      try {\n        const date = new Date(value);\n        if (isNaN(date.getTime())) return value;\n        return date.toLocaleDateString('en-US', { \n          month: 'short', \n          day: 'numeric',\n          year: 'numeric'\n        });\n      } catch {\n        return value;\n      }\n    }\n    \n    if (isCurrency || (typeof value === 'number' && valueField && valueField.toLowerCase().includes('amount'))) {\n      if (typeof value === 'number') {\n        return new Intl.NumberFormat('en-US', {\n          style: 'currency',\n          currency: 'USD',\n          minimumFractionDigits: 0,\n          maximumFractionDigits: 0\n        }).format(value);\n      }\n    }\n    \n    if (typeof value === 'number') {\n      // Format large numbers with commas\n      return new Intl.NumberFormat('en-US').format(value);\n    }\n    \n    return value;\n  };\n\n  // Process and aggregate data\n  const processData = React.useMemo(() => {\n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return { chartData: [], categories: [], values: [], isEmpty: true };\n    }\n\n    try {\n      // Validate that fields exist in the actual data, not just entity metadata\n      // This allows for calculated fields from queries that don't exist in base entity\n      if (data.length > 0) {\n        // Check if fields exist in data\n        if (!(groupBy in data[0])) {\n          const error = `Field \"${groupBy}\" not found in data. Available fields: ${Object.keys(data[0]).join(', ')}`;\n          console.error(error);\n          setError(error);\n          return { chartData: [], categories: [], values: [], isEmpty: true };\n        }\n\n        if (valueField && !(valueField in data[0])) {\n          const error = `Value field \"${valueField}\" not found in data. Available fields: ${Object.keys(data[0]).join(', ')}`;\n          console.error(error);\n          setError(error);\n          return { chartData: [], categories: [], values: [], isEmpty: true };\n        }\n      }\n      \n      // Group data by the specified field\n      const grouped = {};\n      \n      // Check if groupBy field is a date field using entity metadata\n      let isDateField = false;\n      if (entityInfo && entityInfo.Fields) {\n        const fieldInfo = entityInfo.Fields.find(f => f.Name === groupBy);\n        isDateField = fieldInfo && (fieldInfo.Type === 'datetime' || fieldInfo.Type === 'date');\n      }\n      \n      // Fallback to value-based detection if no metadata available\n      if (!isDateField && data.length > 0) {\n        const sampleValue = data[0][groupBy];\n        isDateField = sampleValue && (\n          sampleValue instanceof Date ||\n          (typeof sampleValue === 'string' && !isNaN(Date.parse(sampleValue)))\n        );\n      }\n      \n      data.forEach(record => {\n        let key = record[groupBy] || 'Unknown';\n        \n        // Format date values for display\n        if (isDateField && key !== 'Unknown') {\n          const date = new Date(key);\n          if (!isNaN(date.getTime())) {\n            // Format as YYYY-MM-DD for grouping\n            key = date.toISOString().split('T')[0];\n          }\n        }\n        \n        if (!grouped[key]) {\n          grouped[key] = {\n            label: key,\n            records: [],\n            value: 0\n          };\n        }\n        grouped[key].records.push(record);\n      });\n\n      // Aggregate based on method\n      Object.keys(grouped).forEach(key => {\n        const group = grouped[key];\n        \n        if (aggregateMethod === 'count') {\n          group.value = group.records.length;\n        } else if (valueField) {\n          const values = group.records\n            .map(r => parseFloat(r[valueField]))\n            .filter(v => !isNaN(v));\n          \n          if (values.length > 0) {\n            switch (aggregateMethod) {\n              case 'sum':\n                group.value = values.reduce((a, b) => a + b, 0);\n                break;\n              case 'average':\n                group.value = values.reduce((a, b) => a + b, 0) / values.length;\n                break;\n              case 'min':\n                group.value = Math.min(...values);\n                break;\n              case 'max':\n                group.value = Math.max(...values);\n                break;\n              default:\n                group.value = values.length;\n            }\n          }\n        }\n      });\n\n      // Convert to array and sort\n      let dataArray = Object.values(grouped);\n      \n      if (sortBy === 'label') {\n        dataArray.sort((a, b) => {\n          const comparison = String(a.label).localeCompare(String(b.label));\n          return sortOrder === 'asc' ? comparison : -comparison;\n        });\n      } else if (sortBy === 'value') {\n        dataArray.sort((a, b) => {\n          const comparison = a.value - b.value;\n          return sortOrder === 'asc' ? comparison : -comparison;\n        });\n      }\n      \n      // Apply limit if specified\n      if (limit && limit > 0) {\n        dataArray = dataArray.slice(0, limit);\n      }\n\n      const categories = dataArray.map(d => String(d.label));\n      const values = dataArray.map(d => d.value);\n\n      return {\n        chartData: dataArray,\n        categories,\n        values,\n        isEmpty: false\n      };\n    } catch (err) {\n      console.error('Error processing chart data:', err);\n      setError(err.message);\n      return { chartData: [], categories: [], values: [], isEmpty: true };\n    }\n  }, [data, groupBy, valueField, aggregateMethod, sortBy, sortOrder, limit, entityInfo]);\n\n  // Determine chart type automatically\n  const determineChartType = () => {\n    if (chartType !== 'auto') {\n      // Map 'donut' to Chart.js 'doughnut' \n      if (chartType === 'donut') return 'doughnut';\n      // Map 'column' to Chart.js 'bar'\n      if (chartType === 'column') return 'bar';\n      return chartType;\n    }\n    \n    // Check if groupBy field is a date field using entity metadata\n    let isDateField = false;\n    if (entityInfo && entityInfo.Fields) {\n      const fieldInfo = entityInfo.Fields.find(f => f.Name === groupBy);\n      isDateField = fieldInfo && (fieldInfo.Type === 'datetime' || fieldInfo.Type === 'date');\n    }\n    \n    // Fallback to value-based detection if no metadata available\n    if (!isDateField && data && data.length > 0) {\n      const sampleValue = data[0][groupBy];\n      isDateField = sampleValue && (\n        sampleValue instanceof Date ||\n        (typeof sampleValue === 'string' && !isNaN(Date.parse(sampleValue)))\n      );\n    }\n    \n    if (isDateField) {\n      return 'line';\n    }\n    \n    // Use pie/doughnut for small number of categories\n    if (processData.categories && processData.categories.length <= 5) {\n      return 'doughnut';\n    }\n    \n    // Default to bar chart\n    return 'bar';\n  };\n\n  const actualChartType = determineChartType();\n\n  // Generate chart configuration for Chart.js\n  const getChartConfig = () => {\n    const isPieOrDoughnut = actualChartType === 'pie' || actualChartType === 'doughnut';\n    const isLineOrArea = actualChartType === 'line' || actualChartType === 'area';\n    \n    const config = {\n      type: actualChartType === 'area' ? 'line' : actualChartType,\n      data: {\n        labels: processData.categories,\n        datasets: [{\n          label: valueField || 'Count',\n          data: processData.values,\n          backgroundColor: isPieOrDoughnut \n            ? (colors || defaultColors).slice(0, processData.values.length)\n            : isLineOrArea \n              ? 'rgba(24, 144, 255, 0.2)'\n              : (colors || defaultColors)[0],\n          borderColor: isPieOrDoughnut\n            ? undefined\n            : isLineOrArea\n              ? (colors || defaultColors)[0]\n              : (colors || defaultColors)[0],\n          borderWidth: isLineOrArea ? 2 : 1,\n          fill: actualChartType === 'area',\n          tension: isLineOrArea ? 0.1 : undefined\n        }]\n      },\n      options: {\n        responsive: true,\n        maintainAspectRatio: false,\n        onClick: (_event, elements) => {\n          if (elements && elements.length > 0 && onDataPointClick) {\n            const index = elements[0].index;\n            const clickedData = processData.chartData[index];\n            onDataPointClick({\n              chartType: actualChartType,\n              series: valueField || 'Count',\n              label: clickedData.label,\n              value: clickedData.value,\n              records: clickedData.records,\n              percentage: (clickedData.value / processData.values.reduce((a, b) => a + b, 0)) * 100\n            });\n          }\n        },\n        plugins: {\n          title: {\n            display: !!title,\n            text: title || `${entityName} by ${groupBy}`,\n            font: {\n              size: 16,\n              weight: 600\n            },\n            padding: {\n              bottom: 10\n            }\n          },\n          legend: {\n            display: showLegend && (isPieOrDoughnut || processData.categories.length <= 10),\n            position: legendPosition === 'auto'\n              ? (isPieOrDoughnut ? 'bottom' : 'top')\n              : legendPosition,\n            labels: {\n              font: {\n                size: legendFontSize\n              }\n            }\n          },\n          datalabels: showDataLabels ? {\n            display: true,\n            formatter: (value) => formatValue(value),\n            color: isPieOrDoughnut ? '#fff' : '#666'\n          } : undefined,\n          tooltip: {\n            callbacks: {\n              label: (context) => {\n                const label = context.dataset.label || '';\n                const value = formatValue(context.parsed.y !== undefined ? context.parsed.y : context.parsed);\n                return `${label}: ${value}`;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // Add scales for non-pie/doughnut charts\n    if (!isPieOrDoughnut) {\n      config.options.scales = {\n        y: {\n          beginAtZero: true,\n          ticks: {\n            callback: (value) => formatValue(value)\n          }\n        },\n        x: {\n          ticks: {\n            autoSkip: true,\n            maxRotation: 45,\n            minRotation: 0\n          }\n        }\n      };\n    }\n\n    // Add export functionality if enabled\n    if (enableExport && config.options.plugins) {\n      config.options.plugins.title = {\n        ...config.options.plugins.title,\n        display: true // Always show title when export is enabled\n      };\n    }\n\n    return config;\n  };\n\n  // Render chart\n  React.useEffect(() => {\n    if (processData.isEmpty || !canvasRef.current) {\n      return;\n    }\n\n    if (!ChartJS) {\n      console.error('[SimpleChart] Chart.js library not loaded');\n      setError('Chart.js library not loaded. Please ensure it is included in the component libraries.');\n      return;\n    }\n\n    try {\n      setError(null);\n\n      // Destroy existing chart\n      if (chartInstanceRef.current) {\n        chartInstanceRef.current.destroy();\n        chartInstanceRef.current = null;\n      }\n\n      const config = getChartConfig();\n      \n      // Create new chart instance\n      const ctx = canvasRef.current.getContext('2d');\n      chartInstanceRef.current = new ChartJS(ctx, config);\n\n      // Fire rendered event\n      if (onChartRendered) {\n        onChartRendered({\n          chartType: actualChartType,\n          dataPointCount: processData.chartData.length,\n          aggregateMethod: aggregateMethod,\n          totalValue: processData.values.reduce((a, b) => a + b, 0)\n        });\n      }\n\n    } catch (err) {\n      console.error('[SimpleChart] Error rendering chart:', err);\n      setError(`Failed to render chart: ${err.message}`);\n    }\n\n    // Cleanup on unmount\n    return () => {\n      if (chartInstanceRef.current) {\n        chartInstanceRef.current.destroy();\n        chartInstanceRef.current = null;\n      }\n    };\n  }, [processData, actualChartType, title, height, colors, showLegend, legendPosition, legendFontSize, showDataLabels, enableExport, ChartJS]);\n\n  // Download chart as image\n  React.useEffect(() => {\n    if (enableExport && chartInstanceRef.current && canvasRef.current) {\n      // Add a simple export button overlay\n      const exportHandler = () => {\n        const url = canvasRef.current.toDataURL('image/png');\n        const link = document.createElement('a');\n        link.download = `${title || 'chart'}.png`;\n        link.href = url;\n        link.click();\n      };\n      \n      // Store handler for cleanup\n      window.SimpleChartExport = exportHandler;\n    }\n    \n    return () => {\n      delete window.SimpleChartExport;\n    };\n  }, [enableExport, title]);\n\n  // Error state\n  if (error) {\n    return (\n      <div style={{ \n        display: 'flex', \n        flexDirection: 'column',\n        justifyContent: 'center', \n        alignItems: 'center', \n        height: height,\n        color: '#ff4d4f',\n        padding: '20px'\n      }}>\n        <div>Error rendering chart</div>\n        <div style={{ fontSize: '12px', marginTop: '8px', color: '#999' }}>{error}</div>\n      </div>\n    );\n  }\n\n  // Empty state\n  if (!data || data.length === 0 || processData.isEmpty) {\n    return (\n      <div style={{ \n        display: 'flex', \n        justifyContent: 'center', \n        alignItems: 'center', \n        height: height,\n        color: '#999',\n        backgroundColor: '#f5f5f5',\n        borderRadius: '4px'\n      }}>\n        No data available to display\n      </div>\n    );\n  }\n\n  // Render chart container with canvas\n  return (\n    <div style={{ width: '100%', position: 'relative' }}>\n      {enableExport && (\n        <button\n          onClick={() => window.SimpleChartExport && window.SimpleChartExport()}\n          style={{\n            position: 'absolute',\n            top: 10,\n            right: 10,\n            padding: '4px 8px',\n            fontSize: '12px',\n            backgroundColor: '#fff',\n            border: '1px solid #d9d9d9',\n            borderRadius: '4px',\n            cursor: 'pointer',\n            zIndex: 10,\n            display: 'flex',\n            alignItems: 'center',\n            gap: '4px'\n          }}\n          title=\"Download as PNG\"\n        >\n          📥 Export\n        </button>\n      )}\n      <div style={{ width: '100%', height: `${height}px` }}>\n        <canvas ref={canvasRef} />\n      </div>\n    </div>\n  );\n}",
      "exampleUsage": "<SimpleChart\n  entityName=\"Invoice Line Items\"\n  data={invoiceItems}\n  groupBy=\"ProductCategory\"\n  valueField=\"TotalAmount\"\n  aggregateMethod=\"sum\"\n  chartType=\"bar\"\n  title=\"Revenue by Product Category\"\n  limit={10}\n  onDataPointClick={handleDrillDown}\n/>",
      "registry": "Skip"
    }
  ],
  "properties": [
    {
      "name": "callbacks",
      "type": "object",
      "description": "Object holding persisted user preferences such as selected year range",
      "required": false
    },
    {
      "name": "utilities",
      "type": "object",
      "description": "MJ utilities for executing queries and other helper functions",
      "required": false
    },
    {
      "name": "styles",
      "type": "object",
      "description": "Optional styling overrides for the component container",
      "required": false
    },
    {
      "name": "components",
      "type": "object",
      "description": "Optional overrides for internal UI sub‑components (e.g., custom filter selector)",
      "required": false
    }
  ],
  "events": [
    {
      "name": "onYearSelect",
      "description": "Called when a user clicks a data point on the chart, providing the selected year and member count",
      "parameters": [
        {
          "name": "year",
          "type": "string",
          "description": "The year selected by the user"
        },
        {
          "name": "count",
          "type": "number",
          "description": "Number of members joined in that year"
        }
      ]
    },
    {
      "name": "onError",
      "description": "Called when there is an error fetching data or rendering the chart",
      "parameters": [
        {
          "name": "error",
          "type": "string",
          "description": "Error message describing what went wrong"
        }
      ]
    }
  ],
  "exampleUsage": "<MemberJoinLineChart\n  utilities={utils}\n  userState={savedSettings}\n  callbacks={{\n    onSaveUserSettings: saveSettings,\n    onYearSelect: handleYearSelect,\n    onError: handleError\n  }}\n/>",
  "relevantExamples": [
    {
      "name": "DealVelocityChart",
      "namespace": "CRM/Analytics",
      "version": "1.0.0",
      "description": "Interactive line chart showing deal velocity metrics over time with multiple view modes",
      "relevance": 0.8054297033542939
    },
    {
      "name": "DealVelocityMetrics",
      "namespace": "CRM/Analytics",
      "version": "1.0.0",
      "description": "Analyze and visualize the speed of deals through the sales pipeline with detailed stage-by-stage metrics",
      "relevance": 0.7933239920330635
    },
    {
      "name": "ProductRevenueMatrix",
      "namespace": "CRM/Analytics",
      "version": "1.0.0",
      "description": "Visualize product performance across customers and time periods in an interactive matrix format with treemap and sparklines",
      "relevance": 0.7652138506072901
    }
  ],
  "code": "function MemberJoinLineChart({ utilities, styles, components, savedUserSettings, onError, onYearSelect, onSaveUserSettings }) {\n  // State management\n  const [selectedYears, setSelectedYears] = useState(savedUserSettings?.selectedYears || []);\n  const [queryData, setQueryData] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Extract SimpleChart component from registry\n  const { SimpleChart } = components;\n\n  // Unwrap Ant Design components\n  const { Select, Option } = unwrapLibraryComponents(antd, 'Select', 'Select.Option');\n\n  // Load data on mount\n  useEffect(() => {\n    loadData();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Load data function\n  const loadData = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      // Run the registered query by name (QueryName is required)\n      const result = await utilities.rq.RunQuery({ QueryName: 'MembersJoinedPerYear', CategoryPath: 'Skip/Membership/Analytics/MembersJoinedPerYear',\n                                                 Parameters: {\n          startYear: 2023,\n          endYear: 2025\n        }});\n      if (result && result.Success) {\n        const rows = result.Results || [];\n        setQueryData(rows);\n        // If no years are saved, default to all years returned and persist the default selection\n        if ((selectedYears?.length ?? 0) === 0 && rows.length > 0) {\n          const years = rows.map(r => r.Year).filter(y => y != null);\n          setSelectedYears(years);\n          if (onSaveUserSettings) {\n            onSaveUserSettings({ ...(savedUserSettings || {}), selectedYears: years });\n          }\n        }\n      } else {\n        const msg = (result && result.ErrorMessage) || 'Failed to load member data';\n        setError(msg);\n        if (onError) onError(msg);\n      }\n    } catch (err) {\n      const msg = err?.message || 'Unexpected error while loading data';\n      setError(msg);\n      if (onError) onError(msg);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Handle year selection change (no immediate settings save to avoid noisy updates)\n  const handleYearChange = (values) => {\n    setSelectedYears(values);\n  };\n\n  // Filter data based on selected years\n  const filteredData = useMemo(() => {\n    if (!selectedYears || selectedYears.length === 0) return [];\n    return queryData.filter(row => selectedYears.includes(row.Year));\n  }, [queryData, selectedYears]);\n\n  // Handle chart point click\n  const handleDataPointClick = (payload) => {\n    if (!payload) return;\n    const year = payload.label !== undefined ? payload.label : payload.seriesName;\n    const count = payload.value;\n    if (onYearSelect) {\n      onYearSelect(year, count);\n    }\n  };\n\n  // Render loading / error states\n  if (loading) {\n    return (\n      <div style={{ padding: '40px', textAlign: 'center' }}>\n        <div style={{ fontSize: '18px', color: '#6B7280' }}>Loading member join data...</div>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div style={{ padding: '40px', textAlign: 'center', color: '#EF4444' }}>\n        <div>{error}</div>\n        <button\n          onClick={loadData}\n          style={{\n            marginTop: '12px',\n            padding: '8px 16px',\n            backgroundColor: '#3B82F6',\n            color: 'white',\n            border: 'none',\n            borderRadius: '6px',\n            cursor: 'pointer'\n          }}\n        >\n          Retry\n        </button>\n      </div>\n    );\n  }\n\n  // Options for year selector\n  const yearOptions = useMemo(() => {\n    const years = queryData.map(r => r.Year).filter(y => y != null);\n    return Array.from(new Set(years)).sort();\n  }, [queryData]);\n\n  return (\n    <div style={{ padding: '20px' }}>\n      {/* Year filter */}\n      <div style={{ marginBottom: '16px' }}>\n        <Select\n          mode=\"multiple\"\n          placeholder=\"Select years\"\n          value={selectedYears}\n          onChange={handleYearChange}\n          style={{ minWidth: 200 }}\n        >\n          {yearOptions.map(year => (\n            <Option key={year} value={year}>\n              {year}\n            </Option>\n          ))}\n        </Select>\n      </div>\n\n      {/* Chart */}\n      {SimpleChart && (\n        <SimpleChart\n          entityName=\"Accounts\"\n          data={filteredData}\n          groupBy=\"Year\"\n          valueField=\"MemberCount\"\n          aggregateMethod=\"sum\"\n          chartType=\"line\"\n          title=\"Members Joined by Year\"\n          styles={styles}\n          utilities={utilities}\n          components={components}\n          dataPointClick={handleDataPointClick}\n        />\n      )}\n    </div>\n  );\n}",
  "namespace": "analytics/dashboards",
  "location": "registry",
  "registry": "Skip"
}