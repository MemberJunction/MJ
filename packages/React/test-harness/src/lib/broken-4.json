{
  "functionalRequirements": "```md\n## Business Objectives\n- Provide visual overview of invoice volume/amounts over time\n\n## Functional Requirements\n1. [Chart Type] Line chart showing total invoice amount per day/month\n2. [Basic Filter] Optional date range selector\n3. [Visual Clarity] Clear X/Y axis labels (dates vs $ amounts)\n4. [Data Points] Show tooltip with exact values on hover\n5. [Legend] Differentiate paid/unsold invoices if applicable\n```",
  "title": "Invoice Trends Over Time",
  "type": "Chart",
  "name": "InvoiceTrendChart",
  "userExplanation": "Visualizes invoice amounts over time with date filtering and value tooltips",
  "dataRequirements": {
    "mode": "queries",
    "entities": [
      {
        "name": "Invoices",
        "description": "Customer invoices for products and services rendered",
        "displayFields": [
          "InvoiceDate",
          "TotalAmount",
          "Status"
        ],
        "filterFields": [
          "InvoiceDate"
        ],
        "sortFields": [
          "InvoiceDate"
        ],
        "fieldMetadata": [
          {
            "name": "InvoiceDate",
            "sequence": 5,
            "defaultInView": false,
            "type": "date",
            "allowsNull": false,
            "isPrimaryKey": false
          },
          {
            "name": "TotalAmount",
            "sequence": 11,
            "defaultInView": false,
            "type": "numeric",
            "allowsNull": true,
            "isPrimaryKey": false
          },
          {
            "name": "Status",
            "sequence": 7,
            "defaultInView": false,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "possibleValues": [
              "Draft",
              "Sent",
              "Paid",
              "Partial",
              "Overdue",
              "Cancelled"
            ]
          }
        ],
        "permissionLevelNeeded": [
          "read"
        ]
      }
    ],
    "queries": [
      {
        "name": "InvoiceTrendData",
        "categoryPath": "Skip/Analytics",
        "description": "Aggregates invoice totals by date range with payment status",
        "fields": [
          {
            "name": "TotalInvoices",
            "sequence": 2,
            "type": "decimal",
            "description": "Count of invoices for each date and payment status combination",
            "defaultInView": true,
            "allowsNull": false,
            "isPrimaryKey": false
          },
          {
            "name": "TotalAmount",
            "sequence": 3,
            "type": "decimal",
            "description": "Sum of all invoice amounts for each date and payment status combination",
            "defaultInView": true,
            "allowsNull": false,
            "isPrimaryKey": false
          },
          {
            "name": "GroupedDate",
            "sequence": 1,
            "type": "datetime",
            "description": "The invoice date cast as DATE, used for grouping daily results",
            "defaultInView": true,
            "allowsNull": false,
            "isPrimaryKey": false
          },
          {
            "name": "PaymentStatus",
            "sequence": 4,
            "type": "nvarchar",
            "description": "The payment status of invoices (e.g., 'Paid', 'Pending', 'Overdue')",
            "defaultInView": true,
            "allowsNull": false,
            "isPrimaryKey": false
          }
        ],
        "parameters": [
          {
            "name": "EndDate",
            "value": "@runtime",
            "testValue": "2023-12-31",
            "description": "End of date range for analysis"
          },
          {
            "name": "StartDate",
            "value": "@runtime",
            "testValue": "2023-01-01",
            "description": "Start of date range for analysis"
          }
        ]
      }
    ],
    "description": "Uses daily invoice aggregation with flexible date range filtering to support line chart visualization of invoice trends"
  },
  "location": "embedded",
  "description": "Interactive line chart visualization showing invoice amounts over time with date filtering, legend for payment status differentiation, and hover tooltips for exact values.",
  "technicalDesign": "## Component Architecture\nThe InvoiceTrendChart is a self-contained React component that manages its own state for date filtering and chart interactions.\n\n## Data Flow\n- Fetches aggregated invoice data via the InvoiceTrendData query\n- Groups data by date and payment status\n- Transforms data for chart consumption\n\n## State Management\n- **dateRange**: { startDate, endDate } - controlled via date picker\n- **selectedStatus**: string - filter for specific payment status\n- **chartData**: transformed data for chart rendering\n\n## Chart Configuration\n- **Chart Type**: Line chart with multiple series\n- **X-Axis**: Dates (daily/monthly aggregation)\n- **Y-Axis**: Total invoice amounts (currency formatted)\n- **Series**: Separate lines for each payment status\n- **Tooltip**: Shows exact date, amount, and status on hover\n\n## Dependencies\n- ChartContainer: Wrapper for responsive chart layout\n- DateRangePicker: Date filtering component\n- StatusFilter: Payment status selection dropdown\n- ExportControls: Chart export functionality\n\n## Implementation Notes\n- Uses ApexCharts for responsive line chart rendering\n- Memoizes data transformations for performance\n- Provides fallback UI for empty states\n- Includes accessibility features (ARIA labels, keyboard navigation)\n\n## Event Handling\n- onDateRangeChange: Updates date filter\n- onStatusFilterChange: Updates status filter\n- onDataPointClick: Handles drill-down interactions\n- onExport: Triggers chart export",
  "properties": [
    {
      "name": "defaultDateRange",
      "type": "object",
      "description": "Initial date range for chart display (defaults to last 30 days)",
      "required": false,
      "defaultValue": {
        "startDate": "2023-11-01",
        "endDate": "2023-12-01"
      }
    },
    {
      "name": "showExport",
      "type": "boolean",
      "description": "Whether to show export controls for the chart",
      "required": false,
      "defaultValue": true
    },
    {
      "name": "height",
      "type": "number",
      "description": "Chart container height in pixels",
      "required": false,
      "defaultValue": 400
    }
  ],
  "events": [
    {
      "name": "onDateRangeChange",
      "description": "Fired when user changes the date range filter",
      "parameters": [
        {
          "name": "dateRange",
          "type": "object",
          "description": "Object containing startDate and endDate"
        },
        {
          "name": "triggeredBy",
          "type": "string",
          "description": "Source of the change (user, reset, etc.)"
        }
      ]
    },
    {
      "name": "onStatusFilterChange",
      "description": "Fired when user changes the payment status filter",
      "parameters": [
        {
          "name": "status",
          "type": "string",
          "description": "Selected payment status filter value"
        },
        {
          "name": "previousStatus",
          "type": "string",
          "description": "Previous status filter value"
        }
      ]
    },
    {
      "name": "onDataPointClick",
      "description": "Fired when user clicks on a data point in the chart",
      "parameters": [
        {
          "name": "dataPoint",
          "type": "object",
          "description": "Chart data point with date, amount, and status information"
        },
        {
          "name": "event",
          "type": "object",
          "description": "Original click event for position information"
        }
      ]
    }
  ],
  "exampleUsage": "<InvoiceTrendChart\n  defaultDateRange={{\n    startDate: '2023-11-01',\n    endDate: '2023-12-01'\n  }}\n  showExport={true}\n  height={400}\n  onDateRangeChange={({ dateRange, triggeredBy }) => {\n    console.log('Date range changed:', dateRange, 'triggered by:', triggeredBy);\n  }}\n  onStatusFilterChange={({ status, previousStatus }) => {\n    console.log('Status filter changed from', previousStatus, 'to', status);\n  }}\n  onDataPointClick={({ dataPoint, event }) => {\n    console.log('Data point clicked:', dataPoint);\n  }}\n/>",
  "dependencies": [
    {
      "name": "AIInsightsPanel",
      "description": "",
      "location": "registry",
      "type": "",
      "functionalRequirements": "",
      "technicalDesign": "",
      "exampleUsage": "",
      "namespace": "Generic/UI/AI",
      "version": "1.0.0",
      "selectionReasoning": "The AIInsightsPanel component provides loading and error states, supports responsiveness, and includes a container structure for content (charts could be substituted in place of AI insights). It offers UI fallback states, accessibility features (via hover/visual feedback), and handles resizing events for responsive design."
    },
    {
      "name": "DateRangePicker",
      "description": "Date range selection component with preset options and custom range support",
      "location": "embedded",
      "type": "form",
      "functionalRequirements": "Allows users to select date ranges with preset options (today, last 7 days, last 30 days, custom range) and provides date validation.",
      "technicalDesign": "React component using Material-UI date pickers with preset range buttons and custom range selection. Validates date ranges and emits change events.",
      "properties": [
        {
          "name": "startDate",
          "type": "string",
          "description": "Start date in ISO format",
          "required": true
        },
        {
          "name": "endDate",
          "type": "string",
          "description": "End date in ISO format",
          "required": true
        },
        {
          "name": "presets",
          "type": "array",
          "description": "Array of preset date range options",
          "required": false,
          "defaultValue": [
            "today",
            "last7days",
            "last30days",
            "custom"
          ]
        }
      ],
      "events": [
        {
          "name": "onChange",
          "description": "Called when date range changes",
          "parameters": [
            {
              "name": "range",
              "type": "object",
              "description": "Object with startDate and endDate properties"
            }
          ]
        }
      ],
      "dataRequirements": {
        "mode": "queries",
        "description": "Form component with no direct data requirements"
      },
      "exampleUsage": "<DateRangePicker startDate=\"2023-11-01\" endDate=\"2023-12-01\" onChange={({ range }) => console.log('New range:', range)} />",
      "libraries": [
        {
          "name": "@mui/material",
          "globalVariable": "MaterialUI",
          "version": "5.15.2"
        }
      ],
      "relevantExamples": [
        {
          "name": "RecentDealsList",
          "namespace": "CRM/Sales",
          "version": "1.0.0",
          "description": "Displays a list of the most recent deals with stage indicators and key metrics",
          "relevance": 0.6877463332673587
        },
        {
          "name": "TimelineTab",
          "namespace": "CRM/Customer",
          "version": "1.0.0",
          "description": "Timeline tab showing customer interaction history",
          "relevance": 0.7815805605745714
        },
        {
          "name": "Customer360Timeline",
          "namespace": "CRM/Customer",
          "version": "1.0.0",
          "description": "Timeline view of customer activities and interactions",
          "relevance": 0.6678240124452565
        },
        {
          "name": "AIPerformanceDashboard",
          "namespace": "AI/Analytics/Performance",
          "version": "1.0.0",
          "description": "Comprehensive dashboard for analyzing AI agent and prompt performance with time-series charts, cost analysis, and drill-down capabilities",
          "relevance": 0.6519773267006149
        },
        {
          "name": "DealVelocityChart",
          "namespace": "CRM/Analytics",
          "version": "1.0.0",
          "description": "Interactive line chart showing deal velocity metrics over time with multiple view modes",
          "relevance": 0.6468370060920184
        }
      ],
      "code": "function DateRangePicker({ utilities, styles, components, callbacks, savedUserSettings, onSaveUserSettings, startDate, endDate, presets }) {\n  const { useState, useEffect, useMemo } = React;\n  const { LocalizationProvider, DatePicker } = MaterialUI;\n\n  // State initialization from props and saved settings\n  const [localStartDate, setLocalStartDate] = useState(startDate ? new Date(startDate) : null);\n  const [localEndDate, setLocalEndDate] = useState(endDate ? new Date(endDate) : null);\n  const [selectedPreset, setSelectedPreset] = useState(savedUserSettings?.selectedPreset || 'custom');\n  const [open, setOpen] = useState(false);\n\n  // Date utility functions\n  const addDays = (date, days) => {\n    const result = new Date(date);\n    result.setDate(result.getDate() + days);\n    return result;\n  };\n\n  const startOfDay = (date) => {\n    const result = new Date(date);\n    result.setHours(0, 0, 0, 0);\n    return result;\n  };\n\n  const subDays = (date, days) => {\n    const result = new Date(date);\n    result.setDate(result.getDate() - days);\n    return result;\n  };\n\n  const endOfDay = (date) => {\n    const result = new Date(date);\n    result.setHours(23, 59, 59, 999);\n    return result;\n  };\n\n  // Memoize preset configurations\n  const presetConfigs = useMemo(() => {\n    const today = startOfDay(new Date());\n    return {\n      today: {\n        label: 'Today',\n        startDate: today,\n        endDate: endOfDay(today)\n      },\n      last7days: {\n        label: 'Last 7 Days',\n        startDate: startOfDay(subDays(today, 6)),\n        endDate: endOfDay(today)\n      },\n      last30days: {\n        label: 'Last 30 Days',\n        startDate: startOfDay(subDays(today, 29)),\n        endDate: endOfDay(today)\n      },\n      thisMonth: {\n        label: 'This Month',\n        startDate: startOfDay(new Date(today.getFullYear(), today.getMonth(), 1)),\n        endDate: endOfDay(new Date(today.getFullYear(), today.getMonth() + 1, 0))\n      },\n      lastMonth: {\n        label: 'Last Month',\n        startDate: startOfDay(new Date(today.getFullYear(), today.getMonth() - 1, 1)),\n        endDate: endOfDay(new Date(today.getFullYear(), today.getMonth(), 0))\n      }\n    };\n  }, []);\n\n  // Get available presets\n  const availablePresets = useMemo(() => {\n    const allPresets = presets || ['today', 'last7days', 'last30days', 'custom'];\n    return allPresets.filter(key => key === 'custom' || presetConfigs[key]);\n  }, [presets, presetConfigs]);\n\n  // Handle preset selection\n  const handlePresetSelect = (presetKey) => {\n    setSelectedPreset(presetKey);\n    \n    if (presetKey === 'custom') {\n      // Don't change dates for custom, just update preset\n      setOpen(true);\n    } else {\n      const config = presetConfigs[presetKey];\n      if (config) {\n        setLocalStartDate(config.startDate);\n        setLocalEndDate(config.endDate);\n        \n        // Emit change event\n        const range = {\n          startDate: config.startDate.toISOString(),\n          endDate: config.endDate.toISOString()\n        };\n        \n        if (callbacks && callbacks.onChange) {\n          callbacks.onChange(range);\n        }\n        \n        // Save user preference\n        if (onSaveUserSettings) {\n          onSaveUserSettings({\n            ...savedUserSettings,\n            selectedPreset: presetKey\n          });\n        }\n      }\n    }\n  };\n\n  // Handle custom date changes\n  const handleDateChange = (type, date) => {\n    if (type === 'startDate') {\n      setLocalStartDate(date);\n    } else {\n      setLocalEndDate(date);\n    }\n  };\n\n  // Handle apply for custom range\n  const handleApply = () => {\n    if (localStartDate && localEndDate) {\n      const range = {\n        startDate: localStartDate.toISOString(),\n        endDate: localEndDate.toISOString()\n      };\n      \n      // Validate range\n      if (localStartDate <= localEndDate) {\n        if (callbacks && callbacks.onChange) {\n          callbacks.onChange(range);\n        }\n        \n        if (onSaveUserSettings) {\n          onSaveUserSettings({\n            ...savedUserSettings,\n            selectedPreset: 'custom'\n          });\n        }\n        setOpen(false);\n      }\n    }\n  };\n\n  // Sync with external changes to props\n  useEffect(() => {\n    if (startDate && (!localStartDate || new Date(startDate).getTime() !== localStartDate.getTime())) {\n      setLocalStartDate(new Date(startDate));\n    }\n    if (endDate && (!localEndDate || new Date(endDate).getTime() !== localEndDate.getTime())) {\n      setLocalEndDate(new Date(endDate));\n    }\n  }, [startDate, endDate]);\n\n  // Determine selected preset based on current date range\n  useEffect(() => {\n    if (!localStartDate || !localEndDate) return;\n    \n    // Check if current range matches any preset\n    const currentRange = {\n      startDate: localStartDate.toISOString(),\n      endDate: localEndDate.toISOString()\n    };\n    \n    for (const [key, config] of Object.entries(presetConfigs)) {\n      if (\n        config.startDate.getTime() === localStartDate.getTime() &&\n        config.endDate.getTime() === localEndDate.getTime()\n      ) {\n        setSelectedPreset(key);\n        return;\n      }\n    }\n    \n    setSelectedPreset('custom');\n  }, [localStartDate, localEndDate, presetConfigs]);\n\n  const formatDisplayDate = (date) => {\n    if (!date) return '';\n    return date.toLocaleDateString();\n  };\n\n  return (\n    <MaterialUI.Box>\n      <MaterialUI.FormControl variant=\"outlined\" fullWidth>\n        <MaterialUI.InputLabel id=\"date-range-label\">Date Range</MaterialUI.InputLabel>\n        <MaterialUI.Select\n          value={selectedPreset}\n          onChange={(e) => handlePresetSelect(e.target.value)}\n          label=\"Date Range\"\n          labelId=\"date-range-label\"\n        >\n          {availablePresets.map((preset) => (\n            <MaterialUI.MenuItem key={preset} value={preset}>\n              {preset === 'custom' ? 'Custom Range' : presetConfigs[preset]?.label}\n            </MaterialUI.MenuItem>\n          ))}\n        </MaterialUI.Select>\n      </MaterialUI.FormControl>\n\n      {selectedPreset === 'custom' && open && (\n        <MaterialUI.Dialog\n          open={open}\n          onClose={() => setOpen(false)}\n          maxWidth=\"sm\"\n          fullWidth\n        >\n          <MaterialUI.DialogTitle>Custom Date Range</MaterialUI.DialogTitle>\n          <MaterialUI.DialogContent>\n            <MaterialUI.Stack spacing={3} sx={{ mt: 1 }}>\n              <MaterialUI.TextField\n                label=\"Start Date\"\n                type=\"date\"\n                value={localStartDate ? localStartDate.toISOString().split('T')[0] : ''}\n                onChange={(e) => handleDateChange('startDate', new Date(e.target.value))}\n                inputProps={{ max: new Date().toISOString().split('T')[0] }}\n                fullWidth\n              />\n              <MaterialUI.TextField\n                label=\"End Date\"\n                type=\"date\"\n                value={localEndDate ? localEndDate.toISOString().split('T')[0] : ''}\n                onChange={(e) => handleDateChange('endDate', new Date(e.target.value))}\n                inputProps={{ max: new Date().toISOString().split('T')[0] }}\n                fullWidth\n              />\n            </MaterialUI.Stack>\n          </MaterialUI.DialogContent>\n          <MaterialUI.DialogActions>\n            <MaterialUI.Button onClick={() => setOpen(false)}>Cancel</MaterialUI.Button>\n            <MaterialUI.Button \n              onClick={handleApply} \n              variant=\"contained\"\n              disabled={!localStartDate || !localEndDate || localStartDate > localEndDate}\n            >\n              Apply\n            </MaterialUI.Button>\n          </MaterialUI.DialogActions>\n        </MaterialUI.Dialog>\n      )}\n\n      {!open && selectedPreset === 'custom' && (\n        <MaterialUI.Button\n          onClick={() => setOpen(true)}\n          size=\"small\"\n          sx={{ mt: 1 }}\n        >\n          Edit Range\n        </MaterialUI.Button>\n      )}\n    </MaterialUI.Box>\n  );\n}"
    },
    {
      "name": "StatusFilter",
      "description": "Payment status filter dropdown with multi-select support",
      "location": "embedded",
      "type": "form",
      "functionalRequirements": "Provides dropdown interface for filtering by invoice payment status with support for multiple selection and 'All' option.",
      "technicalDesign": "React component using Material-UI select component with multi-select capability for invoice status filtering. Supports keyboard navigation and clear selection.",
      "properties": [
        {
          "name": "selectedStatus",
          "type": "string",
          "description": "Currently selected status filter (or 'All')",
          "required": false,
          "defaultValue": "All"
        },
        {
          "name": "statusOptions",
          "type": "array",
          "description": "Array of available status options",
          "required": false,
          "defaultValue": [
            "All",
            "Draft",
            "Sent",
            "Paid",
            "Partial",
            "Overdue",
            "Cancelled"
          ]
        }
      ],
      "events": [
        {
          "name": "onChange",
          "description": "Called when status filter changes",
          "parameters": [
            {
              "name": "status",
              "type": "string",
              "description": "Selected status value"
            }
          ]
        }
      ],
      "dataRequirements": {
        "mode": "queries",
        "description": "Filter component with no direct data requirements"
      },
      "exampleUsage": "<StatusFilter selectedStatus=\"Paid\" onChange={({ status }) => console.log('Status changed to:', status)} />",
      "libraries": [
        {
          "name": "@mui/material",
          "globalVariable": "MaterialUI",
          "version": "5.15.2"
        }
      ],
      "relevantExamples": [
        {
          "name": "InvoiceStatusDashboard",
          "namespace": "CRM/Finance",
          "version": "1.0.0",
          "description": "Track invoice statuses, payment timelines, and accounts receivable aging with actionable insights and collection metrics",
          "relevance": 0.7053959204096468
        },
        {
          "name": "CustomerBalances",
          "namespace": "CRM/Finance",
          "version": "1.0.0",
          "description": "Table showing customer outstanding balances",
          "relevance": 0.755236366240618
        },
        {
          "name": "AIModelFilter",
          "namespace": "AI",
          "version": "1.0.0",
          "description": "Collapsible filter panel for filtering models by type, status, developer, and provider",
          "relevance": 0.6720578007945616
        },
        {
          "name": "EntityFilter",
          "namespace": "Admin/Entities",
          "version": "1.0.0",
          "description": "Collapsible filter panel for filtering entities by various criteria",
          "relevance": 0.656099876390862
        },
        {
          "name": "EntityBrowser",
          "namespace": "Admin/Entities",
          "version": "1.0.0",
          "description": "A comprehensive multi-panel dashboard component for browsing and exploring entities in a data system. Features a three-panel layout with collapsible filters, main entity list (grid/card view), and sliding details panel.",
          "relevance": 0.6479142747082043
        }
      ],
      "code": "function StatusFilter(props) {\n  const {\n    utilities,\n    styles,\n    components,\n    callbacks,\n    savedUserSettings,\n    onSaveUserSettings,\n    selectedStatus = 'All',\n    statusOptions = ['All', 'Draft', 'Sent', 'Paid', 'Partial', 'Overdue', 'Cancelled'],\n    onChange\n  } = props;\n\n  const [selected, setSelected] = useState(() => {\n    const saved = savedUserSettings?.selectedStatus;\n    return saved || selectedStatus;\n  });\n\n  const [anchorEl, setAnchorEl] = useState(null);\n\n  const handleClick = (event) => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const handleClose = () => {\n    setAnchorEl(null);\n  };\n\n  const handleStatusChange = (status) => {\n    setSelected(status);\n    onChange?.(status);\n    \n    setAnchorEl(null);\n  };\n\n  const handleBlur = () => {\n    if (onSaveUserSettings) {\n      onSaveUserSettings({\n        ...savedUserSettings,\n        selectedStatus: selected\n      });\n    }\n  };\n\n  const { Select, MenuItem, FormControl, InputLabel, Chip, Box, IconButton, Paper, Popper } = MaterialUI;\n\n  return (\n    <Box sx={{ minWidth: 200 }}>\n      <FormControl fullWidth size=\"small\">\n        <InputLabel>Status</InputLabel>\n        <Select\n          value={selected}\n          onChange={(e) => handleStatusChange(e.target.value)}\n          onBlur={handleBlur}\n          label=\"Status\"\n          renderValue={(value) => (\n            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>\n              <Chip key={value} label={value} size=\"small\" />\n            </Box>\n          )}\n        >\n          {statusOptions.map((option) => (\n            <MenuItem key={option} value={option}>\n              {option}\n            </MenuItem>\n          ))}\n        </Select>\n      </FormControl>\n    </Box>\n  );\n}"
    }
  ],
  "libraries": [
    {
      "name": "ApexCharts",
      "globalVariable": "ApexCharts",
      "version": "^3.45.1"
    },
    {
      "name": "@mui/material",
      "globalVariable": "MaterialUI",
      "version": "^5.15.2"
    },
    {
      "name": "dayjs",
      "globalVariable": "dayjs",
      "version": "^1.11.10"
    },
    {
      "name": "lodash",
      "globalVariable": "_",
      "version": "^4.17.21"
    }
  ],
  "code": "function InvoiceTrendChart({ utilities, styles, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  const [loading, setLoading] = React.useState(true);\n  const [error, setError] = React.useState(null);\n  const [chartData, setChartData] = React.useState([]);\n  const [dateRange, setDateRange] = React.useState(savedUserSettings?.dateRange || {\n    startDate: dayjs().subtract(30, 'days').format('YYYY-MM-DD'),\n    endDate: dayjs().format('YYYY-MM-DD')\n  });\n  const [selectedStatus, setSelectedStatus] = React.useState(savedUserSettings?.selectedStatus || 'All');\n\n  const { DateRangePicker, StatusFilter } = components;\n\n  const loadData = async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      \n      const result = await utilities.rq.RunQuery({\n        QueryName: 'InvoiceTrendData',\n        Parameters: {\n          StartDate: dateRange.startDate,\n          EndDate: dateRange.endDate\n        }\n      });\n\n      if (result?.length) {\n        const processedData = processChartData(result);\n        setChartData(processedData);\n      } else {\n        setChartData([]);\n      }\n    } catch (err) {\n      setError(err.message || 'Failed to load data');\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const processChartData = (data) => {\n    const groupedByDate = {};\n    const statusSet = new Set();\n\n    data.forEach(item => {\n      const date = dayjs(item.GroupedDate).format('YYYY-MM-DD');\n      statusSet.add(item.PaymentStatus);\n      \n      if (!groupedByDate[date]) {\n        groupedByDate[date] = {};\n      }\n      groupedByDate[date][item.PaymentStatus] = parseFloat(item.TotalAmount) || 0;\n    });\n\n    const dates = Object.keys(groupedByDate).sort();\n    const series = Array.from(statusSet).map(status => ({\n      name: status,\n      data: dates.map(date => ({\n        x: date,\n        y: groupedByDate[date][status] || 0\n      }))\n    }));\n\n    return {\n      categories: dates,\n      series\n    };\n  };\n\n  React.useEffect(() => {\n    loadData();\n  }, [dateRange]);\n\n  React.useEffect(() => {\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      dateRange,\n      selectedStatus\n    });\n  }, [dateRange, selectedStatus]);\n\n  const handleDateRangeChange = ({ range }) => {\n    setDateRange(range);\n    callbacks?.onDateRangeChange?.({ dateRange: range, triggeredBy: 'user' });\n  };\n\n  const handleStatusChange = ({ status }) => {\n    const previousStatus = selectedStatus;\n    setSelectedStatus(status);\n    callbacks?.onStatusFilterChange?.({ status, previousStatus });\n  };\n\n  const handleDataPointClick = (event, chartContext, config) => {\n    if (config.dataPointIndex !== -1 && config.seriesIndex !== -1) {\n      const category = chartData.categories[config.dataPointIndex];\n      const seriesName = chartData.series[config.seriesIndex].name;\n      const value = chartData.series[config.seriesIndex].data[config.dataPointIndex].y;\n      \n      const dataPoint = {\n        date: category,\n        amount: value,\n        status: seriesName\n      };\n      \n      callbacks?.onDataPointClick?.({ dataPoint, event: event });\n    }\n  };\n\n  const chartOptions = React.useMemo(() => ({\n    chart: {\n      type: 'line',\n      height: savedUserSettings?.height || 400,\n      toolbar: {\n        show: true,\n        tools: {\n          download: savedUserSettings?.showExport !== false,\n          selection: true,\n          zoom: true,\n          zoomin: true,\n          zoomout: true,\n          pan: true,\n          reset: true\n        }\n      },\n      events: {\n        dataPointSelection: handleDataPointClick\n      }\n    },\n    stroke: {\n      width: 2,\n      curve: 'smooth'\n    },\n    xaxis: {\n      type: 'datetime',\n      categories: chartData.categories || [],\n      labels: {\n        datetimeFormatter: {\n          year: 'yyyy',\n          month: 'MMM yyyy',\n          day: 'MMM dd'\n        }\n      }\n    },\n    yaxis: {\n      title: {\n        text: 'Total Amount ($)'\n      },\n      labels: {\n        formatter: (value) => `$${value.toLocaleString()}`\n      }\n    },\n    tooltip: {\n      y: {\n        formatter: (value) => `$${value.toLocaleString()}`\n      },\n      x: {\n        formatter: (value) => dayjs(value).format('MMM DD, YYYY')\n      }\n    },\n    legend: {\n      position: 'top'\n    },\n    colors: ['#10B981', '#F59E0B', '#EF4444', '#6366F1', '#8B5CF6', '#06B6D4'],\n    responsive: [{\n      breakpoint: 480,\n      options: {\n        legend: {\n          position: 'bottom'\n        }\n      }\n    }]\n  }), [chartData, savedUserSettings]);\n\n  const filteredSeries = React.useMemo(() => {\n    if (selectedStatus === 'All') {\n      return chartData.series || [];\n    }\n    return chartData.series?.filter(s => s.name === selectedStatus) || [];\n  }, [chartData, selectedStatus]);\n\n  const renderChart = () => {\n    if (loading) {\n      return (\n        <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: savedUserSettings?.height || 400 }}>\n          <MaterialUI.CircularProgress />\n        </div>\n      );\n    }\n\n    if (error) {\n      return (\n        <div style={{ \n          display: 'flex', \n          justifyContent: 'center', \n          alignItems: 'center', \n          height: savedUserSettings?.height || 400,\n          textAlign: 'center',\n          color: '#ef4444'\n        }}>\n          <div>\n            <MaterialUI.Typography variant=\"h6\">Error loading data</MaterialUI.Typography>\n            <MaterialUI.Typography variant=\"body2\">{error}</MaterialUI.Typography>\n          </div>\n        </div>\n      );\n    }\n\n    if (!chartData.series?.length) {\n      return (\n        <div style={{ \n          display: 'flex', \n          justifyContent: 'center', \n          alignItems: 'center', \n          height: savedUserSettings?.height || 400,\n          textAlign: 'center'\n        }}>\n          <div>\n            <MaterialUI.Typography variant=\"h6\">No data available</MaterialUI.Typography>\n            <MaterialUI.Typography variant=\"body2\">\n              Try adjusting the date range or status filter\n            </MaterialUI.Typography>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div id=\"chart\" style={{ height: savedUserSettings?.height || 400 }}>\n        <div ref={(el) => {\n          if (el && ApexCharts) {\n            const chart = new ApexCharts(el, {\n              ...chartOptions,\n              series: filteredSeries\n            });\n            chart.render();\n            return () => chart.destroy();\n          }\n        }} style={{ height: '100%' }} />\n      </div>\n    );\n  };\n\n  return (\n    <div style={{ padding: '20px', backgroundColor: '#f9fafb' }}>\n      <MaterialUI.Paper elevation={1} style={{ padding: '20px', marginBottom: '20px' }}>\n        <MaterialUI.Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>\n          <MaterialUI.Typography variant=\"h4\" component=\"h1\">\n            Invoice Trend Analysis\n          </MaterialUI.Typography>\n        </MaterialUI.Box>\n\n        <MaterialUI.Grid container spacing={3} alignItems=\"center\" sx={{ mb: 3 }}>\n          <MaterialUI.Grid item xs={12} md={6}>\n            <DateRangePicker\n              startDate={dateRange.startDate}\n              endDate={dateRange.endDate}\n              onChange={handleDateRangeChange}\n              utilities={utilities}\n              styles={styles}\n              components={components}\n              callbacks={callbacks}\n              savedUserSettings={savedUserSettings}\n              onSaveUserSettings={onSaveUserSettings}\n            />\n          </MaterialUI.Grid>\n          <MaterialUI.Grid item xs={12} md={3}>\n            <StatusFilter\n              selectedStatus={selectedStatus}\n              onChange={handleStatusChange}\n              utilities={utilities}\n              styles={styles}\n              components={components}\n              callbacks={callbacks}\n              savedUserSettings={savedUserSettings}\n              onSaveUserSettings={onSaveUserSettings}\n            />\n          </MaterialUI.Grid>\n        </MaterialUI.Grid>\n\n        {renderChart()}\n      </MaterialUI.Paper>\n    </div>\n  );\n}"
}