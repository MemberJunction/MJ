import { Command, Flags } from '@oclif/core';

export default class DbDocExportSampleQueries extends Command {
  static description = 'Export sample queries to MemberJunction metadata format (delegates to db-auto-doc export-sample-queries)';

  static examples = [
    '<%= config.bin %> <%= command.id %> --input ./output/sample-queries.json --output ./metadata/queries/.queries.json',
    '<%= config.bin %> <%= command.id %> --input ./sample-queries.json --output ./metadata/queries/.queries.json --separate-sql-files',
    '<%= config.bin %> <%= command.id %> --input ./sample-queries.json --output ./queries/.queries.json --category "Database Documentation"',
    '<%= config.bin %> <%= command.id %> --input ./sample-queries.json --output ./queries/.queries.json --status Pending --min-confidence 0.8',
  ];

  static flags = {
    input: Flags.string({
      char: 'i',
      description: 'Path to sample-queries.json file generated by generate-queries command',
      required: true
    }),
    output: Flags.string({
      char: 'o',
      description: 'Output path for the .queries.json metadata file',
      required: true
    }),
    'separate-sql-files': Flags.boolean({
      description: 'Write SQL to separate files and use @file: references',
      default: false
    }),
    'sql-dir': Flags.string({
      description: 'Directory for SQL files when using --separate-sql-files (relative to output file)',
      default: 'SQL'
    }),
    category: Flags.string({
      description: 'Category name for @lookup reference (e.g., "Database Documentation")',
      required: false
    }),
    status: Flags.string({
      description: 'Status to assign to exported queries',
      options: ['Approved', 'Pending', 'Rejected', 'Expired'],
      default: 'Pending'
    }),
    'min-confidence': Flags.string({
      description: 'Minimum confidence threshold to export (0-1)',
      default: '0'
    }),
    'validated-only': Flags.boolean({
      description: 'Only export queries that were successfully validated',
      default: false
    }),
    append: Flags.boolean({
      description: 'Append to existing metadata file instead of overwriting',
      default: false
    }),
    'include-primary-key': Flags.boolean({
      description: 'Include primaryKey and sync fields (for updating existing records)',
      default: false
    })
  };

  async run(): Promise<void> {
    const { flags } = await this.parse(DbDocExportSampleQueries);

    // Load DBAutoDoc command dynamically
    const { default: ExportSampleQueriesCommand } = await import('@memberjunction/db-auto-doc/dist/commands/export-sample-queries');

    // Build args array for DBAutoDoc command
    const args: string[] = [];

    if (flags.input) {
      args.push('--input', flags.input);
    }
    if (flags.output) {
      args.push('--output', flags.output);
    }
    if (flags['separate-sql-files']) {
      args.push('--separate-sql-files');
    }
    if (flags['sql-dir'] && flags['sql-dir'] !== 'SQL') {
      args.push('--sql-dir', flags['sql-dir']);
    }
    if (flags.category) {
      args.push('--category', flags.category);
    }
    if (flags.status && flags.status !== 'Pending') {
      args.push('--status', flags.status);
    }
    if (flags['min-confidence'] && flags['min-confidence'] !== '0') {
      args.push('--min-confidence', flags['min-confidence']);
    }
    if (flags['validated-only']) {
      args.push('--validated-only');
    }
    if (flags.append) {
      args.push('--append');
    }
    if (flags['include-primary-key']) {
      args.push('--include-primary-key');
    }

    // Execute the DBAutoDoc export-sample-queries command
    await ExportSampleQueriesCommand.run(args);
  }
}
