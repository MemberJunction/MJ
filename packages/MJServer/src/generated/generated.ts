/********************************************************************************
* ALL ENTITIES - TypeGraphQL Type Class Definition - AUTO GENERATED FILE
* Generated Entities and Resolvers for Server
*
*   >>> DO NOT MODIFY THIS FILE!!!!!!!!!!!!
*   >>> YOUR CHANGES WILL BE OVERWRITTEN
*   >>> THE NEXT TIME THIS FILE IS GENERATED
*
**********************************************************************************/
import { Arg, Ctx, Int, Query, Resolver, Field, Float, ObjectType, FieldResolver, Root, InputType, Mutation,
            PubSub, PubSubEngine, ResolverBase, RunViewByIDInput, RunViewByNameInput, RunDynamicViewInput,
            AppContext, KeyValuePairInput, DeleteOptionsInput, GraphQLTimestamp as Timestamp,
            GetReadOnlyDataSource, GetReadWriteDataSource, GetReadOnlyProvider, GetReadWriteProvider } from '@memberjunction/server';
import { SQLServerDataProvider } from '@memberjunction/sqlserver-dataprovider';
import { Metadata, EntityPermissionType, CompositeKey, UserInfo } from '@memberjunction/core'

import { MaxLength } from 'class-validator';
import { mj_core_schema } from '../config.js';



import { ActionAuthorizationEntity, ActionCategoryEntity, ActionContextTypeEntity, ActionContextEntity, ActionExecutionLogEntity, ActionFilterEntity, ActionLibraryEntity, ActionParamEntity, ActionResultCodeEntity, ActionEntity, AIActionEntity, AIAgentActionEntity, AIAgentLearningCycleEntity, AIAgentModelEntity, AIAgentNoteTypeEntity, AIAgentNoteEntity, AIAgentRequestEntity, AIAgentEntity, AIModelActionEntity, AIModelTypeEntity, AIModelEntity, AIPromptCategoryEntity, AIPromptTypeEntity, AIPromptEntity, AIResultCacheEntity, ApplicationEntityEntity, ApplicationSettingEntity, ApplicationEntity, AuditLogTypeEntity, AuditLogEntity, AuthorizationRoleEntity, AuthorizationEntity, CommunicationBaseMessageTypeEntity, CommunicationLogEntity, CommunicationProviderMessageTypeEntity, CommunicationProviderEntity, CommunicationRunEntity, CompanyEntity, CompanyIntegrationRecordMapEntity, CompanyIntegrationRunAPILogEntity, CompanyIntegrationRunDetailEntity, CompanyIntegrationRunEntity, CompanyIntegrationEntity, ContentFileTypeEntity, ContentItemAttributeEntity, ContentItemTagEntity, ContentItemEntity, ContentProcessRunEntity, ContentSourceParamEntity, ContentSourceTypeParamEntity, ContentSourceTypeEntity, ContentSourceEntity, ContentTypeAttributeEntity, ContentTypeEntity, ConversationDetailEntity, ConversationEntity, DashboardCategoryEntity, DashboardEntity, DataContextItemEntity, DataContextEntity, DatasetItemEntity, DatasetEntity, DuplicateRunDetailMatchEntity, DuplicateRunDetailEntity, DuplicateRunEntity, EmployeeCompanyIntegrationEntity, EmployeeRoleEntity, EmployeeSkillEntity, EmployeeEntity, EntityEntity, EntityActionFilterEntity, EntityActionInvocationTypeEntity, EntityActionInvocationEntity, EntityActionParamEntity, EntityActionEntity, EntityAIActionEntity, EntityCommunicationFieldEntity, EntityCommunicationMessageTypeEntity, EntityDocumentRunEntity, EntityDocumentSettingEntity, EntityDocumentTypeEntity, EntityDocumentEntity, EntityFieldValueEntity, EntityFieldEntity, EntityPermissionEntity, EntityRecordDocumentEntity, EntityRelationshipDisplayComponentEntity, EntityRelationshipEntity, EntitySettingEntity, ErrorLogEntity, ExplorerNavigationItemEntity, FileCategoryEntity, FileEntityRecordLinkEntity, FileStorageProviderEntity, FileEntity, GeneratedCodeCategoryEntity, GeneratedCodeEntity, IntegrationURLFormatEntity, IntegrationEntity, LibraryEntity, LibraryItemEntity, ListCategoryEntity, ListDetailEntity, ListEntity, ArtifactTypeEntity, ConversationArtifactPermissionEntity, ConversationArtifactVersionEntity, ConversationArtifactEntity, ReportUserStateEntity, ReportVersionEntity, OutputDeliveryTypeEntity, OutputFormatTypeEntity, OutputTriggerTypeEntity, QueryEntity, QueryCategoryEntity, QueryEntityEntity, QueryFieldEntity, QueryPermissionEntity, QueueTaskEntity, QueueTypeEntity, QueueEntity, RecommendationItemEntity, RecommendationProviderEntity, RecommendationRunEntity, RecommendationEntity, RecordChangeReplayRunEntity, RecordChangeEntity, RecordMergeDeletionLogEntity, RecordMergeLogEntity, ReportCategoryEntity, ReportSnapshotEntity, ReportEntity, ResourceLinkEntity, ResourcePermissionEntity, ResourceTypeEntity, RoleEntity, RowLevelSecurityFilterEntity, ScheduledActionParamEntity, ScheduledActionEntity, SchemaInfoEntity, SkillEntity, TaggedItemEntity, TagEntity, TemplateCategoryEntity, TemplateContentTypeEntity, TemplateContentEntity, TemplateParamEntity, TemplateEntity, UserApplicationEntityEntity, UserApplicationEntity, UserFavoriteEntity, UserNotificationEntity, UserRecordLogEntity, UserRoleEntity, UserViewCategoryEntity, UserViewRunDetailEntity, UserViewRunEntity, UserViewEntity, UserEntity, VectorDatabaseEntity, VectorIndexEntity, VersionInstallationEntity, WorkflowEngineEntity, WorkflowRunEntity, WorkflowEntity, WorkspaceItemEntity, WorkspaceEntity } from '@memberjunction/core-entities';
    

//****************************************************************************
// ENTITY CLASS for Action Authorizations
//****************************************************************************
@ObjectType({ description: `Links actions to authorizations, one or more of these must be possessed by a user in order to execute the action.` })
export class MJActionAuthorization_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(16)
    AuthorizationID: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(200)
    Authorization: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Authorizations
//****************************************************************************
@InputType()
export class CreateMJActionAuthorizationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Authorizations
//****************************************************************************
@InputType()
export class UpdateMJActionAuthorizationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Authorizations
//****************************************************************************
@ObjectType()
export class RunMJActionAuthorizationViewResult {
    @Field(() => [MJActionAuthorization_])
    Results: MJActionAuthorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionAuthorization_)
export class MJActionAuthorizationResolver extends ResolverBase {
    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Authorizations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionAuthorization_, { nullable: true })
    async MJActionAuthorization(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionAuthorization_ | null> {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Authorizations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJActionAuthorization_)
    async CreateMJActionAuthorization(
        @Arg('input', () => CreateMJActionAuthorizationInput) input: CreateMJActionAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Authorizations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionAuthorization_)
    async UpdateMJActionAuthorization(
        @Arg('input', () => UpdateMJActionAuthorizationInput) input: UpdateMJActionAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Authorizations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionAuthorization_)
    async DeleteMJActionAuthorization(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Authorizations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Categories
//****************************************************************************
@ObjectType({ description: `Organizes actions into categories, including name, description, and optional parent category for hierarchy.` })
export class MJActionCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the action category.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the action category.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Status of the action category (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [MJActionCategory_])
    ActionCategories_ParentIDArray: MJActionCategory_[]; // Link to ActionCategories
    
    @Field(() => [MJAction_])
    Actions_CategoryIDArray: MJAction_[]; // Link to Actions
    
}

//****************************************************************************
// INPUT TYPE for Action Categories
//****************************************************************************
@InputType()
export class CreateMJActionCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Action Categories
//****************************************************************************
@InputType()
export class UpdateMJActionCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Categories
//****************************************************************************
@ObjectType()
export class RunMJActionCategoryViewResult {
    @Field(() => [MJActionCategory_])
    Results: MJActionCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionCategory_)
export class MJActionCategoryResolver extends ResolverBase {
    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionCategory_, { nullable: true })
    async MJActionCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionCategory_ | null> {
        this.CheckUserReadPermissions('Action Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJActionCategory_])
    async ActionCategories_ParentIDArray(@Root() mjactioncategory_: MJActionCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionCategories] WHERE [ParentID]='${mjactioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async Actions_CategoryIDArray(@Root() mjactioncategory_: MJActionCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [CategoryID]='${mjactioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Actions', rows);
        return result;
    }
        
    @Mutation(() => MJActionCategory_)
    async CreateMJActionCategory(
        @Arg('input', () => CreateMJActionCategoryInput) input: CreateMJActionCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionCategory_)
    async UpdateMJActionCategory(
        @Arg('input', () => UpdateMJActionCategoryInput) input: UpdateMJActionCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionCategory_)
    async DeleteMJActionCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Context Types
//****************************************************************************
@ObjectType({ description: `Lists possible contexts for action execution with optional descriptions.` })
export class MJActionContextType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the context type.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the context type.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJActionContext_])
    ActionContexts_ContextTypeIDArray: MJActionContext_[]; // Link to ActionContexts
    
}

//****************************************************************************
// INPUT TYPE for Action Context Types
//****************************************************************************
@InputType()
export class CreateMJActionContextTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Context Types
//****************************************************************************
@InputType()
export class UpdateMJActionContextTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Context Types
//****************************************************************************
@ObjectType()
export class RunMJActionContextTypeViewResult {
    @Field(() => [MJActionContextType_])
    Results: MJActionContextType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionContextType_)
export class MJActionContextTypeResolver extends ResolverBase {
    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Context Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionContextType_, { nullable: true })
    async MJActionContextType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionContextType_ | null> {
        this.CheckUserReadPermissions('Action Context Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContextTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Context Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Context Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJActionContext_])
    async ActionContexts_ContextTypeIDArray(@Root() mjactioncontexttype_: MJActionContextType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ContextTypeID]='${mjactioncontexttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Contexts', rows);
        return result;
    }
        
    @Mutation(() => MJActionContextType_)
    async CreateMJActionContextType(
        @Arg('input', () => CreateMJActionContextTypeInput) input: CreateMJActionContextTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Context Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionContextType_)
    async UpdateMJActionContextType(
        @Arg('input', () => UpdateMJActionContextTypeInput) input: UpdateMJActionContextTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Context Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionContextType_)
    async DeleteMJActionContextType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Context Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Contexts
//****************************************************************************
@ObjectType({ description: `Links actions to their supported context types enabling a given action to be executable in more than one context.` })
export class MJActionContext_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ContextTypeID?: string;
        
    @Field({description: `Status of the action context (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContextType?: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Contexts
//****************************************************************************
@InputType()
export class CreateMJActionContextInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Action Contexts
//****************************************************************************
@InputType()
export class UpdateMJActionContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Contexts
//****************************************************************************
@ObjectType()
export class RunMJActionContextViewResult {
    @Field(() => [MJActionContext_])
    Results: MJActionContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionContext_)
export class MJActionContextResolver extends ResolverBase {
    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Contexts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionContext_, { nullable: true })
    async MJActionContext(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionContext_ | null> {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Contexts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJActionContext_)
    async CreateMJActionContext(
        @Arg('input', () => CreateMJActionContextInput) input: CreateMJActionContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Contexts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionContext_)
    async UpdateMJActionContext(
        @Arg('input', () => UpdateMJActionContextInput) input: UpdateMJActionContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Contexts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionContext_)
    async DeleteMJActionContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Contexts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Execution Logs
//****************************************************************************
@ObjectType({ description: `Tracks every execution of an action, including start and end times, inputs, outputs, and result codes.` })
export class MJActionExecutionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Timestamp of when the action started execution.`}) 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp of when the action ended execution.`}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Params?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ResultCode?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain the log; NULL for indefinite retention.`}) 
    RetentionPeriod?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Execution Logs
//****************************************************************************
@InputType()
export class CreateMJActionExecutionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Params: string | null;

    @Field({ nullable: true })
    ResultCode: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Execution Logs
//****************************************************************************
@InputType()
export class UpdateMJActionExecutionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Params?: string | null;

    @Field({ nullable: true })
    ResultCode?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Execution Logs
//****************************************************************************
@ObjectType()
export class RunMJActionExecutionLogViewResult {
    @Field(() => [MJActionExecutionLog_])
    Results: MJActionExecutionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionExecutionLog_)
export class MJActionExecutionLogResolver extends ResolverBase {
    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Execution Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionExecutionLog_, { nullable: true })
    async MJActionExecutionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionExecutionLog_ | null> {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Execution Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJActionExecutionLog_)
    async CreateMJActionExecutionLog(
        @Arg('input', () => CreateMJActionExecutionLogInput) input: CreateMJActionExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Execution Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionExecutionLog_)
    async UpdateMJActionExecutionLog(
        @Arg('input', () => UpdateMJActionExecutionLogInput) input: UpdateMJActionExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Execution Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionExecutionLog_)
    async DeleteMJActionExecutionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Execution Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Filters
//****************************************************************************
@ObjectType({ description: `Defines filters that can be evaluated ahead of executing an action. Action Filters are usable in any code pipeline you can execute them with the same context as the action itself and use the outcome to determine if the action should execute or not.` })
export class MJActionFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    UserDescription: string;
        
    @Field({nullable: true}) 
    UserComments?: string;
        
    @Field() 
    Code: string;
        
    @Field({nullable: true}) 
    CodeExplanation?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityActionFilter_])
    EntityActionFilters_ActionFilterIDArray: MJEntityActionFilter_[]; // Link to EntityActionFilters
    
}

//****************************************************************************
// INPUT TYPE for Action Filters
//****************************************************************************
@InputType()
export class CreateMJActionFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Filters
//****************************************************************************
@InputType()
export class UpdateMJActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Filters
//****************************************************************************
@ObjectType()
export class RunMJActionFilterViewResult {
    @Field(() => [MJActionFilter_])
    Results: MJActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionFilter_)
export class MJActionFilterResolver extends ResolverBase {
    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionFilter_, { nullable: true })
    async MJActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionFilter_ | null> {
        this.CheckUserReadPermissions('Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Filters', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionFilter_])
    async EntityActionFilters_ActionFilterIDArray(@Root() mjactionfilter_: MJActionFilter_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [ActionFilterID]='${mjactionfilter_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Filters', rows);
        return result;
    }
        
    @Mutation(() => MJActionFilter_)
    async CreateMJActionFilter(
        @Arg('input', () => CreateMJActionFilterInput) input: CreateMJActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionFilter_)
    async UpdateMJActionFilter(
        @Arg('input', () => UpdateMJActionFilterInput) input: UpdateMJActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionFilter_)
    async DeleteMJActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Libraries
//****************************************************************************
@ObjectType({ description: `Tracks the list of libraries that a given Action uses, including a list of classes/functions for each library.` })
export class MJActionLibrary_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({nullable: true, description: `List of classes and functions used by the action from the library.`}) 
    ItemsUsed?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(510)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Libraries
//****************************************************************************
@InputType()
export class CreateMJActionLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Libraries
//****************************************************************************
@InputType()
export class UpdateMJActionLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Libraries
//****************************************************************************
@ObjectType()
export class RunMJActionLibraryViewResult {
    @Field(() => [MJActionLibrary_])
    Results: MJActionLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionLibrary_)
export class MJActionLibraryResolver extends ResolverBase {
    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionLibrary_, { nullable: true })
    async MJActionLibrary(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionLibrary_ | null> {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Libraries', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJActionLibrary_)
    async CreateMJActionLibrary(
        @Arg('input', () => CreateMJActionLibraryInput) input: CreateMJActionLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionLibrary_)
    async UpdateMJActionLibrary(
        @Arg('input', () => UpdateMJActionLibraryInput) input: UpdateMJActionLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionLibrary_)
    async DeleteMJActionLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Params
//****************************************************************************
@ObjectType({ description: `Tracks the input and output parameters for Actions.` })
export class MJActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    DefaultValue?: string;
        
    @Field() 
    @MaxLength(20)
    Type: string;
        
    @Field({description: `Tracks the basic value type of the parameter, additional information can be provided in the Description field`}) 
    @MaxLength(60)
    ValueType: string;
        
    @Field(() => Boolean) 
    IsArray: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean) 
    IsRequired: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [MJEntityActionParam_])
    EntityActionParams_ActionParamIDArray: MJEntityActionParam_[]; // Link to EntityActionParams
    
    @Field(() => [MJScheduledActionParam_])
    ScheduledActionParams_ActionParamIDArray: MJScheduledActionParam_[]; // Link to ScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for Action Params
//****************************************************************************
@InputType()
export class CreateMJActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Action Params
//****************************************************************************
@InputType()
export class UpdateMJActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Params
//****************************************************************************
@ObjectType()
export class RunMJActionParamViewResult {
    @Field(() => [MJActionParam_])
    Results: MJActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionParam_)
export class MJActionParamResolver extends ResolverBase {
    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionParam_, { nullable: true })
    async MJActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionParam_ | null> {
        this.CheckUserReadPermissions('Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionParam_])
    async EntityActionParams_ActionParamIDArray(@Root() mjactionparam_: MJActionParam_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [ActionParamID]='${mjactionparam_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Params', rows);
        return result;
    }
        
    @FieldResolver(() => [MJScheduledActionParam_])
    async ScheduledActionParams_ActionParamIDArray(@Root() mjactionparam_: MJActionParam_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ActionParamID]='${mjactionparam_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Action Params', rows);
        return result;
    }
        
    @Mutation(() => MJActionParam_)
    async CreateMJActionParam(
        @Arg('input', () => CreateMJActionParamInput) input: CreateMJActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionParam_)
    async UpdateMJActionParam(
        @Arg('input', () => UpdateMJActionParamInput) input: UpdateMJActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionParam_)
    async DeleteMJActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Result Codes
//****************************************************************************
@ObjectType({ description: `Defines the possible result codes for each action.` })
export class MJActionResultCode_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(510)
    ResultCode: string;
        
    @Field(() => Boolean, {description: `Indicates if the result code is a success or not. It is possible an action might have more than one failure condition/result code and same for success conditions.`}) 
    IsSuccess: boolean;
        
    @Field({nullable: true, description: `Description of the result code.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Result Codes
//****************************************************************************
@InputType()
export class CreateMJActionResultCodeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Result Codes
//****************************************************************************
@InputType()
export class UpdateMJActionResultCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Result Codes
//****************************************************************************
@ObjectType()
export class RunMJActionResultCodeViewResult {
    @Field(() => [MJActionResultCode_])
    Results: MJActionResultCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionResultCode_)
export class MJActionResultCodeResolver extends ResolverBase {
    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Result Codes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionResultCode_, { nullable: true })
    async MJActionResultCode(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionResultCode_ | null> {
        this.CheckUserReadPermissions('Action Result Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionResultCodes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Result Codes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJActionResultCode_)
    async CreateMJActionResultCode(
        @Arg('input', () => CreateMJActionResultCodeInput) input: CreateMJActionResultCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Result Codes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionResultCode_)
    async UpdateMJActionResultCode(
        @Arg('input', () => UpdateMJActionResultCodeInput) input: UpdateMJActionResultCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Result Codes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionResultCode_)
    async DeleteMJActionResultCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Result Codes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Actions
//****************************************************************************
@ObjectType({ description: `Stores action definitions, including prompts, generated code, user comments, and status.` })
export class MJAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(850)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Generated or Custom. Generated means the UserPrompt is used to prompt an AI model to automatically create the code for the Action. Custom means that a custom class has been implemented that subclasses the BaseAction class. The custom class needs to use the @RegisterClass decorator and be included in the MJAPI (or other runtime environment) to be available for execution.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true}) 
    UserPrompt?: string;
        
    @Field({nullable: true, description: `User's comments not shared with the LLM.`}) 
    UserComments?: string;
        
    @Field({nullable: true}) 
    Code?: string;
        
    @Field({nullable: true, description: `AI's explanation of the code.`}) 
    CodeComments?: string;
        
    @Field({description: `An action won't be usable until the code is approved.`}) 
    @MaxLength(40)
    CodeApprovalStatus: string;
        
    @Field({nullable: true, description: `Optional comments when an individual (or an AI) reviews and approves the code.`}) 
    CodeApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CodeApprovedByUserID?: string;
        
    @Field({nullable: true, description: `When the code was approved.`}) 
    @MaxLength(8)
    CodeApprovedAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 1, Code will never be generated by the AI system. This overrides all other settings including the ForceCodeGeneration bit`}) 
    CodeLocked: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, the Action will generate code for the provided UserPrompt on the next Save even if the UserPrompt hasn't changed. This is useful to force regeneration when other candidates (such as a change in Action Inputs/Outputs) occurs or on demand by a user.`}) 
    ForceCodeGeneration: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain execution logs; NULL for indefinite.`}) 
    RetentionPeriod?: number;
        
    @Field({description: `Status of the action (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CodeApprovedByUser?: string;
        
    @Field(() => [MJActionParam_])
    ActionParams_ActionIDArray: MJActionParam_[]; // Link to ActionParams
    
    @Field(() => [MJActionLibrary_])
    ActionLibraries_ActionIDArray: MJActionLibrary_[]; // Link to ActionLibraries
    
    @Field(() => [MJActionResultCode_])
    ActionResultCodes_ActionIDArray: MJActionResultCode_[]; // Link to ActionResultCodes
    
    @Field(() => [MJScheduledAction_])
    ScheduledActions_ActionIDArray: MJScheduledAction_[]; // Link to ScheduledActions
    
    @Field(() => [MJAIAgentAction_])
    AIAgentActions_ActionIDArray: MJAIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [MJActionContext_])
    ActionContexts_ActionIDArray: MJActionContext_[]; // Link to ActionContexts
    
    @Field(() => [MJEntityAction_])
    EntityActions_ActionIDArray: MJEntityAction_[]; // Link to EntityActions
    
    @Field(() => [MJActionExecutionLog_])
    ActionExecutionLogs_ActionIDArray: MJActionExecutionLog_[]; // Link to ActionExecutionLogs
    
    @Field(() => [MJActionAuthorization_])
    ActionAuthorizations_ActionIDArray: MJActionAuthorization_[]; // Link to ActionAuthorizations
    
}

//****************************************************************************
// INPUT TYPE for Actions
//****************************************************************************
@InputType()
export class CreateMJActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    CodeComments: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID: string | null;

    @Field({ nullable: true })
    CodeApprovedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Actions
//****************************************************************************
@InputType()
export class UpdateMJActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    CodeComments?: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments?: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID?: string | null;

    @Field({ nullable: true })
    CodeApprovedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Actions
//****************************************************************************
@ObjectType()
export class RunMJActionViewResult {
    @Field(() => [MJAction_])
    Results: MJAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAction_)
export class MJActionResolver extends ResolverBase {
    @Query(() => RunMJActionViewResult)
    async RunMJActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionViewResult)
    async RunMJActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionViewResult)
    async RunMJActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAction_, { nullable: true })
    async MJAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAction_ | null> {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJActionParam_])
    async ActionParams_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionParams] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Params', rows);
        return result;
    }
        
    @FieldResolver(() => [MJActionLibrary_])
    async ActionLibraries_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Libraries', rows);
        return result;
    }
        
    @FieldResolver(() => [MJActionResultCode_])
    async ActionResultCodes_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Result Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionResultCodes] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Result Codes', rows);
        return result;
    }
        
    @FieldResolver(() => [MJScheduledAction_])
    async ScheduledActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentAction_])
    async AIAgentActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJActionContext_])
    async ActionContexts_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Contexts', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityAction_])
    async EntityActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJActionExecutionLog_])
    async ActionExecutionLogs_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Execution Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJActionAuthorization_])
    async ActionAuthorizations_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Authorizations', rows);
        return result;
    }
        
    @Mutation(() => MJAction_)
    async CreateMJAction(
        @Arg('input', () => CreateMJActionInput) input: CreateMJActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAction_)
    async UpdateMJAction(
        @Arg('input', () => UpdateMJActionInput) input: UpdateMJActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAction_)
    async DeleteMJAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Actions
//****************************************************************************
@ObjectType({ description: `List of all actions that are possible across all AI Models` })
export class MJAIAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    DefaultPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DefaultModelID?: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DefaultModel?: string;
        
    @Field(() => [MJAIModelAction_])
    AIModelActions_AIActionIDArray: MJAIModelAction_[]; // Link to AIModelActions
    
    @Field(() => [MJEntityAIAction_])
    EntityAIActions_AIActionIDArray: MJEntityAIAction_[]; // Link to EntityAIActions
    
}

//****************************************************************************
// INPUT TYPE for AI Actions
//****************************************************************************
@InputType()
export class CreateMJAIActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultPrompt: string | null;

    @Field({ nullable: true })
    DefaultModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for AI Actions
//****************************************************************************
@InputType()
export class UpdateMJAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultPrompt?: string | null;

    @Field({ nullable: true })
    DefaultModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Actions
//****************************************************************************
@ObjectType()
export class RunMJAIActionViewResult {
    @Field(() => [MJAIAction_])
    Results: MJAIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAction_)
export class MJAIActionResolver extends ResolverBase {
    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAction_, { nullable: true })
    async MJAIAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAction_ | null> {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJAIAction_])
    async AllAIActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions]` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Actions', rows);
        return result;
    }
    
    @FieldResolver(() => [MJAIModelAction_])
    async AIModelActions_AIActionIDArray(@Root() mjaiaction_: MJAIAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [AIActionID]='${mjaiaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async EntityAIActions_AIActionIDArray(@Root() mjaiaction_: MJAIAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [AIActionID]='${mjaiaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows);
        return result;
    }
        
    @Mutation(() => MJAIAction_)
    async CreateMJAIAction(
        @Arg('input', () => CreateMJAIActionInput) input: CreateMJAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAction_)
    async UpdateMJAIAction(
        @Arg('input', () => UpdateMJAIActionInput) input: UpdateMJAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAction_)
    async DeleteMJAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Actions
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and actions.` })
export class MJAIAgentAction_ {
    @Field({description: `The unique identifier for each AI agent-action mapping. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from the AIAgent table.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated action from the Action table.`}) 
    @MaxLength(16)
    ActionID?: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    Action?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Actions
//****************************************************************************
@InputType()
export class CreateMJAIAgentActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ActionID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Actions
//****************************************************************************
@InputType()
export class UpdateMJAIAgentActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ActionID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Actions
//****************************************************************************
@ObjectType()
export class RunMJAIAgentActionViewResult {
    @Field(() => [MJAIAgentAction_])
    Results: MJAIAgentAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentAction_)
export class MJAIAgentActionResolver extends ResolverBase {
    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentAction_, { nullable: true })
    async MJAIAgentAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentAction_ | null> {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJAIAgentAction_)
    async CreateMJAIAgentAction(
        @Arg('input', () => CreateMJAIAgentActionInput) input: CreateMJAIAgentActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentAction_)
    async UpdateMJAIAgentAction(
        @Arg('input', () => UpdateMJAIAgentActionInput) input: UpdateMJAIAgentActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentAction_)
    async DeleteMJAIAgentAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Learning Cycles
//****************************************************************************
@ObjectType({ description: `Tracks the learning cycles for AI Agents where the Agent does offline reasoning, reflection, learning, and updates metadata.` })
export class MJAIAgentLearningCycle_ {
    @Field({description: `Unique identifier for the learning cycle.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Identifier for the AI Agent associated with this learning cycle.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Timestamp indicating when the learning cycle started.`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp indicating when the learning cycle ended.`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Status of the learning cycle (In-Progress, Complete, or Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Text summary provided by the agent about what it learned and any changes it requested for stored metadata.`}) 
    AgentSummary?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class CreateMJAIAgentLearningCycleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class UpdateMJAIAgentLearningCycleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Learning Cycles
//****************************************************************************
@ObjectType()
export class RunMJAIAgentLearningCycleViewResult {
    @Field(() => [MJAIAgentLearningCycle_])
    Results: MJAIAgentLearningCycle_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentLearningCycle_)
export class MJAIAgentLearningCycleResolver extends ResolverBase {
    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Learning Cycles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentLearningCycle_, { nullable: true })
    async MJAIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentLearningCycle_ | null> {
        this.CheckUserReadPermissions('AI Agent Learning Cycles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentLearningCycles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Learning Cycles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJAIAgentLearningCycle_)
    async CreateMJAIAgentLearningCycle(
        @Arg('input', () => CreateMJAIAgentLearningCycleInput) input: CreateMJAIAgentLearningCycleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Learning Cycles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentLearningCycle_)
    async UpdateMJAIAgentLearningCycle(
        @Arg('input', () => UpdateMJAIAgentLearningCycleInput) input: UpdateMJAIAgentLearningCycleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Learning Cycles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentLearningCycle_)
    async DeleteMJAIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Learning Cycles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Models
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and AI models.` })
export class MJAIAgentModel_ {
    @Field({description: `The unique identifier for each AI agent-model mapping. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from AIAgent table.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `The unique identifier of the associated AI model.`}) 
    @MaxLength(16)
    ModelID?: string;
        
    @Field(() => Boolean, {nullable: true}) 
    Active?: boolean;
        
    @Field(() => Int, {nullable: true, description: `The priority level of the AI model for the agent, where higher values indicate higher priority.`}) 
    Priority?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Model?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Models
//****************************************************************************
@InputType()
export class CreateMJAIAgentModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    Active: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority: number | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Models
//****************************************************************************
@InputType()
export class UpdateMJAIAgentModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Models
//****************************************************************************
@ObjectType()
export class RunMJAIAgentModelViewResult {
    @Field(() => [MJAIAgentModel_])
    Results: MJAIAgentModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentModel_)
export class MJAIAgentModelResolver extends ResolverBase {
    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentModel_, { nullable: true })
    async MJAIAgentModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentModel_ | null> {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Models', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJAIAgentModel_)
    async CreateMJAIAgentModel(
        @Arg('input', () => CreateMJAIAgentModelInput) input: CreateMJAIAgentModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentModel_)
    async UpdateMJAIAgentModel(
        @Arg('input', () => UpdateMJAIAgentModelInput) input: UpdateMJAIAgentModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentModel_)
    async DeleteMJAIAgentModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Note Types
//****************************************************************************
@ObjectType()
export class MJAIAgentNoteType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_AgentNoteTypeIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
}

//****************************************************************************
// INPUT TYPE for AI Agent Note Types
//****************************************************************************
@InputType()
export class CreateMJAIAgentNoteTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Note Types
//****************************************************************************
@InputType()
export class UpdateMJAIAgentNoteTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Note Types
//****************************************************************************
@ObjectType()
export class RunMJAIAgentNoteTypeViewResult {
    @Field(() => [MJAIAgentNoteType_])
    Results: MJAIAgentNoteType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentNoteType_)
export class MJAIAgentNoteTypeResolver extends ResolverBase {
    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Note Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentNoteType_, { nullable: true })
    async MJAIAgentNoteType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentNoteType_ | null> {
        this.CheckUserReadPermissions('AI Agent Note Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNoteTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Note Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Note Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_AgentNoteTypeIDArray(@Root() mjaiagentnotetype_: MJAIAgentNoteType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [AgentNoteTypeID]='${mjaiagentnotetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows);
        return result;
    }
        
    @Mutation(() => MJAIAgentNoteType_)
    async CreateMJAIAgentNoteType(
        @Arg('input', () => CreateMJAIAgentNoteTypeInput) input: CreateMJAIAgentNoteTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Note Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentNoteType_)
    async UpdateMJAIAgentNoteType(
        @Arg('input', () => UpdateMJAIAgentNoteTypeInput) input: UpdateMJAIAgentNoteTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Note Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentNoteType_)
    async DeleteMJAIAgentNoteType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Note Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Notes
//****************************************************************************
@ObjectType()
export class MJAIAgentNote_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentNoteTypeID?: string;
        
    @Field({nullable: true}) 
    Note?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates the type of note, either User-specific or Global.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Foreign key referencing the ID column in the User table, indicating the user associated with the note. Used when Type=User`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AgentNoteType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Notes
//****************************************************************************
@InputType()
export class CreateMJAIAgentNoteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID: string | null;

    @Field({ nullable: true })
    Note: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Notes
//****************************************************************************
@InputType()
export class UpdateMJAIAgentNoteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID?: string | null;

    @Field({ nullable: true })
    Note?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Notes
//****************************************************************************
@ObjectType()
export class RunMJAIAgentNoteViewResult {
    @Field(() => [MJAIAgentNote_])
    Results: MJAIAgentNote_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentNote_)
export class MJAIAgentNoteResolver extends ResolverBase {
    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Notes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentNote_, { nullable: true })
    async MJAIAgentNote(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentNote_ | null> {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Notes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJAIAgentNote_)
    async CreateMJAIAgentNote(
        @Arg('input', () => CreateMJAIAgentNoteInput) input: CreateMJAIAgentNoteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Notes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentNote_)
    async UpdateMJAIAgentNote(
        @Arg('input', () => UpdateMJAIAgentNoteInput) input: UpdateMJAIAgentNoteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Notes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentNote_)
    async DeleteMJAIAgentNote(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Notes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Requests
//****************************************************************************
@ObjectType({ description: `Table to log AI Agent requests, responses, and their statuses.` })
export class MJAIAgentRequest_ {
    @Field({description: `Primary key for the AIAgentRequest table, uniquely identifies each record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key referencing the ID column in the AIAgent table.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Timestamp when the request was made by the agent.`}) 
    @MaxLength(8)
    RequestedAt: Date;
        
    @Field({nullable: true, description: `Optional, a user that the AI specifically is directing the request to, if null intended for general system owner.`}) 
    @MaxLength(16)
    RequestForUserID?: string;
        
    @Field({description: `Current status of the request (Requested, Approved, Rejected, Canceled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Details of what the AI Agent is requesting.`}) 
    Request: string;
        
    @Field({nullable: true, description: `Response provided by the human to the agent request.`}) 
    Response?: string;
        
    @Field({nullable: true, description: `Populated when a user responds indicating which user responded to the request.`}) 
    @MaxLength(16)
    ResponseByUserID?: string;
        
    @Field({nullable: true, description: `Timestamp when the response was provided by the human.`}) 
    @MaxLength(8)
    RespondedAt?: Date;
        
    @Field({nullable: true, description: `Additional comments about the request. Not shared with the agent, purely record keeping.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    RequestForUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ResponseByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Requests
//****************************************************************************
@InputType()
export class CreateMJAIAgentRequestInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response: string | null;

    @Field({ nullable: true })
    ResponseByUserID: string | null;

    @Field({ nullable: true })
    RespondedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Requests
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRequestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response?: string | null;

    @Field({ nullable: true })
    ResponseByUserID?: string | null;

    @Field({ nullable: true })
    RespondedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Requests
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRequestViewResult {
    @Field(() => [MJAIAgentRequest_])
    Results: MJAIAgentRequest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRequest_)
export class MJAIAgentRequestResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Requests';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRequest_, { nullable: true })
    async MJAIAgentRequest(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRequest_ | null> {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Requests', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJAIAgentRequest_)
    async CreateMJAIAgentRequest(
        @Arg('input', () => CreateMJAIAgentRequestInput) input: CreateMJAIAgentRequestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Requests', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRequest_)
    async UpdateMJAIAgentRequest(
        @Arg('input', () => UpdateMJAIAgentRequestInput) input: UpdateMJAIAgentRequestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Requests', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRequest_)
    async DeleteMJAIAgentRequest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Requests', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agents
//****************************************************************************
@ObjectType({ description: `Table to store information about AI agents.` })
export class MJAIAgent_ {
    @Field({description: `The unique identifier for each AI agent. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `The name of the AI agent.`}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true, description: `A detailed description of the AI agent.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LogoURL?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIAgentModel_])
    AIAgentModels_AgentIDArray: MJAIAgentModel_[]; // Link to AIAgentModels
    
    @Field(() => [MJAIAgentAction_])
    AIAgentActions_AgentIDArray: MJAIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [MJAIAgentLearningCycle_])
    AIAgentLearningCycles_AgentIDArray: MJAIAgentLearningCycle_[]; // Link to AIAgentLearningCycles
    
    @Field(() => [MJAIAgentRequest_])
    AIAgentRequests_AgentIDArray: MJAIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_AgentIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
}

//****************************************************************************
// INPUT TYPE for AI Agents
//****************************************************************************
@InputType()
export class CreateMJAIAgentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agents
//****************************************************************************
@InputType()
export class UpdateMJAIAgentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agents
//****************************************************************************
@ObjectType()
export class RunMJAIAgentViewResult {
    @Field(() => [MJAIAgent_])
    Results: MJAIAgent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgent_)
export class MJAIAgentResolver extends ResolverBase {
    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgent_, { nullable: true })
    async MJAIAgent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgent_ | null> {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agents', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentModel_])
    async AIAgentModels_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Models', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentAction_])
    async AIAgentActions_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentLearningCycle_])
    async AIAgentLearningCycles_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Learning Cycles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentLearningCycles] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Learning Cycles', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async AIAgentRequests_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows);
        return result;
    }
        
    @Mutation(() => MJAIAgent_)
    async CreateMJAIAgent(
        @Arg('input', () => CreateMJAIAgentInput) input: CreateMJAIAgentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgent_)
    async UpdateMJAIAgent(
        @Arg('input', () => UpdateMJAIAgentInput) input: UpdateMJAIAgentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgent_)
    async DeleteMJAIAgent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Model Actions
//****************************************************************************
@ObjectType({ description: `Tracks the actions supported by each AI Model` })
export class MJAIModelAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field() 
    @MaxLength(16)
    AIActionID: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field() 
    @MaxLength(100)
    AIAction: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Model Actions
//****************************************************************************
@InputType()
export class CreateMJAIModelActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for AI Model Actions
//****************************************************************************
@InputType()
export class UpdateMJAIModelActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Model Actions
//****************************************************************************
@ObjectType()
export class RunMJAIModelActionViewResult {
    @Field(() => [MJAIModelAction_])
    Results: MJAIModelAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelAction_)
export class MJAIModelActionResolver extends ResolverBase {
    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Model Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelAction_, { nullable: true })
    async MJAIModelAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelAction_ | null> {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Model Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJAIModelAction_])
    async AllAIModelActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions]` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows);
        return result;
    }
    
    @Mutation(() => MJAIModelAction_)
    async CreateMJAIModelAction(
        @Arg('input', () => CreateMJAIModelActionInput) input: CreateMJAIModelActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Model Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelAction_)
    async UpdateMJAIModelAction(
        @Arg('input', () => UpdateMJAIModelActionInput) input: UpdateMJAIModelActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Model Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelAction_)
    async DeleteMJAIModelAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Model Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Model Types
//****************************************************************************
@ObjectType({ description: `Types of AI Models` })
export class MJAIModelType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIModel_])
    AIModels_AIModelTypeIDArray: MJAIModel_[]; // Link to AIModels
    
}

//****************************************************************************
// INPUT TYPE for AI Model Types
//****************************************************************************
@InputType()
export class CreateMJAIModelTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Model Types
//****************************************************************************
@InputType()
export class UpdateMJAIModelTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Model Types
//****************************************************************************
@ObjectType()
export class RunMJAIModelTypeViewResult {
    @Field(() => [MJAIModelType_])
    Results: MJAIModelType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelType_)
export class MJAIModelTypeResolver extends ResolverBase {
    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Model Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelType_, { nullable: true })
    async MJAIModelType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelType_ | null> {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Model Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJAIModelType_])
    async AllAIModelTypes(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes]` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Types', rows);
        return result;
    }
    
    @FieldResolver(() => [MJAIModel_])
    async AIModels_AIModelTypeIDArray(@Root() mjaimodeltype_: MJAIModelType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [AIModelTypeID]='${mjaimodeltype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Models', rows);
        return result;
    }
        
    @Mutation(() => MJAIModelType_)
    async CreateMJAIModelType(
        @Arg('input', () => CreateMJAIModelTypeInput) input: CreateMJAIModelTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Model Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelType_)
    async UpdateMJAIModelType(
        @Arg('input', () => UpdateMJAIModelTypeInput) input: UpdateMJAIModelTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Model Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelType_)
    async DeleteMJAIModelType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Model Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Models
//****************************************************************************
@ObjectType({ description: `Catalog of all AI Models configured in the system` })
export class MJAIModel_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Vendor?: string;
        
    @Field() 
    @MaxLength(16)
    AIModelTypeID: string;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the power of the AI model. Default is 0 and should be non-negative.`}) 
    PowerRank?: number;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DriverImportPath?: string;
        
    @Field({nullable: true, description: `The name of the model to use with API calls which might differ from the Name, if APIName is not provided, Name will be used for API calls`}) 
    @MaxLength(200)
    APIName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModelType: string;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the speed of the AI model. Default is 0 and should be non-negative.`}) 
    SpeedRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the cost of the AI model. Default is 0 and should be non-negative.`}) 
    CostRank?: number;
        
    @Field({nullable: true, description: `This column stores unstructured text notes that provide insights into what the model is particularly good at and areas where it may not perform as well. These notes can be used by a human or an AI to determine if the model is a good fit for various purposes.`}) 
    ModelSelectionInsights?: string;
        
    @Field(() => Int, {nullable: true, description: `Stores the maximum number of tokens that fit in the context window for the model.`}) 
    InputTokenLimit?: number;
        
    @Field({description: `A comma-delimited string indicating the supported response formats for the AI model. Options include Any, Text, Markdown, JSON, and ModelSpecific. Defaults to Any if not specified.`}) 
    @MaxLength(200)
    SupportedResponseFormats: string;
        
    @Field(() => [MJAIAction_])
    AIActions_DefaultModelIDArray: MJAIAction_[]; // Link to AIActions
    
    @Field(() => [MJAIModelAction_])
    AIModelActions_AIModelIDArray: MJAIModelAction_[]; // Link to AIModelActions
    
    @Field(() => [MJVectorIndex_])
    VectorIndexes_EmbeddingModelIDArray: MJVectorIndex_[]; // Link to VectorIndexes
    
    @Field(() => [MJEntityDocument_])
    EntityDocuments_AIModelIDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [MJEntityAIAction_])
    EntityAIActions_AIModelIDArray: MJEntityAIAction_[]; // Link to EntityAIActions
    
    @Field(() => [MJContentType_])
    ContentTypes_AIModelIDArray: MJContentType_[]; // Link to ContentTypes
    
    @Field(() => [MJAIResultCache_])
    AIResultCache_AIModelIDArray: MJAIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [MJAIAgentModel_])
    AIAgentModels_ModelIDArray: MJAIAgentModel_[]; // Link to AIAgentModels
    
    @Field(() => [MJGeneratedCode_])
    GeneratedCodes_GeneratedByModelIDArray: MJGeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for AI Models
//****************************************************************************
@InputType()
export class CreateMJAIModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Vendor: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    APIName: string | null;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights: string | null;

    @Field(() => Int, { nullable: true })
    InputTokenLimit: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;
}
    

//****************************************************************************
// INPUT TYPE for AI Models
//****************************************************************************
@InputType()
export class UpdateMJAIModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Vendor?: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    APIName?: string | null;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights?: string | null;

    @Field(() => Int, { nullable: true })
    InputTokenLimit?: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Models
//****************************************************************************
@ObjectType()
export class RunMJAIModelViewResult {
    @Field(() => [MJAIModel_])
    Results: MJAIModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModel_)
export class MJAIModelResolver extends ResolverBase {
    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModel_, { nullable: true })
    async MJAIModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModel_ | null> {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Models', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJAIModel_])
    async AllAIModels(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels]` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Models', rows);
        return result;
    }
    
    @FieldResolver(() => [MJAIAction_])
    async AIActions_DefaultModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions] WHERE [DefaultModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIModelAction_])
    async AIModelActions_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJVectorIndex_])
    async VectorIndexes_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [EmbeddingModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Vector Indexes', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async EntityAIActions_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJContentType_])
    async ContentTypes_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypes] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Types', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async AIResultCache_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentModel_])
    async AIAgentModels_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [ModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Models', rows);
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async GeneratedCodes_GeneratedByModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [GeneratedByModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows);
        return result;
    }
        
    @Mutation(() => MJAIModel_)
    async CreateMJAIModel(
        @Arg('input', () => CreateMJAIModelInput) input: CreateMJAIModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModel_)
    async UpdateMJAIModel(
        @Arg('input', () => UpdateMJAIModelInput) input: UpdateMJAIModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModel_)
    async DeleteMJAIModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompt Categories
//****************************************************************************
@ObjectType({ description: `Categories for organizing AI prompts in a hierarchical structure.` })
export class MJAIPromptCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Parent category ID for hierarchical organization.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [MJAIPrompt_])
    AIPrompts_CategoryIDArray: MJAIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [MJAIPromptCategory_])
    AIPromptCategories_ParentIDArray: MJAIPromptCategory_[]; // Link to AIPromptCategories
    
}

//****************************************************************************
// INPUT TYPE for AI Prompt Categories
//****************************************************************************
@InputType()
export class CreateMJAIPromptCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompt Categories
//****************************************************************************
@InputType()
export class UpdateMJAIPromptCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompt Categories
//****************************************************************************
@ObjectType()
export class RunMJAIPromptCategoryViewResult {
    @Field(() => [MJAIPromptCategory_])
    Results: MJAIPromptCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptCategory_)
export class MJAIPromptCategoryResolver extends ResolverBase {
    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompt Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptCategory_, { nullable: true })
    async MJAIPromptCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptCategory_ | null> {
        this.CheckUserReadPermissions('AI Prompt Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Prompt Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJAIPrompt_])
    async AIPrompts_CategoryIDArray(@Root() mjaipromptcategory_: MJAIPromptCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [CategoryID]='${mjaipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptCategory_])
    async AIPromptCategories_ParentIDArray(@Root() mjaipromptcategory_: MJAIPromptCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompt Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptCategories] WHERE [ParentID]='${mjaipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompt Categories', rows);
        return result;
    }
        
    @Mutation(() => MJAIPromptCategory_)
    async CreateMJAIPromptCategory(
        @Arg('input', () => CreateMJAIPromptCategoryInput) input: CreateMJAIPromptCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompt Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptCategory_)
    async UpdateMJAIPromptCategory(
        @Arg('input', () => UpdateMJAIPromptCategoryInput) input: UpdateMJAIPromptCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompt Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptCategory_)
    async DeleteMJAIPromptCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompt Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompt Types
//****************************************************************************
@ObjectType({ description: `Types of AI prompts such as Chat, Text-to-Image, Text-to-Video, etc.` })
export class MJAIPromptType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIPrompt_])
    AIPrompts_TypeIDArray: MJAIPrompt_[]; // Link to AIPrompts
    
}

//****************************************************************************
// INPUT TYPE for AI Prompt Types
//****************************************************************************
@InputType()
export class CreateMJAIPromptTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompt Types
//****************************************************************************
@InputType()
export class UpdateMJAIPromptTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompt Types
//****************************************************************************
@ObjectType()
export class RunMJAIPromptTypeViewResult {
    @Field(() => [MJAIPromptType_])
    Results: MJAIPromptType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptType_)
export class MJAIPromptTypeResolver extends ResolverBase {
    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompt Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptType_, { nullable: true })
    async MJAIPromptType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptType_ | null> {
        this.CheckUserReadPermissions('AI Prompt Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Prompt Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJAIPrompt_])
    async AIPrompts_TypeIDArray(@Root() mjaiprompttype_: MJAIPromptType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [TypeID]='${mjaiprompttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows);
        return result;
    }
        
    @Mutation(() => MJAIPromptType_)
    async CreateMJAIPromptType(
        @Arg('input', () => CreateMJAIPromptTypeInput) input: CreateMJAIPromptTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompt Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptType_)
    async UpdateMJAIPromptType(
        @Arg('input', () => UpdateMJAIPromptTypeInput) input: UpdateMJAIPromptTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompt Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptType_)
    async DeleteMJAIPromptType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompt Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompts
//****************************************************************************
@ObjectType({ description: `Stores AI prompts, including references to categories, types, and templates.` })
export class MJAIPrompt_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Reference to the template used for the prompt.`}) 
    @MaxLength(16)
    TemplateID: string;
        
    @Field({nullable: true, description: `Reference to the category the prompt belongs to.`}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `Reference to the type of the prompt.`}) 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates whether the results of the prompt should be cached.`}) 
    CacheResults: boolean;
        
    @Field(() => Float, {description: `Number of hours the cache is valid for; can be fractional or 0 if the cache never expires.`}) 
    CacheExpiration: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field({description: `Specifies the expected response format for the AI model. Options include Any, Text, Markdown, JSON, and ModelSpecific. Defaults to Any if not specified.`}) 
    @MaxLength(40)
    ResponseFormat: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({nullable: true, description: `A JSON-formatted string containing model-specific response format instructions. This will be parsed and provided as a JSON object to the model.`}) 
    ModelSpecificResponseFormat?: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
    @Field(() => [MJAIResultCache_])
    AIResultCache_AIPromptIDArray: MJAIResultCache_[]; // Link to AIResultCache
    
}

//****************************************************************************
// INPUT TYPE for AI Prompts
//****************************************************************************
@InputType()
export class CreateMJAIPromptInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    CacheResults?: boolean;

    @Field(() => Float, { nullable: true })
    CacheExpiration?: number;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompts
//****************************************************************************
@InputType()
export class UpdateMJAIPromptInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    CacheResults?: boolean;

    @Field(() => Float, { nullable: true })
    CacheExpiration?: number;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompts
//****************************************************************************
@ObjectType()
export class RunMJAIPromptViewResult {
    @Field(() => [MJAIPrompt_])
    Results: MJAIPrompt_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPrompt_)
export class MJAIPromptResolver extends ResolverBase {
    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPrompt_, { nullable: true })
    async MJAIPrompt(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPrompt_ | null> {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Prompts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJAIResultCache_])
    async AIResultCache_AIPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AIPromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows);
        return result;
    }
        
    @Mutation(() => MJAIPrompt_)
    async CreateMJAIPrompt(
        @Arg('input', () => CreateMJAIPromptInput) input: CreateMJAIPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPrompt_)
    async UpdateMJAIPrompt(
        @Arg('input', () => UpdateMJAIPromptInput) input: UpdateMJAIPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPrompt_)
    async DeleteMJAIPrompt(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Result Cache
//****************************************************************************
@ObjectType({ description: `Stores cached results of AI prompts, including multiple runs for history and tracking purposes.` })
export class MJAIResultCache_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the AI prompt this result corresponds to.`}) 
    @MaxLength(16)
    AIPromptID: string;
        
    @Field({description: `Reference to the AI model that generated this result.`}) 
    @MaxLength(16)
    AIModelID: string;
        
    @Field({description: `Timestamp of when this result was generated.`}) 
    @MaxLength(10)
    RunAt: Date;
        
    @Field({description: `The prompt text used to generate this result.`}) 
    PromptText: string;
        
    @Field({nullable: true, description: `The text of the result generated by the AI model.`}) 
    ResultText?: string;
        
    @Field({description: `The status of this result, indicating whether it is currently active or expired.`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp of when this result was marked as expired.`}) 
    @MaxLength(10)
    ExpiredOn?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    AIPrompt: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Result Cache
//****************************************************************************
@InputType()
export class CreateMJAIResultCacheInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Result Cache
//****************************************************************************
@InputType()
export class UpdateMJAIResultCacheInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Result Cache
//****************************************************************************
@ObjectType()
export class RunMJAIResultCacheViewResult {
    @Field(() => [MJAIResultCache_])
    Results: MJAIResultCache_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIResultCache_)
export class MJAIResultCacheResolver extends ResolverBase {
    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Result Cache';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIResultCache_, { nullable: true })
    async MJAIResultCache(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIResultCache_ | null> {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Result Cache', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJAIResultCache_)
    async CreateMJAIResultCache(
        @Arg('input', () => CreateMJAIResultCacheInput) input: CreateMJAIResultCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Result Cache', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIResultCache_)
    async UpdateMJAIResultCache(
        @Arg('input', () => UpdateMJAIResultCacheInput) input: UpdateMJAIResultCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Result Cache', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIResultCache_)
    async DeleteMJAIResultCache(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Result Cache', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Application Entities
//****************************************************************************
@ObjectType({ description: `List of entities within each application. An application can have any number of entities and an entity can be part of any number of applications.` })
export class MJApplicationEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field(() => Boolean, {description: `When set to 1, the entity will be included by default for a new user when they first access the application in question`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    EntityBaseTableCodeName?: string;
        
}

//****************************************************************************
// INPUT TYPE for Application Entities
//****************************************************************************
@InputType()
export class CreateMJApplicationEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Application Entities
//****************************************************************************
@InputType()
export class UpdateMJApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Application Entities
//****************************************************************************
@ObjectType()
export class RunMJApplicationEntityViewResult {
    @Field(() => [MJApplicationEntity_])
    Results: MJApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplicationEntity_)
export class MJApplicationEntityResolver extends ResolverBase {
    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Application Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplicationEntity_, { nullable: true })
    async MJApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplicationEntity_ | null> {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Application Entities', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJApplicationEntity_)
    async CreateMJApplicationEntity(
        @Arg('input', () => CreateMJApplicationEntityInput) input: CreateMJApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Application Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplicationEntity_)
    async UpdateMJApplicationEntity(
        @Arg('input', () => UpdateMJApplicationEntityInput) input: UpdateMJApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Application Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplicationEntity_)
    async DeleteMJApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Application Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Application Settings
//****************************************************************************
@ObjectType()
export class MJApplicationSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
}

//****************************************************************************
// INPUT TYPE for Application Settings
//****************************************************************************
@InputType()
export class CreateMJApplicationSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Application Settings
//****************************************************************************
@InputType()
export class UpdateMJApplicationSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Application Settings
//****************************************************************************
@ObjectType()
export class RunMJApplicationSettingViewResult {
    @Field(() => [MJApplicationSetting_])
    Results: MJApplicationSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplicationSetting_)
export class MJApplicationSettingResolver extends ResolverBase {
    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Application Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplicationSetting_, { nullable: true })
    async MJApplicationSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplicationSetting_ | null> {
        this.CheckUserReadPermissions('Application Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Application Settings', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJApplicationSetting_)
    async CreateMJApplicationSetting(
        @Arg('input', () => CreateMJApplicationSettingInput) input: CreateMJApplicationSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Application Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplicationSetting_)
    async UpdateMJApplicationSetting(
        @Arg('input', () => UpdateMJApplicationSettingInput) input: UpdateMJApplicationSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Application Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplicationSetting_)
    async DeleteMJApplicationSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Application Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Applications
//****************************************************************************
@ObjectType({ description: `Applications are used to group entities in the user interface for ease of user access` })
export class MJApplication_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Specify the CSS class information for the display icon for each application.`}) 
    @MaxLength(1000)
    Icon?: string;
        
    @Field(() => Boolean, {description: `If turned on, when a new user first uses the MJ Explorer app, the application records with this turned on will have this application included in their selected application list.`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJApplicationEntity_])
    ApplicationEntities_ApplicationIDArray: MJApplicationEntity_[]; // Link to ApplicationEntities
    
    @Field(() => [MJUserApplication_])
    UserApplications_ApplicationIDArray: MJUserApplication_[]; // Link to UserApplications
    
    @Field(() => [MJApplicationSetting_])
    ApplicationSettings_ApplicationIDArray: MJApplicationSetting_[]; // Link to ApplicationSettings
    
}

//****************************************************************************
// INPUT TYPE for Applications
//****************************************************************************
@InputType()
export class CreateMJApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Applications
//****************************************************************************
@InputType()
export class UpdateMJApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Applications
//****************************************************************************
@ObjectType()
export class RunMJApplicationViewResult {
    @Field(() => [MJApplication_])
    Results: MJApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplication_)
export class MJApplicationResolver extends ResolverBase {
    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplication_, { nullable: true })
    async MJApplication(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplication_ | null> {
        this.CheckUserReadPermissions('Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Applications', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJApplication_])
    async AllApplications(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplications]` + this.getRowLevelSecurityWhereClause(provider, 'Applications', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Applications', rows);
        return result;
    }
    
    @FieldResolver(() => [MJApplicationEntity_])
    async ApplicationEntities_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [ApplicationID]='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Application Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserApplication_])
    async UserApplications_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [ApplicationID]='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Applications', rows);
        return result;
    }
        
    @FieldResolver(() => [MJApplicationSetting_])
    async ApplicationSettings_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationSettings] WHERE [ApplicationID]='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Application Settings', rows);
        return result;
    }
        
    @Mutation(() => MJApplication_)
    async CreateMJApplication(
        @Arg('input', () => CreateMJApplicationInput) input: CreateMJApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplication_)
    async UpdateMJApplication(
        @Arg('input', () => UpdateMJApplicationInput) input: UpdateMJApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplication_)
    async DeleteMJApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Audit Log Types
//****************************************************************************
@ObjectType()
export class MJAuditLogType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Authorization?: string;
        
    @Field(() => [MJAuditLog_])
    AuditLogs_AuditLogTypeNameArray: MJAuditLog_[]; // Link to AuditLogs
    
    @Field(() => [MJAuditLogType_])
    AuditLogTypes_ParentIDArray: MJAuditLogType_[]; // Link to AuditLogTypes
    
}
//****************************************************************************
// RESOLVER for Audit Log Types
//****************************************************************************
@ObjectType()
export class RunMJAuditLogTypeViewResult {
    @Field(() => [MJAuditLogType_])
    Results: MJAuditLogType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuditLogType_)
export class MJAuditLogTypeResolver extends ResolverBase {
    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Audit Log Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuditLogType_, { nullable: true })
    async MJAuditLogType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuditLogType_ | null> {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Audit Log Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJAuditLogType_])
    async AllAuditLogTypes(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes]` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows);
        return result;
    }
    
    @FieldResolver(() => [MJAuditLog_])
    async AuditLogs_AuditLogTypeNameArray(@Root() mjauditlogtype_: MJAuditLogType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [AuditLogTypeName]='${mjauditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAuditLogType_])
    async AuditLogTypes_ParentIDArray(@Root() mjauditlogtype_: MJAuditLogType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [ParentID]='${mjauditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Audit Logs
//****************************************************************************
@ObjectType()
export class MJAuditLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    AuditLogTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    Details?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(900)
    RecordID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
    @Field() 
    @MaxLength(100)
    AuditLogType: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Authorization?: string;
        
}

//****************************************************************************
// INPUT TYPE for Audit Logs
//****************************************************************************
@InputType()
export class CreateMJAuditLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Details: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Audit Logs
//****************************************************************************
@InputType()
export class UpdateMJAuditLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Audit Logs
//****************************************************************************
@ObjectType()
export class RunMJAuditLogViewResult {
    @Field(() => [MJAuditLog_])
    Results: MJAuditLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuditLog_)
export class MJAuditLogResolver extends ResolverBase {
    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Audit Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuditLog_, { nullable: true })
    async MJAuditLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuditLog_ | null> {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Audit Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJAuditLog_)
    async CreateMJAuditLog(
        @Arg('input', () => CreateMJAuditLogInput) input: CreateMJAuditLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Audit Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuditLog_)
    async UpdateMJAuditLog(
        @Arg('input', () => UpdateMJAuditLogInput) input: UpdateMJAuditLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Audit Logs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Authorization Roles
//****************************************************************************
@ObjectType()
export class MJAuthorizationRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AuthorizationID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(20)
    Type: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Authorization: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}
//****************************************************************************
// RESOLVER for Authorization Roles
//****************************************************************************
@ObjectType()
export class RunMJAuthorizationRoleViewResult {
    @Field(() => [MJAuthorizationRole_])
    Results: MJAuthorizationRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuthorizationRole_)
export class MJAuthorizationRoleResolver extends ResolverBase {
    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Authorization Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuthorizationRole_, { nullable: true })
    async MJAuthorizationRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuthorizationRole_ | null> {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Authorization Roles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJAuthorizationRole_])
    async AllAuthorizationRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles]` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows);
        return result;
    }
    
}

//****************************************************************************
// ENTITY CLASS for Authorizations
//****************************************************************************
@ObjectType()
export class MJAuthorization_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, Audit Log records are created whenever this authorization is invoked for a user`}) 
    UseAuditLog: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field(() => [MJAuthorizationRole_])
    AuthorizationRoles_AuthorizationIDArray: MJAuthorizationRole_[]; // Link to AuthorizationRoles
    
    @Field(() => [MJAuthorization_])
    Authorizations_ParentIDArray: MJAuthorization_[]; // Link to Authorizations
    
    @Field(() => [MJAuditLogType_])
    AuditLogTypes_AuthorizationNameArray: MJAuditLogType_[]; // Link to AuditLogTypes
    
    @Field(() => [MJAuditLog_])
    AuditLogs_AuthorizationNameArray: MJAuditLog_[]; // Link to AuditLogs
    
    @Field(() => [MJActionAuthorization_])
    ActionAuthorizations_AuthorizationIDArray: MJActionAuthorization_[]; // Link to ActionAuthorizations
    
}
//****************************************************************************
// RESOLVER for Authorizations
//****************************************************************************
@ObjectType()
export class RunMJAuthorizationViewResult {
    @Field(() => [MJAuthorization_])
    Results: MJAuthorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuthorization_)
export class MJAuthorizationResolver extends ResolverBase {
    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Authorizations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuthorization_, { nullable: true })
    async MJAuthorization(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuthorization_ | null> {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Authorizations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJAuthorization_])
    async AllAuthorizations(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations]` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorizations', rows);
        return result;
    }
    
    @FieldResolver(() => [MJAuthorizationRole_])
    async AuthorizationRoles_AuthorizationIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [AuthorizationID]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAuthorization_])
    async Authorizations_ParentIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations] WHERE [ParentID]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorizations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAuditLogType_])
    async AuditLogTypes_AuthorizationNameArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [AuthorizationName]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async AuditLogs_AuthorizationNameArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [AuthorizationName]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJActionAuthorization_])
    async ActionAuthorizations_AuthorizationIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [AuthorizationID]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Authorizations', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Communication Base Message Types
//****************************************************************************
@ObjectType({ description: `Base message types and their supported functionalities.` })
export class MJCommunicationBaseMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates if attachments are supported.`}) 
    SupportsAttachments: boolean;
        
    @Field(() => Boolean, {description: `Indicates if a subject line is supported.`}) 
    SupportsSubjectLine: boolean;
        
    @Field(() => Boolean, {description: `Indicates if HTML content is supported.`}) 
    SupportsHtml: boolean;
        
    @Field(() => Int, {nullable: true, description: `The maximum size in bytes for the message.`}) 
    MaxBytes?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJCommunicationProviderMessageType_])
    CommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray: MJCommunicationProviderMessageType_[]; // Link to CommunicationProviderMessageTypes
    
    @Field(() => [MJEntityCommunicationMessageType_])
    EntityCommunicationMessageTypes_BaseMessageTypeIDArray: MJEntityCommunicationMessageType_[]; // Link to EntityCommunicationMessageTypes
    
}

//****************************************************************************
// INPUT TYPE for Communication Base Message Types
//****************************************************************************
@InputType()
export class CreateMJCommunicationBaseMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Base Message Types
//****************************************************************************
@InputType()
export class UpdateMJCommunicationBaseMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Base Message Types
//****************************************************************************
@ObjectType()
export class RunMJCommunicationBaseMessageTypeViewResult {
    @Field(() => [MJCommunicationBaseMessageType_])
    Results: MJCommunicationBaseMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationBaseMessageType_)
export class MJCommunicationBaseMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Base Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationBaseMessageType_, { nullable: true })
    async MJCommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationBaseMessageType_ | null> {
        this.CheckUserReadPermissions('Communication Base Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationBaseMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Base Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Base Message Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationProviderMessageType_])
    async CommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray(@Root() mjcommunicationbasemessagetype_: MJCommunicationBaseMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [CommunicationBaseMessageTypeID]='${mjcommunicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Provider Message Types', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityCommunicationMessageType_])
    async EntityCommunicationMessageTypes_BaseMessageTypeIDArray(@Root() mjcommunicationbasemessagetype_: MJCommunicationBaseMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [BaseMessageTypeID]='${mjcommunicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Message Types', rows);
        return result;
    }
        
    @Mutation(() => MJCommunicationBaseMessageType_)
    async CreateMJCommunicationBaseMessageType(
        @Arg('input', () => CreateMJCommunicationBaseMessageTypeInput) input: CreateMJCommunicationBaseMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Base Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationBaseMessageType_)
    async UpdateMJCommunicationBaseMessageType(
        @Arg('input', () => UpdateMJCommunicationBaseMessageTypeInput) input: UpdateMJCommunicationBaseMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Base Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationBaseMessageType_)
    async DeleteMJCommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Base Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Logs
//****************************************************************************
@ObjectType({ description: `Logs of sent and received messages.` })
export class MJCommunicationLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderMessageTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CommunicationRunID?: string;
        
    @Field({description: `The direction of the communication log (Sending or Receiving).`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field({description: `The date and time when the message was logged.`}) 
    @MaxLength(8)
    MessageDate: Date;
        
    @Field({description: `The status of the logged message (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `The content of the logged message.`}) 
    MessageContent?: string;
        
    @Field({nullable: true, description: `The error message if the message sending failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(510)
    CommunicationProviderMessageType: string;
        
}

//****************************************************************************
// INPUT TYPE for Communication Logs
//****************************************************************************
@InputType()
export class CreateMJCommunicationLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Logs
//****************************************************************************
@InputType()
export class UpdateMJCommunicationLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID?: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Logs
//****************************************************************************
@ObjectType()
export class RunMJCommunicationLogViewResult {
    @Field(() => [MJCommunicationLog_])
    Results: MJCommunicationLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationLog_)
export class MJCommunicationLogResolver extends ResolverBase {
    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationLog_, { nullable: true })
    async MJCommunicationLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationLog_ | null> {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJCommunicationLog_)
    async CreateMJCommunicationLog(
        @Arg('input', () => CreateMJCommunicationLogInput) input: CreateMJCommunicationLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationLog_)
    async UpdateMJCommunicationLog(
        @Arg('input', () => UpdateMJCommunicationLogInput) input: UpdateMJCommunicationLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Logs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Provider Message Types
//****************************************************************************
@ObjectType({ description: `Providers and their supported message types with additional attributes.` })
export class MJCommunicationProviderMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationBaseMessageTypeID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `The status of the provider message type (Disabled or Active).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Additional attributes specific to the provider message type.`}) 
    AdditionalAttributes?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(200)
    CommunicationBaseMessageType: string;
        
    @Field(() => [MJCommunicationLog_])
    CommunicationLogs_CommunicationProviderMessageTypeIDArray: MJCommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Provider Message Types
//****************************************************************************
@InputType()
export class CreateMJCommunicationProviderMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Provider Message Types
//****************************************************************************
@InputType()
export class UpdateMJCommunicationProviderMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Provider Message Types
//****************************************************************************
@ObjectType()
export class RunMJCommunicationProviderMessageTypeViewResult {
    @Field(() => [MJCommunicationProviderMessageType_])
    Results: MJCommunicationProviderMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationProviderMessageType_)
export class MJCommunicationProviderMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Provider Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationProviderMessageType_, { nullable: true })
    async MJCommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationProviderMessageType_ | null> {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Provider Message Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationLog_])
    async CommunicationLogs_CommunicationProviderMessageTypeIDArray(@Root() mjcommunicationprovidermessagetype_: MJCommunicationProviderMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationProviderMessageTypeID]='${mjcommunicationprovidermessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows);
        return result;
    }
        
    @Mutation(() => MJCommunicationProviderMessageType_)
    async CreateMJCommunicationProviderMessageType(
        @Arg('input', () => CreateMJCommunicationProviderMessageTypeInput) input: CreateMJCommunicationProviderMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Provider Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationProviderMessageType_)
    async UpdateMJCommunicationProviderMessageType(
        @Arg('input', () => UpdateMJCommunicationProviderMessageTypeInput) input: UpdateMJCommunicationProviderMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Provider Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationProviderMessageType_)
    async DeleteMJCommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Provider Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Providers
//****************************************************************************
@ObjectType({ description: `All supported communication providers.` })
export class MJCommunicationProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The status of the communication provider (Disabled or Active).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports sending messages.`}) 
    SupportsSending: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports receiving messages.`}) 
    SupportsReceiving: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports sending messages at a specific time`}) 
    SupportsScheduledSending: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports forwarding messages to another recipient `}) 
    SupportsForwarding: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports replying to messages`}) 
    SupportsReplying: boolean;
        
    @Field(() => [MJCommunicationProviderMessageType_])
    CommunicationProviderMessageTypes_CommunicationProviderIDArray: MJCommunicationProviderMessageType_[]; // Link to CommunicationProviderMessageTypes
    
    @Field(() => [MJCommunicationLog_])
    CommunicationLogs_CommunicationProviderIDArray: MJCommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Providers
//****************************************************************************
@InputType()
export class CreateMJCommunicationProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Communication Providers
//****************************************************************************
@InputType()
export class UpdateMJCommunicationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Providers
//****************************************************************************
@ObjectType()
export class RunMJCommunicationProviderViewResult {
    @Field(() => [MJCommunicationProvider_])
    Results: MJCommunicationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationProvider_)
export class MJCommunicationProviderResolver extends ResolverBase {
    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationProvider_, { nullable: true })
    async MJCommunicationProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationProvider_ | null> {
        this.CheckUserReadPermissions('Communication Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Providers', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationProviderMessageType_])
    async CommunicationProviderMessageTypes_CommunicationProviderIDArray(@Root() mjcommunicationprovider_: MJCommunicationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [CommunicationProviderID]='${mjcommunicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Provider Message Types', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCommunicationLog_])
    async CommunicationLogs_CommunicationProviderIDArray(@Root() mjcommunicationprovider_: MJCommunicationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationProviderID]='${mjcommunicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows);
        return result;
    }
        
    @Mutation(() => MJCommunicationProvider_)
    async CreateMJCommunicationProvider(
        @Arg('input', () => CreateMJCommunicationProviderInput) input: CreateMJCommunicationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationProvider_)
    async UpdateMJCommunicationProvider(
        @Arg('input', () => UpdateMJCommunicationProviderInput) input: UpdateMJCommunicationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationProvider_)
    async DeleteMJCommunicationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Runs
//****************************************************************************
@ObjectType({ description: `Runs of bulk message sends and receives.` })
export class MJCommunicationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `The direction of the communication run (Sending or Receiving).`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field({description: `The status of the communication run (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field({nullable: true, description: `The error message if the communication run failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJCommunicationLog_])
    CommunicationLogs_CommunicationRunIDArray: MJCommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Runs
//****************************************************************************
@InputType()
export class CreateMJCommunicationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Runs
//****************************************************************************
@InputType()
export class UpdateMJCommunicationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Runs
//****************************************************************************
@ObjectType()
export class RunMJCommunicationRunViewResult {
    @Field(() => [MJCommunicationRun_])
    Results: MJCommunicationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationRun_)
export class MJCommunicationRunResolver extends ResolverBase {
    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationRun_, { nullable: true })
    async MJCommunicationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationRun_ | null> {
        this.CheckUserReadPermissions('Communication Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationLog_])
    async CommunicationLogs_CommunicationRunIDArray(@Root() mjcommunicationrun_: MJCommunicationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationRunID]='${mjcommunicationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows);
        return result;
    }
        
    @Mutation(() => MJCommunicationRun_)
    async CreateMJCommunicationRun(
        @Arg('input', () => CreateMJCommunicationRunInput) input: CreateMJCommunicationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationRun_)
    async UpdateMJCommunicationRun(
        @Arg('input', () => UpdateMJCommunicationRunInput) input: UpdateMJCommunicationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Runs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Companies
//****************************************************************************
@ObjectType({ description: `A list of organizational units within your business. These can be subsidiaries or divisions or other units. Companies are used to organizae employee records and also for separating integrations if you have multiple integrations of the same type of system.` })
export class MJCompany_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field() 
    @MaxLength(400)
    Description: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Website?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    LogoURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Domain?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEmployee_])
    Employees_CompanyIDArray: MJEmployee_[]; // Link to Employees
    
    @Field(() => [MJCompanyIntegration_])
    CompanyIntegrations_CompanyNameArray: MJCompanyIntegration_[]; // Link to CompanyIntegrations
    
    @Field(() => [MJWorkflow_])
    Workflows_CompanyNameArray: MJWorkflow_[]; // Link to Workflows
    
}

//****************************************************************************
// INPUT TYPE for Companies
//****************************************************************************
@InputType()
export class CreateMJCompanyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;

    @Field({ nullable: true })
    Domain: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Companies
//****************************************************************************
@InputType()
export class UpdateMJCompanyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field({ nullable: true })
    Domain?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Companies
//****************************************************************************
@ObjectType()
export class RunMJCompanyViewResult {
    @Field(() => [MJCompany_])
    Results: MJCompany_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompany_)
export class MJCompanyResolver extends ResolverBase {
    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Companies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompany_, { nullable: true })
    async MJCompany(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompany_ | null> {
        this.CheckUserReadPermissions('Companies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanies] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Companies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Companies', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJCompany_])
    async AllCompanies(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Companies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanies]` + this.getRowLevelSecurityWhereClause(provider, 'Companies', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Companies', rows);
        return result;
    }
    
    @FieldResolver(() => [MJEmployee_])
    async Employees_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [CompanyID]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegration_])
    async CompanyIntegrations_CompanyNameArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [CompanyName]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integrations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJWorkflow_])
    async Workflows_CompanyNameArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [CompanyName]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workflows', rows);
        return result;
    }
        
    @Mutation(() => MJCompany_)
    async CreateMJCompany(
        @Arg('input', () => CreateMJCompanyInput) input: CreateMJCompanyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Companies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompany_)
    async UpdateMJCompany(
        @Arg('input', () => UpdateMJCompanyInput) input: UpdateMJCompanyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Companies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompany_)
    async DeleteMJCompany(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Companies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Record Maps
//****************************************************************************
@ObjectType()
export class MJCompanyIntegrationRecordMap_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(1500)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(1500)
    EntityRecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Company Integration Record Maps
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRecordMapInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Record Maps
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRecordMapInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Record Maps
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRecordMapViewResult {
    @Field(() => [MJCompanyIntegrationRecordMap_])
    Results: MJCompanyIntegrationRecordMap_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRecordMap_)
export class MJCompanyIntegrationRecordMapResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Record Maps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRecordMap_, { nullable: true })
    async MJCompanyIntegrationRecordMap(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRecordMap_ | null> {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integration Record Maps', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJCompanyIntegrationRecordMap_)
    async CreateMJCompanyIntegrationRecordMap(
        @Arg('input', () => CreateMJCompanyIntegrationRecordMapInput) input: CreateMJCompanyIntegrationRecordMapInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Record Maps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRecordMap_)
    async UpdateMJCompanyIntegrationRecordMap(
        @Arg('input', () => UpdateMJCompanyIntegrationRecordMapInput) input: UpdateMJCompanyIntegrationRecordMapInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Record Maps', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Run API Logs
//****************************************************************************
@ObjectType()
export class MJCompanyIntegrationRunAPILog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationRunID: string;
        
    @Field() 
    @MaxLength(8)
    ExecutedAt: Date;
        
    @Field(() => Boolean) 
    IsSuccess: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(24)
    RequestMethod?: string;
        
    @Field({nullable: true}) 
    URL?: string;
        
    @Field({nullable: true}) 
    Parameters?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Company Integration Run API Logs
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunAPILogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod: string | null;

    @Field({ nullable: true })
    URL: string | null;

    @Field({ nullable: true })
    Parameters: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Run API Logs
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunAPILogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod?: string | null;

    @Field({ nullable: true })
    URL?: string | null;

    @Field({ nullable: true })
    Parameters?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Run API Logs
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunAPILogViewResult {
    @Field(() => [MJCompanyIntegrationRunAPILog_])
    Results: MJCompanyIntegrationRunAPILog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRunAPILog_)
export class MJCompanyIntegrationRunAPILogResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Run API Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRunAPILog_, { nullable: true })
    async MJCompanyIntegrationRunAPILog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRunAPILog_ | null> {
        this.CheckUserReadPermissions('Company Integration Run API Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunAPILogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integration Run API Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJCompanyIntegrationRunAPILog_)
    async CreateMJCompanyIntegrationRunAPILog(
        @Arg('input', () => CreateMJCompanyIntegrationRunAPILogInput) input: CreateMJCompanyIntegrationRunAPILogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Run API Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRunAPILog_)
    async UpdateMJCompanyIntegrationRunAPILog(
        @Arg('input', () => UpdateMJCompanyIntegrationRunAPILogInput) input: UpdateMJCompanyIntegrationRunAPILogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Run API Logs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Run Details
//****************************************************************************
@ObjectType()
export class MJCompanyIntegrationRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationRunID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(40)
    Action: string;
        
    @Field() 
    @MaxLength(8)
    ExecutedAt: Date;
        
    @Field(() => Boolean) 
    IsSuccess: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    RunStartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    RunEndedAt?: Date;
        
    @Field(() => [MJErrorLog_])
    ErrorLogs_CompanyIntegrationRunDetailIDArray: MJErrorLog_[]; // Link to ErrorLogs
    
}

//****************************************************************************
// INPUT TYPE for Company Integration Run Details
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Run Details
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Run Details
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunDetailViewResult {
    @Field(() => [MJCompanyIntegrationRunDetail_])
    Results: MJCompanyIntegrationRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRunDetail_)
export class MJCompanyIntegrationRunDetailResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRunDetail_, { nullable: true })
    async MJCompanyIntegrationRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRunDetail_ | null> {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integration Run Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJErrorLog_])
    async ErrorLogs_CompanyIntegrationRunDetailIDArray(@Root() mjcompanyintegrationrundetail_: MJCompanyIntegrationRunDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [CompanyIntegrationRunDetailID]='${mjcompanyintegrationrundetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Error Logs', rows);
        return result;
    }
        
    @Mutation(() => MJCompanyIntegrationRunDetail_)
    async CreateMJCompanyIntegrationRunDetail(
        @Arg('input', () => CreateMJCompanyIntegrationRunDetailInput) input: CreateMJCompanyIntegrationRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRunDetail_)
    async UpdateMJCompanyIntegrationRunDetail(
        @Arg('input', () => UpdateMJCompanyIntegrationRunDetailInput) input: UpdateMJCompanyIntegrationRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Run Details', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Runs
//****************************************************************************
@ObjectType()
export class MJCompanyIntegrationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field(() => Int) 
    TotalRecords: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the integration run. Possible values: Pending, In Progress, Success, Failed.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Optional error log information for the integration run.`}) 
    ErrorLog?: string;
        
    @Field({nullable: true, description: `Optional configuration data in JSON format for the request that started the integration run for audit purposes.`}) 
    ConfigData?: string;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field() 
    @MaxLength(100)
    Company: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [MJCompanyIntegrationRunAPILog_])
    CompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray: MJCompanyIntegrationRunAPILog_[]; // Link to CompanyIntegrationRunAPILogs
    
    @Field(() => [MJErrorLog_])
    ErrorLogs_CompanyIntegrationRunIDArray: MJErrorLog_[]; // Link to ErrorLogs
    
    @Field(() => [MJCompanyIntegrationRunDetail_])
    CompanyIntegrationRunDetails_CompanyIntegrationRunIDArray: MJCompanyIntegrationRunDetail_[]; // Link to CompanyIntegrationRunDetails
    
}

//****************************************************************************
// INPUT TYPE for Company Integration Runs
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ConfigData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Runs
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ConfigData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Runs
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunViewResult {
    @Field(() => [MJCompanyIntegrationRun_])
    Results: MJCompanyIntegrationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRun_)
export class MJCompanyIntegrationRunResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRun_, { nullable: true })
    async MJCompanyIntegrationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRun_ | null> {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integration Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJCompanyIntegrationRunAPILog_])
    async CompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run API Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunAPILogs] WHERE [CompanyIntegrationRunID]='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run API Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJErrorLog_])
    async ErrorLogs_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [CompanyIntegrationRunID]='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Error Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRunDetail_])
    async CompanyIntegrationRunDetails_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [CompanyIntegrationRunID]='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run Details', rows);
        return result;
    }
        
    @Mutation(() => MJCompanyIntegrationRun_)
    async CreateMJCompanyIntegrationRun(
        @Arg('input', () => CreateMJCompanyIntegrationRunInput) input: CreateMJCompanyIntegrationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRun_)
    async UpdateMJCompanyIntegrationRun(
        @Arg('input', () => UpdateMJCompanyIntegrationRunInput) input: UpdateMJCompanyIntegrationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Runs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integrations
//****************************************************************************
@ObjectType({ description: `Links individual company records to specific integrations` })
export class MJCompanyIntegration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyID: string;
        
    @Field() 
    @MaxLength(16)
    IntegrationID: string;
        
    @Field(() => Boolean, {nullable: true}) 
    IsActive?: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AccessToken?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RefreshToken?: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    TokenExpirationDate?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    APIKey?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ExternalSystemID?: string;
        
    @Field(() => Boolean) 
    IsExternalSystemReadOnly: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ClientID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ClientSecret?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CustomAttribute1?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Company: string;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverImportPath?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LastRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    LastRunStartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    LastRunEndedAt?: Date;
        
    @Field(() => [MJList_])
    Lists_CompanyIntegrationIDArray: MJList_[]; // Link to Lists
    
    @Field(() => [MJEmployeeCompanyIntegration_])
    EmployeeCompanyIntegrations_CompanyIntegrationIDArray: MJEmployeeCompanyIntegration_[]; // Link to EmployeeCompanyIntegrations
    
    @Field(() => [MJCompanyIntegrationRun_])
    CompanyIntegrationRuns_CompanyIntegrationIDArray: MJCompanyIntegrationRun_[]; // Link to CompanyIntegrationRuns
    
    @Field(() => [MJCompanyIntegrationRecordMap_])
    CompanyIntegrationRecordMaps_CompanyIntegrationIDArray: MJCompanyIntegrationRecordMap_[]; // Link to CompanyIntegrationRecordMaps
    
}

//****************************************************************************
// INPUT TYPE for Company Integrations
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean | null;

    @Field({ nullable: true })
    AccessToken?: string | null;

    @Field({ nullable: true })
    RefreshToken?: string | null;

    @Field({ nullable: true })
    TokenExpirationDate?: Date | null;

    @Field({ nullable: true })
    APIKey?: string | null;

    @Field({ nullable: true })
    ExternalSystemID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsExternalSystemReadOnly?: boolean;

    @Field({ nullable: true })
    ClientID?: string | null;

    @Field({ nullable: true })
    ClientSecret?: string | null;

    @Field({ nullable: true })
    CustomAttribute1?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integrations
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationViewResult {
    @Field(() => [MJCompanyIntegration_])
    Results: MJCompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegration_)
export class MJCompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegration_, { nullable: true })
    async MJCompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegration_ | null> {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integrations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJList_])
    async Lists_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [CompanyIntegrationID]='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeCompanyIntegration_])
    async EmployeeCompanyIntegrations_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [CompanyIntegrationID]='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Company Integrations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRun_])
    async CompanyIntegrationRuns_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [CompanyIntegrationID]='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRecordMap_])
    async CompanyIntegrationRecordMaps_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [CompanyIntegrationID]='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Record Maps', rows);
        return result;
    }
        
    @Mutation(() => MJCompanyIntegration_)
    async UpdateMJCompanyIntegration(
        @Arg('input', () => UpdateMJCompanyIntegrationInput) input: UpdateMJCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegration_)
    async DeleteMJCompanyIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content File Types
//****************************************************************************
@ObjectType()
export class MJContentFileType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FileExtension?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJContentSource_])
    ContentSources_ContentFileTypeIDArray: MJContentSource_[]; // Link to ContentSources
    
    @Field(() => [MJContentItem_])
    ContentItems_ContentFileTypeIDArray: MJContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content File Types
//****************************************************************************
@InputType()
export class CreateMJContentFileTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content File Types
//****************************************************************************
@InputType()
export class UpdateMJContentFileTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content File Types
//****************************************************************************
@ObjectType()
export class RunMJContentFileTypeViewResult {
    @Field(() => [MJContentFileType_])
    Results: MJContentFileType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentFileType_)
export class MJContentFileTypeResolver extends ResolverBase {
    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content File Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentFileType_, { nullable: true })
    async MJContentFileType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentFileType_ | null> {
        this.CheckUserReadPermissions('Content File Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentFileTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content File Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content File Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async ContentSources_ContentFileTypeIDArray(@Root() mjcontentfiletype_: MJContentFileType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentFileTypeID]='${mjcontentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', rows);
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async ContentItems_ContentFileTypeIDArray(@Root() mjcontentfiletype_: MJContentFileType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentFileTypeID]='${mjcontentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', rows);
        return result;
    }
        
    @Mutation(() => MJContentFileType_)
    async CreateMJContentFileType(
        @Arg('input', () => CreateMJContentFileTypeInput) input: CreateMJContentFileTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content File Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentFileType_)
    async UpdateMJContentFileType(
        @Arg('input', () => UpdateMJContentFileTypeInput) input: UpdateMJContentFileTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content File Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentFileType_)
    async DeleteMJContentFileType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content File Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Item Attributes
//****************************************************************************
@ObjectType()
export class MJContentItemAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentItemID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Value: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    ContentItem?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Item Attributes
//****************************************************************************
@InputType()
export class CreateMJContentItemAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Item Attributes
//****************************************************************************
@InputType()
export class UpdateMJContentItemAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Item Attributes
//****************************************************************************
@ObjectType()
export class RunMJContentItemAttributeViewResult {
    @Field(() => [MJContentItemAttribute_])
    Results: MJContentItemAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItemAttribute_)
export class MJContentItemAttributeResolver extends ResolverBase {
    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Item Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItemAttribute_, { nullable: true })
    async MJContentItemAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItemAttribute_ | null> {
        this.CheckUserReadPermissions('Content Item Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Item Attributes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJContentItemAttribute_)
    async CreateMJContentItemAttribute(
        @Arg('input', () => CreateMJContentItemAttributeInput) input: CreateMJContentItemAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Item Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItemAttribute_)
    async UpdateMJContentItemAttribute(
        @Arg('input', () => UpdateMJContentItemAttributeInput) input: UpdateMJContentItemAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Item Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItemAttribute_)
    async DeleteMJContentItemAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Item Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Item Tags
//****************************************************************************
@ObjectType()
export class MJContentItemTag_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ItemID: string;
        
    @Field() 
    @MaxLength(400)
    Tag: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Item?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Item Tags
//****************************************************************************
@InputType()
export class CreateMJContentItemTagInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Item Tags
//****************************************************************************
@InputType()
export class UpdateMJContentItemTagInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Item Tags
//****************************************************************************
@ObjectType()
export class RunMJContentItemTagViewResult {
    @Field(() => [MJContentItemTag_])
    Results: MJContentItemTag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItemTag_)
export class MJContentItemTagResolver extends ResolverBase {
    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Item Tags';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItemTag_, { nullable: true })
    async MJContentItemTag(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItemTag_ | null> {
        this.CheckUserReadPermissions('Content Item Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemTags] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Item Tags', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJContentItemTag_)
    async CreateMJContentItemTag(
        @Arg('input', () => CreateMJContentItemTagInput) input: CreateMJContentItemTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Item Tags', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItemTag_)
    async UpdateMJContentItemTag(
        @Arg('input', () => UpdateMJContentItemTagInput) input: UpdateMJContentItemTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Item Tags', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItemTag_)
    async DeleteMJContentItemTag(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Item Tags', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Items
//****************************************************************************
@ObjectType()
export class MJContentItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceID: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentFileTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Checksum?: string;
        
    @Field() 
    @MaxLength(4000)
    URL: string;
        
    @Field({nullable: true}) 
    Text?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContentSource?: string;
        
    @Field() 
    @MaxLength(510)
    ContentType: string;
        
    @Field() 
    @MaxLength(510)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(510)
    ContentFileType: string;
        
    @Field(() => [MJContentItemAttribute_])
    ContentItemAttributes_ContentItemIDArray: MJContentItemAttribute_[]; // Link to ContentItemAttributes
    
    @Field(() => [MJContentItemTag_])
    ContentItemTags_ItemIDArray: MJContentItemTag_[]; // Link to ContentItemTags
    
}

//****************************************************************************
// INPUT TYPE for Content Items
//****************************************************************************
@InputType()
export class CreateMJContentItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Items
//****************************************************************************
@InputType()
export class UpdateMJContentItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum?: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Items
//****************************************************************************
@ObjectType()
export class RunMJContentItemViewResult {
    @Field(() => [MJContentItem_])
    Results: MJContentItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItem_)
export class MJContentItemResolver extends ResolverBase {
    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItem_, { nullable: true })
    async MJContentItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItem_ | null> {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJContentItemAttribute_])
    async ContentItemAttributes_ContentItemIDArray(@Root() mjcontentitem_: MJContentItem_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Item Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemAttributes] WHERE [ContentItemID]='${mjcontentitem_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Item Attributes', rows);
        return result;
    }
        
    @FieldResolver(() => [MJContentItemTag_])
    async ContentItemTags_ItemIDArray(@Root() mjcontentitem_: MJContentItem_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Item Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemTags] WHERE [ItemID]='${mjcontentitem_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Item Tags', rows);
        return result;
    }
        
    @Mutation(() => MJContentItem_)
    async CreateMJContentItem(
        @Arg('input', () => CreateMJContentItemInput) input: CreateMJContentItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItem_)
    async UpdateMJContentItem(
        @Arg('input', () => UpdateMJContentItemInput) input: UpdateMJContentItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItem_)
    async DeleteMJContentItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Process Runs
//****************************************************************************
@ObjectType()
export class MJContentProcessRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    SourceID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartTime?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndTime?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Status?: string;
        
    @Field(() => Int, {nullable: true}) 
    ProcessedItems?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Source?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Process Runs
//****************************************************************************
@InputType()
export class CreateMJContentProcessRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime: Date | null;

    @Field({ nullable: true })
    EndTime: Date | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Process Runs
//****************************************************************************
@InputType()
export class UpdateMJContentProcessRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime?: Date | null;

    @Field({ nullable: true })
    EndTime?: Date | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Process Runs
//****************************************************************************
@ObjectType()
export class RunMJContentProcessRunViewResult {
    @Field(() => [MJContentProcessRun_])
    Results: MJContentProcessRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentProcessRun_)
export class MJContentProcessRunResolver extends ResolverBase {
    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Process Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentProcessRun_, { nullable: true })
    async MJContentProcessRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentProcessRun_ | null> {
        this.CheckUserReadPermissions('Content Process Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentProcessRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Process Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJContentProcessRun_)
    async CreateMJContentProcessRun(
        @Arg('input', () => CreateMJContentProcessRunInput) input: CreateMJContentProcessRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Process Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentProcessRun_)
    async UpdateMJContentProcessRun(
        @Arg('input', () => UpdateMJContentProcessRunInput) input: UpdateMJContentProcessRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Process Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentProcessRun_)
    async DeleteMJContentProcessRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Process Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Params
//****************************************************************************
@ObjectType()
export class MJContentSourceParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeParamID: string;
        
    @Field() 
    Value: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContentSource?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Source Params
//****************************************************************************
@InputType()
export class CreateMJContentSourceParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Params
//****************************************************************************
@InputType()
export class UpdateMJContentSourceParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Params
//****************************************************************************
@ObjectType()
export class RunMJContentSourceParamViewResult {
    @Field(() => [MJContentSourceParam_])
    Results: MJContentSourceParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceParam_)
export class MJContentSourceParamResolver extends ResolverBase {
    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceParam_, { nullable: true })
    async MJContentSourceParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceParam_ | null> {
        this.CheckUserReadPermissions('Content Source Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Source Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJContentSourceParam_)
    async CreateMJContentSourceParam(
        @Arg('input', () => CreateMJContentSourceParamInput) input: CreateMJContentSourceParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceParam_)
    async UpdateMJContentSourceParam(
        @Arg('input', () => UpdateMJContentSourceParamInput) input: UpdateMJContentSourceParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceParam_)
    async DeleteMJContentSourceParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Type Params
//****************************************************************************
@ObjectType()
export class MJContentSourceTypeParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Type?: string;
        
    @Field({nullable: true}) 
    DefaultValue?: string;
        
    @Field(() => Boolean) 
    IsRequired: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Content Source Type Params
//****************************************************************************
@InputType()
export class CreateMJContentSourceTypeParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Type Params
//****************************************************************************
@InputType()
export class UpdateMJContentSourceTypeParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Type Params
//****************************************************************************
@ObjectType()
export class RunMJContentSourceTypeParamViewResult {
    @Field(() => [MJContentSourceTypeParam_])
    Results: MJContentSourceTypeParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceTypeParam_)
export class MJContentSourceTypeParamResolver extends ResolverBase {
    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Type Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceTypeParam_, { nullable: true })
    async MJContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceTypeParam_ | null> {
        this.CheckUserReadPermissions('Content Source Type Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceTypeParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Type Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Source Type Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJContentSourceTypeParam_)
    async CreateMJContentSourceTypeParam(
        @Arg('input', () => CreateMJContentSourceTypeParamInput) input: CreateMJContentSourceTypeParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Type Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceTypeParam_)
    async UpdateMJContentSourceTypeParam(
        @Arg('input', () => UpdateMJContentSourceTypeParamInput) input: UpdateMJContentSourceTypeParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Type Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceTypeParam_)
    async DeleteMJContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Type Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Types
//****************************************************************************
@ObjectType()
export class MJContentSourceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJContentSource_])
    ContentSources_ContentSourceTypeIDArray: MJContentSource_[]; // Link to ContentSources
    
    @Field(() => [MJContentItem_])
    ContentItems_ContentSourceTypeIDArray: MJContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Source Types
//****************************************************************************
@InputType()
export class CreateMJContentSourceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Types
//****************************************************************************
@InputType()
export class UpdateMJContentSourceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Types
//****************************************************************************
@ObjectType()
export class RunMJContentSourceTypeViewResult {
    @Field(() => [MJContentSourceType_])
    Results: MJContentSourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceType_)
export class MJContentSourceTypeResolver extends ResolverBase {
    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceType_, { nullable: true })
    async MJContentSourceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceType_ | null> {
        this.CheckUserReadPermissions('Content Source Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Source Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async ContentSources_ContentSourceTypeIDArray(@Root() mjcontentsourcetype_: MJContentSourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentSourceTypeID]='${mjcontentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', rows);
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async ContentItems_ContentSourceTypeIDArray(@Root() mjcontentsourcetype_: MJContentSourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentSourceTypeID]='${mjcontentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', rows);
        return result;
    }
        
    @Mutation(() => MJContentSourceType_)
    async CreateMJContentSourceType(
        @Arg('input', () => CreateMJContentSourceTypeInput) input: CreateMJContentSourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceType_)
    async UpdateMJContentSourceType(
        @Arg('input', () => UpdateMJContentSourceTypeInput) input: UpdateMJContentSourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceType_)
    async DeleteMJContentSourceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Sources
//****************************************************************************
@ObjectType()
export class MJContentSource_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentFileTypeID: string;
        
    @Field() 
    @MaxLength(4000)
    URL: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ContentType: string;
        
    @Field() 
    @MaxLength(510)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(510)
    ContentFileType: string;
        
    @Field(() => [MJContentProcessRun_])
    ContentProcessRuns_SourceIDArray: MJContentProcessRun_[]; // Link to ContentProcessRuns
    
    @Field(() => [MJContentSourceParam_])
    ContentSourceParams_ContentSourceIDArray: MJContentSourceParam_[]; // Link to ContentSourceParams
    
    @Field(() => [MJContentItem_])
    ContentItems_ContentSourceIDArray: MJContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Sources
//****************************************************************************
@InputType()
export class CreateMJContentSourceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Sources
//****************************************************************************
@InputType()
export class UpdateMJContentSourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Sources
//****************************************************************************
@ObjectType()
export class RunMJContentSourceViewResult {
    @Field(() => [MJContentSource_])
    Results: MJContentSource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSource_)
export class MJContentSourceResolver extends ResolverBase {
    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Sources';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSource_, { nullable: true })
    async MJContentSource(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSource_ | null> {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Sources', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJContentProcessRun_])
    async ContentProcessRuns_SourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Process Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentProcessRuns] WHERE [SourceID]='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Process Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJContentSourceParam_])
    async ContentSourceParams_ContentSourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Source Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceParams] WHERE [ContentSourceID]='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Source Params', rows);
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async ContentItems_ContentSourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentSourceID]='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', rows);
        return result;
    }
        
    @Mutation(() => MJContentSource_)
    async CreateMJContentSource(
        @Arg('input', () => CreateMJContentSourceInput) input: CreateMJContentSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Sources', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSource_)
    async UpdateMJContentSource(
        @Arg('input', () => UpdateMJContentSourceInput) input: UpdateMJContentSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Sources', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSource_)
    async DeleteMJContentSource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Sources', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Type Attributes
//****************************************************************************
@ObjectType()
export class MJContentTypeAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Prompt: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Content Type Attributes
//****************************************************************************
@InputType()
export class CreateMJContentTypeAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Type Attributes
//****************************************************************************
@InputType()
export class UpdateMJContentTypeAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Type Attributes
//****************************************************************************
@ObjectType()
export class RunMJContentTypeAttributeViewResult {
    @Field(() => [MJContentTypeAttribute_])
    Results: MJContentTypeAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentTypeAttribute_)
export class MJContentTypeAttributeResolver extends ResolverBase {
    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Type Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentTypeAttribute_, { nullable: true })
    async MJContentTypeAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentTypeAttribute_ | null> {
        this.CheckUserReadPermissions('Content Type Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypeAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Type Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Type Attributes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJContentTypeAttribute_)
    async CreateMJContentTypeAttribute(
        @Arg('input', () => CreateMJContentTypeAttributeInput) input: CreateMJContentTypeAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Type Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentTypeAttribute_)
    async UpdateMJContentTypeAttribute(
        @Arg('input', () => UpdateMJContentTypeAttributeInput) input: UpdateMJContentTypeAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Type Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentTypeAttribute_)
    async DeleteMJContentTypeAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Type Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Types
//****************************************************************************
@ObjectType()
export class MJContentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field(() => Int) 
    MinTags: number;
        
    @Field(() => Int) 
    MaxTags: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field(() => [MJContentSource_])
    ContentSources_ContentTypeIDArray: MJContentSource_[]; // Link to ContentSources
    
    @Field(() => [MJContentItem_])
    ContentItems_ContentTypeIDArray: MJContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Types
//****************************************************************************
@InputType()
export class CreateMJContentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;
}
    

//****************************************************************************
// INPUT TYPE for Content Types
//****************************************************************************
@InputType()
export class UpdateMJContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Types
//****************************************************************************
@ObjectType()
export class RunMJContentTypeViewResult {
    @Field(() => [MJContentType_])
    Results: MJContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentType_)
export class MJContentTypeResolver extends ResolverBase {
    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentType_, { nullable: true })
    async MJContentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentType_ | null> {
        this.CheckUserReadPermissions('Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async ContentSources_ContentTypeIDArray(@Root() mjcontenttype_: MJContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentTypeID]='${mjcontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', rows);
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async ContentItems_ContentTypeIDArray(@Root() mjcontenttype_: MJContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentTypeID]='${mjcontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', rows);
        return result;
    }
        
    @Mutation(() => MJContentType_)
    async CreateMJContentType(
        @Arg('input', () => CreateMJContentTypeInput) input: CreateMJContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentType_)
    async UpdateMJContentType(
        @Arg('input', () => UpdateMJContentTypeInput) input: UpdateMJContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentType_)
    async DeleteMJContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Conversation Details
//****************************************************************************
@ObjectType()
export class MJConversationDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ConversationID: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ExternalID?: string;
        
    @Field() 
    @MaxLength(40)
    Role: string;
        
    @Field() 
    Message: string;
        
    @Field({nullable: true}) 
    Error?: string;
        
    @Field(() => Boolean) 
    HiddenToUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `This column is used to capture user feedback as a rating scale. The scale ranges from 1 to 10, where 1 might represent thumbs down, and 10 might represent thumbs up or the highest rating in a star-based scale.`}) 
    UserRating?: number;
        
    @Field({nullable: true, description: `This column is used to store user text feedback about a given AI response, describing what they liked or disliked.`}) 
    UserFeedback?: string;
        
    @Field({nullable: true, description: `This column stores human or AI-generated reflections on how to improve future responses based on the user feedback and the AI output generated for prior messages in the conversation.`}) 
    ReflectionInsights?: string;
        
    @Field({nullable: true, description: `This column optionally stores a summary of the entire conversation leading up to this particular conversation detail record. It is used in long-running conversations to optimize performance by summarizing earlier parts.`}) 
    SummaryOfEarlierConversation?: string;
        
    @Field({nullable: true, description: `This field, when populated, overrides the UserID at the Conversation level to specify a different user created the message.`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field(() => [MJReport_])
    Reports_ConversationDetailIDArray: MJReport_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Conversation Details
//****************************************************************************
@InputType()
export class CreateMJConversationDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating: number | null;

    @Field({ nullable: true })
    UserFeedback: string | null;

    @Field({ nullable: true })
    ReflectionInsights: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation: string | null;

    @Field({ nullable: true })
    UserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Conversation Details
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error?: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating?: number | null;

    @Field({ nullable: true })
    UserFeedback?: string | null;

    @Field({ nullable: true })
    ReflectionInsights?: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Conversation Details
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailViewResult {
    @Field(() => [MJConversationDetail_])
    Results: MJConversationDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetail_)
export class MJConversationDetailResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Conversation Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetail_, { nullable: true })
    async MJConversationDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetail_ | null> {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Conversation Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @Mutation(() => MJConversationDetail_)
    async CreateMJConversationDetail(
        @Arg('input', () => CreateMJConversationDetailInput) input: CreateMJConversationDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Conversation Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetail_)
    async UpdateMJConversationDetail(
        @Arg('input', () => UpdateMJConversationDetailInput) input: UpdateMJConversationDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Conversation Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetail_)
    async DeleteMJConversationDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Conversation Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Conversations
//****************************************************************************
@ObjectType()
export class MJConversation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    ExternalID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Boolean) 
    IsArchived: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    LinkedRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DataContextID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LinkedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DataContext?: string;
        
    @Field(() => [MJConversationDetail_])
    ConversationDetails_ConversationIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
    @Field(() => [MJReport_])
    Reports_ConversationIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJConversationArtifact_])
    MJ_ConversationArtifacts_ConversationIDArray: MJConversationArtifact_[]; // Link to MJ_ConversationArtifacts
    
}

//****************************************************************************
// INPUT TYPE for Conversations
//****************************************************************************
@InputType()
export class CreateMJConversationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Conversations
//****************************************************************************
@InputType()
export class UpdateMJConversationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Conversations
//****************************************************************************
@ObjectType()
export class RunMJConversationViewResult {
    @Field(() => [MJConversation_])
    Results: MJConversation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversation_)
export class MJConversationResolver extends ResolverBase {
    @Query(() => RunMJConversationViewResult)
    async RunMJConversationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationViewResult)
    async RunMJConversationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationViewResult)
    async RunMJConversationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Conversations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversation_, { nullable: true })
    async MJConversation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversation_ | null> {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Conversations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [MJConversationArtifact_])
    async MJ_ConversationArtifacts_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows);
        return result;
    }
        
    @Mutation(() => MJConversation_)
    async CreateMJConversation(
        @Arg('input', () => CreateMJConversationInput) input: CreateMJConversationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Conversations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversation_)
    async UpdateMJConversation(
        @Arg('input', () => UpdateMJConversationInput) input: UpdateMJConversationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Conversations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversation_)
    async DeleteMJConversation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Conversations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dashboard Categories
//****************************************************************************
@ObjectType()
export class MJDashboardCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJDashboard_])
    Dashboards_CategoryIDArray: MJDashboard_[]; // Link to Dashboards
    
    @Field(() => [MJDashboardCategory_])
    DashboardCategories_ParentIDArray: MJDashboardCategory_[]; // Link to DashboardCategories
    
}

//****************************************************************************
// INPUT TYPE for Dashboard Categories
//****************************************************************************
@InputType()
export class CreateMJDashboardCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Dashboard Categories
//****************************************************************************
@InputType()
export class UpdateMJDashboardCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dashboard Categories
//****************************************************************************
@ObjectType()
export class RunMJDashboardCategoryViewResult {
    @Field(() => [MJDashboardCategory_])
    Results: MJDashboardCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardCategory_)
export class MJDashboardCategoryResolver extends ResolverBase {
    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dashboard Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardCategory_, { nullable: true })
    async MJDashboardCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardCategory_ | null> {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Dashboard Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJDashboard_])
    async Dashboards_CategoryIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [CategoryID]='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboards', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategory_])
    async DashboardCategories_ParentIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [ParentID]='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboard Categories', rows);
        return result;
    }
        
    @Mutation(() => MJDashboardCategory_)
    async CreateMJDashboardCategory(
        @Arg('input', () => CreateMJDashboardCategoryInput) input: CreateMJDashboardCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Dashboard Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardCategory_)
    async UpdateMJDashboardCategory(
        @Arg('input', () => UpdateMJDashboardCategoryInput) input: UpdateMJDashboardCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Dashboard Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardCategory_)
    async DeleteMJDashboardCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dashboard Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dashboards
//****************************************************************************
@ObjectType({ description: `Dashboards are used to group resources into a single display pane for an end-user` })
export class MJDashboard_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    UIConfigDetails: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
}

//****************************************************************************
// INPUT TYPE for Dashboards
//****************************************************************************
@InputType()
export class CreateMJDashboardInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;
}
    

//****************************************************************************
// INPUT TYPE for Dashboards
//****************************************************************************
@InputType()
export class UpdateMJDashboardInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dashboards
//****************************************************************************
@ObjectType()
export class RunMJDashboardViewResult {
    @Field(() => [MJDashboard_])
    Results: MJDashboard_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboard_)
export class MJDashboardResolver extends ResolverBase {
    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dashboards';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboard_, { nullable: true })
    async MJDashboard(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboard_ | null> {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Dashboards', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJDashboard_)
    async CreateMJDashboard(
        @Arg('input', () => CreateMJDashboardInput) input: CreateMJDashboardInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Dashboards', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboard_)
    async UpdateMJDashboard(
        @Arg('input', () => UpdateMJDashboardInput) input: UpdateMJDashboardInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Dashboards', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboard_)
    async DeleteMJDashboard(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dashboards', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Data Context Items
//****************************************************************************
@ObjectType({ description: `Data Context Items store information about each item within a Data Context. Each item stores a link to a view, query, or raw sql statement and can optionally cache the JSON representing the last run of that data object as well.` })
export class MJDataContextItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DataContextID: string;
        
    @Field({description: `The type of the item, either "view", "query", "full_entity", "single_record", or "sql"`}) 
    @MaxLength(100)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    QueryID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `The Primary Key value for the record, only used when Type='single_record'`}) 
    @MaxLength(900)
    RecordID?: string;
        
    @Field({nullable: true, description: `Only used when Type=sql`}) 
    SQL?: string;
        
    @Field({nullable: true, description: `Optionally used to cache results of an item. This can be used for performance optimization, and also for having snapshots of data for historical comparisons.`}) 
    DataJSON?: string;
        
    @Field({nullable: true, description: `If DataJSON is populated, this field will show the date the the data was captured`}) 
    @MaxLength(8)
    LastRefreshedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    DataContext: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    View?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Query?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Data Context Items
//****************************************************************************
@InputType()
export class CreateMJDataContextItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID: string | null;

    @Field({ nullable: true })
    QueryID: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    DataJSON: string | null;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Data Context Items
//****************************************************************************
@InputType()
export class UpdateMJDataContextItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID?: string | null;

    @Field({ nullable: true })
    QueryID?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    DataJSON?: string | null;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Data Context Items
//****************************************************************************
@ObjectType()
export class RunMJDataContextItemViewResult {
    @Field(() => [MJDataContextItem_])
    Results: MJDataContextItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataContextItem_)
export class MJDataContextItemResolver extends ResolverBase {
    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Data Context Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataContextItem_, { nullable: true })
    async MJDataContextItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataContextItem_ | null> {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Data Context Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJDataContextItem_)
    async CreateMJDataContextItem(
        @Arg('input', () => CreateMJDataContextItemInput) input: CreateMJDataContextItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Data Context Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDataContextItem_)
    async UpdateMJDataContextItem(
        @Arg('input', () => UpdateMJDataContextItemInput) input: UpdateMJDataContextItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Data Context Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDataContextItem_)
    async DeleteMJDataContextItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Data Context Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Data Contexts
//****************************************************************************
@ObjectType({ description: `Data Contexts are a primitive within the MemberJunction architecture. They store information about data contexts which are groups of data including views, queries, or raw SQL statements. Data contexts can be used in conversations, reports and more.` })
export class MJDataContext_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    LastRefreshedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJDataContextItem_])
    DataContextItems_DataContextIDArray: MJDataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [MJReport_])
    Reports_DataContextIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJConversation_])
    Conversations_DataContextIDArray: MJConversation_[]; // Link to Conversations
    
}

//****************************************************************************
// INPUT TYPE for Data Contexts
//****************************************************************************
@InputType()
export class CreateMJDataContextInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for Data Contexts
//****************************************************************************
@InputType()
export class UpdateMJDataContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Data Contexts
//****************************************************************************
@ObjectType()
export class RunMJDataContextViewResult {
    @Field(() => [MJDataContext_])
    Results: MJDataContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataContext_)
export class MJDataContextResolver extends ResolverBase {
    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Data Contexts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataContext_, { nullable: true })
    async MJDataContext(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataContext_ | null> {
        this.CheckUserReadPermissions('Data Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContexts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Data Contexts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJDataContextItem_])
    async DataContextItems_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [DataContextID]='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [DataContextID]='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [DataContextID]='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', rows);
        return result;
    }
        
    @Mutation(() => MJDataContext_)
    async CreateMJDataContext(
        @Arg('input', () => CreateMJDataContextInput) input: CreateMJDataContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Data Contexts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDataContext_)
    async UpdateMJDataContext(
        @Arg('input', () => UpdateMJDataContextInput) input: UpdateMJDataContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Data Contexts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDataContext_)
    async DeleteMJDataContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Data Contexts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dataset Items
//****************************************************************************
@ObjectType({ description: `A single item in a Dataset and can be sourced from multiple methods.` })
export class MJDatasetItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Code: string;
        
    @Field() 
    @MaxLength(16)
    DatasetID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({nullable: true}) 
    WhereClause?: string;
        
    @Field() 
    @MaxLength(200)
    DateFieldToCheck: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional column to store a comma-delimited list of columns for the DatasetItem`}) 
    Columns?: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    Dataset: string;
        
}
//****************************************************************************
// RESOLVER for Dataset Items
//****************************************************************************
@ObjectType()
export class RunMJDatasetItemViewResult {
    @Field(() => [MJDatasetItem_])
    Results: MJDatasetItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDatasetItem_)
export class MJDatasetItemResolver extends ResolverBase {
    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dataset Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDatasetItem_, { nullable: true })
    async MJDatasetItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDatasetItem_ | null> {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Dataset Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
}

//****************************************************************************
// ENTITY CLASS for Datasets
//****************************************************************************
@ObjectType({ description: `Cacheable sets of data that can span one or more items` })
export class MJDataset_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJDatasetItem_])
    DatasetItems_DatasetNameArray: MJDatasetItem_[]; // Link to DatasetItems
    
}
//****************************************************************************
// RESOLVER for Datasets
//****************************************************************************
@ObjectType()
export class RunMJDatasetViewResult {
    @Field(() => [MJDataset_])
    Results: MJDataset_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataset_)
export class MJDatasetResolver extends ResolverBase {
    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Datasets';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataset_, { nullable: true })
    async MJDataset(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataset_ | null> {
        this.CheckUserReadPermissions('Datasets', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasets] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Datasets', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Datasets', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJDatasetItem_])
    async DatasetItems_DatasetNameArray(@Root() mjdataset_: MJDataset_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [DatasetName]='${mjdataset_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dataset Items', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Duplicate Run Detail Matches
//****************************************************************************
@ObjectType()
export class MJDuplicateRunDetailMatch_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DuplicateRunDetailID: string;
        
    @Field({description: `Either Vector or SP`}) 
    @MaxLength(40)
    MatchSource: string;
        
    @Field() 
    @MaxLength(1000)
    MatchRecordID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 designating the computed probability of a match`}) 
    MatchProbability: number;
        
    @Field() 
    @MaxLength(8)
    MatchedAt: Date;
        
    @Field() 
    @MaxLength(40)
    Action: string;
        
    @Field() 
    @MaxLength(40)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RecordMergeLogID?: string;
        
    @Field() 
    @MaxLength(40)
    MergeStatus: string;
        
    @Field() 
    @MaxLength(8)
    MergedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunDetailMatchInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunDetailMatchInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Run Detail Matches
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunDetailMatchViewResult {
    @Field(() => [MJDuplicateRunDetailMatch_])
    Results: MJDuplicateRunDetailMatch_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRunDetailMatch_)
export class MJDuplicateRunDetailMatchResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Run Detail Matches';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRunDetailMatch_, { nullable: true })
    async MJDuplicateRunDetailMatch(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRunDetailMatch_ | null> {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJDuplicateRunDetailMatch_)
    async CreateMJDuplicateRunDetailMatch(
        @Arg('input', () => CreateMJDuplicateRunDetailMatchInput) input: CreateMJDuplicateRunDetailMatchInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Run Detail Matches', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRunDetailMatch_)
    async UpdateMJDuplicateRunDetailMatch(
        @Arg('input', () => UpdateMJDuplicateRunDetailMatchInput) input: UpdateMJDuplicateRunDetailMatchInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Run Detail Matches', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Run Details
//****************************************************************************
@ObjectType()
export class MJDuplicateRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DuplicateRunID: string;
        
    @Field() 
    @MaxLength(1000)
    RecordID: string;
        
    @Field() 
    @MaxLength(40)
    MatchStatus: string;
        
    @Field({nullable: true, description: `If MatchStatus=Skipped, this field can be used to store the reason why the record was skipped`}) 
    SkippedReason?: string;
        
    @Field({nullable: true, description: `If MatchStatus='Error' this field can be used to track the error from that phase of the process for logging/diagnostics.`}) 
    MatchErrorMessage?: string;
        
    @Field() 
    @MaxLength(40)
    MergeStatus: string;
        
    @Field({nullable: true}) 
    MergeErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJDuplicateRunDetailMatch_])
    DuplicateRunDetailMatches_DuplicateRunDetailIDArray: MJDuplicateRunDetailMatch_[]; // Link to DuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for Duplicate Run Details
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason: string | null;

    @Field({ nullable: true })
    MatchErrorMessage: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Run Details
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason?: string | null;

    @Field({ nullable: true })
    MatchErrorMessage?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Run Details
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunDetailViewResult {
    @Field(() => [MJDuplicateRunDetail_])
    Results: MJDuplicateRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRunDetail_)
export class MJDuplicateRunDetailResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRunDetail_, { nullable: true })
    async MJDuplicateRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRunDetail_ | null> {
        this.CheckUserReadPermissions('Duplicate Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Duplicate Run Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJDuplicateRunDetailMatch_])
    async DuplicateRunDetailMatches_DuplicateRunDetailIDArray(@Root() mjduplicaterundetail_: MJDuplicateRunDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [DuplicateRunDetailID]='${mjduplicaterundetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows);
        return result;
    }
        
    @Mutation(() => MJDuplicateRunDetail_)
    async CreateMJDuplicateRunDetail(
        @Arg('input', () => CreateMJDuplicateRunDetailInput) input: CreateMJDuplicateRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRunDetail_)
    async UpdateMJDuplicateRunDetail(
        @Arg('input', () => UpdateMJDuplicateRunDetailInput) input: UpdateMJDuplicateRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Run Details', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Runs
//****************************************************************************
@ObjectType()
export class MJDuplicateRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    StartedByUserID: string;
        
    @Field() 
    @MaxLength(16)
    SourceListID: string;
        
    @Field() 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field() 
    @MaxLength(40)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    ApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ApprovedByUserID?: string;
        
    @Field() 
    @MaxLength(40)
    ProcessingStatus: string;
        
    @Field({nullable: true}) 
    ProcessingErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    StartedByUser: string;
        
    @Field() 
    @MaxLength(200)
    SourceList: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ApprovedByUser?: string;
        
    @Field(() => [MJDuplicateRunDetail_])
    DuplicateRunDetails_DuplicateRunIDArray: MJDuplicateRunDetail_[]; // Link to DuplicateRunDetails
    
}

//****************************************************************************
// INPUT TYPE for Duplicate Runs
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments: string | null;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Runs
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments?: string | null;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Runs
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunViewResult {
    @Field(() => [MJDuplicateRun_])
    Results: MJDuplicateRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRun_)
export class MJDuplicateRunResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRun_, { nullable: true })
    async MJDuplicateRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRun_ | null> {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Duplicate Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJDuplicateRunDetail_])
    async DuplicateRunDetails_DuplicateRunIDArray(@Root() mjduplicaterun_: MJDuplicateRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetails] WHERE [DuplicateRunID]='${mjduplicaterun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Details', rows);
        return result;
    }
        
    @Mutation(() => MJDuplicateRun_)
    async CreateMJDuplicateRun(
        @Arg('input', () => CreateMJDuplicateRunInput) input: CreateMJDuplicateRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRun_)
    async UpdateMJDuplicateRun(
        @Arg('input', () => UpdateMJDuplicateRunInput) input: UpdateMJDuplicateRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Runs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Company Integrations
//****************************************************************************
@ObjectType()
export class MJEmployeeCompanyIntegration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(1500)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Employee Company Integrations
//****************************************************************************
@InputType()
export class UpdateMJEmployeeCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Company Integrations
//****************************************************************************
@ObjectType()
export class RunMJEmployeeCompanyIntegrationViewResult {
    @Field(() => [MJEmployeeCompanyIntegration_])
    Results: MJEmployeeCompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeCompanyIntegration_)
export class MJEmployeeCompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Company Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeCompanyIntegration_, { nullable: true })
    async MJEmployeeCompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeCompanyIntegration_ | null> {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Employee Company Integrations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEmployeeCompanyIntegration_)
    async UpdateMJEmployeeCompanyIntegration(
        @Arg('input', () => UpdateMJEmployeeCompanyIntegrationInput) input: UpdateMJEmployeeCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Company Integrations', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Roles
//****************************************************************************
@ObjectType()
export class MJEmployeeRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Roles
//****************************************************************************
@InputType()
export class UpdateMJEmployeeRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Roles
//****************************************************************************
@ObjectType()
export class RunMJEmployeeRoleViewResult {
    @Field(() => [MJEmployeeRole_])
    Results: MJEmployeeRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeRole_)
export class MJEmployeeRoleResolver extends ResolverBase {
    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeRole_, { nullable: true })
    async MJEmployeeRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeRole_ | null> {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Employee Roles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEmployeeRole_)
    async UpdateMJEmployeeRole(
        @Arg('input', () => UpdateMJEmployeeRoleInput) input: UpdateMJEmployeeRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployeeRole_)
    async DeleteMJEmployeeRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Skills
//****************************************************************************
@ObjectType()
export class MJEmployeeSkill_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    SkillID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Skill: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Skills
//****************************************************************************
@InputType()
export class UpdateMJEmployeeSkillInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    SkillID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Skills
//****************************************************************************
@ObjectType()
export class RunMJEmployeeSkillViewResult {
    @Field(() => [MJEmployeeSkill_])
    Results: MJEmployeeSkill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeSkill_)
export class MJEmployeeSkillResolver extends ResolverBase {
    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Skills';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeSkill_, { nullable: true })
    async MJEmployeeSkill(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeSkill_ | null> {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Employee Skills', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEmployeeSkill_)
    async UpdateMJEmployeeSkill(
        @Arg('input', () => UpdateMJEmployeeSkillInput) input: UpdateMJEmployeeSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Skills', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployeeSkill_)
    async DeleteMJEmployeeSkill(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Skills', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employees
//****************************************************************************
@ObjectType({ description: `A list of employees across all units of your organization` })
export class MJEmployee_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    BCMID: string;
        
    @Field() 
    @MaxLength(60)
    FirstName: string;
        
    @Field() 
    @MaxLength(100)
    LastName: string;
        
    @Field() 
    @MaxLength(16)
    CompanyID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SupervisorID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Title?: string;
        
    @Field() 
    @MaxLength(200)
    Email: string;
        
    @Field({nullable: true}) 
    @MaxLength(40)
    Phone?: string;
        
    @Field(() => Boolean) 
    Active: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    Supervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(60)
    SupervisorFirstName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SupervisorLastName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SupervisorEmail?: string;
        
    @Field(() => [MJEmployee_])
    Employees_SupervisorIDArray: MJEmployee_[]; // Link to Employees
    
    @Field(() => [MJEmployeeCompanyIntegration_])
    EmployeeCompanyIntegrations_EmployeeIDArray: MJEmployeeCompanyIntegration_[]; // Link to EmployeeCompanyIntegrations
    
    @Field(() => [MJEmployeeRole_])
    EmployeeRoles_EmployeeIDArray: MJEmployeeRole_[]; // Link to EmployeeRoles
    
    @Field(() => [MJEmployeeSkill_])
    EmployeeSkills_EmployeeIDArray: MJEmployeeSkill_[]; // Link to EmployeeSkills
    
    @Field(() => [MJUser_])
    Users_EmployeeIDArray: MJUser_[]; // Link to Users
    
}

//****************************************************************************
// INPUT TYPE for Employees
//****************************************************************************
@InputType()
export class CreateMJEmployeeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Employees
//****************************************************************************
@InputType()
export class UpdateMJEmployeeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employees
//****************************************************************************
@ObjectType()
export class RunMJEmployeeViewResult {
    @Field(() => [MJEmployee_])
    Results: MJEmployee_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployee_)
export class MJEmployeeResolver extends ResolverBase {
    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employees';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployee_, { nullable: true })
    async MJEmployee(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployee_ | null> {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Employees', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJEmployee_])
    async AllEmployees(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees]` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', rows);
        return result;
    }
    
    @FieldResolver(() => [MJEmployee_])
    async Employees_SupervisorIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [SupervisorID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeCompanyIntegration_])
    async EmployeeCompanyIntegrations_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [EmployeeID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Company Integrations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeRole_])
    async EmployeeRoles_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [EmployeeID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeSkill_])
    async EmployeeSkills_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [EmployeeID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Skills', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUser_])
    async Users_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [EmployeeID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Users', rows);
        return result;
    }
        
    @Mutation(() => MJEmployee_)
    async CreateMJEmployee(
        @Arg('input', () => CreateMJEmployeeInput) input: CreateMJEmployeeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employees', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployee_)
    async UpdateMJEmployee(
        @Arg('input', () => UpdateMJEmployeeInput) input: UpdateMJEmployeeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employees', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployee_)
    async DeleteMJEmployee(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employees', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entities
//****************************************************************************
@ObjectType({ description: `Catalog of all entities across all schemas` })
export class MJEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    NameSuffix?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the underlying view (first choice) or table (second choice), the Description column in the entity definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field() 
    @MaxLength(510)
    BaseTable: string;
        
    @Field() 
    @MaxLength(510)
    BaseView: string;
        
    @Field(() => Boolean, {description: `When set to 0, CodeGen no longer generates a base view for the entity.`}) 
    BaseViewGenerated: boolean;
        
    @Field() 
    @MaxLength(510)
    SchemaName: string;
        
    @Field(() => Boolean) 
    VirtualEntity: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, changes made via the MemberJunction architecture will result in tracking records being created in the RecordChange table. In addition, when turned on CodeGen will ensure that your table has two fields: __mj_CreatedAt and __mj_UpdatedAt which are special fields used in conjunction with the RecordChange table to track changes to rows in your entity.`}) 
    TrackRecordChanges: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, accessing a record by an end-user will result in an Audit Log record being created`}) 
    AuditRecordAccess: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, users running a view against this entity will result in an Audit Log record being created.`}) 
    AuditViewRuns: boolean;
        
    @Field(() => Boolean, {description: `If set to 0, the entity will not be available at all in the GraphQL API or the object model.`}) 
    IncludeInAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, a GraphQL query will be enabled that allows access to all rows in the entity.`}) 
    AllowAllRowsAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if updates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if creates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowCreateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if deletes are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowDeleteAPI: boolean;
        
    @Field(() => Boolean, {description: `Set to 1 if a custom resolver has been created for the entity.`}) 
    CustomResolverAPI: boolean;
        
    @Field(() => Boolean, {description: `Enabling this bit will result in search being possible at the API and UI layers`}) 
    AllowUserSearchAPI: boolean;
        
    @Field(() => Boolean) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FullTextCatalog?: string;
        
    @Field(() => Boolean) 
    FullTextCatalogGenerated: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FullTextIndex?: string;
        
    @Field(() => Boolean) 
    FullTextIndexGenerated: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FullTextSearchFunction?: string;
        
    @Field(() => Boolean) 
    FullTextSearchFunctionGenerated: boolean;
        
    @Field(() => Int, {nullable: true}) 
    UserViewMaxRows?: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    spCreate?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    spUpdate?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    spDelete?: string;
        
    @Field(() => Boolean) 
    spCreateGenerated: boolean;
        
    @Field(() => Boolean) 
    spUpdateGenerated: boolean;
        
    @Field(() => Boolean) 
    spDeleteGenerated: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, the deleted spDelete will pre-process deletion to related entities that have 1:M cardinality with this entity. This does not have effect if spDeleteGenerated = 0`}) 
    CascadeDeletes: boolean;
        
    @Field({description: `Hard deletes physically remove rows from the underlying BaseTable. Soft deletes do not remove rows but instead mark the row as deleted by using the special field __mj_DeletedAt which will automatically be added to the entity's basetable by the CodeGen tool.`}) 
    @MaxLength(20)
    DeleteType: string;
        
    @Field(() => Boolean, {description: `This field must be turned on in order to enable merging of records for the entity. For AllowRecordMerge to be turned on, AllowDeleteAPI must be set to 1, and DeleteType must be set to Soft`}) 
    AllowRecordMerge: boolean;
        
    @Field({nullable: true, description: `When specified, this stored procedure is used to find matching records in this particular entity. The convention is to pass in the primary key(s) columns for the given entity to the procedure and the return will be zero to many rows where there is a column for each primary key field(s) and a ProbabilityScore (numeric(1,12)) column that has a 0 to 1 value of the probability of a match.`}) 
    @MaxLength(510)
    spMatch?: string;
        
    @Field({description: `When another entity links to this entity with a foreign key, this is the default component type that will be used in the UI. CodeGen will populate the RelatedEntityDisplayType column in the Entity Fields entity with whatever is provided here whenever a new foreign key is detected by CodeGen. The selection can be overridden on a per-foreign-key basis in each row of the Entity Fields entity.`}) 
    @MaxLength(40)
    RelationshipDefaultDisplayType: string;
        
    @Field(() => Boolean) 
    UserFormGenerated: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    EntityObjectSubclassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    EntityObjectSubclassImport?: string;
        
    @Field({nullable: true, description: `Used to specify a field within the entity that in turn contains the field name that will be used for record-level communication preferences. For example in a hypothetical entity called Contacts, say there is a field called PreferredComm and that field had possible values of Email1, SMS, and Phone, and those value in turn corresponded to field names in the entity. Each record in the Contacts entity could have a specific preference for which field would be used for communication. The MJ Communication Framework will use this information when available, as a priority ahead of the data in the Entity Communication Fields entity which is entity-level and not record-level.`}) 
    @MaxLength(510)
    PreferredCommunicationField?: string;
        
    @Field({nullable: true, description: `Optional, specify an icon (CSS Class) for each entity for display in the UI`}) 
    @MaxLength(1000)
    Icon?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    CodeName?: string;
        
    @Field({nullable: true, description: `Optional, comma-delimited string indicating the default scope for entity visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for simple defaults for filtering entity visibility, not security enforcement.`}) 
    @MaxLength(200)
    ScopeDefault?: string;
        
    @Field({nullable: true}) 
    ClassName?: string;
        
    @Field({description: `Determines how entity rows should be packaged for external use. Options include None, Sample, and All. Defaults to None.`}) 
    @MaxLength(40)
    RowsToPackWithSchema: string;
        
    @Field({nullable: true}) 
    BaseTableCodeName?: string;
        
    @Field({description: `Defines the sampling method for row packing when RowsToPackWithSchema is set to Sample. Options include random, top n, and bottom n. Defaults to random.`}) 
    @MaxLength(40)
    RowsToPackSampleMethod: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentEntity?: string;
        
    @Field(() => Int, {description: `The number of rows to pack when RowsToPackWithSchema is set to Sample, based on the designated sampling method. Defaults to 0.`}) 
    RowsToPackSampleCount: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentBaseTable?: string;
        
    @Field({nullable: true, description: `An optional ORDER BY clause for row packing when RowsToPackWithSchema is set to Sample. Allows custom ordering for selected entity data when using top n and bottom n.`}) 
    RowsToPackSampleOrder?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentBaseView?: string;
        
    @Field(() => [MJEntityPermission_])
    EntityPermissions_EntityIDArray: MJEntityPermission_[]; // Link to EntityPermissions
    
    @Field(() => [MJEntityRelationship_])
    EntityRelationships_EntityIDArray: MJEntityRelationship_[]; // Link to EntityRelationships
    
    @Field(() => [MJEntityField_])
    EntityFields_EntityIDArray: MJEntityField_[]; // Link to EntityFields
    
    @Field(() => [MJEntityAIAction_])
    EntityAIActions_EntityIDArray: MJEntityAIAction_[]; // Link to EntityAIActions
    
    @Field(() => [MJUserRecordLog_])
    UserRecordLogs_EntityIDArray: MJUserRecordLog_[]; // Link to UserRecordLogs
    
    @Field(() => [MJIntegrationURLFormat_])
    IntegrationURLFormats_EntityIDArray: MJIntegrationURLFormat_[]; // Link to IntegrationURLFormats
    
    @Field(() => [MJEntity_])
    Entities_ParentIDArray: MJEntity_[]; // Link to Entities
    
    @Field(() => [MJUserFavorite_])
    UserFavorites_EntityIDArray: MJUserFavorite_[]; // Link to UserFavorites
    
    @Field(() => [MJCompanyIntegrationRunDetail_])
    CompanyIntegrationRunDetails_EntityIDArray: MJCompanyIntegrationRunDetail_[]; // Link to CompanyIntegrationRunDetails
    
    @Field(() => [MJApplicationEntity_])
    ApplicationEntities_EntityIDArray: MJApplicationEntity_[]; // Link to ApplicationEntities
    
    @Field(() => [MJUserApplicationEntity_])
    UserApplicationEntities_EntityIDArray: MJUserApplicationEntity_[]; // Link to UserApplicationEntities
    
    @Field(() => [MJList_])
    Lists_EntityIDArray: MJList_[]; // Link to Lists
    
    @Field(() => [MJUserView_])
    UserViews_EntityIDArray: MJUserView_[]; // Link to UserViews
    
    @Field(() => [MJRecordChange_])
    RecordChanges_EntityIDArray: MJRecordChange_[]; // Link to RecordChanges
    
    @Field(() => [MJAuditLog_])
    AuditLogs_EntityIDArray: MJAuditLog_[]; // Link to AuditLogs
    
    @Field(() => [MJResourceType_])
    ResourceTypes_EntityIDArray: MJResourceType_[]; // Link to ResourceTypes
    
    @Field(() => [MJTaggedItem_])
    TaggedItems_EntityIDArray: MJTaggedItem_[]; // Link to TaggedItems
    
    @Field(() => [MJDatasetItem_])
    DatasetItems_EntityIDArray: MJDatasetItem_[]; // Link to DatasetItems
    
    @Field(() => [MJCompanyIntegrationRecordMap_])
    CompanyIntegrationRecordMaps_EntityIDArray: MJCompanyIntegrationRecordMap_[]; // Link to CompanyIntegrationRecordMaps
    
    @Field(() => [MJRecordMergeLog_])
    RecordMergeLogs_EntityIDArray: MJRecordMergeLog_[]; // Link to RecordMergeLogs
    
    @Field(() => [MJQueryField_])
    QueryFields_SourceEntityIDArray: MJQueryField_[]; // Link to QueryFields
    
    @Field(() => [MJConversation_])
    Conversations_LinkedEntityIDArray: MJConversation_[]; // Link to Conversations
    
    @Field(() => [MJEntityDocument_])
    EntityDocuments_EntityIDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [MJDataContextItem_])
    DataContextItems_EntityIDArray: MJDataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [MJUser_])
    Users_LinkedEntityIDArray: MJUser_[]; // Link to Users
    
    @Field(() => [MJEntityRecordDocument_])
    EntityRecordDocuments_EntityIDArray: MJEntityRecordDocument_[]; // Link to EntityRecordDocuments
    
    @Field(() => [MJFileEntityRecordLink_])
    FileEntityRecordLinks_EntityIDArray: MJFileEntityRecordLink_[]; // Link to FileEntityRecordLinks
    
    @Field(() => [MJUserViewCategory_])
    UserViewCategories_EntityIDArray: MJUserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [MJEntitySetting_])
    EntitySettings_EntityIDArray: MJEntitySetting_[]; // Link to EntitySettings
    
    @Field(() => [MJDuplicateRun_])
    DuplicateRuns_EntityIDArray: MJDuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [MJEntityAction_])
    EntityActions_EntityIDArray: MJEntityAction_[]; // Link to EntityActions
    
    @Field(() => [MJTemplateParam_])
    TemplateParams_EntityIDArray: MJTemplateParam_[]; // Link to TemplateParams
    
    @Field(() => [MJRecommendation_])
    Recommendations_SourceEntityIDArray: MJRecommendation_[]; // Link to Recommendations
    
    @Field(() => [MJRecommendationItem_])
    RecommendationItems_DestinationEntityIDArray: MJRecommendationItem_[]; // Link to RecommendationItems
    
    @Field(() => [MJEntityCommunicationMessageType_])
    EntityCommunicationMessageTypes_EntityIDArray: MJEntityCommunicationMessageType_[]; // Link to EntityCommunicationMessageTypes
    
    @Field(() => [MJQueryEntity_])
    QueryEntities_EntityIDArray: MJQueryEntity_[]; // Link to QueryEntities
    
    @Field(() => [MJGeneratedCode_])
    GeneratedCodes_LinkedEntityIDArray: MJGeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for Entities
//****************************************************************************
@InputType()
export class CreateMJEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate: string | null;

    @Field({ nullable: true })
    spUpdate: string | null;

    @Field({ nullable: true })
    spDelete: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entities
//****************************************************************************
@InputType()
export class UpdateMJEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate?: string | null;

    @Field({ nullable: true })
    spUpdate?: string | null;

    @Field({ nullable: true })
    spDelete?: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch?: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName?: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport?: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entities
//****************************************************************************
@ObjectType()
export class RunMJEntityViewResult {
    @Field(() => [MJEntity_])
    Results: MJEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntity_)
export class MJEntityResolverBase extends ResolverBase {
    @Query(() => RunMJEntityViewResult)
    async RunMJEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityViewResult)
    async RunMJEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityViewResult)
    async RunMJEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntity_, { nullable: true })
    async MJEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntity_ | null> {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entities', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJEntity_])
    async AllEntities(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities]` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entities', rows);
        return result;
    }
    
    @FieldResolver(() => [MJEntityPermission_])
    async EntityPermissions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityRelationship_])
    async EntityRelationships_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityField_])
    async EntityFields_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Fields', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async EntityAIActions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserRecordLog_])
    async UserRecordLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Record Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJIntegrationURLFormat_])
    async IntegrationURLFormats_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntity_])
    async Entities_ParentIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities] WHERE [ParentID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserFavorite_])
    async UserFavorites_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Favorites', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRunDetail_])
    async CompanyIntegrationRunDetails_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run Details', rows);
        return result;
    }
        
    @FieldResolver(() => [MJApplicationEntity_])
    async ApplicationEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Application Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserApplicationEntity_])
    async UserApplicationEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Application Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async Lists_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async UserViews_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async RecordChanges_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async AuditLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJResourceType_])
    async ResourceTypes_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceTypes] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Types', rows);
        return result;
    }
        
    @FieldResolver(() => [MJTaggedItem_])
    async TaggedItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Tagged Items', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDatasetItem_])
    async DatasetItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dataset Items', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRecordMap_])
    async CompanyIntegrationRecordMaps_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Record Maps', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecordMergeLog_])
    async RecordMergeLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJQueryField_])
    async QueryFields_SourceEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [SourceEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Fields', rows);
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [LinkedEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async DataContextItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUser_])
    async Users_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [LinkedEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Users', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityRecordDocument_])
    async EntityRecordDocuments_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows);
        return result;
    }
        
    @FieldResolver(() => [MJFileEntityRecordLink_])
    async FileEntityRecordLinks_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('File Entity Record Links', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserViewCategory_])
    async UserViewCategories_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntitySetting_])
    async EntitySettings_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntitySettings] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Settings', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async DuplicateRuns_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityAction_])
    async EntityActions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJTemplateParam_])
    async TemplateParams_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Params', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecommendation_])
    async Recommendations_SourceEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [SourceEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecommendationItem_])
    async RecommendationItems_DestinationEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [DestinationEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Items', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityCommunicationMessageType_])
    async EntityCommunicationMessageTypes_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Message Types', rows);
        return result;
    }
        
    @FieldResolver(() => [MJQueryEntity_])
    async QueryEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async GeneratedCodes_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [LinkedEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows);
        return result;
    }
        
    @Mutation(() => MJEntity_)
    async CreateMJEntity(
        @Arg('input', () => CreateMJEntityInput) input: CreateMJEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntity_)
    async UpdateMJEntity(
        @Arg('input', () => UpdateMJEntityInput) input: UpdateMJEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntity_)
    async DeleteMJEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Filters
//****************************************************************************
@ObjectType({ description: `Optional use. Maps Action Filters to specific EntityAction instances, specifying execution order and status. This allows for pre-processing before an Action actually is fired off, to check for various state/dirty/value conditions.` })
export class MJEntityActionFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionFilterID: string;
        
    @Field(() => Int, {description: `Order of filter execution.`}) 
    Sequence: number;
        
    @Field({description: `Status of the entity action filter (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Filters
//****************************************************************************
@InputType()
export class CreateMJEntityActionFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Filters
//****************************************************************************
@InputType()
export class UpdateMJEntityActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Filters
//****************************************************************************
@ObjectType()
export class RunMJEntityActionFilterViewResult {
    @Field(() => [MJEntityActionFilter_])
    Results: MJEntityActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionFilter_)
export class MJEntityActionFilterResolver extends ResolverBase {
    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionFilter_, { nullable: true })
    async MJEntityActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionFilter_ | null> {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Action Filters', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEntityActionFilter_)
    async CreateMJEntityActionFilter(
        @Arg('input', () => CreateMJEntityActionFilterInput) input: CreateMJEntityActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionFilter_)
    async UpdateMJEntityActionFilter(
        @Arg('input', () => UpdateMJEntityActionFilterInput) input: UpdateMJEntityActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionFilter_)
    async DeleteMJEntityActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Invocation Types
//****************************************************************************
@ObjectType({ description: `Stores the possible invocation types of an action within the context of an entity. Examples would be: Record Created/Updated/Deleted/Accessed as well as things like View or List where you could run an EntityAction against an entire set of records in a view or list  either by user click or programmatically.` })
export class MJEntityActionInvocationType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the invocation type such as Record Created/Updated/etc.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the invocation type.`}) 
    Description?: string;
        
    @Field(() => Int) 
    DisplaySequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityActionInvocation_])
    EntityActionInvocations_InvocationTypeIDArray: MJEntityActionInvocation_[]; // Link to EntityActionInvocations
    
}

//****************************************************************************
// INPUT TYPE for Entity Action Invocation Types
//****************************************************************************
@InputType()
export class CreateMJEntityActionInvocationTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Invocation Types
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInvocationTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Invocation Types
//****************************************************************************
@ObjectType()
export class RunMJEntityActionInvocationTypeViewResult {
    @Field(() => [MJEntityActionInvocationType_])
    Results: MJEntityActionInvocationType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionInvocationType_)
export class MJEntityActionInvocationTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Invocation Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionInvocationType_, { nullable: true })
    async MJEntityActionInvocationType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionInvocationType_ | null> {
        this.CheckUserReadPermissions('Entity Action Invocation Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocationTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocation Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Action Invocation Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionInvocation_])
    async EntityActionInvocations_InvocationTypeIDArray(@Root() mjentityactioninvocationtype_: MJEntityActionInvocationType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [InvocationTypeID]='${mjentityactioninvocationtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Invocations', rows);
        return result;
    }
        
    @Mutation(() => MJEntityActionInvocationType_)
    async CreateMJEntityActionInvocationType(
        @Arg('input', () => CreateMJEntityActionInvocationTypeInput) input: CreateMJEntityActionInvocationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Invocation Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionInvocationType_)
    async UpdateMJEntityActionInvocationType(
        @Arg('input', () => UpdateMJEntityActionInvocationTypeInput) input: UpdateMJEntityActionInvocationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Invocation Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionInvocationType_)
    async DeleteMJEntityActionInvocationType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Invocation Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Invocations
//****************************************************************************
@ObjectType({ description: `Links invocation types to entity actions  for example you might link a particular EntityAction to just Create Record and you might also have a second item in this table allowing the same Entity Action to be invoked from a User View or List, on demand.` })
export class MJEntityActionInvocation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    InvocationTypeID: string;
        
    @Field({description: `Status of the entity action invocation (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    InvocationType: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Invocations
//****************************************************************************
@InputType()
export class CreateMJEntityActionInvocationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Invocations
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInvocationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Invocations
//****************************************************************************
@ObjectType()
export class RunMJEntityActionInvocationViewResult {
    @Field(() => [MJEntityActionInvocation_])
    Results: MJEntityActionInvocation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionInvocation_)
export class MJEntityActionInvocationResolver extends ResolverBase {
    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Invocations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionInvocation_, { nullable: true })
    async MJEntityActionInvocation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionInvocation_ | null> {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Action Invocations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEntityActionInvocation_)
    async CreateMJEntityActionInvocation(
        @Arg('input', () => CreateMJEntityActionInvocationInput) input: CreateMJEntityActionInvocationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Invocations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionInvocation_)
    async UpdateMJEntityActionInvocation(
        @Arg('input', () => UpdateMJEntityActionInvocationInput) input: UpdateMJEntityActionInvocationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Invocations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionInvocation_)
    async DeleteMJEntityActionInvocation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Invocations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Params
//****************************************************************************
@ObjectType({ description: `Stores paramater mappings to enable Entity Actions to automatically invoke Actions` })
export class MJEntityActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionParamID: string;
        
    @Field({description: `Type of the value, which can be Static, Entity Object, or Script.`}) 
    @MaxLength(40)
    ValueType: string;
        
    @Field({nullable: true, description: `Value of the parameter, used only when ValueType is Static or Script. When value is Script, any valid JavaScript code can be provided. The script will have access to an object called EntityActionContext. This object will have a property called EntityObject on it that will contain the BaseEntity derived sub-class with the current data for the entity object this action is operating against. The script must provide the parameter value to the EntityActionContext.result property. This scripting capabilty is designed for very small and simple code, for anything of meaningful complexity, create a sub-class instead.`}) 
    Value?: string;
        
    @Field({nullable: true, description: `Additional comments regarding the parameter.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Params
//****************************************************************************
@InputType()
export class CreateMJEntityActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Params
//****************************************************************************
@InputType()
export class UpdateMJEntityActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Params
//****************************************************************************
@ObjectType()
export class RunMJEntityActionParamViewResult {
    @Field(() => [MJEntityActionParam_])
    Results: MJEntityActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionParam_)
export class MJEntityActionParamResolver extends ResolverBase {
    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionParam_, { nullable: true })
    async MJEntityActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionParam_ | null> {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Action Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEntityActionParam_)
    async CreateMJEntityActionParam(
        @Arg('input', () => CreateMJEntityActionParamInput) input: CreateMJEntityActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionParam_)
    async UpdateMJEntityActionParam(
        @Arg('input', () => UpdateMJEntityActionParamInput) input: UpdateMJEntityActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionParam_)
    async DeleteMJEntityActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Actions
//****************************************************************************
@ObjectType({ description: `Links entities to actions - this is the main place where you define the actions that part of, or available, for a given entity.` })
export class MJEntityAction_ {
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Status of the entity action (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [MJEntityActionInvocation_])
    EntityActionInvocations_EntityActionIDArray: MJEntityActionInvocation_[]; // Link to EntityActionInvocations
    
    @Field(() => [MJEntityActionFilter_])
    EntityActionFilters_EntityActionIDArray: MJEntityActionFilter_[]; // Link to EntityActionFilters
    
    @Field(() => [MJEntityActionParam_])
    EntityActionParams_EntityActionIDArray: MJEntityActionParam_[]; // Link to EntityActionParams
    
}

//****************************************************************************
// INPUT TYPE for Entity Actions
//****************************************************************************
@InputType()
export class CreateMJEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Actions
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Actions
//****************************************************************************
@ObjectType()
export class RunMJEntityActionViewResult {
    @Field(() => [MJEntityAction_])
    Results: MJEntityAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityAction_)
export class MJEntityActionResolver extends ResolverBase {
    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityAction_, { nullable: true })
    async MJEntityAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityAction_ | null> {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionInvocation_])
    async EntityActionInvocations_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [EntityActionID]='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Invocations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityActionFilter_])
    async EntityActionFilters_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [EntityActionID]='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Filters', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityActionParam_])
    async EntityActionParams_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [EntityActionID]='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Params', rows);
        return result;
    }
        
    @Mutation(() => MJEntityAction_)
    async CreateMJEntityAction(
        @Arg('input', () => CreateMJEntityActionInput) input: CreateMJEntityActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityAction_)
    async UpdateMJEntityAction(
        @Arg('input', () => UpdateMJEntityActionInput) input: UpdateMJEntityActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityAction_)
    async DeleteMJEntityAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity AI Actions
//****************************************************************************
@ObjectType({ description: `Tracks the AI actions that should be invoked based on changes to records within a given entity.` })
export class MJEntityAIAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field() 
    @MaxLength(16)
    AIActionID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Prompt?: string;
        
    @Field() 
    @MaxLength(30)
    TriggerEvent: string;
        
    @Field() 
    UserMessage: string;
        
    @Field() 
    @MaxLength(20)
    OutputType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OutputField?: string;
        
    @Field(() => Boolean) 
    SkipIfOutputFieldNotEmpty: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputEntityID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field() 
    @MaxLength(100)
    AIAction: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity AI Actions
//****************************************************************************
@InputType()
export class CreateMJEntityAIActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity AI Actions
//****************************************************************************
@InputType()
export class UpdateMJEntityAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField?: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity AI Actions
//****************************************************************************
@ObjectType()
export class RunMJEntityAIActionViewResult {
    @Field(() => [MJEntityAIAction_])
    Results: MJEntityAIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityAIAction_)
export class MJEntityAIActionResolver extends ResolverBase {
    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity AI Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityAIAction_, { nullable: true })
    async MJEntityAIAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityAIAction_ | null> {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity AI Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJEntityAIAction_])
    async AllEntityAIActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions]` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows);
        return result;
    }
    
    @Mutation(() => MJEntityAIAction_)
    async CreateMJEntityAIAction(
        @Arg('input', () => CreateMJEntityAIActionInput) input: CreateMJEntityAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity AI Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityAIAction_)
    async UpdateMJEntityAIAction(
        @Arg('input', () => UpdateMJEntityAIActionInput) input: UpdateMJEntityAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity AI Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityAIAction_)
    async DeleteMJEntityAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity AI Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Communication Fields
//****************************************************************************
@ObjectType({ description: `Mapping between entity fields and communication base message types with priority` })
export class MJEntityCommunicationField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityCommunicationMessageTypeID: string;
        
    @Field({description: `Name of the field in the entity that maps to the communication base message type`}) 
    @MaxLength(1000)
    FieldName: string;
        
    @Field(() => Int, {description: `Priority of the field for the communication base message type`}) 
    Priority: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Entity Communication Fields
//****************************************************************************
@InputType()
export class CreateMJEntityCommunicationFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Communication Fields
//****************************************************************************
@InputType()
export class UpdateMJEntityCommunicationFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Communication Fields
//****************************************************************************
@ObjectType()
export class RunMJEntityCommunicationFieldViewResult {
    @Field(() => [MJEntityCommunicationField_])
    Results: MJEntityCommunicationField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityCommunicationField_)
export class MJEntityCommunicationFieldResolver extends ResolverBase {
    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Communication Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityCommunicationField_, { nullable: true })
    async MJEntityCommunicationField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityCommunicationField_ | null> {
        this.CheckUserReadPermissions('Entity Communication Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Communication Fields', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEntityCommunicationField_)
    async CreateMJEntityCommunicationField(
        @Arg('input', () => CreateMJEntityCommunicationFieldInput) input: CreateMJEntityCommunicationFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Communication Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityCommunicationField_)
    async UpdateMJEntityCommunicationField(
        @Arg('input', () => UpdateMJEntityCommunicationFieldInput) input: UpdateMJEntityCommunicationFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Communication Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityCommunicationField_)
    async DeleteMJEntityCommunicationField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Communication Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Communication Message Types
//****************************************************************************
@ObjectType({ description: `Mapping between entities and communication base message types` })
export class MJEntityCommunicationMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    BaseMessageTypeID: string;
        
    @Field(() => Boolean, {description: `Indicates whether the message type is active`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    BaseMessageType: string;
        
    @Field(() => [MJEntityCommunicationField_])
    EntityCommunicationFields_EntityCommunicationMessageTypeIDArray: MJEntityCommunicationField_[]; // Link to EntityCommunicationFields
    
}

//****************************************************************************
// INPUT TYPE for Entity Communication Message Types
//****************************************************************************
@InputType()
export class CreateMJEntityCommunicationMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Entity Communication Message Types
//****************************************************************************
@InputType()
export class UpdateMJEntityCommunicationMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Communication Message Types
//****************************************************************************
@ObjectType()
export class RunMJEntityCommunicationMessageTypeViewResult {
    @Field(() => [MJEntityCommunicationMessageType_])
    Results: MJEntityCommunicationMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityCommunicationMessageType_)
export class MJEntityCommunicationMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Communication Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityCommunicationMessageType_, { nullable: true })
    async MJEntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityCommunicationMessageType_ | null> {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Communication Message Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityCommunicationField_])
    async EntityCommunicationFields_EntityCommunicationMessageTypeIDArray(@Root() mjentitycommunicationmessagetype_: MJEntityCommunicationMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationFields] WHERE [EntityCommunicationMessageTypeID]='${mjentitycommunicationmessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Fields', rows);
        return result;
    }
        
    @Mutation(() => MJEntityCommunicationMessageType_)
    async CreateMJEntityCommunicationMessageType(
        @Arg('input', () => CreateMJEntityCommunicationMessageTypeInput) input: CreateMJEntityCommunicationMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Communication Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityCommunicationMessageType_)
    async UpdateMJEntityCommunicationMessageType(
        @Arg('input', () => UpdateMJEntityCommunicationMessageTypeInput) input: UpdateMJEntityCommunicationMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Communication Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityCommunicationMessageType_)
    async DeleteMJEntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Communication Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Runs
//****************************************************************************
@ObjectType()
export class MJEntityDocumentRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({description: `Can be Pending, In Progress, Completed, or Failed`}) 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Document Runs
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Runs
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Runs
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentRunViewResult {
    @Field(() => [MJEntityDocumentRun_])
    Results: MJEntityDocumentRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentRun_)
export class MJEntityDocumentRunResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentRun_, { nullable: true })
    async MJEntityDocumentRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentRun_ | null> {
        this.CheckUserReadPermissions('Entity Document Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Document Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEntityDocumentRun_)
    async CreateMJEntityDocumentRun(
        @Arg('input', () => CreateMJEntityDocumentRunInput) input: CreateMJEntityDocumentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentRun_)
    async UpdateMJEntityDocumentRun(
        @Arg('input', () => UpdateMJEntityDocumentRunInput) input: UpdateMJEntityDocumentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Runs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Settings
//****************************************************************************
@ObjectType()
export class MJEntityDocumentSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Document Settings
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Settings
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Settings
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentSettingViewResult {
    @Field(() => [MJEntityDocumentSetting_])
    Results: MJEntityDocumentSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentSetting_)
export class MJEntityDocumentSettingResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentSetting_, { nullable: true })
    async MJEntityDocumentSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentSetting_ | null> {
        this.CheckUserReadPermissions('Entity Document Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Document Settings', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEntityDocumentSetting_)
    async CreateMJEntityDocumentSetting(
        @Arg('input', () => CreateMJEntityDocumentSettingInput) input: CreateMJEntityDocumentSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentSetting_)
    async UpdateMJEntityDocumentSetting(
        @Arg('input', () => UpdateMJEntityDocumentSettingInput) input: UpdateMJEntityDocumentSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocumentSetting_)
    async DeleteMJEntityDocumentSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Types
//****************************************************************************
@ObjectType()
export class MJEntityDocumentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityDocument_])
    EntityDocuments_TypeIDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Entity Document Types
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Types
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Types
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentTypeViewResult {
    @Field(() => [MJEntityDocumentType_])
    Results: MJEntityDocumentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentType_)
export class MJEntityDocumentTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentType_, { nullable: true })
    async MJEntityDocumentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentType_ | null> {
        this.CheckUserReadPermissions('Entity Document Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Document Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_TypeIDArray(@Root() mjentitydocumenttype_: MJEntityDocumentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [TypeID]='${mjentitydocumenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @Mutation(() => MJEntityDocumentType_)
    async CreateMJEntityDocumentType(
        @Arg('input', () => CreateMJEntityDocumentTypeInput) input: CreateMJEntityDocumentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentType_)
    async UpdateMJEntityDocumentType(
        @Arg('input', () => UpdateMJEntityDocumentTypeInput) input: UpdateMJEntityDocumentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocumentType_)
    async DeleteMJEntityDocumentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Documents
//****************************************************************************
@ObjectType()
export class MJEntityDocument_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(500)
    Name: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered a potential matching record. Value must be <= AbsoluteMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    PotentialMatchThreshold: number;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered an absolute matching record. Value must be >= PotentialMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    AbsoluteMatchThreshold: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field(() => [MJEntityDocumentRun_])
    EntityDocumentRuns_EntityDocumentIDArray: MJEntityDocumentRun_[]; // Link to EntityDocumentRuns
    
    @Field(() => [MJEntityDocumentSetting_])
    EntityDocumentSettings_EntityDocumentIDArray: MJEntityDocumentSetting_[]; // Link to EntityDocumentSettings
    
    @Field(() => [MJEntityRecordDocument_])
    EntityRecordDocuments_EntityDocumentIDArray: MJEntityRecordDocument_[]; // Link to EntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for Entity Documents
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Documents
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Documents
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentViewResult {
    @Field(() => [MJEntityDocument_])
    Results: MJEntityDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocument_)
export class MJEntityDocumentResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Documents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocument_, { nullable: true })
    async MJEntityDocument(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocument_ | null> {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Documents', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityDocumentRun_])
    async EntityDocumentRuns_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Document Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentRuns] WHERE [EntityDocumentID]='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Document Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocumentSetting_])
    async EntityDocumentSettings_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Document Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentSettings] WHERE [EntityDocumentID]='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Document Settings', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityRecordDocument_])
    async EntityRecordDocuments_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [EntityDocumentID]='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows);
        return result;
    }
        
    @Mutation(() => MJEntityDocument_)
    async CreateMJEntityDocument(
        @Arg('input', () => CreateMJEntityDocumentInput) input: CreateMJEntityDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Documents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocument_)
    async UpdateMJEntityDocument(
        @Arg('input', () => UpdateMJEntityDocumentInput) input: UpdateMJEntityDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Documents', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Field Values
//****************************************************************************
@ObjectType()
export class MJEntityFieldValue_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityFieldID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field() 
    @MaxLength(510)
    Value: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Code?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    EntityField: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Field Values
//****************************************************************************
@InputType()
export class UpdateMJEntityFieldValueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityFieldID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Field Values
//****************************************************************************
@ObjectType()
export class RunMJEntityFieldValueViewResult {
    @Field(() => [MJEntityFieldValue_])
    Results: MJEntityFieldValue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityFieldValue_)
export class MJEntityFieldValueResolver extends ResolverBase {
    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Field Values';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityFieldValue_, { nullable: true })
    async MJEntityFieldValue(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityFieldValue_ | null> {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Field Values', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJEntityFieldValue_])
    async AllEntityFieldValues(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Field Values', rows);
        return result;
    }
    
    @Mutation(() => MJEntityFieldValue_)
    async UpdateMJEntityFieldValue(
        @Arg('input', () => UpdateMJEntityFieldValueInput) input: UpdateMJEntityFieldValueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Field Values', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Fields
//****************************************************************************
@ObjectType({ description: `List of all fields within each entity with metadata about each field` })
export class MJEntityField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of the field within the entity`}) 
    Sequence: number;
        
    @Field({description: `Name of the field within the database table`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `A user friendly alternative to the field name`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({nullable: true, description: `Descriptive text explaining the purpose of the field`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the column within the underlying view (first choice) or table (second choice), the Description column in the entity field definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity field definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field is part of the primary key for the entity (auto maintained by CodeGen)`}) 
    IsPrimaryKey: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field must have unique values within the entity.`}) 
    IsUnique: boolean;
        
    @Field({nullable: true, description: `Used for generating custom tabs in the generated forms, only utilized if GeneratedFormSection=Category`}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({description: `SQL Data type (auto maintained by CodeGen)`}) 
    @MaxLength(200)
    Type: string;
        
    @Field(() => Int, {nullable: true, description: `SQL data length (auto maintained by CodeGen)`}) 
    Length?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL precision (auto maintained by CodeGen)`}) 
    Precision?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL scale (auto maintained by CodeGen)`}) 
    Scale?: number;
        
    @Field(() => Boolean, {description: `Does the column allow null or not (auto maintained by CodeGen)`}) 
    AllowsNull: boolean;
        
    @Field({nullable: true, description: `If a default value is defined for the field it is stored here (auto maintained by CodeGen)`}) 
    @MaxLength(510)
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `If this field automatically increments within the table, this field is set to 1 (auto maintained by CodeGen)`}) 
    AutoIncrement: boolean;
        
    @Field({description: `Possible Values of None, List, ListOrUserEntry - the last option meaning that the list of possible values are options, but a user can enter anything else desired too.`}) 
    @MaxLength(40)
    ValueListType: string;
        
    @Field({nullable: true, description: `Defines extended behaviors for a field such as for Email, Web URLs, Code, etc.`}) 
    @MaxLength(100)
    ExtendedType?: string;
        
    @Field({nullable: true, description: `The type of code associated with this field. Only used when the ExtendedType field is set to "Code"`}) 
    @MaxLength(100)
    CodeType?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included by default in any new view created by a user.`}) 
    DefaultInView: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    ViewCellTemplate?: string;
        
    @Field(() => Int, {nullable: true, description: `Determines the default width for this field when included in a view`}) 
    DefaultColumnWidth?: number;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be considered updateable by the API and object model. For this field to have effect, the column type must be updateable (e.g. not part of the primary key and not auto-increment)`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, and if AllowUpdateAPI=1, the field can be edited within a view when the view is in edit mode.`}) 
    AllowUpdateInView: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be included in user search queries for both traditional and full text search`}) 
    IncludeInUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, CodeGen will automatically generate a Full Text Catalog/Index in the database and include this field in the search index.`}) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    @MaxLength(1000)
    UserSearchParamFormatAPI?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included in the generated form by CodeGen. If set to 0, this field will be excluded from the generated form. For custom forms, this field has no effect as the layout is controlled independently.`}) 
    IncludeInGeneratedForm: boolean;
        
    @Field({description: `When set to Top, the field will be placed in a "top area" on the top of a generated form and visible regardless of which tab is displayed. When set to "category" Options: Top, Category, Details`}) 
    @MaxLength(20)
    GeneratedFormSection: string;
        
    @Field(() => Boolean, {description: `NULL`}) 
    IsVirtual: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be used as the "Name" field for the entity and will be used to display the name of the record in various places in the UI.`}) 
    IsNameField: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RelatedEntityID?: string;
        
    @Field({nullable: true, description: `Name of the field in the Related Entity that this field links to (auto maintained by CodeGen)`}) 
    @MaxLength(510)
    RelatedEntityFieldName?: string;
        
    @Field(() => Boolean, {description: `If set to 1, the "Name" field of the Related Entity will be included in this entity as a virtual field`}) 
    IncludeRelatedEntityNameFieldInBaseView: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityNameFieldMap?: string;
        
    @Field({description: `Controls the generated form in the MJ Explorer UI - defaults to a search box, other option is a drop down. Possible values are Search and Dropdown`}) 
    @MaxLength(40)
    RelatedEntityDisplayType: string;
        
    @Field({nullable: true, description: `Optional, used for "Soft Keys" to link records to different entity/record combinations on a per-record basis (for example the FileEntityRecordLink table has an EntityID/RecordID field pair. For that entity, the RecordID specifies "EntityID" for this field. This information allows MJ to detect soft keys/links for dependency detection, merging and for preventing orphaned soft-linked records during delete operations.`}) 
    @MaxLength(200)
    EntityIDFieldName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field({nullable: true, description: `A comma-delimited string indicating the default scope for field visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for a simple method of filtering field defaults for visibility, not security enforcement.`}) 
    @MaxLength(200)
    ScopeDefault?: string;
        
    @Field() 
    @MaxLength(510)
    SchemaName: string;
        
    @Field(() => Boolean, {description: `Indicates whether the related entity information should be automatically updated from the database schema. When set to 0, relationships not part of the database schema can be manually defined at the application and AI agent level. Defaults to 1.`}) 
    AutoUpdateRelatedEntityInfo: boolean;
        
    @Field() 
    @MaxLength(510)
    BaseTable: string;
        
    @Field({description: `Determines whether values for the field should be included when the schema is packed. Options: Auto (include manually set or auto-derived values), None (exclude all values), All (include all distinct values from the table). Defaults to Auto.`}) 
    @MaxLength(20)
    ValuesToPackWithSchema: string;
        
    @Field() 
    @MaxLength(510)
    BaseView: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntitySchemaName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityBaseView?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field(() => [MJEntityFieldValue_])
    EntityFieldValues_EntityFieldIDArray: MJEntityFieldValue_[]; // Link to EntityFieldValues
    
}

//****************************************************************************
// INPUT TYPE for Entity Fields
//****************************************************************************
@InputType()
export class CreateMJEntityFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType: string | null;

    @Field({ nullable: true })
    CodeType: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Fields
//****************************************************************************
@InputType()
export class UpdateMJEntityFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType?: string | null;

    @Field({ nullable: true })
    CodeType?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate?: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth?: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID?: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap?: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Fields
//****************************************************************************
@ObjectType()
export class RunMJEntityFieldViewResult {
    @Field(() => [MJEntityField_])
    Results: MJEntityField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityField_)
export class MJEntityFieldResolver extends ResolverBase {
    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityField_, { nullable: true })
    async MJEntityField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityField_ | null> {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Fields', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJEntityField_])
    async AllEntityFields(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Fields', rows);
        return result;
    }
    
    @FieldResolver(() => [MJEntityFieldValue_])
    async EntityFieldValues_EntityFieldIDArray(@Root() mjentityfield_: MJEntityField_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues] WHERE [EntityFieldID]='${mjentityfield_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Field Values', rows);
        return result;
    }
        
    @Mutation(() => MJEntityField_)
    async CreateMJEntityField(
        @Arg('input', () => CreateMJEntityFieldInput) input: CreateMJEntityFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityField_)
    async UpdateMJEntityField(
        @Arg('input', () => UpdateMJEntityFieldInput) input: UpdateMJEntityFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityField_)
    async DeleteMJEntityField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Permissions
//****************************************************************************
@ObjectType({ description: `Security settings for each entity` })
export class MJEntityPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field(() => Boolean) 
    CanCreate: boolean;
        
    @Field(() => Boolean) 
    CanRead: boolean;
        
    @Field(() => Boolean) 
    CanUpdate: boolean;
        
    @Field(() => Boolean) 
    CanDelete: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ReadRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CreateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UpdateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DeleteRLSFilterID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    RoleName: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    RoleSQLName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CreateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ReadRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    UpdateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DeleteRLSFilter?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Permissions
//****************************************************************************
@InputType()
export class CreateMJEntityPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Permissions
//****************************************************************************
@InputType()
export class UpdateMJEntityPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID?: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID?: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID?: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Permissions
//****************************************************************************
@ObjectType()
export class RunMJEntityPermissionViewResult {
    @Field(() => [MJEntityPermission_])
    Results: MJEntityPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityPermission_)
export class MJEntityPermissionResolver extends ResolverBase {
    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityPermission_, { nullable: true })
    async MJEntityPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityPermission_ | null> {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Permissions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJEntityPermission_])
    async AllEntityPermissions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows);
        return result;
    }
    
    @Mutation(() => MJEntityPermission_)
    async CreateMJEntityPermission(
        @Arg('input', () => CreateMJEntityPermissionInput) input: CreateMJEntityPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityPermission_)
    async UpdateMJEntityPermission(
        @Arg('input', () => UpdateMJEntityPermissionInput) input: UpdateMJEntityPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityPermission_)
    async DeleteMJEntityPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Record Documents
//****************************************************************************
@ObjectType()
export class MJEntityRecordDocument_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field({nullable: true}) 
    DocumentText?: string;
        
    @Field() 
    @MaxLength(16)
    VectorIndexID: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    VectorID?: string;
        
    @Field({nullable: true}) 
    VectorJSON?: string;
        
    @Field() 
    @MaxLength(8)
    EntityRecordUpdatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
    @Field() 
    @MaxLength(510)
    VectorIndex: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Record Documents
//****************************************************************************
@InputType()
export class CreateMJEntityRecordDocumentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID: string | null;

    @Field({ nullable: true })
    VectorJSON: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Entity Record Documents
//****************************************************************************
@InputType()
export class UpdateMJEntityRecordDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText?: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID?: string | null;

    @Field({ nullable: true })
    VectorJSON?: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Record Documents
//****************************************************************************
@ObjectType()
export class RunMJEntityRecordDocumentViewResult {
    @Field(() => [MJEntityRecordDocument_])
    Results: MJEntityRecordDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRecordDocument_)
export class MJEntityRecordDocumentResolver extends ResolverBase {
    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Record Documents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRecordDocument_, { nullable: true })
    async MJEntityRecordDocument(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRecordDocument_ | null> {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Record Documents', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEntityRecordDocument_)
    async CreateMJEntityRecordDocument(
        @Arg('input', () => CreateMJEntityRecordDocumentInput) input: CreateMJEntityRecordDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Record Documents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRecordDocument_)
    async UpdateMJEntityRecordDocument(
        @Arg('input', () => UpdateMJEntityRecordDocumentInput) input: UpdateMJEntityRecordDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Record Documents', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Relationship Display Components
//****************************************************************************
@ObjectType({ description: `This table stores a list of components that are available for displaying relationships in the MJ Explorer UI` })
export class MJEntityRelationshipDisplayComponent_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The type of relationship the component displays. Valid values are "One to Many", "Many to Many", or "Both".`}) 
    @MaxLength(40)
    RelationshipType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityRelationship_])
    EntityRelationships_DisplayComponentIDArray: MJEntityRelationship_[]; // Link to EntityRelationships
    
}

//****************************************************************************
// INPUT TYPE for Entity Relationship Display Components
//****************************************************************************
@InputType()
export class CreateMJEntityRelationshipDisplayComponentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Relationship Display Components
//****************************************************************************
@InputType()
export class UpdateMJEntityRelationshipDisplayComponentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Relationship Display Components
//****************************************************************************
@ObjectType()
export class RunMJEntityRelationshipDisplayComponentViewResult {
    @Field(() => [MJEntityRelationshipDisplayComponent_])
    Results: MJEntityRelationshipDisplayComponent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRelationshipDisplayComponent_)
export class MJEntityRelationshipDisplayComponentResolver extends ResolverBase {
    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Relationship Display Components';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRelationshipDisplayComponent_, { nullable: true })
    async MJEntityRelationshipDisplayComponent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRelationshipDisplayComponent_ | null> {
        this.CheckUserReadPermissions('Entity Relationship Display Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationshipDisplayComponents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationship Display Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Relationship Display Components', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityRelationship_])
    async EntityRelationships_DisplayComponentIDArray(@Root() mjentityrelationshipdisplaycomponent_: MJEntityRelationshipDisplayComponent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [DisplayComponentID]='${mjentityrelationshipdisplaycomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows);
        return result;
    }
        
    @Mutation(() => MJEntityRelationshipDisplayComponent_)
    async CreateMJEntityRelationshipDisplayComponent(
        @Arg('input', () => CreateMJEntityRelationshipDisplayComponentInput) input: CreateMJEntityRelationshipDisplayComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Relationship Display Components', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRelationshipDisplayComponent_)
    async UpdateMJEntityRelationshipDisplayComponent(
        @Arg('input', () => UpdateMJEntityRelationshipDisplayComponentInput) input: UpdateMJEntityRelationshipDisplayComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Relationship Display Components', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Relationships
//****************************************************************************
@ObjectType({ description: `Metadata about relationships between entities including display preferences for the UI` })
export class MJEntityRelationship_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Used for display order in generated forms and in other places in the UI where relationships for an entity are shown`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(16)
    RelatedEntityID: string;
        
    @Field(() => Boolean) 
    BundleInAPI: boolean;
        
    @Field(() => Boolean) 
    IncludeInParentAllQuery: boolean;
        
    @Field() 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    EntityKeyField?: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityJoinField: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    JoinView?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    JoinEntityJoinField?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    JoinEntityInverseJoinField?: string;
        
    @Field(() => Boolean, {description: `When unchecked the relationship will NOT be displayed on the generated form`}) 
    DisplayInForm: boolean;
        
    @Field() 
    @MaxLength(100)
    DisplayLocation: string;
        
    @Field({nullable: true, description: `Optional, when specified this value overrides the related entity name for the label on the tab`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({description: `When Related Entity Icon - uses the icon from the related entity, if one exists. When Custom, uses the value in the DisplayIcon field in this record, and when None, no icon is displayed`}) 
    @MaxLength(100)
    DisplayIconType: string;
        
    @Field({nullable: true, description: `If specified, the icon `}) 
    @MaxLength(510)
    DisplayIcon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DisplayUserViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DisplayComponentID?: string;
        
    @Field({nullable: true, description: `If DisplayComponentID is specified, this field can optionally be used to track component-specific and relationship-specific configuration details that will be used by CodeGen to provide to the display component selected.`}) 
    DisplayComponentConfiguration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field(() => Boolean, {description: `Indicates whether this relationship should be automatically updated by CodeGen. When set to 0, the record will not be modified by CodeGen. Defaults to 1.`}) 
    AutoUpdateFromSchema: boolean;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntity: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityBaseView: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityBaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DisplayUserViewName?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Relationships
//****************************************************************************
@InputType()
export class CreateMJEntityRelationshipInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon: string | null;

    @Field({ nullable: true })
    DisplayComponentID: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Entity Relationships
//****************************************************************************
@InputType()
export class UpdateMJEntityRelationshipInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField?: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView?: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField?: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField?: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon?: string | null;

    @Field({ nullable: true })
    DisplayComponentID?: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Relationships
//****************************************************************************
@ObjectType()
export class RunMJEntityRelationshipViewResult {
    @Field(() => [MJEntityRelationship_])
    Results: MJEntityRelationship_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRelationship_)
export class MJEntityRelationshipResolver extends ResolverBase {
    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Relationships';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRelationship_, { nullable: true })
    async MJEntityRelationship(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRelationship_ | null> {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Relationships', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJEntityRelationship_])
    async AllEntityRelationships(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows);
        return result;
    }
    
    @Mutation(() => MJEntityRelationship_)
    async CreateMJEntityRelationship(
        @Arg('input', () => CreateMJEntityRelationshipInput) input: CreateMJEntityRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Relationships', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRelationship_)
    async UpdateMJEntityRelationship(
        @Arg('input', () => UpdateMJEntityRelationshipInput) input: UpdateMJEntityRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Relationships', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityRelationship_)
    async DeleteMJEntityRelationship(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Relationships', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Settings
//****************************************************************************
@ObjectType()
export class MJEntitySetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Settings
//****************************************************************************
@InputType()
export class CreateMJEntitySettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Settings
//****************************************************************************
@InputType()
export class UpdateMJEntitySettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Settings
//****************************************************************************
@ObjectType()
export class RunMJEntitySettingViewResult {
    @Field(() => [MJEntitySetting_])
    Results: MJEntitySetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntitySetting_)
export class MJEntitySettingResolver extends ResolverBase {
    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntitySetting_, { nullable: true })
    async MJEntitySetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntitySetting_ | null> {
        this.CheckUserReadPermissions('Entity Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntitySettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Settings', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJEntitySetting_)
    async CreateMJEntitySetting(
        @Arg('input', () => CreateMJEntitySettingInput) input: CreateMJEntitySettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntitySetting_)
    async UpdateMJEntitySetting(
        @Arg('input', () => UpdateMJEntitySettingInput) input: UpdateMJEntitySettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntitySetting_)
    async DeleteMJEntitySetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Error Logs
//****************************************************************************
@ObjectType()
export class MJErrorLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationRunDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(40)
    Code?: string;
        
    @Field({nullable: true}) 
    Message?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    CreatedBy?: string;
        
    @Field({nullable: true}) 
    @MaxLength(20)
    Status?: string;
        
    @Field({nullable: true}) 
    @MaxLength(40)
    Category?: string;
        
    @Field({nullable: true}) 
    Details?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Error Logs
//****************************************************************************
@InputType()
export class CreateMJErrorLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    Details: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Error Logs
//****************************************************************************
@InputType()
export class UpdateMJErrorLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Error Logs
//****************************************************************************
@ObjectType()
export class RunMJErrorLogViewResult {
    @Field(() => [MJErrorLog_])
    Results: MJErrorLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJErrorLog_)
export class MJErrorLogResolver extends ResolverBase {
    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Error Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJErrorLog_, { nullable: true })
    async MJErrorLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJErrorLog_ | null> {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Error Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJErrorLog_)
    async CreateMJErrorLog(
        @Arg('input', () => CreateMJErrorLogInput) input: CreateMJErrorLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Error Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJErrorLog_)
    async UpdateMJErrorLog(
        @Arg('input', () => UpdateMJErrorLogInput) input: UpdateMJErrorLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Error Logs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Explorer Navigation Items
//****************************************************************************
@ObjectType({ description: `Table to store navigation items for MemberJunction Explorer` })
export class MJExplorerNavigationItem_ {
    @Field({description: `Unique identifier for each navigation item`}) 
    @MaxLength(16)
    ID: string;
        
    @Field(() => Int, {description: `Sequence number for the navigation item, must be unique and greater than 0`}) 
    Sequence: number;
        
    @Field({description: `Unique name of the navigation item displayed to the user`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The route for the navigation item relative to the app main URL, using Angular syntax like "entity/:entityName"`}) 
    @MaxLength(510)
    Route: string;
        
    @Field(() => Boolean, {description: `Indicates if the navigation item is active; allows turning off items in the UI without deleting them from the metadata`}) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `Controls if the navigation item is shown on the Home screen for MJ Explorer`}) 
    ShowInHomeScreen: boolean;
        
    @Field(() => Boolean, {description: `Controls if the item is shown in the left navigation drawer in the MJ Explorer app or not.`}) 
    ShowInNavigationDrawer: boolean;
        
    @Field({nullable: true, description: `Optional, CSS class for an icon to be displayed with the navigation item`}) 
    @MaxLength(200)
    IconCSSClass?: string;
        
    @Field({nullable: true, description: `Description of the navigation item, shown to the user on hover or in larger displays`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Administrator comments, not shown to the end user in MJ Explorer app`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Explorer Navigation Items
//****************************************************************************
@InputType()
export class CreateMJExplorerNavigationItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Explorer Navigation Items
//****************************************************************************
@InputType()
export class UpdateMJExplorerNavigationItemInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Explorer Navigation Items
//****************************************************************************
@ObjectType()
export class RunMJExplorerNavigationItemViewResult {
    @Field(() => [MJExplorerNavigationItem_])
    Results: MJExplorerNavigationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJExplorerNavigationItem_)
export class MJExplorerNavigationItemResolver extends ResolverBase {
    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Explorer Navigation Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJExplorerNavigationItem_, { nullable: true })
    async MJExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJExplorerNavigationItem_ | null> {
        this.CheckUserReadPermissions('Explorer Navigation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwExplorerNavigationItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Explorer Navigation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Explorer Navigation Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJExplorerNavigationItem_)
    async CreateMJExplorerNavigationItem(
        @Arg('input', () => CreateMJExplorerNavigationItemInput) input: CreateMJExplorerNavigationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Explorer Navigation Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJExplorerNavigationItem_)
    async UpdateMJExplorerNavigationItem(
        @Arg('input', () => UpdateMJExplorerNavigationItemInput) input: UpdateMJExplorerNavigationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Explorer Navigation Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJExplorerNavigationItem_)
    async DeleteMJExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Explorer Navigation Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Categories
//****************************************************************************
@ObjectType()
export class MJFileCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [MJFile_])
    Files_CategoryIDArray: MJFile_[]; // Link to Files
    
    @Field(() => [MJFileCategory_])
    FileCategories_ParentIDArray: MJFileCategory_[]; // Link to FileCategories
    
}

//****************************************************************************
// INPUT TYPE for File Categories
//****************************************************************************
@InputType()
export class CreateMJFileCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for File Categories
//****************************************************************************
@InputType()
export class UpdateMJFileCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Categories
//****************************************************************************
@ObjectType()
export class RunMJFileCategoryViewResult {
    @Field(() => [MJFileCategory_])
    Results: MJFileCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileCategory_)
export class MJFileCategoryResolver extends ResolverBase {
    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileCategory_, { nullable: true })
    async MJFileCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileCategory_ | null> {
        this.CheckUserReadPermissions('File Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('File Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJFile_])
    async Files_CategoryIDArray(@Root() mjfilecategory_: MJFileCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [CategoryID]='${mjfilecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Files', rows);
        return result;
    }
        
    @FieldResolver(() => [MJFileCategory_])
    async FileCategories_ParentIDArray(@Root() mjfilecategory_: MJFileCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileCategories] WHERE [ParentID]='${mjfilecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('File Categories', rows);
        return result;
    }
        
    @Mutation(() => MJFileCategory_)
    async CreateMJFileCategory(
        @Arg('input', () => CreateMJFileCategoryInput) input: CreateMJFileCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileCategory_)
    async UpdateMJFileCategory(
        @Arg('input', () => UpdateMJFileCategoryInput) input: UpdateMJFileCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileCategory_)
    async DeleteMJFileCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Entity Record Links
//****************************************************************************
@ObjectType()
export class MJFileEntityRecordLink_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    FileID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    File: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for File Entity Record Links
//****************************************************************************
@InputType()
export class CreateMJFileEntityRecordLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for File Entity Record Links
//****************************************************************************
@InputType()
export class UpdateMJFileEntityRecordLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Entity Record Links
//****************************************************************************
@ObjectType()
export class RunMJFileEntityRecordLinkViewResult {
    @Field(() => [MJFileEntityRecordLink_])
    Results: MJFileEntityRecordLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileEntityRecordLink_)
export class MJFileEntityRecordLinkResolver extends ResolverBase {
    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Entity Record Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileEntityRecordLink_, { nullable: true })
    async MJFileEntityRecordLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileEntityRecordLink_ | null> {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('File Entity Record Links', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJFileEntityRecordLink_)
    async CreateMJFileEntityRecordLink(
        @Arg('input', () => CreateMJFileEntityRecordLinkInput) input: CreateMJFileEntityRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Entity Record Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileEntityRecordLink_)
    async UpdateMJFileEntityRecordLink(
        @Arg('input', () => UpdateMJFileEntityRecordLinkInput) input: UpdateMJFileEntityRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Entity Record Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileEntityRecordLink_)
    async DeleteMJFileEntityRecordLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Entity Record Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Storage Providers
//****************************************************************************
@ObjectType()
export class MJFileStorageProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(200)
    ServerDriverKey: string;
        
    @Field() 
    @MaxLength(200)
    ClientDriverKey: string;
        
    @Field(() => Int) 
    Priority: number;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJFile_])
    Files_ProviderIDArray: MJFile_[]; // Link to Files
    
}

//****************************************************************************
// INPUT TYPE for File Storage Providers
//****************************************************************************
@InputType()
export class CreateMJFileStorageProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for File Storage Providers
//****************************************************************************
@InputType()
export class UpdateMJFileStorageProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Storage Providers
//****************************************************************************
@ObjectType()
export class RunMJFileStorageProviderViewResult {
    @Field(() => [MJFileStorageProvider_])
    Results: MJFileStorageProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileStorageProvider_)
export class MJFileStorageProviderResolver extends ResolverBase {
    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Storage Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileStorageProvider_, { nullable: true })
    async MJFileStorageProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileStorageProvider_ | null> {
        this.CheckUserReadPermissions('File Storage Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileStorageProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Storage Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('File Storage Providers', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJFile_])
    async Files_ProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [ProviderID]='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Files', rows);
        return result;
    }
        
    @Mutation(() => MJFileStorageProvider_)
    async CreateMJFileStorageProvider(
        @Arg('input', () => CreateMJFileStorageProviderInput) input: CreateMJFileStorageProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Storage Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileStorageProvider_)
    async UpdateMJFileStorageProvider(
        @Arg('input', () => UpdateMJFileStorageProviderInput) input: UpdateMJFileStorageProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Storage Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileStorageProvider_)
    async DeleteMJFileStorageProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Storage Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Files
//****************************************************************************
@ObjectType()
export class MJFile_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(1000)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(16)
    ProviderID: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ContentType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    ProviderKey?: string;
        
    @Field({description: `Pending, Uploading, Uploaded, Deleting, Deleted`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(100)
    Provider: string;
        
    @Field(() => [MJFileEntityRecordLink_])
    FileEntityRecordLinks_FileIDArray: MJFileEntityRecordLink_[]; // Link to FileEntityRecordLinks
    
}

//****************************************************************************
// INPUT TYPE for Files
//****************************************************************************
@InputType()
export class CreateMJFileInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType: string | null;

    @Field({ nullable: true })
    ProviderKey: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Files
//****************************************************************************
@InputType()
export class UpdateMJFileInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType?: string | null;

    @Field({ nullable: true })
    ProviderKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Files
//****************************************************************************
@ObjectType()
export class RunMJFileViewResult {
    @Field(() => [MJFile_])
    Results: MJFile_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFile_)
export class MJFileResolver extends ResolverBase {
    @Query(() => RunMJFileViewResult)
    async RunMJFileViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileViewResult)
    async RunMJFileViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileViewResult)
    async RunMJFileDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Files';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFile_, { nullable: true })
    async MJFile(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFile_ | null> {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Files', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJFileEntityRecordLink_])
    async FileEntityRecordLinks_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [FileID]='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('File Entity Record Links', rows);
        return result;
    }
        
    @Mutation(() => MJFile_)
    async CreateMJFile(
        @Arg('input', () => CreateMJFileInput) input: CreateMJFileInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Files', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFile_)
    async UpdateMJFile(
        @Arg('input', () => UpdateMJFileInput) input: UpdateMJFileInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Files', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFile_)
    async DeleteMJFile(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Files', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Generated Code Categories
//****************************************************************************
@ObjectType({ description: `Categorization for generated code, including optional parent-child relationships.` })
export class MJGeneratedCodeCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Parent category ID, allowing for hierarchical categorization.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [MJGeneratedCodeCategory_])
    GeneratedCodeCategories_ParentIDArray: MJGeneratedCodeCategory_[]; // Link to GeneratedCodeCategories
    
    @Field(() => [MJGeneratedCode_])
    GeneratedCodes_CategoryIDArray: MJGeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for Generated Code Categories
//****************************************************************************
@InputType()
export class CreateMJGeneratedCodeCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Generated Code Categories
//****************************************************************************
@InputType()
export class UpdateMJGeneratedCodeCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Generated Code Categories
//****************************************************************************
@ObjectType()
export class RunMJGeneratedCodeCategoryViewResult {
    @Field(() => [MJGeneratedCodeCategory_])
    Results: MJGeneratedCodeCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJGeneratedCodeCategory_)
export class MJGeneratedCodeCategoryResolver extends ResolverBase {
    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Generated Code Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJGeneratedCodeCategory_, { nullable: true })
    async MJGeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJGeneratedCodeCategory_ | null> {
        this.CheckUserReadPermissions('Generated Code Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodeCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Generated Code Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJGeneratedCodeCategory_])
    async GeneratedCodeCategories_ParentIDArray(@Root() mjgeneratedcodecategory_: MJGeneratedCodeCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Code Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodeCategories] WHERE [ParentID]='${mjgeneratedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Code Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async GeneratedCodes_CategoryIDArray(@Root() mjgeneratedcodecategory_: MJGeneratedCodeCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [CategoryID]='${mjgeneratedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows);
        return result;
    }
        
    @Mutation(() => MJGeneratedCodeCategory_)
    async CreateMJGeneratedCodeCategory(
        @Arg('input', () => CreateMJGeneratedCodeCategoryInput) input: CreateMJGeneratedCodeCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Generated Code Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJGeneratedCodeCategory_)
    async UpdateMJGeneratedCodeCategory(
        @Arg('input', () => UpdateMJGeneratedCodeCategoryInput) input: UpdateMJGeneratedCodeCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Generated Code Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJGeneratedCodeCategory_)
    async DeleteMJGeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Generated Code Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Generated Codes
//****************************************************************************
@ObjectType({ description: `Stores LLM-generated code snippets, tracking their source, category, and validation status.` })
export class MJGeneratedCode_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `When the code was generated.`}) 
    @MaxLength(10)
    GeneratedAt: Date;
        
    @Field({description: `Reference to the category of generated code.`}) 
    @MaxLength(16)
    CategoryID: string;
        
    @Field({description: `AI model responsible for generating this code.`}) 
    @MaxLength(16)
    GeneratedByModelID: string;
        
    @Field({description: `Descriptive name of the generated code.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the generated code.`}) 
    Description?: string;
        
    @Field({description: `The actual generated code.`}) 
    Code: string;
        
    @Field({description: `Source material used to generate the code, e.g., a SQL CHECK constraint.`}) 
    Source: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true}) 
    LinkedRecordPrimaryKey?: string;
        
    @Field({description: `Status of the generated code, e.g., Pending, Approved, or Rejected.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Programming language of the generated code (TypeScript, SQL, HTML, CSS, JavaScript, Python, or Other).`}) 
    @MaxLength(100)
    Language: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Category: string;
        
    @Field() 
    @MaxLength(100)
    GeneratedByModel: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LinkedEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Generated Codes
//****************************************************************************
@InputType()
export class CreateMJGeneratedCodeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;
}
    

//****************************************************************************
// INPUT TYPE for Generated Codes
//****************************************************************************
@InputType()
export class UpdateMJGeneratedCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Generated Codes
//****************************************************************************
@ObjectType()
export class RunMJGeneratedCodeViewResult {
    @Field(() => [MJGeneratedCode_])
    Results: MJGeneratedCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJGeneratedCode_)
export class MJGeneratedCodeResolver extends ResolverBase {
    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Generated Codes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJGeneratedCode_, { nullable: true })
    async MJGeneratedCode(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJGeneratedCode_ | null> {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Generated Codes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJGeneratedCode_)
    async CreateMJGeneratedCode(
        @Arg('input', () => CreateMJGeneratedCodeInput) input: CreateMJGeneratedCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Generated Codes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJGeneratedCode_)
    async UpdateMJGeneratedCode(
        @Arg('input', () => UpdateMJGeneratedCodeInput) input: UpdateMJGeneratedCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Generated Codes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJGeneratedCode_)
    async DeleteMJGeneratedCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Generated Codes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Integration URL Formats
//****************************************************************************
@ObjectType({ description: `Used to generate web links for end users to easily access resources in a source system. URL Formats support templating to inject various field values at run-time to take a user directly to a resource in a source system.` })
export class MJIntegrationURLFormat_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    IntegrationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The URL Format for the given integration including the ability to include markup with fields from the integration`}) 
    @MaxLength(1000)
    URLFormat: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    NavigationBaseURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    FullURLFormat?: string;
        
}

//****************************************************************************
// INPUT TYPE for Integration URL Formats
//****************************************************************************
@InputType()
export class UpdateMJIntegrationURLFormatInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    URLFormat?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Integration URL Formats
//****************************************************************************
@ObjectType()
export class RunMJIntegrationURLFormatViewResult {
    @Field(() => [MJIntegrationURLFormat_])
    Results: MJIntegrationURLFormat_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJIntegrationURLFormat_)
export class MJIntegrationURLFormatResolver extends ResolverBase {
    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Integration URL Formats';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJIntegrationURLFormat_, { nullable: true })
    async MJIntegrationURLFormat(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJIntegrationURLFormat_ | null> {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Integration URL Formats', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJIntegrationURLFormat_])
    async AllIntegrationURLFormats(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats]` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows);
        return result;
    }
    
    @Mutation(() => MJIntegrationURLFormat_)
    async UpdateMJIntegrationURLFormat(
        @Arg('input', () => UpdateMJIntegrationURLFormatInput) input: UpdateMJIntegrationURLFormatInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Integration URL Formats', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJIntegrationURLFormat_)
    async DeleteMJIntegrationURLFormat(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Integration URL Formats', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Integrations
//****************************************************************************
@ObjectType({ description: `Catalog of all integrations that have been configured in the system.` })
export class MJIntegration_ {
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    NavigationBaseURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ImportPath?: string;
        
    @Field(() => Int) 
    BatchMaxRequestCount: number;
        
    @Field(() => Int) 
    BatchRequestWaitTime: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field(() => [MJIntegrationURLFormat_])
    IntegrationURLFormats_IntegrationIDArray: MJIntegrationURLFormat_[]; // Link to IntegrationURLFormats
    
    @Field(() => [MJCompanyIntegration_])
    CompanyIntegrations_IntegrationNameArray: MJCompanyIntegration_[]; // Link to CompanyIntegrations
    
    @Field(() => [MJRecordChange_])
    RecordChanges_IntegrationIDArray: MJRecordChange_[]; // Link to RecordChanges
    
}

//****************************************************************************
// INPUT TYPE for Integrations
//****************************************************************************
@InputType()
export class UpdateMJIntegrationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    NavigationBaseURL?: string | null;

    @Field({ nullable: true })
    ClassName?: string | null;

    @Field({ nullable: true })
    ImportPath?: string | null;

    @Field(() => Int, { nullable: true })
    BatchMaxRequestCount?: number;

    @Field(() => Int, { nullable: true })
    BatchRequestWaitTime?: number;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Integrations
//****************************************************************************
@ObjectType()
export class RunMJIntegrationViewResult {
    @Field(() => [MJIntegration_])
    Results: MJIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJIntegration_)
export class MJIntegrationResolver extends ResolverBase {
    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJIntegration_, { nullable: true })
    async MJIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJIntegration_ | null> {
        this.CheckUserReadPermissions('Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Integrations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJIntegration_])
    async AllIntegrations(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrations]` + this.getRowLevelSecurityWhereClause(provider, 'Integrations', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Integrations', rows);
        return result;
    }
    
    @FieldResolver(() => [MJIntegrationURLFormat_])
    async IntegrationURLFormats_IntegrationIDArray(@Root() mjintegration_: MJIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [IntegrationID]='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegration_])
    async CompanyIntegrations_IntegrationNameArray(@Root() mjintegration_: MJIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [IntegrationName]='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integrations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async RecordChanges_IntegrationIDArray(@Root() mjintegration_: MJIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [IntegrationID]='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', rows);
        return result;
    }
        
    @Mutation(() => MJIntegration_)
    async UpdateMJIntegration(
        @Arg('input', () => UpdateMJIntegrationInput) input: UpdateMJIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJIntegration_)
    async DeleteMJIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Libraries
//****************************************************************************
@ObjectType({ description: `Stores information about the available libraries, including a list of classes/functions, type definitions, and sample code. You can add additional custom libraries here to make them avaialable to code generation features within the system.` })
export class MJLibrary_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Status of the library, only libraries marked as Active will be available for use by generated code. If a library was once active but no longer is, existing code that used the library will not be affected.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Code showing the types and functions defined in the library to be used for reference by humans and AI`}) 
    TypeDefinitions?: string;
        
    @Field({nullable: true, description: `Examples of code use of the classes and/or functions from within the library`}) 
    SampleCode?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJActionLibrary_])
    ActionLibraries_LibraryIDArray: MJActionLibrary_[]; // Link to ActionLibraries
    
    @Field(() => [MJLibraryItem_])
    LibraryItems_LibraryIDArray: MJLibraryItem_[]; // Link to LibraryItems
    
}

//****************************************************************************
// INPUT TYPE for Libraries
//****************************************************************************
@InputType()
export class CreateMJLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions: string | null;

    @Field({ nullable: true })
    SampleCode: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Libraries
//****************************************************************************
@InputType()
export class UpdateMJLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions?: string | null;

    @Field({ nullable: true })
    SampleCode?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Libraries
//****************************************************************************
@ObjectType()
export class RunMJLibraryViewResult {
    @Field(() => [MJLibrary_])
    Results: MJLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJLibrary_)
export class MJLibraryResolver extends ResolverBase {
    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJLibrary_, { nullable: true })
    async MJLibrary(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJLibrary_ | null> {
        this.CheckUserReadPermissions('Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Libraries', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJActionLibrary_])
    async ActionLibraries_LibraryIDArray(@Root() mjlibrary_: MJLibrary_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [LibraryID]='${mjlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Libraries', rows);
        return result;
    }
        
    @FieldResolver(() => [MJLibraryItem_])
    async LibraryItems_LibraryIDArray(@Root() mjlibrary_: MJLibrary_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Library Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraryItems] WHERE [LibraryID]='${mjlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Library Items', rows);
        return result;
    }
        
    @Mutation(() => MJLibrary_)
    async CreateMJLibrary(
        @Arg('input', () => CreateMJLibraryInput) input: CreateMJLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJLibrary_)
    async UpdateMJLibrary(
        @Arg('input', () => UpdateMJLibraryInput) input: UpdateMJLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJLibrary_)
    async DeleteMJLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Library Items
//****************************************************************************
@ObjectType({ description: `Table to store individual library items` })
export class MJLibraryItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field() 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({description: `Type of the library item for example Class, Interface, etc.`}) 
    @MaxLength(100)
    Type: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for Library Items
//****************************************************************************
@InputType()
export class CreateMJLibraryItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;
}
    

//****************************************************************************
// INPUT TYPE for Library Items
//****************************************************************************
@InputType()
export class UpdateMJLibraryItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Library Items
//****************************************************************************
@ObjectType()
export class RunMJLibraryItemViewResult {
    @Field(() => [MJLibraryItem_])
    Results: MJLibraryItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJLibraryItem_)
export class MJLibraryItemResolver extends ResolverBase {
    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Library Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJLibraryItem_, { nullable: true })
    async MJLibraryItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJLibraryItem_ | null> {
        this.CheckUserReadPermissions('Library Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraryItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Library Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJLibraryItem_)
    async CreateMJLibraryItem(
        @Arg('input', () => CreateMJLibraryItemInput) input: CreateMJLibraryItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Library Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJLibraryItem_)
    async UpdateMJLibraryItem(
        @Arg('input', () => UpdateMJLibraryItemInput) input: UpdateMJLibraryItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Library Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJLibraryItem_)
    async DeleteMJLibraryItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Library Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for List Categories
//****************************************************************************
@ObjectType()
export class MJListCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJListCategory_])
    ListCategories_ParentIDArray: MJListCategory_[]; // Link to ListCategories
    
    @Field(() => [MJList_])
    Lists_CategoryIDArray: MJList_[]; // Link to Lists
    
}

//****************************************************************************
// INPUT TYPE for List Categories
//****************************************************************************
@InputType()
export class CreateMJListCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for List Categories
//****************************************************************************
@InputType()
export class UpdateMJListCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for List Categories
//****************************************************************************
@ObjectType()
export class RunMJListCategoryViewResult {
    @Field(() => [MJListCategory_])
    Results: MJListCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListCategory_)
export class MJListCategoryResolver extends ResolverBase {
    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'List Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListCategory_, { nullable: true })
    async MJListCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListCategory_ | null> {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('List Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJListCategory_])
    async ListCategories_ParentIDArray(@Root() mjlistcategory_: MJListCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [ParentID]='${mjlistcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('List Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async Lists_CategoryIDArray(@Root() mjlistcategory_: MJListCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [CategoryID]='${mjlistcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', rows);
        return result;
    }
        
    @Mutation(() => MJListCategory_)
    async CreateMJListCategory(
        @Arg('input', () => CreateMJListCategoryInput) input: CreateMJListCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('List Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListCategory_)
    async UpdateMJListCategory(
        @Arg('input', () => UpdateMJListCategoryInput) input: UpdateMJListCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('List Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListCategory_)
    async DeleteMJListCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('List Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for List Details
//****************************************************************************
@ObjectType({ description: `Tracks the records within each list.` })
export class MJListDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ListID: string;
        
    @Field() 
    @MaxLength(890)
    RecordID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    List: string;
        
    @Field({description: `Tracks the status of each individual list detail row to enable processing of various types and the use of the status column for filtering list detail rows within a list that are in a particular state.`}) 
    @MaxLength(60)
    Status: string;
        
    @Field({nullable: true, description: `Optional column that allows for tracking any additional data for each ListDetail row`}) 
    AdditionalData?: string;
        
}

//****************************************************************************
// INPUT TYPE for List Details
//****************************************************************************
@InputType()
export class CreateMJListDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for List Details
//****************************************************************************
@InputType()
export class UpdateMJListDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for List Details
//****************************************************************************
@ObjectType()
export class RunMJListDetailViewResult {
    @Field(() => [MJListDetail_])
    Results: MJListDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListDetail_)
export class MJListDetailResolver extends ResolverBase {
    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'List Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListDetail_, { nullable: true })
    async MJListDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListDetail_ | null> {
        this.CheckUserReadPermissions('List Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('List Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJListDetail_)
    async CreateMJListDetail(
        @Arg('input', () => CreateMJListDetailInput) input: CreateMJListDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('List Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListDetail_)
    async UpdateMJListDetail(
        @Arg('input', () => UpdateMJListDetailInput) input: UpdateMJListDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('List Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListDetail_)
    async DeleteMJListDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('List Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Lists
//****************************************************************************
@ObjectType({ description: `Static lists are useful for controlling a set of data for a given entity. These can be used programatically for applications like logging and tracking long-running tasks and also by end users for tracking any particular list of records they want to directly control the set.` })
export class MJList_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ExternalSystemRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field(() => [MJListDetail_])
    ListDetails_ListIDArray: MJListDetail_[]; // Link to ListDetails
    
    @Field(() => [MJDuplicateRun_])
    DuplicateRuns_SourceListIDArray: MJDuplicateRun_[]; // Link to DuplicateRuns
    
}

//****************************************************************************
// INPUT TYPE for Lists
//****************************************************************************
@InputType()
export class CreateMJListInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Lists
//****************************************************************************
@InputType()
export class UpdateMJListInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Lists
//****************************************************************************
@ObjectType()
export class RunMJListViewResult {
    @Field(() => [MJList_])
    Results: MJList_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJList_)
export class MJListResolver extends ResolverBase {
    @Query(() => RunMJListViewResult)
    async RunMJListViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListViewResult)
    async RunMJListViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListViewResult)
    async RunMJListDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Lists';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJList_, { nullable: true })
    async MJList(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJList_ | null> {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Lists', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJListDetail_])
    async ListDetails_ListIDArray(@Root() mjlist_: MJList_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListDetails] WHERE [ListID]='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('List Details', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async DuplicateRuns_SourceListIDArray(@Root() mjlist_: MJList_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [SourceListID]='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows);
        return result;
    }
        
    @Mutation(() => MJList_)
    async CreateMJList(
        @Arg('input', () => CreateMJListInput) input: CreateMJListInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Lists', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJList_)
    async UpdateMJList(
        @Arg('input', () => UpdateMJListInput) input: UpdateMJListInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Lists', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJList_)
    async DeleteMJList(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Lists', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Types
//****************************************************************************
@ObjectType({ description: `Defines the types of artifacts that can be created within conversations` })
export class MJArtifactType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the artifact type`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the artifact type`}) 
    Description?: string;
        
    @Field({description: `MIME type or content identifier for this artifact type`}) 
    @MaxLength(200)
    ContentType: string;
        
    @Field(() => Boolean, {description: `Indicates if this artifact type is currently available for use`}) 
    IsEnabled: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJConversationArtifact_])
    MJ_ConversationArtifacts_ArtifactTypeIDArray: MJConversationArtifact_[]; // Link to MJ_ConversationArtifacts
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class CreateMJArtifactTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class UpdateMJArtifactTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Types
//****************************************************************************
@ObjectType()
export class RunMJArtifactTypeViewResult {
    @Field(() => [MJArtifactType_])
    Results: MJArtifactType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactType_)
export class MJArtifactTypeResolver extends ResolverBase {
    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactType_, { nullable: true })
    async MJArtifactType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactType_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Artifact Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJConversationArtifact_])
    async MJ_ConversationArtifacts_ArtifactTypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ArtifactTypeID]='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows);
        return result;
    }
        
    @Mutation(() => MJArtifactType_)
    async CreateMJArtifactType(
        @Arg('input', () => CreateMJArtifactTypeInput) input: CreateMJArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactType_)
    async UpdateMJArtifactType(
        @Arg('input', () => UpdateMJArtifactTypeInput) input: UpdateMJArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactType_)
    async DeleteMJArtifactType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for conversation artifacts` })
export class MJConversationArtifactPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the artifact this permission applies to`}) 
    @MaxLength(16)
    ConversationArtifactID: string;
        
    @Field({description: `User this permission applies to`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Level of access granted (Read, Edit, Owner)`}) 
    @MaxLength(40)
    AccessLevel: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ConversationArtifact: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactPermissionViewResult {
    @Field(() => [MJConversationArtifactPermission_])
    Results: MJConversationArtifactPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifactPermission_)
export class MJConversationArtifactPermissionResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifactPermission_, { nullable: true })
    async MJConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifactPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJConversationArtifactPermission_)
    async CreateMJConversationArtifactPermission(
        @Arg('input', () => CreateMJConversationArtifactPermissionInput) input: CreateMJConversationArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifact Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifactPermission_)
    async UpdateMJConversationArtifactPermission(
        @Arg('input', () => UpdateMJConversationArtifactPermissionInput) input: UpdateMJConversationArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifact Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifactPermission_)
    async DeleteMJConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType({ description: `Stores versions of conversation artifacts` })
export class MJConversationArtifactVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the parent artifact`}) 
    @MaxLength(16)
    ConversationArtifactID: string;
        
    @Field(() => Int, {description: `Sequential version number (starting from 1) for this artifact`}) 
    Version: number;
        
    @Field({description: `JSON configuration and metadata for this artifact version`}) 
    Configuration: string;
        
    @Field({nullable: true, description: `Actual content of the artifact, if stored separately from configuration`}) 
    Content?: string;
        
    @Field({nullable: true, description: `User comments specific to this version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ConversationArtifact: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactVersionViewResult {
    @Field(() => [MJConversationArtifactVersion_])
    Results: MJConversationArtifactVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifactVersion_)
export class MJConversationArtifactVersionResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifactVersion_, { nullable: true })
    async MJConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifactVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJConversationArtifactVersion_)
    async CreateMJConversationArtifactVersion(
        @Arg('input', () => CreateMJConversationArtifactVersionInput) input: CreateMJConversationArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifact Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifactVersion_)
    async UpdateMJConversationArtifactVersion(
        @Arg('input', () => UpdateMJConversationArtifactVersionInput) input: UpdateMJConversationArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifact Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifactVersion_)
    async DeleteMJConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType({ description: `Stores metadata for artifacts created within conversations` })
export class MJConversationArtifact_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the artifact`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Extended description of the artifact`}) 
    Description?: string;
        
    @Field({description: `Reference to the conversation this artifact belongs to`}) 
    @MaxLength(16)
    ConversationID: string;
        
    @Field({description: `Reference to the type of artifact`}) 
    @MaxLength(16)
    ArtifactTypeID: string;
        
    @Field({description: `Controls who can view this artifact (None, SpecificUsers, Everyone, Public)`}) 
    @MaxLength(100)
    SharingScope: string;
        
    @Field({nullable: true, description: `User comments about the artifact`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field() 
    @MaxLength(200)
    ArtifactType: string;
        
    @Field(() => [MJConversationArtifactPermission_])
    MJ_ConversationArtifactPermissions_ConversationArtifactIDArray: MJConversationArtifactPermission_[]; // Link to MJ_ConversationArtifactPermissions
    
    @Field(() => [MJConversationArtifactVersion_])
    MJ_ConversationArtifactVersions_ConversationArtifactIDArray: MJConversationArtifactVersion_[]; // Link to MJ_ConversationArtifactVersions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactViewResult {
    @Field(() => [MJConversationArtifact_])
    Results: MJConversationArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifact_)
export class MJConversationArtifactResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifact_, { nullable: true })
    async MJConversationArtifact(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJConversationArtifactPermission_])
    async MJ_ConversationArtifactPermissions_ConversationArtifactIDArray(@Root() mjconversationartifact_: MJConversationArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactPermissions] WHERE [ConversationArtifactID]='${mjconversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJConversationArtifactVersion_])
    async MJ_ConversationArtifactVersions_ConversationArtifactIDArray(@Root() mjconversationartifact_: MJConversationArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactVersions] WHERE [ConversationArtifactID]='${mjconversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', rows);
        return result;
    }
        
    @Mutation(() => MJConversationArtifact_)
    async CreateMJConversationArtifact(
        @Arg('input', () => CreateMJConversationArtifactInput) input: CreateMJConversationArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifact_)
    async UpdateMJConversationArtifact(
        @Arg('input', () => UpdateMJConversationArtifactInput) input: UpdateMJConversationArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifact_)
    async DeleteMJConversationArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report User States
//****************************************************************************
@ObjectType({ description: `Tracks individual user state within interactive reports` })
export class MJReportUserState_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `JSON serialized state of user interaction with the report`}) 
    ReportState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class CreateMJReportUserStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class UpdateMJReportUserStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report User States
//****************************************************************************
@ObjectType()
export class RunMJReportUserStateViewResult {
    @Field(() => [MJReportUserState_])
    Results: MJReportUserState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportUserState_)
export class MJReportUserStateResolver extends ResolverBase {
    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report User States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportUserState_, { nullable: true })
    async MJReportUserState(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportUserState_ | null> {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Report User States', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJReportUserState_)
    async CreateMJReportUserState(
        @Arg('input', () => CreateMJReportUserStateInput) input: CreateMJReportUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report User States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportUserState_)
    async UpdateMJReportUserState(
        @Arg('input', () => UpdateMJReportUserStateInput) input: UpdateMJReportUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report User States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportUserState_)
    async DeleteMJReportUserState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report User States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report Versions
//****************************************************************************
@ObjectType({ description: `Stores iterations of report logic, structure, and layout changes` })
export class MJReportVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field(() => Int, {description: `Report version number, sequential per report starting at 1`}) 
    VersionNumber: number;
        
    @Field({description: `Name of this report version`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of this report version`}) 
    Description?: string;
        
    @Field({nullable: true, description: `JSON configuration of report structure, layout and logic`}) 
    Configuration?: string;
        
    @Field(() => Boolean, {description: `Indicates if the data context was updated in this version`}) 
    DataContextUpdated: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class CreateMJReportVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class UpdateMJReportVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report Versions
//****************************************************************************
@ObjectType()
export class RunMJReportVersionViewResult {
    @Field(() => [MJReportVersion_])
    Results: MJReportVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportVersion_)
export class MJReportVersionResolver extends ResolverBase {
    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportVersion_, { nullable: true })
    async MJReportVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Report Versions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJReportVersion_)
    async CreateMJReportVersion(
        @Arg('input', () => CreateMJReportVersionInput) input: CreateMJReportVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportVersion_)
    async UpdateMJReportVersion(
        @Arg('input', () => UpdateMJReportVersionInput) input: UpdateMJReportVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportVersion_)
    async DeleteMJReportVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Output Delivery Types
//****************************************************************************
@ObjectType()
export class MJOutputDeliveryType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    Reports_OutputDeliveryTypeIDArray: MJReport_[]; // Link to Reports
    
}
//****************************************************************************
// RESOLVER for Output Delivery Types
//****************************************************************************
@ObjectType()
export class RunMJOutputDeliveryTypeViewResult {
    @Field(() => [MJOutputDeliveryType_])
    Results: MJOutputDeliveryType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputDeliveryType_)
export class MJOutputDeliveryTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Delivery Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputDeliveryType_, { nullable: true })
    async MJOutputDeliveryType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputDeliveryType_ | null> {
        this.CheckUserReadPermissions('Output Delivery Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputDeliveryTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Delivery Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Output Delivery Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_OutputDeliveryTypeIDArray(@Root() mjoutputdeliverytype_: MJOutputDeliveryType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputDeliveryTypeID]='${mjoutputdeliverytype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Output Format Types
//****************************************************************************
@ObjectType()
export class MJOutputFormatType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    DisplayFormat?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    Reports_OutputFormatTypeIDArray: MJReport_[]; // Link to Reports
    
}
//****************************************************************************
// RESOLVER for Output Format Types
//****************************************************************************
@ObjectType()
export class RunMJOutputFormatTypeViewResult {
    @Field(() => [MJOutputFormatType_])
    Results: MJOutputFormatType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputFormatType_)
export class MJOutputFormatTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Format Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputFormatType_, { nullable: true })
    async MJOutputFormatType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputFormatType_ | null> {
        this.CheckUserReadPermissions('Output Format Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputFormatTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Format Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Output Format Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_OutputFormatTypeIDArray(@Root() mjoutputformattype_: MJOutputFormatType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputFormatTypeID]='${mjoutputformattype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Output Trigger Types
//****************************************************************************
@ObjectType()
export class MJOutputTriggerType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    Reports_OutputTriggerTypeIDArray: MJReport_[]; // Link to Reports
    
}
//****************************************************************************
// RESOLVER for Output Trigger Types
//****************************************************************************
@ObjectType()
export class RunMJOutputTriggerTypeViewResult {
    @Field(() => [MJOutputTriggerType_])
    Results: MJOutputTriggerType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputTriggerType_)
export class MJOutputTriggerTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Trigger Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputTriggerType_, { nullable: true })
    async MJOutputTriggerType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputTriggerType_ | null> {
        this.CheckUserReadPermissions('Output Trigger Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputTriggerTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Trigger Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Output Trigger Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_OutputTriggerTypeIDArray(@Root() mjoutputtriggertype_: MJOutputTriggerType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputTriggerTypeID]='${mjoutputtriggertype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Queries
//****************************************************************************
@ObjectType({ description: `Catalog of stored queries. This is useful for any arbitrary query that is known to be performant and correct and can be reused. Queries can be viewed/run by a user, used programatically via RunQuery, and also used by AI systems for improved reliability instead of dynamically generated SQL. Queries can also improve security since they store the SQL instead of using dynamic SQL.` })
export class MJQuery_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true}) 
    UserQuestion?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    SQL?: string;
        
    @Field({nullable: true}) 
    TechnicalDescription?: string;
        
    @Field({nullable: true}) 
    OriginalSQL?: string;
        
    @Field({nullable: true}) 
    Feedback?: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Value indicating the quality of the query, higher values mean a better quality`}) 
    QualityRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Higher numbers indicate more execution overhead/time required. Useful for planning which queries to use in various scenarios.`}) 
    ExecutionCostRank?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Category?: string;
        
    @Field(() => [MJQueryField_])
    QueryFields_QueryIDArray: MJQueryField_[]; // Link to QueryFields
    
    @Field(() => [MJQueryPermission_])
    QueryPermissions_QueryIDArray: MJQueryPermission_[]; // Link to QueryPermissions
    
    @Field(() => [MJDataContextItem_])
    DataContextItems_QueryIDArray: MJDataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [MJQueryEntity_])
    QueryEntities_QueryIDArray: MJQueryEntity_[]; // Link to QueryEntities
    
}

//****************************************************************************
// INPUT TYPE for Queries
//****************************************************************************
@InputType()
export class CreateMJQueryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserQuestion: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    TechnicalDescription: string | null;

    @Field({ nullable: true })
    OriginalSQL: string | null;

    @Field({ nullable: true })
    Feedback: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Queries
//****************************************************************************
@InputType()
export class UpdateMJQueryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserQuestion?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    TechnicalDescription?: string | null;

    @Field({ nullable: true })
    OriginalSQL?: string | null;

    @Field({ nullable: true })
    Feedback?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queries
//****************************************************************************
@ObjectType()
export class RunMJQueryViewResult {
    @Field(() => [MJQuery_])
    Results: MJQuery_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQuery_)
export class MJQueryResolver extends ResolverBase {
    @Query(() => RunMJQueryViewResult)
    async RunMJQueryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryViewResult)
    async RunMJQueryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryViewResult)
    async RunMJQueryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQuery_, { nullable: true })
    async MJQuery(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQuery_ | null> {
        this.CheckUserReadPermissions('Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Queries', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJQueryField_])
    async QueryFields_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Fields', rows);
        return result;
    }
        
    @FieldResolver(() => [MJQueryPermission_])
    async QueryPermissions_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async DataContextItems_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows);
        return result;
    }
        
    @FieldResolver(() => [MJQueryEntity_])
    async QueryEntities_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Entities', rows);
        return result;
    }
        
    @Mutation(() => MJQuery_)
    async CreateMJQuery(
        @Arg('input', () => CreateMJQueryInput) input: CreateMJQueryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQuery_)
    async UpdateMJQuery(
        @Arg('input', () => UpdateMJQueryInput) input: UpdateMJQueryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQuery_)
    async DeleteMJQuery(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Categories
//****************************************************************************
@ObjectType()
export class MJQueryCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJQueryCategory_])
    QueryCategories_ParentIDArray: MJQueryCategory_[]; // Link to QueryCategories
    
    @Field(() => [MJQuery_])
    Queries_CategoryIDArray: MJQuery_[]; // Link to Queries
    
}

//****************************************************************************
// INPUT TYPE for Query Categories
//****************************************************************************
@InputType()
export class CreateMJQueryCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Query Categories
//****************************************************************************
@InputType()
export class UpdateMJQueryCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Categories
//****************************************************************************
@ObjectType()
export class RunMJQueryCategoryViewResult {
    @Field(() => [MJQueryCategory_])
    Results: MJQueryCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryCategory_)
export class MJQueryCategoryResolver extends ResolverBase {
    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryCategory_, { nullable: true })
    async MJQueryCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryCategory_ | null> {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Query Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJQueryCategory_])
    async QueryCategories_ParentIDArray(@Root() mjquerycategory_: MJQueryCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [ParentID]='${mjquerycategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJQuery_])
    async Queries_CategoryIDArray(@Root() mjquerycategory_: MJQueryCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [CategoryID]='${mjquerycategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Queries', rows);
        return result;
    }
        
    @Mutation(() => MJQueryCategory_)
    async CreateMJQueryCategory(
        @Arg('input', () => CreateMJQueryCategoryInput) input: CreateMJQueryCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryCategory_)
    async UpdateMJQueryCategory(
        @Arg('input', () => UpdateMJQueryCategoryInput) input: UpdateMJQueryCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryCategory_)
    async DeleteMJQueryCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Entities
//****************************************************************************
@ObjectType({ description: `Tracks which entities are involved in a given query. The Queries table stores SQL and descriptions for stored queries that can be executed and serve as examples for AI.` })
export class MJQueryEntity_ {
    @Field({description: `Unique identifier for the QueryEntity record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `References the ID of the query in the Queries table.`}) 
    @MaxLength(16)
    QueryID: string;
        
    @Field({description: `References the ID of the entity in the Entities table.`}) 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Entities
//****************************************************************************
@InputType()
export class CreateMJQueryEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Query Entities
//****************************************************************************
@InputType()
export class UpdateMJQueryEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Entities
//****************************************************************************
@ObjectType()
export class RunMJQueryEntityViewResult {
    @Field(() => [MJQueryEntity_])
    Results: MJQueryEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryEntity_)
export class MJQueryEntityResolver extends ResolverBase {
    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryEntity_, { nullable: true })
    async MJQueryEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryEntity_ | null> {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Query Entities', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJQueryEntity_)
    async CreateMJQueryEntity(
        @Arg('input', () => CreateMJQueryEntityInput) input: CreateMJQueryEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryEntity_)
    async UpdateMJQueryEntity(
        @Arg('input', () => UpdateMJQueryEntityInput) input: UpdateMJQueryEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryEntity_)
    async DeleteMJQueryEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Fields
//****************************************************************************
@ObjectType()
export class MJQueryField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field({description: `The base type, not including parameters, in SQL. For example this field would be nvarchar or decimal, and wouldn't include type parameters. The SQLFullType field provides that information.`}) 
    @MaxLength(100)
    SQLBaseType: string;
        
    @Field({description: `The full SQL type for the field, for example datetime or nvarchar(10) etc.`}) 
    @MaxLength(200)
    SQLFullType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SourceEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceFieldName?: string;
        
    @Field(() => Boolean) 
    IsComputed: boolean;
        
    @Field({nullable: true}) 
    ComputationDescription?: string;
        
    @Field(() => Boolean) 
    IsSummary: boolean;
        
    @Field({nullable: true}) 
    SummaryDescription?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Fields
//****************************************************************************
@InputType()
export class CreateMJQueryFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID: string | null;

    @Field({ nullable: true })
    SourceFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Query Fields
//****************************************************************************
@InputType()
export class UpdateMJQueryFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID?: string | null;

    @Field({ nullable: true })
    SourceFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Fields
//****************************************************************************
@ObjectType()
export class RunMJQueryFieldViewResult {
    @Field(() => [MJQueryField_])
    Results: MJQueryField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryField_)
export class MJQueryFieldResolver extends ResolverBase {
    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryField_, { nullable: true })
    async MJQueryField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryField_ | null> {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Query Fields', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJQueryField_)
    async CreateMJQueryField(
        @Arg('input', () => CreateMJQueryFieldInput) input: CreateMJQueryFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryField_)
    async UpdateMJQueryField(
        @Arg('input', () => UpdateMJQueryFieldInput) input: UpdateMJQueryFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryField_)
    async DeleteMJQueryField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Permissions
//****************************************************************************
@ObjectType()
export class MJQueryPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Permissions
//****************************************************************************
@InputType()
export class CreateMJQueryPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Query Permissions
//****************************************************************************
@InputType()
export class UpdateMJQueryPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Permissions
//****************************************************************************
@ObjectType()
export class RunMJQueryPermissionViewResult {
    @Field(() => [MJQueryPermission_])
    Results: MJQueryPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryPermission_)
export class MJQueryPermissionResolver extends ResolverBase {
    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryPermission_, { nullable: true })
    async MJQueryPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryPermission_ | null> {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Query Permissions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJQueryPermission_)
    async CreateMJQueryPermission(
        @Arg('input', () => CreateMJQueryPermissionInput) input: CreateMJQueryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryPermission_)
    async UpdateMJQueryPermission(
        @Arg('input', () => UpdateMJQueryPermissionInput) input: UpdateMJQueryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryPermission_)
    async DeleteMJQueryPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queue Tasks
//****************************************************************************
@ObjectType()
export class MJQueueTask_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueueID: string;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Data?: string;
        
    @Field({nullable: true}) 
    Options?: string;
        
    @Field({nullable: true}) 
    Output?: string;
        
    @Field({nullable: true}) 
    ErrorMessage?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Queue: string;
        
}

//****************************************************************************
// INPUT TYPE for Queue Tasks
//****************************************************************************
@InputType()
export class CreateMJQueueTaskInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Data: string | null;

    @Field({ nullable: true })
    Options: string | null;

    @Field({ nullable: true })
    Output: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Queue Tasks
//****************************************************************************
@InputType()
export class UpdateMJQueueTaskInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Data?: string | null;

    @Field({ nullable: true })
    Options?: string | null;

    @Field({ nullable: true })
    Output?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queue Tasks
//****************************************************************************
@ObjectType()
export class RunMJQueueTaskViewResult {
    @Field(() => [MJQueueTask_])
    Results: MJQueueTask_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueueTask_)
export class MJQueueTaskResolver extends ResolverBase {
    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queue Tasks';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueueTask_, { nullable: true })
    async MJQueueTask(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueueTask_ | null> {
        this.CheckUserReadPermissions('Queue Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTasks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Queue Tasks', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJQueueTask_)
    async CreateMJQueueTask(
        @Arg('input', () => CreateMJQueueTaskInput) input: CreateMJQueueTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queue Tasks', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueueTask_)
    async UpdateMJQueueTask(
        @Arg('input', () => UpdateMJQueueTaskInput) input: UpdateMJQueueTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queue Tasks', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queue Types
//****************************************************************************
@ObjectType()
export class MJQueueType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(200)
    DriverClass: string;
        
    @Field({nullable: true}) 
    @MaxLength(400)
    DriverImportPath?: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJQueue_])
    Queues_QueueTypeIDArray: MJQueue_[]; // Link to Queues
    
}
//****************************************************************************
// RESOLVER for Queue Types
//****************************************************************************
@ObjectType()
export class RunMJQueueTypeViewResult {
    @Field(() => [MJQueueType_])
    Results: MJQueueType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueueType_)
export class MJQueueTypeResolver extends ResolverBase {
    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queue Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueueType_, { nullable: true })
    async MJQueueType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueueType_ | null> {
        this.CheckUserReadPermissions('Queue Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Queue Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJQueue_])
    async Queues_QueueTypeIDArray(@Root() mjqueuetype_: MJQueueType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queues', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueues] WHERE [QueueTypeID]='${mjqueuetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queues', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Queues', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Queues
//****************************************************************************
@ObjectType({ description: `Queues can be used to async execute long running tasks` })
export class MJQueue_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    QueueTypeID: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field(() => Int, {nullable: true}) 
    ProcessPID?: number;
        
    @Field({nullable: true}) 
    @MaxLength(60)
    ProcessPlatform?: string;
        
    @Field({nullable: true}) 
    @MaxLength(30)
    ProcessVersion?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ProcessCwd?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ProcessIPAddress?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ProcessMacAddress?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    ProcessOSName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(20)
    ProcessOSVersion?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ProcessHostName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    ProcessUserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ProcessUserName?: string;
        
    @Field() 
    @MaxLength(8)
    LastHeartbeat: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    QueueType: string;
        
    @Field(() => [MJQueueTask_])
    QueueTasks_QueueIDArray: MJQueueTask_[]; // Link to QueueTasks
    
}

//****************************************************************************
// INPUT TYPE for Queues
//****************************************************************************
@InputType()
export class CreateMJQueueInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID: number | null;

    @Field({ nullable: true })
    ProcessPlatform: string | null;

    @Field({ nullable: true })
    ProcessVersion: string | null;

    @Field({ nullable: true })
    ProcessCwd: string | null;

    @Field({ nullable: true })
    ProcessIPAddress: string | null;

    @Field({ nullable: true })
    ProcessMacAddress: string | null;

    @Field({ nullable: true })
    ProcessOSName: string | null;

    @Field({ nullable: true })
    ProcessOSVersion: string | null;

    @Field({ nullable: true })
    ProcessHostName: string | null;

    @Field({ nullable: true })
    ProcessUserID: string | null;

    @Field({ nullable: true })
    ProcessUserName: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Queues
//****************************************************************************
@InputType()
export class UpdateMJQueueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID?: number | null;

    @Field({ nullable: true })
    ProcessPlatform?: string | null;

    @Field({ nullable: true })
    ProcessVersion?: string | null;

    @Field({ nullable: true })
    ProcessCwd?: string | null;

    @Field({ nullable: true })
    ProcessIPAddress?: string | null;

    @Field({ nullable: true })
    ProcessMacAddress?: string | null;

    @Field({ nullable: true })
    ProcessOSName?: string | null;

    @Field({ nullable: true })
    ProcessOSVersion?: string | null;

    @Field({ nullable: true })
    ProcessHostName?: string | null;

    @Field({ nullable: true })
    ProcessUserID?: string | null;

    @Field({ nullable: true })
    ProcessUserName?: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queues
//****************************************************************************
@ObjectType()
export class RunMJQueueViewResult {
    @Field(() => [MJQueue_])
    Results: MJQueue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueue_)
export class MJQueueResolver extends ResolverBase {
    @Query(() => RunMJQueueViewResult)
    async RunMJQueueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueViewResult)
    async RunMJQueueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueViewResult)
    async RunMJQueueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queues';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueue_, { nullable: true })
    async MJQueue(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueue_ | null> {
        this.CheckUserReadPermissions('Queues', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueues] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queues', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Queues', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJQueueTask_])
    async QueueTasks_QueueIDArray(@Root() mjqueue_: MJQueue_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queue Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTasks] WHERE [QueueID]='${mjqueue_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Queue Tasks', rows);
        return result;
    }
        
    @Mutation(() => MJQueue_)
    async CreateMJQueue(
        @Arg('input', () => CreateMJQueueInput) input: CreateMJQueueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queues', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueue_)
    async UpdateMJQueue(
        @Arg('input', () => UpdateMJQueueInput) input: UpdateMJQueueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queues', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Items
//****************************************************************************
@ObjectType({ description: `Table to store individual recommendation items that are the right side of the recommendation which we track in the DestinationEntityID/DestinationEntityRecordID` })
export class MJRecommendationItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationID: string;
        
    @Field() 
    @MaxLength(16)
    DestinationEntityID: string;
        
    @Field({description: `The record ID of the destination entity`}) 
    @MaxLength(900)
    DestinationEntityRecordID: string;
        
    @Field(() => Float, {nullable: true, description: `A value between 0 and 1 indicating the probability of the match, higher numbers indicating a more certain match/recommendation.`}) 
    MatchProbability?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    DestinationEntity: string;
        
}

//****************************************************************************
// INPUT TYPE for Recommendation Items
//****************************************************************************
@InputType()
export class CreateMJRecommendationItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Items
//****************************************************************************
@InputType()
export class UpdateMJRecommendationItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Items
//****************************************************************************
@ObjectType()
export class RunMJRecommendationItemViewResult {
    @Field(() => [MJRecommendationItem_])
    Results: MJRecommendationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationItem_)
export class MJRecommendationItemResolver extends ResolverBase {
    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationItem_, { nullable: true })
    async MJRecommendationItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationItem_ | null> {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Recommendation Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJRecommendationItem_)
    async CreateMJRecommendationItem(
        @Arg('input', () => CreateMJRecommendationItemInput) input: CreateMJRecommendationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationItem_)
    async UpdateMJRecommendationItem(
        @Arg('input', () => UpdateMJRecommendationItemInput) input: UpdateMJRecommendationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Items', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Providers
//****************************************************************************
@ObjectType({ description: `Recommendation providers details` })
export class MJRecommendationProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJRecommendationRun_])
    RecommendationRuns_RecommendationProviderIDArray: MJRecommendationRun_[]; // Link to RecommendationRuns
    
}

//****************************************************************************
// INPUT TYPE for Recommendation Providers
//****************************************************************************
@InputType()
export class CreateMJRecommendationProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Providers
//****************************************************************************
@InputType()
export class UpdateMJRecommendationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Providers
//****************************************************************************
@ObjectType()
export class RunMJRecommendationProviderViewResult {
    @Field(() => [MJRecommendationProvider_])
    Results: MJRecommendationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationProvider_)
export class MJRecommendationProviderResolver extends ResolverBase {
    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationProvider_, { nullable: true })
    async MJRecommendationProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationProvider_ | null> {
        this.CheckUserReadPermissions('Recommendation Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Recommendation Providers', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJRecommendationRun_])
    async RecommendationRuns_RecommendationProviderIDArray(@Root() mjrecommendationprovider_: MJRecommendationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [RecommendationProviderID]='${mjrecommendationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Runs', rows);
        return result;
    }
        
    @Mutation(() => MJRecommendationProvider_)
    async CreateMJRecommendationProvider(
        @Arg('input', () => CreateMJRecommendationProviderInput) input: CreateMJRecommendationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationProvider_)
    async UpdateMJRecommendationProvider(
        @Arg('input', () => UpdateMJRecommendationProviderInput) input: UpdateMJRecommendationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendationProvider_)
    async DeleteMJRecommendationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendation Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Runs
//****************************************************************************
@ObjectType({ description: `Recommendation runs log each time a provider is requested to provide recommendations` })
export class MJRecommendationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationProviderID: string;
        
    @Field({description: `The start date of the recommendation run`}) 
    @MaxLength(8)
    StartDate: Date;
        
    @Field({nullable: true, description: `The end date of the recommendation run`}) 
    @MaxLength(8)
    EndDate?: Date;
        
    @Field({description: `The status of the recommendation run`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    RecommendationProvider: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [MJRecommendation_])
    Recommendations_RecommendationRunIDArray: MJRecommendation_[]; // Link to Recommendations
    
}

//****************************************************************************
// INPUT TYPE for Recommendation Runs
//****************************************************************************
@InputType()
export class CreateMJRecommendationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Runs
//****************************************************************************
@InputType()
export class UpdateMJRecommendationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Runs
//****************************************************************************
@ObjectType()
export class RunMJRecommendationRunViewResult {
    @Field(() => [MJRecommendationRun_])
    Results: MJRecommendationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationRun_)
export class MJRecommendationRunResolver extends ResolverBase {
    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationRun_, { nullable: true })
    async MJRecommendationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationRun_ | null> {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Recommendation Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJRecommendation_])
    async Recommendations_RecommendationRunIDArray(@Root() mjrecommendationrun_: MJRecommendationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [RecommendationRunID]='${mjrecommendationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendations', rows);
        return result;
    }
        
    @Mutation(() => MJRecommendationRun_)
    async CreateMJRecommendationRun(
        @Arg('input', () => CreateMJRecommendationRunInput) input: CreateMJRecommendationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationRun_)
    async UpdateMJRecommendationRun(
        @Arg('input', () => UpdateMJRecommendationRunInput) input: UpdateMJRecommendationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Runs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendations
//****************************************************************************
@ObjectType({ description: `Recommendation headers that store the left side of the recommendation which we track in the SourceEntityID/SourceEntityRecordID` })
export class MJRecommendation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationRunID: string;
        
    @Field() 
    @MaxLength(16)
    SourceEntityID: string;
        
    @Field({description: `The record ID of the source entity`}) 
    SourceEntityRecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    SourceEntity: string;
        
    @Field(() => [MJRecommendationItem_])
    RecommendationItems_RecommendationIDArray: MJRecommendationItem_[]; // Link to RecommendationItems
    
}

//****************************************************************************
// INPUT TYPE for Recommendations
//****************************************************************************
@InputType()
export class CreateMJRecommendationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Recommendations
//****************************************************************************
@InputType()
export class UpdateMJRecommendationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendations
//****************************************************************************
@ObjectType()
export class RunMJRecommendationViewResult {
    @Field(() => [MJRecommendation_])
    Results: MJRecommendation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendation_)
export class MJRecommendationResolver extends ResolverBase {
    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendation_, { nullable: true })
    async MJRecommendation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendation_ | null> {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Recommendations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJRecommendationItem_])
    async RecommendationItems_RecommendationIDArray(@Root() mjrecommendation_: MJRecommendation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [RecommendationID]='${mjrecommendation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Items', rows);
        return result;
    }
        
    @Mutation(() => MJRecommendation_)
    async CreateMJRecommendation(
        @Arg('input', () => CreateMJRecommendationInput) input: CreateMJRecommendationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendation_)
    async UpdateMJRecommendation(
        @Arg('input', () => UpdateMJRecommendationInput) input: UpdateMJRecommendationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendations', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Change Replay Runs
//****************************************************************************
@ObjectType({ description: `Table to track the runs of replaying external record changes` })
export class MJRecordChangeReplayRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Timestamp when the replay run started`}) 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the replay run ended`}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({description: `Status of the replay run (Pending, In Progress, Complete, Error)`}) 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJRecordChange_])
    RecordChanges_ReplayRunIDArray: MJRecordChange_[]; // Link to RecordChanges
    
}

//****************************************************************************
// INPUT TYPE for Record Change Replay Runs
//****************************************************************************
@InputType()
export class CreateMJRecordChangeReplayRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Record Change Replay Runs
//****************************************************************************
@InputType()
export class UpdateMJRecordChangeReplayRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Change Replay Runs
//****************************************************************************
@ObjectType()
export class RunMJRecordChangeReplayRunViewResult {
    @Field(() => [MJRecordChangeReplayRun_])
    Results: MJRecordChangeReplayRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordChangeReplayRun_)
export class MJRecordChangeReplayRunResolver extends ResolverBase {
    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Change Replay Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordChangeReplayRun_, { nullable: true })
    async MJRecordChangeReplayRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordChangeReplayRun_ | null> {
        this.CheckUserReadPermissions('Record Change Replay Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChangeReplayRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Record Change Replay Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJRecordChange_])
    async RecordChanges_ReplayRunIDArray(@Root() mjrecordchangereplayrun_: MJRecordChangeReplayRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [ReplayRunID]='${mjrecordchangereplayrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', rows);
        return result;
    }
        
    @Mutation(() => MJRecordChangeReplayRun_)
    async CreateMJRecordChangeReplayRun(
        @Arg('input', () => CreateMJRecordChangeReplayRunInput) input: CreateMJRecordChangeReplayRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Change Replay Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordChangeReplayRun_)
    async UpdateMJRecordChangeReplayRun(
        @Arg('input', () => UpdateMJRecordChangeReplayRunInput) input: UpdateMJRecordChangeReplayRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Change Replay Runs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Changes
//****************************************************************************
@ObjectType({ description: `For entities that have TrackRecordChanges=1, Record Changes will store the history of all changes made within the system. For integrations you can directly add values here if you have inbound signals indicating records were changed in a source system. This entity only automatically captures Record Changes if they were made within the system.` })
export class MJRecordChange_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Create, Update, or Delete`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({description: `Internal or External`}) 
    @MaxLength(40)
    Source: string;
        
    @Field({description: `The date/time that the change occured.`}) 
    @MaxLength(10)
    ChangedAt: Date;
        
    @Field({description: `JSON structure that describes what was changed in a structured format.`}) 
    ChangesJSON: string;
        
    @Field({description: `A generated, human-readable description of what was changed.`}) 
    ChangesDescription: string;
        
    @Field({description: `A complete snapshot of the record AFTER the change was applied in a JSON format that can be parsed.`}) 
    FullRecordJSON: string;
        
    @Field({description: `For internal record changes generated within MJ, the status is immediately Complete. For external changes that are detected, the workflow starts off as Pending, then In Progress and finally either Complete or Error`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    ErrorLog?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ReplayRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    IntegrationID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Integration?: string;
        
}

//****************************************************************************
// INPUT TYPE for Record Changes
//****************************************************************************
@InputType()
export class CreateMJRecordChangeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ReplayRunID: string | null;

    @Field({ nullable: true })
    IntegrationID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Changes
//****************************************************************************
@InputType()
export class UpdateMJRecordChangeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ReplayRunID?: string | null;

    @Field({ nullable: true })
    IntegrationID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Changes
//****************************************************************************
@ObjectType()
export class RunMJRecordChangeViewResult {
    @Field(() => [MJRecordChange_])
    Results: MJRecordChange_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordChange_)
export class MJRecordChangeResolver extends ResolverBase {
    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Changes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordChange_, { nullable: true })
    async MJRecordChange(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordChange_ | null> {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Record Changes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJRecordChange_)
    async CreateMJRecordChange(
        @Arg('input', () => CreateMJRecordChangeInput) input: CreateMJRecordChangeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Changes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordChange_)
    async UpdateMJRecordChange(
        @Arg('input', () => UpdateMJRecordChangeInput) input: UpdateMJRecordChangeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Changes', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Merge Deletion Logs
//****************************************************************************
@ObjectType()
export class MJRecordMergeDeletionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecordMergeLogID: string;
        
    @Field() 
    @MaxLength(1500)
    DeletedRecordID: string;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    ProcessingLog?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class CreateMJRecordMergeDeletionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class UpdateMJRecordMergeDeletionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Merge Deletion Logs
//****************************************************************************
@ObjectType()
export class RunMJRecordMergeDeletionLogViewResult {
    @Field(() => [MJRecordMergeDeletionLog_])
    Results: MJRecordMergeDeletionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordMergeDeletionLog_)
export class MJRecordMergeDeletionLogResolver extends ResolverBase {
    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Merge Deletion Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordMergeDeletionLog_, { nullable: true })
    async MJRecordMergeDeletionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordMergeDeletionLog_ | null> {
        this.CheckUserReadPermissions('Record Merge Deletion Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeDeletionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Record Merge Deletion Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJRecordMergeDeletionLog_)
    async CreateMJRecordMergeDeletionLog(
        @Arg('input', () => CreateMJRecordMergeDeletionLogInput) input: CreateMJRecordMergeDeletionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Merge Deletion Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordMergeDeletionLog_)
    async UpdateMJRecordMergeDeletionLog(
        @Arg('input', () => UpdateMJRecordMergeDeletionLogInput) input: UpdateMJRecordMergeDeletionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Merge Deletion Logs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Merge Logs
//****************************************************************************
@ObjectType()
export class MJRecordMergeLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    SurvivingRecordID: string;
        
    @Field() 
    @MaxLength(16)
    InitiatedByUserID: string;
        
    @Field() 
    @MaxLength(20)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ApprovedByUserID?: string;
        
    @Field() 
    @MaxLength(20)
    ProcessingStatus: string;
        
    @Field() 
    @MaxLength(8)
    ProcessingStartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    ProcessingEndedAt?: Date;
        
    @Field({nullable: true}) 
    ProcessingLog?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    InitiatedByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ApprovedByUser?: string;
        
    @Field(() => [MJRecordMergeDeletionLog_])
    RecordMergeDeletionLogs_RecordMergeLogIDArray: MJRecordMergeDeletionLog_[]; // Link to RecordMergeDeletionLogs
    
    @Field(() => [MJDuplicateRunDetailMatch_])
    DuplicateRunDetailMatches_RecordMergeLogIDArray: MJDuplicateRunDetailMatch_[]; // Link to DuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for Record Merge Logs
//****************************************************************************
@InputType()
export class CreateMJRecordMergeLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt: Date | null;

    @Field({ nullable: true })
    ProcessingLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Merge Logs
//****************************************************************************
@InputType()
export class UpdateMJRecordMergeLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt?: Date | null;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Merge Logs
//****************************************************************************
@ObjectType()
export class RunMJRecordMergeLogViewResult {
    @Field(() => [MJRecordMergeLog_])
    Results: MJRecordMergeLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordMergeLog_)
export class MJRecordMergeLogResolver extends ResolverBase {
    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Merge Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordMergeLog_, { nullable: true })
    async MJRecordMergeLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordMergeLog_ | null> {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Record Merge Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJRecordMergeDeletionLog_])
    async RecordMergeDeletionLogs_RecordMergeLogIDArray(@Root() mjrecordmergelog_: MJRecordMergeLog_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Deletion Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeDeletionLogs] WHERE [RecordMergeLogID]='${mjrecordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Deletion Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRunDetailMatch_])
    async DuplicateRunDetailMatches_RecordMergeLogIDArray(@Root() mjrecordmergelog_: MJRecordMergeLog_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [RecordMergeLogID]='${mjrecordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows);
        return result;
    }
        
    @Mutation(() => MJRecordMergeLog_)
    async CreateMJRecordMergeLog(
        @Arg('input', () => CreateMJRecordMergeLogInput) input: CreateMJRecordMergeLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Merge Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordMergeLog_)
    async UpdateMJRecordMergeLog(
        @Arg('input', () => UpdateMJRecordMergeLogInput) input: UpdateMJRecordMergeLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Merge Logs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Report Categories
//****************************************************************************
@ObjectType()
export class MJReportCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJReportCategory_])
    ReportCategories_ParentIDArray: MJReportCategory_[]; // Link to ReportCategories
    
    @Field(() => [MJReport_])
    Reports_CategoryIDArray: MJReport_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Report Categories
//****************************************************************************
@InputType()
export class CreateMJReportCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Report Categories
//****************************************************************************
@InputType()
export class UpdateMJReportCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Report Categories
//****************************************************************************
@ObjectType()
export class RunMJReportCategoryViewResult {
    @Field(() => [MJReportCategory_])
    Results: MJReportCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportCategory_)
export class MJReportCategoryResolver extends ResolverBase {
    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Report Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportCategory_, { nullable: true })
    async MJReportCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportCategory_ | null> {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Report Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJReportCategory_])
    async ReportCategories_ParentIDArray(@Root() mjreportcategory_: MJReportCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [ParentID]='${mjreportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Report Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_CategoryIDArray(@Root() mjreportcategory_: MJReportCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [CategoryID]='${mjreportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @Mutation(() => MJReportCategory_)
    async CreateMJReportCategory(
        @Arg('input', () => CreateMJReportCategoryInput) input: CreateMJReportCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Report Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportCategory_)
    async UpdateMJReportCategory(
        @Arg('input', () => UpdateMJReportCategoryInput) input: UpdateMJReportCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Report Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportCategory_)
    async DeleteMJReportCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Report Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Report Snapshots
//****************************************************************************
@ObjectType()
export class MJReportSnapshot_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field() 
    ResultSet: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for Report Snapshots
//****************************************************************************
@InputType()
export class CreateMJReportSnapshotInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Report Snapshots
//****************************************************************************
@InputType()
export class UpdateMJReportSnapshotInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Report Snapshots
//****************************************************************************
@ObjectType()
export class RunMJReportSnapshotViewResult {
    @Field(() => [MJReportSnapshot_])
    Results: MJReportSnapshot_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportSnapshot_)
export class MJReportSnapshotResolver extends ResolverBase {
    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Report Snapshots';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportSnapshot_, { nullable: true })
    async MJReportSnapshot(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportSnapshot_ | null> {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Report Snapshots', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJReportSnapshot_)
    async CreateMJReportSnapshot(
        @Arg('input', () => CreateMJReportSnapshotInput) input: CreateMJReportSnapshotInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Report Snapshots', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportSnapshot_)
    async UpdateMJReportSnapshot(
        @Arg('input', () => UpdateMJReportSnapshotInput) input: UpdateMJReportSnapshotInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Report Snapshots', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportSnapshot_)
    async DeleteMJReportSnapshot(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Report Snapshots', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Reports
//****************************************************************************
@ObjectType()
export class MJReport_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(40)
    SharingScope: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DataContextID?: string;
        
    @Field({nullable: true}) 
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputTriggerTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputFormatTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputDeliveryTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OutputFrequency?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputTargetEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputWorkflowID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DataContext?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputTriggerType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputFormatType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputDeliveryType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    OutputWorkflow?: string;
        
    @Field(() => [MJReportSnapshot_])
    ReportSnapshots_ReportIDArray: MJReportSnapshot_[]; // Link to ReportSnapshots
    
    @Field(() => [MJReportVersion_])
    MJ_ReportVersions_ReportIDArray: MJReportVersion_[]; // Link to MJ_ReportVersions
    
    @Field(() => [MJReportUserState_])
    MJ_ReportUserStates_ReportIDArray: MJReportUserState_[]; // Link to MJ_ReportUserStates
    
}

//****************************************************************************
// INPUT TYPE for Reports
//****************************************************************************
@InputType()
export class CreateMJReportInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID: string | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID: string | null;

    @Field({ nullable: true })
    OutputFrequency: string | null;

    @Field({ nullable: true })
    OutputTargetEmail: string | null;

    @Field({ nullable: true })
    OutputWorkflowID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Reports
//****************************************************************************
@InputType()
export class UpdateMJReportInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID?: string | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID?: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID?: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID?: string | null;

    @Field({ nullable: true })
    OutputFrequency?: string | null;

    @Field({ nullable: true })
    OutputTargetEmail?: string | null;

    @Field({ nullable: true })
    OutputWorkflowID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Reports
//****************************************************************************
@ObjectType()
export class RunMJReportViewResult {
    @Field(() => [MJReport_])
    Results: MJReport_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReport_)
export class MJReportResolver extends ResolverBase {
    @Query(() => RunMJReportViewResult)
    async RunMJReportViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportViewResult)
    async RunMJReportViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportViewResult)
    async RunMJReportDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Reports';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReport_, { nullable: true })
    async MJReport(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReport_ | null> {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Reports', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJReportSnapshot_])
    async ReportSnapshots_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [ReportID]='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Report Snapshots', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReportVersion_])
    async MJ_ReportVersions_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportVersions] WHERE [ReportID]='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report Versions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReportUserState_])
    async MJ_ReportUserStates_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [ReportID]='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', rows);
        return result;
    }
        
    @Mutation(() => MJReport_)
    async CreateMJReport(
        @Arg('input', () => CreateMJReportInput) input: CreateMJReportInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Reports', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReport_)
    async UpdateMJReport(
        @Arg('input', () => UpdateMJReportInput) input: UpdateMJReportInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Reports', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReport_)
    async DeleteMJReport(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Reports', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Links
//****************************************************************************
@ObjectType({ description: `Table to track user links to shared resources such as views, dashboards, etc.` })
export class MJResourceLink_ {
    @Field({description: `Unique identifier for each resource link`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to the user linking the resource`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Foreign key to the resource type (view, dashboard, etc.)`}) 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being linked`}) 
    @MaxLength(510)
    ResourceRecordID: string;
        
    @Field({nullable: true, description: `Optional folder where the user organizes the linked resource`}) 
    @MaxLength(510)
    FolderID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for Resource Links
//****************************************************************************
@InputType()
export class CreateMJResourceLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Resource Links
//****************************************************************************
@InputType()
export class UpdateMJResourceLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Links
//****************************************************************************
@ObjectType()
export class RunMJResourceLinkViewResult {
    @Field(() => [MJResourceLink_])
    Results: MJResourceLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourceLink_)
export class MJResourceLinkResolver extends ResolverBase {
    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourceLink_, { nullable: true })
    async MJResourceLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourceLink_ | null> {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Resource Links', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJResourceLink_)
    async CreateMJResourceLink(
        @Arg('input', () => CreateMJResourceLinkInput) input: CreateMJResourceLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Resource Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJResourceLink_)
    async UpdateMJResourceLink(
        @Arg('input', () => UpdateMJResourceLinkInput) input: UpdateMJResourceLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Resource Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJResourceLink_)
    async DeleteMJResourceLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Permissions
//****************************************************************************
@ObjectType({ description: `Table for managing sharing of resources to users or roles with time constraints and permission levels` })
export class MJResourcePermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the type of resource being shared (View, Dashboard, Report, etc.)`}) 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being shared`}) 
    @MaxLength(510)
    ResourceRecordID: string;
        
    @Field({description: `The level of sharing either Role or User`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `Optional: Date when sharing starts`}) 
    @MaxLength(10)
    StartSharingAt?: Date;
        
    @Field({nullable: true, description: `Optional: Date when sharing ends`}) 
    @MaxLength(10)
    EndSharingAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RoleID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Permission level defining the type of access (View, Edit, Owner)`}) 
    @MaxLength(40)
    PermissionLevel?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the resource permission request. Possible values are Requested, Approved, Rejected, or Revoked.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Role?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for Resource Permissions
//****************************************************************************
@InputType()
export class CreateMJResourcePermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt: Date | null;

    @Field({ nullable: true })
    EndSharingAt: Date | null;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    PermissionLevel: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Resource Permissions
//****************************************************************************
@InputType()
export class UpdateMJResourcePermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt?: Date | null;

    @Field({ nullable: true })
    EndSharingAt?: Date | null;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    PermissionLevel?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Permissions
//****************************************************************************
@ObjectType()
export class RunMJResourcePermissionViewResult {
    @Field(() => [MJResourcePermission_])
    Results: MJResourcePermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourcePermission_)
export class MJResourcePermissionResolver extends ResolverBase {
    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourcePermission_, { nullable: true })
    async MJResourcePermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourcePermission_ | null> {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Resource Permissions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJResourcePermission_)
    async CreateMJResourcePermission(
        @Arg('input', () => CreateMJResourcePermissionInput) input: CreateMJResourcePermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Resource Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJResourcePermission_)
    async UpdateMJResourcePermission(
        @Arg('input', () => UpdateMJResourcePermissionInput) input: UpdateMJResourcePermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Resource Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJResourcePermission_)
    async DeleteMJResourcePermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Types
//****************************************************************************
@ObjectType()
export class MJResourceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field() 
    @MaxLength(510)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Nullable foreign key to the ID column in Entities entity, representing the category entity. ASSUMPTION: If provided, the assumption is there is a self-referencing/recursive foreign key establishing a hierarchy within the Category Entity, commonly called ParentID, but it can be named anything.`}) 
    @MaxLength(16)
    CategoryEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CategoryEntity?: string;
        
    @Field(() => [MJWorkspaceItem_])
    WorkspaceItems_ResourceTypeIDArray: MJWorkspaceItem_[]; // Link to WorkspaceItems
    
    @Field(() => [MJUserNotification_])
    UserNotifications_ResourceTypeIDArray: MJUserNotification_[]; // Link to UserNotifications
    
    @Field(() => [MJResourceLink_])
    ResourceLinks_ResourceTypeIDArray: MJResourceLink_[]; // Link to ResourceLinks
    
    @Field(() => [MJResourcePermission_])
    ResourcePermissions_ResourceTypeIDArray: MJResourcePermission_[]; // Link to ResourcePermissions
    
}
//****************************************************************************
// RESOLVER for Resource Types
//****************************************************************************
@ObjectType()
export class RunMJResourceTypeViewResult {
    @Field(() => [MJResourceType_])
    Results: MJResourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourceType_)
export class MJResourceTypeResolver extends ResolverBase {
    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourceType_, { nullable: true })
    async MJResourceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourceType_ | null> {
        this.CheckUserReadPermissions('Resource Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Resource Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJWorkspaceItem_])
    async WorkspaceItems_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [ResourceTypeID]='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workspace Items', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserNotification_])
    async UserNotifications_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [ResourceTypeID]='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Notifications', rows);
        return result;
    }
        
    @FieldResolver(() => [MJResourceLink_])
    async ResourceLinks_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [ResourceTypeID]='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Links', rows);
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async ResourcePermissions_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [ResourceTypeID]='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Roles
//****************************************************************************
@ObjectType({ description: `Roles are used for security administration and can have zero to many Users as members` })
export class MJRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Description of the role`}) 
    Description?: string;
        
    @Field({nullable: true, description: `The unique ID of the role in the directory being used for authentication, for example an ID in Azure.`}) 
    @MaxLength(500)
    DirectoryID?: string;
        
    @Field({nullable: true, description: `The name of the role in the database, this is used for auto-generating permission statements by CodeGen`}) 
    @MaxLength(500)
    SQLName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEmployeeRole_])
    EmployeeRoles_RoleIDArray: MJEmployeeRole_[]; // Link to EmployeeRoles
    
    @Field(() => [MJEntityPermission_])
    EntityPermissions_RoleNameArray: MJEntityPermission_[]; // Link to EntityPermissions
    
    @Field(() => [MJUserRole_])
    UserRoles_RoleNameArray: MJUserRole_[]; // Link to UserRoles
    
    @Field(() => [MJAuthorizationRole_])
    AuthorizationRoles_RoleNameArray: MJAuthorizationRole_[]; // Link to AuthorizationRoles
    
    @Field(() => [MJQueryPermission_])
    QueryPermissions_RoleNameArray: MJQueryPermission_[]; // Link to QueryPermissions
    
    @Field(() => [MJResourcePermission_])
    ResourcePermissions_RoleIDArray: MJResourcePermission_[]; // Link to ResourcePermissions
    
}

//****************************************************************************
// INPUT TYPE for Roles
//****************************************************************************
@InputType()
export class CreateMJRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DirectoryID: string | null;

    @Field({ nullable: true })
    SQLName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Roles
//****************************************************************************
@InputType()
export class UpdateMJRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DirectoryID?: string | null;

    @Field({ nullable: true })
    SQLName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Roles
//****************************************************************************
@ObjectType()
export class RunMJRoleViewResult {
    @Field(() => [MJRole_])
    Results: MJRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRole_)
export class MJRoleResolver extends ResolverBase {
    @Query(() => RunMJRoleViewResult)
    async RunMJRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRoleViewResult)
    async RunMJRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRoleViewResult)
    async RunMJRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRole_, { nullable: true })
    async MJRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRole_ | null> {
        this.CheckUserReadPermissions('Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Roles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJRole_])
    async AllRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRoles]` + this.getRowLevelSecurityWhereClause(provider, 'Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Roles', rows);
        return result;
    }
    
    @FieldResolver(() => [MJEmployeeRole_])
    async EmployeeRoles_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [RoleID]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityPermission_])
    async EntityPermissions_RoleNameArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [RoleName]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserRole_])
    async UserRoles_RoleNameArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [RoleName]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAuthorizationRole_])
    async AuthorizationRoles_RoleNameArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [RoleName]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [MJQueryPermission_])
    async QueryPermissions_RoleNameArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [RoleName]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async ResourcePermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [RoleID]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows);
        return result;
    }
        
    @Mutation(() => MJRole_)
    async CreateMJRole(
        @Arg('input', () => CreateMJRoleInput) input: CreateMJRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRole_)
    async UpdateMJRole(
        @Arg('input', () => UpdateMJRoleInput) input: UpdateMJRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRole_)
    async DeleteMJRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Row Level Security Filters
//****************************************************************************
@ObjectType()
export class MJRowLevelSecurityFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    FilterText?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityPermission_])
    EntityPermissions_ReadRLSFilterIDArray: MJEntityPermission_[]; // Link to EntityPermissions
    
}
//****************************************************************************
// RESOLVER for Row Level Security Filters
//****************************************************************************
@ObjectType()
export class RunMJRowLevelSecurityFilterViewResult {
    @Field(() => [MJRowLevelSecurityFilter_])
    Results: MJRowLevelSecurityFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRowLevelSecurityFilter_)
export class MJRowLevelSecurityFilterResolver extends ResolverBase {
    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Row Level Security Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRowLevelSecurityFilter_, { nullable: true })
    async MJRowLevelSecurityFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRowLevelSecurityFilter_ | null> {
        this.CheckUserReadPermissions('Row Level Security Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRowLevelSecurityFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Row Level Security Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Row Level Security Filters', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJRowLevelSecurityFilter_])
    async AllRowLevelSecurityFilters(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Row Level Security Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRowLevelSecurityFilters]` + this.getRowLevelSecurityWhereClause(provider, 'Row Level Security Filters', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Row Level Security Filters', rows);
        return result;
    }
    
    @FieldResolver(() => [MJEntityPermission_])
    async EntityPermissions_ReadRLSFilterIDArray(@Root() mjrowlevelsecurityfilter_: MJRowLevelSecurityFilter_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [ReadRLSFilterID]='${mjrowlevelsecurityfilter_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Scheduled Action Params
//****************************************************************************
@ObjectType()
export class MJScheduledActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ScheduledActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionParamID: string;
        
    @Field() 
    @MaxLength(40)
    ValueType: string;
        
    @Field({nullable: true}) 
    Value?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ScheduledAction: string;
        
    @Field() 
    @MaxLength(510)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for Scheduled Action Params
//****************************************************************************
@InputType()
export class CreateMJScheduledActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Scheduled Action Params
//****************************************************************************
@InputType()
export class UpdateMJScheduledActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Scheduled Action Params
//****************************************************************************
@ObjectType()
export class RunMJScheduledActionParamViewResult {
    @Field(() => [MJScheduledActionParam_])
    Results: MJScheduledActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledActionParam_)
export class MJScheduledActionParamResolver extends ResolverBase {
    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Scheduled Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledActionParam_, { nullable: true })
    async MJScheduledActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledActionParam_ | null> {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Scheduled Action Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJScheduledActionParam_)
    async CreateMJScheduledActionParam(
        @Arg('input', () => CreateMJScheduledActionParamInput) input: CreateMJScheduledActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Scheduled Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledActionParam_)
    async UpdateMJScheduledActionParam(
        @Arg('input', () => UpdateMJScheduledActionParamInput) input: UpdateMJScheduledActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Scheduled Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledActionParam_)
    async DeleteMJScheduledActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Scheduled Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Scheduled Actions
//****************************************************************************
@ObjectType({ description: `Track scheduled actions and their details` })
export class MJScheduledAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    CreatedByUserID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Type of the scheduled action (Daily, Weekly, Monthly, Yearly, Custom)`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Cron expression defining the schedule, automatically maintained by the system unless Type is Custom, in which case the user directly sets this`}) 
    @MaxLength(200)
    CronExpression?: string;
        
    @Field({description: `Timezone for the scheduled action, if not specified defaults to UTC/Z`}) 
    @MaxLength(200)
    Timezone: string;
        
    @Field({description: `Status of the scheduled action (Pending, Active, Disabled, Expired)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Interval in days for the scheduled action`}) 
    IntervalDays?: number;
        
    @Field({nullable: true, description: `Day of the week for the scheduled action`}) 
    @MaxLength(40)
    DayOfWeek?: string;
        
    @Field(() => Int, {nullable: true, description: `Day of the month for the scheduled action`}) 
    DayOfMonth?: number;
        
    @Field({nullable: true, description: `Month for the scheduled action`}) 
    @MaxLength(40)
    Month?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CustomCronExpression?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    CreatedByUser: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [MJScheduledActionParam_])
    ScheduledActionParams_ScheduledActionIDArray: MJScheduledActionParam_[]; // Link to ScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for Scheduled Actions
//****************************************************************************
@InputType()
export class CreateMJScheduledActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays: number | null;

    @Field({ nullable: true })
    DayOfWeek: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth: number | null;

    @Field({ nullable: true })
    Month: string | null;

    @Field({ nullable: true })
    CustomCronExpression: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Scheduled Actions
//****************************************************************************
@InputType()
export class UpdateMJScheduledActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression?: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays?: number | null;

    @Field({ nullable: true })
    DayOfWeek?: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth?: number | null;

    @Field({ nullable: true })
    Month?: string | null;

    @Field({ nullable: true })
    CustomCronExpression?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Scheduled Actions
//****************************************************************************
@ObjectType()
export class RunMJScheduledActionViewResult {
    @Field(() => [MJScheduledAction_])
    Results: MJScheduledAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledAction_)
export class MJScheduledActionResolver extends ResolverBase {
    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Scheduled Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledAction_, { nullable: true })
    async MJScheduledAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledAction_ | null> {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Scheduled Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJScheduledActionParam_])
    async ScheduledActionParams_ScheduledActionIDArray(@Root() mjscheduledaction_: MJScheduledAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ScheduledActionID]='${mjscheduledaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Action Params', rows);
        return result;
    }
        
    @Mutation(() => MJScheduledAction_)
    async CreateMJScheduledAction(
        @Arg('input', () => CreateMJScheduledActionInput) input: CreateMJScheduledActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Scheduled Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledAction_)
    async UpdateMJScheduledAction(
        @Arg('input', () => UpdateMJScheduledActionInput) input: UpdateMJScheduledActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Scheduled Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledAction_)
    async DeleteMJScheduledAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Scheduled Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Schema Info
//****************************************************************************
@ObjectType({ description: `Tracks the schemas in the system and the ID ranges that are valid for entities within each schema.` })
export class MJSchemaInfo_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    SchemaName: string;
        
    @Field(() => Int) 
    EntityIDMin: number;
        
    @Field(() => Int) 
    EntityIDMax: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Schema Info
//****************************************************************************
@InputType()
export class CreateMJSchemaInfoInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Schema Info
//****************************************************************************
@InputType()
export class UpdateMJSchemaInfoInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Schema Info
//****************************************************************************
@ObjectType()
export class RunMJSchemaInfoViewResult {
    @Field(() => [MJSchemaInfo_])
    Results: MJSchemaInfo_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJSchemaInfo_)
export class MJSchemaInfoResolver extends ResolverBase {
    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Schema Info';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJSchemaInfo_, { nullable: true })
    async MJSchemaInfo(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJSchemaInfo_ | null> {
        this.CheckUserReadPermissions('Schema Info', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSchemaInfos] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Schema Info', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Schema Info', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJSchemaInfo_)
    async CreateMJSchemaInfo(
        @Arg('input', () => CreateMJSchemaInfoInput) input: CreateMJSchemaInfoInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Schema Info', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJSchemaInfo_)
    async UpdateMJSchemaInfo(
        @Arg('input', () => UpdateMJSchemaInfoInput) input: UpdateMJSchemaInfoInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Schema Info', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Skills
//****************************************************************************
@ObjectType({ description: `A hierarchical list of possible skills that are linked to Employees and can also be linked to any other entity` })
export class MJSkill_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field(() => [MJEmployeeSkill_])
    EmployeeSkills_SkillIDArray: MJEmployeeSkill_[]; // Link to EmployeeSkills
    
    @Field(() => [MJSkill_])
    Skills_ParentIDArray: MJSkill_[]; // Link to Skills
    
}
//****************************************************************************
// RESOLVER for Skills
//****************************************************************************
@ObjectType()
export class RunMJSkillViewResult {
    @Field(() => [MJSkill_])
    Results: MJSkill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJSkill_)
export class MJSkillResolver extends ResolverBase {
    @Query(() => RunMJSkillViewResult)
    async RunMJSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSkillViewResult)
    async RunMJSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSkillViewResult)
    async RunMJSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Skills';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJSkill_, { nullable: true })
    async MJSkill(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJSkill_ | null> {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Skills', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJSkill_])
    async AllSkills(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills]` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Skills', rows);
        return result;
    }
    
    @FieldResolver(() => [MJEmployeeSkill_])
    async EmployeeSkills_SkillIDArray(@Root() mjskill_: MJSkill_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [SkillID]='${mjskill_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Skills', rows);
        return result;
    }
        
    @FieldResolver(() => [MJSkill_])
    async Skills_ParentIDArray(@Root() mjskill_: MJSkill_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills] WHERE [ParentID]='${mjskill_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Skills', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Tagged Items
//****************************************************************************
@ObjectType({ description: `Tracks the links between any record in any entity with Tags` })
export class MJTaggedItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TagID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Tag: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}
//****************************************************************************
// RESOLVER for Tagged Items
//****************************************************************************
@ObjectType()
export class RunMJTaggedItemViewResult {
    @Field(() => [MJTaggedItem_])
    Results: MJTaggedItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTaggedItem_)
export class MJTaggedItemResolver extends ResolverBase {
    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Tagged Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTaggedItem_, { nullable: true })
    async MJTaggedItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTaggedItem_ | null> {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Tagged Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
}

//****************************************************************************
// ENTITY CLASS for Tags
//****************************************************************************
@ObjectType({ description: `Tags are used to arbitrarily associate any record in any entity with addtional information.` })
export class MJTag_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(510)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [MJTag_])
    Tags_ParentIDArray: MJTag_[]; // Link to Tags
    
    @Field(() => [MJTaggedItem_])
    TaggedItems_TagIDArray: MJTaggedItem_[]; // Link to TaggedItems
    
}
//****************************************************************************
// RESOLVER for Tags
//****************************************************************************
@ObjectType()
export class RunMJTagViewResult {
    @Field(() => [MJTag_])
    Results: MJTag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTag_)
export class MJTagResolver extends ResolverBase {
    @Query(() => RunMJTagViewResult)
    async RunMJTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTagViewResult)
    async RunMJTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTagViewResult)
    async RunMJTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Tags';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTag_, { nullable: true })
    async MJTag(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTag_ | null> {
        this.CheckUserReadPermissions('Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTags] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Tags', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJTag_])
    async Tags_ParentIDArray(@Root() mjtag_: MJTag_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTags] WHERE [ParentID]='${mjtag_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Tags', rows);
        return result;
    }
        
    @FieldResolver(() => [MJTaggedItem_])
    async TaggedItems_TagIDArray(@Root() mjtag_: MJTag_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [TagID]='${mjtag_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Tagged Items', rows);
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Template Categories
//****************************************************************************
@ObjectType({ description: `Template categories for organizing templates` })
export class MJTemplateCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template category`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template category`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJTemplate_])
    Templates_CategoryIDArray: MJTemplate_[]; // Link to Templates
    
    @Field(() => [MJTemplateCategory_])
    TemplateCategories_ParentIDArray: MJTemplateCategory_[]; // Link to TemplateCategories
    
}

//****************************************************************************
// INPUT TYPE for Template Categories
//****************************************************************************
@InputType()
export class CreateMJTemplateCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Template Categories
//****************************************************************************
@InputType()
export class UpdateMJTemplateCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Categories
//****************************************************************************
@ObjectType()
export class RunMJTemplateCategoryViewResult {
    @Field(() => [MJTemplateCategory_])
    Results: MJTemplateCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateCategory_)
export class MJTemplateCategoryResolver extends ResolverBase {
    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateCategory_, { nullable: true })
    async MJTemplateCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateCategory_ | null> {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Template Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJTemplate_])
    async Templates_CategoryIDArray(@Root() mjtemplatecategory_: MJTemplateCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [CategoryID]='${mjtemplatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Templates', rows);
        return result;
    }
        
    @FieldResolver(() => [MJTemplateCategory_])
    async TemplateCategories_ParentIDArray(@Root() mjtemplatecategory_: MJTemplateCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [ParentID]='${mjtemplatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Categories', rows);
        return result;
    }
        
    @Mutation(() => MJTemplateCategory_)
    async CreateMJTemplateCategory(
        @Arg('input', () => CreateMJTemplateCategoryInput) input: CreateMJTemplateCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateCategory_)
    async UpdateMJTemplateCategory(
        @Arg('input', () => UpdateMJTemplateCategoryInput) input: UpdateMJTemplateCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateCategory_)
    async DeleteMJTemplateCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Content Types
//****************************************************************************
@ObjectType({ description: `Template content types for categorizing content within templates` })
export class MJTemplateContentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template content type`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template content type`}) 
    Description?: string;
        
    @Field({description: `Refers to the primary language or codetype of the templates of this type, HTML, JSON, JavaScript, etc`}) 
    @MaxLength(50)
    CodeType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJTemplateContent_])
    TemplateContents_TypeIDArray: MJTemplateContent_[]; // Link to TemplateContents
    
}

//****************************************************************************
// INPUT TYPE for Template Content Types
//****************************************************************************
@InputType()
export class CreateMJTemplateContentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CodeType?: string;
}
    

//****************************************************************************
// INPUT TYPE for Template Content Types
//****************************************************************************
@InputType()
export class UpdateMJTemplateContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CodeType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Content Types
//****************************************************************************
@ObjectType()
export class RunMJTemplateContentTypeViewResult {
    @Field(() => [MJTemplateContentType_])
    Results: MJTemplateContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateContentType_)
export class MJTemplateContentTypeResolver extends ResolverBase {
    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Content Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateContentType_, { nullable: true })
    async MJTemplateContentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateContentType_ | null> {
        this.CheckUserReadPermissions('Template Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Template Content Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJTemplateContent_])
    async TemplateContents_TypeIDArray(@Root() mjtemplatecontenttype_: MJTemplateContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [TypeID]='${mjtemplatecontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Contents', rows);
        return result;
    }
        
    @Mutation(() => MJTemplateContentType_)
    async CreateMJTemplateContentType(
        @Arg('input', () => CreateMJTemplateContentTypeInput) input: CreateMJTemplateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Content Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateContentType_)
    async UpdateMJTemplateContentType(
        @Arg('input', () => UpdateMJTemplateContentTypeInput) input: UpdateMJTemplateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Content Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateContentType_)
    async DeleteMJTemplateContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Content Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Contents
//****************************************************************************
@ObjectType({ description: `Template content for different versions of a template for purposes like HTML/Text/etc` })
export class MJTemplateContent_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field({nullable: true, description: `The actual text content for the template`}) 
    TemplateText?: string;
        
    @Field(() => Int, {description: `Priority of the content version, higher priority versions will be used ahead of lower priority versions for a given Type`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `Indicates whether the content is active or not. Use this to disable a particular Template Content item without having to remove it`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
}

//****************************************************************************
// INPUT TYPE for Template Contents
//****************************************************************************
@InputType()
export class CreateMJTemplateContentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Template Contents
//****************************************************************************
@InputType()
export class UpdateMJTemplateContentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Contents
//****************************************************************************
@ObjectType()
export class RunMJTemplateContentViewResult {
    @Field(() => [MJTemplateContent_])
    Results: MJTemplateContent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateContent_)
export class MJTemplateContentResolver extends ResolverBase {
    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Contents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateContent_, { nullable: true })
    async MJTemplateContent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateContent_ | null> {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Template Contents', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJTemplateContent_)
    async CreateMJTemplateContent(
        @Arg('input', () => CreateMJTemplateContentInput) input: CreateMJTemplateContentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Contents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateContent_)
    async UpdateMJTemplateContent(
        @Arg('input', () => UpdateMJTemplateContentInput) input: UpdateMJTemplateContentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Contents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateContent_)
    async DeleteMJTemplateContent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Contents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Params
//****************************************************************************
@ObjectType({ description: `Parameters allowed for use inside the template` })
export class MJTemplateParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field({description: `Name of the parameter`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the parameter`}) 
    Description?: string;
        
    @Field({description: `Type of the parameter - Record is an individual record within the entity specified by EntityID. Entity means an entire Entity or an entity filtered by the LinkedParameterName/Field attributes and/or ExtraFilter. Object is any valid JSON object. Array and Scalar have their common meanings.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Default value of the parameter`}) 
    DefaultValue?: string;
        
    @Field(() => Boolean) 
    IsRequired: boolean;
        
    @Field({nullable: true, description: `Only used when Type=Entity, this is used to link an Entity parameter with another parameter so that the rows in the Entity parameter can be filtered automatically based on the FKEY relationship between the Record and this Entity parameter. For example, if the Entity-based parameter is for an entity like Activities and there is another parameter of type Record for an entity like Contacts, in that situation the Activities Parameter would point to the Contacts parameter as the LinkedParameterName because we would filter down the Activities in each template render to only those linked to the Contact.`}) 
    @MaxLength(510)
    LinkedParameterName?: string;
        
    @Field({nullable: true, description: `If the LinkedParameterName is specified, this is an optional setting to specify the field within the LinkedParameter that will be used for filtering. This is only needed if there is more than one foreign key relationship between the Entity parameter and the Linked parameter, or if there is no defined foreign key in the database between the two entities.`}) 
    @MaxLength(1000)
    LinkedParameterField?: string;
        
    @Field({nullable: true, description: `Only used when Type = Entity, used to specify an optional filter to reduce the set of rows that are returned for each of the templates being rendered.`}) 
    ExtraFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `Record ID, used only when Type is Record and a specific hardcoded record ID is desired, this is an uncommon use case, helpful for pulling in static types and metadata in some cases.`}) 
    @MaxLength(4000)
    RecordID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field({nullable: true, description: `This field is used only when the Type of the TemplateParam table is "Entity". It is an optional field used to specify the sorting order for the related entity data that is used in the template for the Entity specified.`}) 
    OrderBy?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Template Params
//****************************************************************************
@InputType()
export class CreateMJTemplateParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName: string | null;

    @Field({ nullable: true })
    LinkedParameterField: string | null;

    @Field({ nullable: true })
    ExtraFilter: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    OrderBy: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Template Params
//****************************************************************************
@InputType()
export class UpdateMJTemplateParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName?: string | null;

    @Field({ nullable: true })
    LinkedParameterField?: string | null;

    @Field({ nullable: true })
    ExtraFilter?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    OrderBy?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Params
//****************************************************************************
@ObjectType()
export class RunMJTemplateParamViewResult {
    @Field(() => [MJTemplateParam_])
    Results: MJTemplateParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateParam_)
export class MJTemplateParamResolver extends ResolverBase {
    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateParam_, { nullable: true })
    async MJTemplateParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateParam_ | null> {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Template Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJTemplateParam_)
    async CreateMJTemplateParam(
        @Arg('input', () => CreateMJTemplateParamInput) input: CreateMJTemplateParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateParam_)
    async UpdateMJTemplateParam(
        @Arg('input', () => UpdateMJTemplateParamInput) input: UpdateMJTemplateParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateParam_)
    async DeleteMJTemplateParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Templates
//****************************************************************************
@ObjectType({ description: `Templates are used for dynamic expansion of a static template with data from a given context. Templates can be used to create documents, messages and anything else that requires dynamic document creation merging together static text, data and lightweight logic` })
export class MJTemplate_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true, description: `This prompt will be used by the AI to generate template content as requested by the user.`}) 
    UserPrompt?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use until the specified date. Requires IsActive to be set to 1`}) 
    @MaxLength(8)
    ActiveAt?: Date;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use after the specified date. If IsActive=0, this has no effect.`}) 
    @MaxLength(8)
    DisabledAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 0, the template will be disabled regardless of the values in ActiveAt/DisabledAt. `}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJTemplateParam_])
    TemplateParams_TemplateIDArray: MJTemplateParam_[]; // Link to TemplateParams
    
    @Field(() => [MJTemplateContent_])
    TemplateContents_TemplateIDArray: MJTemplateContent_[]; // Link to TemplateContents
    
    @Field(() => [MJAIPrompt_])
    AIPrompts_TemplateIDArray: MJAIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [MJEntityDocument_])
    EntityDocuments_TemplateIDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Templates
//****************************************************************************
@InputType()
export class CreateMJTemplateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt: Date | null;

    @Field({ nullable: true })
    DisabledAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Templates
//****************************************************************************
@InputType()
export class UpdateMJTemplateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt?: Date | null;

    @Field({ nullable: true })
    DisabledAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Templates
//****************************************************************************
@ObjectType()
export class RunMJTemplateViewResult {
    @Field(() => [MJTemplate_])
    Results: MJTemplate_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplate_)
export class MJTemplateResolver extends ResolverBase {
    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Templates';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplate_, { nullable: true })
    async MJTemplate(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplate_ | null> {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Templates', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJTemplateParam_])
    async TemplateParams_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [TemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Params', rows);
        return result;
    }
        
    @FieldResolver(() => [MJTemplateContent_])
    async TemplateContents_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [TemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Contents', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIPrompt_])
    async AIPrompts_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [TemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [TemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @Mutation(() => MJTemplate_)
    async CreateMJTemplate(
        @Arg('input', () => CreateMJTemplateInput) input: CreateMJTemplateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Templates', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplate_)
    async UpdateMJTemplate(
        @Arg('input', () => UpdateMJTemplateInput) input: UpdateMJTemplateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Templates', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplate_)
    async DeleteMJTemplate(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Templates', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Application Entities
//****************************************************************************
@ObjectType()
export class MJUserApplicationEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserApplicationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for User Application Entities
//****************************************************************************
@InputType()
export class CreateMJUserApplicationEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for User Application Entities
//****************************************************************************
@InputType()
export class UpdateMJUserApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Application Entities
//****************************************************************************
@ObjectType()
export class RunMJUserApplicationEntityViewResult {
    @Field(() => [MJUserApplicationEntity_])
    Results: MJUserApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserApplicationEntity_)
export class MJUserApplicationEntityResolver extends ResolverBase {
    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Application Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserApplicationEntity_, { nullable: true })
    async MJUserApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserApplicationEntity_ | null> {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Application Entities', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJUserApplicationEntity_)
    async CreateMJUserApplicationEntity(
        @Arg('input', () => CreateMJUserApplicationEntityInput) input: CreateMJUserApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Application Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserApplicationEntity_)
    async UpdateMJUserApplicationEntity(
        @Arg('input', () => UpdateMJUserApplicationEntityInput) input: UpdateMJUserApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Application Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserApplicationEntity_)
    async DeleteMJUserApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Application Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Applications
//****************************************************************************
@ObjectType()
export class MJUserApplication_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field(() => [MJUserApplicationEntity_])
    UserApplicationEntities_UserApplicationIDArray: MJUserApplicationEntity_[]; // Link to UserApplicationEntities
    
}

//****************************************************************************
// INPUT TYPE for User Applications
//****************************************************************************
@InputType()
export class CreateMJUserApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for User Applications
//****************************************************************************
@InputType()
export class UpdateMJUserApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Applications
//****************************************************************************
@ObjectType()
export class RunMJUserApplicationViewResult {
    @Field(() => [MJUserApplication_])
    Results: MJUserApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserApplication_)
export class MJUserApplicationResolver extends ResolverBase {
    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserApplication_, { nullable: true })
    async MJUserApplication(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserApplication_ | null> {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Applications', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJUserApplicationEntity_])
    async UserApplicationEntities_UserApplicationIDArray(@Root() mjuserapplication_: MJUserApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [UserApplicationID]='${mjuserapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Application Entities', rows);
        return result;
    }
        
    @Mutation(() => MJUserApplication_)
    async CreateMJUserApplication(
        @Arg('input', () => CreateMJUserApplicationInput) input: CreateMJUserApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserApplication_)
    async UpdateMJUserApplication(
        @Arg('input', () => UpdateMJUserApplicationInput) input: UpdateMJUserApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserApplication_)
    async DeleteMJUserApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Favorites
//****************************************************************************
@ObjectType({ description: `Records that each user can mark as a favorite for easy access` })
export class MJUserFavorite_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
}

//****************************************************************************
// INPUT TYPE for User Favorites
//****************************************************************************
@InputType()
export class CreateMJUserFavoriteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User Favorites
//****************************************************************************
@InputType()
export class UpdateMJUserFavoriteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Favorites
//****************************************************************************
@ObjectType()
export class RunMJUserFavoriteViewResult {
    @Field(() => [MJUserFavorite_])
    Results: MJUserFavorite_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserFavorite_)
export class MJUserFavoriteResolverBase extends ResolverBase {
    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Favorites';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserFavorite_, { nullable: true })
    async MJUserFavorite(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserFavorite_ | null> {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Favorites', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJUserFavorite_)
    async CreateMJUserFavorite(
        @Arg('input', () => CreateMJUserFavoriteInput) input: CreateMJUserFavoriteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Favorites', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserFavorite_)
    async UpdateMJUserFavorite(
        @Arg('input', () => UpdateMJUserFavoriteInput) input: UpdateMJUserFavoriteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Favorites', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserFavorite_)
    async DeleteMJUserFavorite(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Favorites', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Notifications
//****************************************************************************
@ObjectType()
export class MJUserNotification_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Title?: string;
        
    @Field({nullable: true}) 
    Message?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ResourceTypeID?: string;
        
    @Field({nullable: true}) 
    ResourceConfiguration?: string;
        
    @Field(() => Boolean) 
    Unread: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    ReadAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ResourceRecordID?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ResourceType?: string;
        
}

//****************************************************************************
// INPUT TYPE for User Notifications
//****************************************************************************
@InputType()
export class CreateMJUserNotificationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    ResourceTypeID: string | null;

    @Field({ nullable: true })
    ResourceConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt: Date | null;

    @Field({ nullable: true })
    ResourceRecordID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for User Notifications
//****************************************************************************
@InputType()
export class UpdateMJUserNotificationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    ResourceTypeID?: string | null;

    @Field({ nullable: true })
    ResourceConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt?: Date | null;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Notifications
//****************************************************************************
@ObjectType()
export class RunMJUserNotificationViewResult {
    @Field(() => [MJUserNotification_])
    Results: MJUserNotification_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserNotification_)
export class MJUserNotificationResolver extends ResolverBase {
    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Notifications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserNotification_, { nullable: true })
    async MJUserNotification(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserNotification_ | null> {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Notifications', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJUserNotification_)
    async CreateMJUserNotification(
        @Arg('input', () => CreateMJUserNotificationInput) input: CreateMJUserNotificationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Notifications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserNotification_)
    async UpdateMJUserNotification(
        @Arg('input', () => UpdateMJUserNotificationInput) input: UpdateMJUserNotificationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Notifications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserNotification_)
    async DeleteMJUserNotification(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Notifications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Record Logs
//****************************************************************************
@ObjectType()
export class MJUserRecordLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(8)
    EarliestAt: Date;
        
    @Field() 
    @MaxLength(8)
    LatestAt: Date;
        
    @Field(() => Int) 
    TotalCount: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(200)
    UserEmail: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    UserSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    UserSupervisorEmail?: string;
        
}

//****************************************************************************
// INPUT TYPE for User Record Logs
//****************************************************************************
@InputType()
export class UpdateMJUserRecordLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EarliestAt?: Date;

    @Field({ nullable: true })
    LatestAt?: Date;

    @Field(() => Int, { nullable: true })
    TotalCount?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Record Logs
//****************************************************************************
@ObjectType()
export class RunMJUserRecordLogViewResult {
    @Field(() => [MJUserRecordLog_])
    Results: MJUserRecordLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserRecordLog_)
export class MJUserRecordLogResolver extends ResolverBase {
    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Record Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserRecordLog_, { nullable: true })
    async MJUserRecordLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserRecordLog_ | null> {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Record Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJUserRecordLog_)
    async UpdateMJUserRecordLog(
        @Arg('input', () => UpdateMJUserRecordLogInput) input: UpdateMJUserRecordLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Record Logs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Roles
//****************************************************************************
@ObjectType()
export class MJUserRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for User Roles
//****************************************************************************
@InputType()
export class CreateMJUserRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    
//****************************************************************************
// RESOLVER for User Roles
//****************************************************************************
@ObjectType()
export class RunMJUserRoleViewResult {
    @Field(() => [MJUserRole_])
    Results: MJUserRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserRole_)
export class MJUserRoleResolver extends ResolverBase {
    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserRole_, { nullable: true })
    async MJUserRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserRole_ | null> {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Roles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJUserRole_])
    async AllUserRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles]` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', rows);
        return result;
    }
    
    @Mutation(() => MJUserRole_)
    async CreateMJUserRole(
        @Arg('input', () => CreateMJUserRoleInput) input: CreateMJUserRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserRole_)
    async DeleteMJUserRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Categories
//****************************************************************************
@ObjectType()
export class MJUserViewCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field(() => [MJUserViewCategory_])
    UserViewCategories_ParentIDArray: MJUserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [MJUserView_])
    UserViews_CategoryIDArray: MJUserView_[]; // Link to UserViews
    
}

//****************************************************************************
// INPUT TYPE for User View Categories
//****************************************************************************
@InputType()
export class CreateMJUserViewCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Categories
//****************************************************************************
@InputType()
export class UpdateMJUserViewCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Categories
//****************************************************************************
@ObjectType()
export class RunMJUserViewCategoryViewResult {
    @Field(() => [MJUserViewCategory_])
    Results: MJUserViewCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewCategory_)
export class MJUserViewCategoryResolver extends ResolverBase {
    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewCategory_, { nullable: true })
    async MJUserViewCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewCategory_ | null> {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User View Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJUserViewCategory_])
    async UserViewCategories_ParentIDArray(@Root() mjuserviewcategory_: MJUserViewCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [ParentID]='${mjuserviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async UserViews_CategoryIDArray(@Root() mjuserviewcategory_: MJUserViewCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [CategoryID]='${mjuserviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', rows);
        return result;
    }
        
    @Mutation(() => MJUserViewCategory_)
    async CreateMJUserViewCategory(
        @Arg('input', () => CreateMJUserViewCategoryInput) input: CreateMJUserViewCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewCategory_)
    async UpdateMJUserViewCategory(
        @Arg('input', () => UpdateMJUserViewCategoryInput) input: UpdateMJUserViewCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserViewCategory_)
    async DeleteMJUserViewCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User View Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Run Details
//****************************************************************************
@ObjectType({ description: `Tracks the set of records that were included in each run of a given user view.` })
export class MJUserViewRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserViewRunID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    UserViewID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for User View Run Details
//****************************************************************************
@InputType()
export class CreateMJUserViewRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Run Details
//****************************************************************************
@InputType()
export class UpdateMJUserViewRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Run Details
//****************************************************************************
@ObjectType()
export class RunMJUserViewRunDetailViewResult {
    @Field(() => [MJUserViewRunDetail_])
    Results: MJUserViewRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewRunDetail_)
export class MJUserViewRunDetailResolver extends ResolverBase {
    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewRunDetail_, { nullable: true })
    async MJUserViewRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewRunDetail_ | null> {
        this.CheckUserReadPermissions('User View Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User View Run Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJUserViewRunDetail_)
    async CreateMJUserViewRunDetail(
        @Arg('input', () => CreateMJUserViewRunDetailInput) input: CreateMJUserViewRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewRunDetail_)
    async UpdateMJUserViewRunDetail(
        @Arg('input', () => UpdateMJUserViewRunDetailInput) input: UpdateMJUserViewRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Run Details', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Runs
//****************************************************************************
@ObjectType({ description: `User Views can be logged when run to capture the date and user that ran the view as well as the output results.` })
export class MJUserViewRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserViewID: string;
        
    @Field() 
    @MaxLength(8)
    RunAt: Date;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    UserView: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [MJUserViewRunDetail_])
    UserViewRunDetails_UserViewRunIDArray: MJUserViewRunDetail_[]; // Link to UserViewRunDetails
    
}

//****************************************************************************
// INPUT TYPE for User View Runs
//****************************************************************************
@InputType()
export class CreateMJUserViewRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Runs
//****************************************************************************
@InputType()
export class UpdateMJUserViewRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Runs
//****************************************************************************
@ObjectType()
export class RunMJUserViewRunViewResult {
    @Field(() => [MJUserViewRun_])
    Results: MJUserViewRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewRun_)
export class MJUserViewRunResolver extends ResolverBase {
    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewRun_, { nullable: true })
    async MJUserViewRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewRun_ | null> {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User View Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJUserViewRunDetail_])
    async UserViewRunDetails_UserViewRunIDArray(@Root() mjuserviewrun_: MJUserViewRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRunDetails] WHERE [UserViewRunID]='${mjuserviewrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Run Details', rows);
        return result;
    }
        
    @Mutation(() => MJUserViewRun_)
    async CreateMJUserViewRun(
        @Arg('input', () => CreateMJUserViewRunInput) input: CreateMJUserViewRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewRun_)
    async UpdateMJUserViewRun(
        @Arg('input', () => UpdateMJUserViewRunInput) input: UpdateMJUserViewRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Runs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Views
//****************************************************************************
@ObjectType({ description: `Views are sets of records within a given entity defined by filtering rules. Views can be used programatically to retrieve dynamic sets of data and in user interfaces like MJ Explorer for end-user consumption.` })
export class MJUserView_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field(() => Boolean) 
    IsShared: boolean;
        
    @Field(() => Boolean) 
    IsDefault: boolean;
        
    @Field({nullable: true}) 
    GridState?: string;
        
    @Field({nullable: true}) 
    FilterState?: string;
        
    @Field(() => Boolean) 
    CustomFilterState: boolean;
        
    @Field(() => Boolean) 
    SmartFilterEnabled: boolean;
        
    @Field({nullable: true}) 
    SmartFilterPrompt?: string;
        
    @Field({nullable: true}) 
    SmartFilterWhereClause?: string;
        
    @Field({nullable: true}) 
    SmartFilterExplanation?: string;
        
    @Field({nullable: true}) 
    WhereClause?: string;
        
    @Field(() => Boolean) 
    CustomWhereClause: boolean;
        
    @Field({nullable: true}) 
    SortState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(200)
    UserEmail: string;
        
    @Field() 
    @MaxLength(30)
    UserType: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
    @Field(() => [MJEntityRelationship_])
    EntityRelationships_DisplayUserViewGUIDArray: MJEntityRelationship_[]; // Link to EntityRelationships
    
    @Field(() => [MJUserViewRun_])
    UserViewRuns_UserViewIDArray: MJUserViewRun_[]; // Link to UserViewRuns
    
    @Field(() => [MJDataContextItem_])
    DataContextItems_ViewIDArray: MJDataContextItem_[]; // Link to DataContextItems
    
}

//****************************************************************************
// INPUT TYPE for User Views
//****************************************************************************
@InputType()
export class CreateMJUserViewInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState: string | null;

    @Field({ nullable: true })
    FilterState: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation: string | null;

    @Field({ nullable: true })
    WhereClause: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for User Views
//****************************************************************************
@InputType()
export class UpdateMJUserViewInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState?: string | null;

    @Field({ nullable: true })
    FilterState?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt?: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause?: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation?: string | null;

    @Field({ nullable: true })
    WhereClause?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Views
//****************************************************************************
@ObjectType()
export class RunMJUserViewViewResult {
    @Field(() => [MJUserView_])
    Results: MJUserView_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserView_)
export class MJUserViewResolverBase extends ResolverBase {
    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Views';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserView_, { nullable: true })
    async MJUserView(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserView_ | null> {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Views', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJUserView_])
    async AllUserViews(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews]` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', rows);
        return result;
    }
    
    @FieldResolver(() => [MJEntityRelationship_])
    async EntityRelationships_DisplayUserViewGUIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [DisplayUserViewGUID]='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserViewRun_])
    async UserViewRuns_UserViewIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [UserViewID]='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async DataContextItems_ViewIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [ViewID]='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows);
        return result;
    }
        
    @Mutation(() => MJUserView_)
    async CreateMJUserView(
        @Arg('input', () => CreateMJUserViewInput) input: CreateMJUserViewInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Views', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserView_)
    async UpdateMJUserView(
        @Arg('input', () => UpdateMJUserViewInput) input: UpdateMJUserViewInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Views', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserView_)
    async DeleteMJUserView(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Views', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Users
//****************************************************************************
@ObjectType({ description: `A list of all users who have or had access to the system` })
export class MJUser_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    FirstName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    LastName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Title?: string;
        
    @Field() 
    @MaxLength(200)
    Email: string;
        
    @Field() 
    @MaxLength(30)
    Type: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(20)
    LinkedRecordType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(900)
    LinkedEntityRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EmployeeID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    EmployeeFirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    EmployeeEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmployeeTitle?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    EmployeeSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    EmployeeSupervisorEmail?: string;
        
    @Field(() => [MJUserApplication_])
    UserApplications_UserIDArray: MJUserApplication_[]; // Link to UserApplications
    
    @Field(() => [MJUserRole_])
    UserRoles_UserIDArray: MJUserRole_[]; // Link to UserRoles
    
    @Field(() => [MJWorkspace_])
    Workspaces_UserIDArray: MJWorkspace_[]; // Link to Workspaces
    
    @Field(() => [MJReport_])
    Reports_UserIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJReportSnapshot_])
    ReportSnapshots_UserIDArray: MJReportSnapshot_[]; // Link to ReportSnapshots
    
    @Field(() => [MJRecordChange_])
    RecordChanges_UserIDArray: MJRecordChange_[]; // Link to RecordChanges
    
    @Field(() => [MJDashboard_])
    Dashboards_UserIDArray: MJDashboard_[]; // Link to Dashboards
    
    @Field(() => [MJUserViewRun_])
    UserViewRuns_RunByUserIDArray: MJUserViewRun_[]; // Link to UserViewRuns
    
    @Field(() => [MJAuditLog_])
    AuditLogs_UserIDArray: MJAuditLog_[]; // Link to AuditLogs
    
    @Field(() => [MJList_])
    Lists_UserIDArray: MJList_[]; // Link to Lists
    
    @Field(() => [MJUserFavorite_])
    UserFavorites_UserIDArray: MJUserFavorite_[]; // Link to UserFavorites
    
    @Field(() => [MJUserRecordLog_])
    UserRecordLogs_UserIDArray: MJUserRecordLog_[]; // Link to UserRecordLogs
    
    @Field(() => [MJUserView_])
    UserViews_UserIDArray: MJUserView_[]; // Link to UserViews
    
    @Field(() => [MJCompanyIntegrationRun_])
    CompanyIntegrationRuns_RunByUserIDArray: MJCompanyIntegrationRun_[]; // Link to CompanyIntegrationRuns
    
    @Field(() => [MJUserNotification_])
    UserNotifications_UserIDArray: MJUserNotification_[]; // Link to UserNotifications
    
    @Field(() => [MJConversation_])
    Conversations_UserIDArray: MJConversation_[]; // Link to Conversations
    
    @Field(() => [MJRecordMergeLog_])
    RecordMergeLogs_InitiatedByUserIDArray: MJRecordMergeLog_[]; // Link to RecordMergeLogs
    
    @Field(() => [MJDataContext_])
    DataContexts_UserIDArray: MJDataContext_[]; // Link to DataContexts
    
    @Field(() => [MJReportCategory_])
    ReportCategories_UserIDArray: MJReportCategory_[]; // Link to ReportCategories
    
    @Field(() => [MJUserViewCategory_])
    UserViewCategories_UserIDArray: MJUserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [MJDashboardCategory_])
    DashboardCategories_UserIDArray: MJDashboardCategory_[]; // Link to DashboardCategories
    
    @Field(() => [MJQueryCategory_])
    QueryCategories_UserIDArray: MJQueryCategory_[]; // Link to QueryCategories
    
    @Field(() => [MJDuplicateRun_])
    DuplicateRuns_StartedByUserIDArray: MJDuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [MJActionExecutionLog_])
    ActionExecutionLogs_UserIDArray: MJActionExecutionLog_[]; // Link to ActionExecutionLogs
    
    @Field(() => [MJAction_])
    Actions_CodeApprovedByUserIDArray: MJAction_[]; // Link to Actions
    
    @Field(() => [MJCommunicationRun_])
    CommunicationRuns_UserIDArray: MJCommunicationRun_[]; // Link to CommunicationRuns
    
    @Field(() => [MJTemplate_])
    Templates_UserIDArray: MJTemplate_[]; // Link to Templates
    
    @Field(() => [MJTemplateCategory_])
    TemplateCategories_UserIDArray: MJTemplateCategory_[]; // Link to TemplateCategories
    
    @Field(() => [MJRecommendationRun_])
    RecommendationRuns_RunByUserIDArray: MJRecommendationRun_[]; // Link to RecommendationRuns
    
    @Field(() => [MJRecordChangeReplayRun_])
    RecordChangeReplayRuns_UserIDArray: MJRecordChangeReplayRun_[]; // Link to RecordChangeReplayRuns
    
    @Field(() => [MJListCategory_])
    ListCategories_UserIDArray: MJListCategory_[]; // Link to ListCategories
    
    @Field(() => [MJScheduledAction_])
    ScheduledActions_CreatedByUserIDArray: MJScheduledAction_[]; // Link to ScheduledActions
    
    @Field(() => [MJResourceLink_])
    ResourceLinks_UserIDArray: MJResourceLink_[]; // Link to ResourceLinks
    
    @Field(() => [MJAIAgentRequest_])
    AIAgentRequests_ResponseByUserIDArray: MJAIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_UserIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJReportUserState_])
    MJ_ReportUserStates_UserIDArray: MJReportUserState_[]; // Link to MJ_ReportUserStates
    
    @Field(() => [MJResourcePermission_])
    ResourcePermissions_UserIDArray: MJResourcePermission_[]; // Link to ResourcePermissions
    
    @Field(() => [MJAIAgentRequest_])
    AIAgentRequests_RequestForUserIDArray: MJAIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [MJConversationDetail_])
    ConversationDetails_UserIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for Users
//****************************************************************************
@InputType()
export class CreateMJUserInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName: string | null;

    @Field({ nullable: true })
    LastName: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID: string | null;

    @Field({ nullable: true })
    EmployeeID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Users
//****************************************************************************
@InputType()
export class UpdateMJUserInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName?: string | null;

    @Field({ nullable: true })
    LastName?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID?: string | null;

    @Field({ nullable: true })
    EmployeeID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Users
//****************************************************************************
@ObjectType()
export class RunMJUserViewResult {
    @Field(() => [MJUser_])
    Results: MJUser_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUser_)
export class MJUserResolverBase extends ResolverBase {
    @Query(() => RunMJUserViewResult)
    async RunMJUserViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewResult)
    async RunMJUserViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewResult)
    async RunMJUserDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Users';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUser_, { nullable: true })
    async MJUser(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUser_ | null> {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Users', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [MJUser_])
    async AllUsers(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers]` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Users', rows);
        return result;
    }
    
    @FieldResolver(() => [MJUserApplication_])
    async UserApplications_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Applications', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserRole_])
    async UserRoles_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [MJWorkspace_])
    async Workspaces_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspaces', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaces] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workspaces', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReportSnapshot_])
    async ReportSnapshots_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Report Snapshots', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async RecordChanges_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDashboard_])
    async Dashboards_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboards', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserViewRun_])
    async UserViewRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [RunByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async AuditLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async Lists_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserFavorite_])
    async UserFavorites_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Favorites', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserRecordLog_])
    async UserRecordLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Record Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async UserViews_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRun_])
    async CompanyIntegrationRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [RunByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserNotification_])
    async UserNotifications_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Notifications', rows);
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecordMergeLog_])
    async RecordMergeLogs_InitiatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [InitiatedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDataContext_])
    async DataContexts_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContexts] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Contexts', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReportCategory_])
    async ReportCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Report Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJUserViewCategory_])
    async UserViewCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategory_])
    async DashboardCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboard Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJQueryCategory_])
    async QueryCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async DuplicateRuns_StartedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [StartedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJActionExecutionLog_])
    async ActionExecutionLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Execution Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async Actions_CodeApprovedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [CodeApprovedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJCommunicationRun_])
    async CommunicationRuns_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationRuns] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJTemplate_])
    async Templates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Templates', rows);
        return result;
    }
        
    @FieldResolver(() => [MJTemplateCategory_])
    async TemplateCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecommendationRun_])
    async RecommendationRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [RunByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJRecordChangeReplayRun_])
    async RecordChangeReplayRuns_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Change Replay Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChangeReplayRuns] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Change Replay Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [MJListCategory_])
    async ListCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('List Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [MJScheduledAction_])
    async ScheduledActions_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [CreatedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJResourceLink_])
    async ResourceLinks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Links', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async AIAgentRequests_ResponseByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [ResponseByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows);
        return result;
    }
        
    @FieldResolver(() => [MJReportUserState_])
    async MJ_ReportUserStates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', rows);
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async ResourcePermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async AIAgentRequests_RequestForUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [RequestForUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows);
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows);
        return result;
    }
        
    @Mutation(() => MJUser_)
    async CreateMJUser(
        @Arg('input', () => CreateMJUserInput) input: CreateMJUserInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Users', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUser_)
    async UpdateMJUser(
        @Arg('input', () => UpdateMJUserInput) input: UpdateMJUserInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Users', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUser_)
    async DeleteMJUser(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Users', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Vector Databases
//****************************************************************************
@ObjectType()
export class MJVectorDatabase_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DefaultURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ClassKey?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJVectorIndex_])
    VectorIndexes_VectorDatabaseIDArray: MJVectorIndex_[]; // Link to VectorIndexes
    
    @Field(() => [MJEntityDocument_])
    EntityDocuments_IDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Vector Databases
//****************************************************************************
@InputType()
export class CreateMJVectorDatabaseInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultURL: string | null;

    @Field({ nullable: true })
    ClassKey: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Vector Databases
//****************************************************************************
@InputType()
export class UpdateMJVectorDatabaseInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultURL?: string | null;

    @Field({ nullable: true })
    ClassKey?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Vector Databases
//****************************************************************************
@ObjectType()
export class RunMJVectorDatabaseViewResult {
    @Field(() => [MJVectorDatabase_])
    Results: MJVectorDatabase_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVectorDatabase_)
export class MJVectorDatabaseResolver extends ResolverBase {
    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Vector Databases';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVectorDatabase_, { nullable: true })
    async MJVectorDatabase(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVectorDatabase_ | null> {
        this.CheckUserReadPermissions('Vector Databases', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorDatabases] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Databases', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Vector Databases', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJVectorIndex_])
    async VectorIndexes_VectorDatabaseIDArray(@Root() mjvectordatabase_: MJVectorDatabase_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [VectorDatabaseID]='${mjvectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Vector Indexes', rows);
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_IDArray(@Root() mjvectordatabase_: MJVectorDatabase_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [ID]='${mjvectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @Mutation(() => MJVectorDatabase_)
    async CreateMJVectorDatabase(
        @Arg('input', () => CreateMJVectorDatabaseInput) input: CreateMJVectorDatabaseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Vector Databases', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVectorDatabase_)
    async UpdateMJVectorDatabase(
        @Arg('input', () => UpdateMJVectorDatabaseInput) input: UpdateMJVectorDatabaseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Vector Databases', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVectorDatabase_)
    async DeleteMJVectorDatabase(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Vector Databases', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Vector Indexes
//****************************************************************************
@ObjectType()
export class MJVectorIndex_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(16)
    EmbeddingModelID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(100)
    EmbeddingModel: string;
        
    @Field(() => [MJEntityRecordDocument_])
    EntityRecordDocuments_VectorIndexIDArray: MJEntityRecordDocument_[]; // Link to EntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for Vector Indexes
//****************************************************************************
@InputType()
export class CreateMJVectorIndexInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Vector Indexes
//****************************************************************************
@InputType()
export class UpdateMJVectorIndexInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Vector Indexes
//****************************************************************************
@ObjectType()
export class RunMJVectorIndexViewResult {
    @Field(() => [MJVectorIndex_])
    Results: MJVectorIndex_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVectorIndex_)
export class MJVectorIndexResolver extends ResolverBase {
    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Vector Indexes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVectorIndex_, { nullable: true })
    async MJVectorIndex(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVectorIndex_ | null> {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Vector Indexes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJEntityRecordDocument_])
    async EntityRecordDocuments_VectorIndexIDArray(@Root() mjvectorindex_: MJVectorIndex_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [VectorIndexID]='${mjvectorindex_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows);
        return result;
    }
        
    @Mutation(() => MJVectorIndex_)
    async CreateMJVectorIndex(
        @Arg('input', () => CreateMJVectorIndexInput) input: CreateMJVectorIndexInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Vector Indexes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVectorIndex_)
    async UpdateMJVectorIndex(
        @Arg('input', () => UpdateMJVectorIndexInput) input: UpdateMJVectorIndexInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Vector Indexes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVectorIndex_)
    async DeleteMJVectorIndex(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Vector Indexes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Version Installations
//****************************************************************************
@ObjectType()
export class MJVersionInstallation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field(() => Int) 
    MajorVersion: number;
        
    @Field(() => Int) 
    MinorVersion: number;
        
    @Field(() => Int) 
    PatchVersion: number;
        
    @Field({nullable: true, description: `What type of installation was applied`}) 
    @MaxLength(40)
    Type?: string;
        
    @Field() 
    @MaxLength(8)
    InstalledAt: Date;
        
    @Field({description: `Pending, Complete, Failed`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Any logging that was saved from the installation process`}) 
    InstallLog?: string;
        
    @Field({nullable: true, description: `Optional, comments the administrator wants to save for each installed version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(604)
    CompleteVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for Version Installations
//****************************************************************************
@InputType()
export class CreateMJVersionInstallationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Version Installations
//****************************************************************************
@InputType()
export class UpdateMJVersionInstallationInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Version Installations
//****************************************************************************
@ObjectType()
export class RunMJVersionInstallationViewResult {
    @Field(() => [MJVersionInstallation_])
    Results: MJVersionInstallation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionInstallation_)
export class MJVersionInstallationResolver extends ResolverBase {
    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Version Installations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionInstallation_, { nullable: true })
    async MJVersionInstallation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionInstallation_ | null> {
        this.CheckUserReadPermissions('Version Installations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionInstallations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Version Installations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Version Installations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJVersionInstallation_)
    async CreateMJVersionInstallation(
        @Arg('input', () => CreateMJVersionInstallationInput) input: CreateMJVersionInstallationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Version Installations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionInstallation_)
    async UpdateMJVersionInstallation(
        @Arg('input', () => UpdateMJVersionInstallationInput) input: UpdateMJVersionInstallationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Version Installations', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflow Engines
//****************************************************************************
@ObjectType()
export class MJWorkflowEngine_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(1000)
    DriverPath: string;
        
    @Field() 
    @MaxLength(200)
    DriverClass: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJWorkflow_])
    Workflows_WorkflowEngineNameArray: MJWorkflow_[]; // Link to Workflows
    
}

//****************************************************************************
// INPUT TYPE for Workflow Engines
//****************************************************************************
@InputType()
export class UpdateMJWorkflowEngineInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverPath?: string;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflow Engines
//****************************************************************************
@ObjectType()
export class RunMJWorkflowEngineViewResult {
    @Field(() => [MJWorkflowEngine_])
    Results: MJWorkflowEngine_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflowEngine_)
export class MJWorkflowEngineResolver extends ResolverBase {
    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflow Engines';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflowEngine_, { nullable: true })
    async MJWorkflowEngine(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflowEngine_ | null> {
        this.CheckUserReadPermissions('Workflow Engines', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowEngines] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Engines', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workflow Engines', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJWorkflow_])
    async Workflows_WorkflowEngineNameArray(@Root() mjworkflowengine_: MJWorkflowEngine_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [WorkflowEngineName]='${mjworkflowengine_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workflows', rows);
        return result;
    }
        
    @Mutation(() => MJWorkflowEngine_)
    async UpdateMJWorkflowEngine(
        @Arg('input', () => UpdateMJWorkflowEngineInput) input: UpdateMJWorkflowEngineInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflow Engines', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkflowEngine_)
    async DeleteMJWorkflowEngine(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workflow Engines', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflow Runs
//****************************************************************************
@ObjectType()
export class MJWorkflowRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    WorkflowID: string;
        
    @Field() 
    @MaxLength(1000)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    Results?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Workflow: string;
        
    @Field() 
    @MaxLength(200)
    WorkflowEngineName: string;
        
}

//****************************************************************************
// INPUT TYPE for Workflow Runs
//****************************************************************************
@InputType()
export class UpdateMJWorkflowRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    WorkflowID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Results?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflow Runs
//****************************************************************************
@ObjectType()
export class RunMJWorkflowRunViewResult {
    @Field(() => [MJWorkflowRun_])
    Results: MJWorkflowRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflowRun_)
export class MJWorkflowRunResolver extends ResolverBase {
    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflow Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflowRun_, { nullable: true })
    async MJWorkflowRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflowRun_ | null> {
        this.CheckUserReadPermissions('Workflow Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workflow Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJWorkflowRun_)
    async UpdateMJWorkflowRun(
        @Arg('input', () => UpdateMJWorkflowRunInput) input: UpdateMJWorkflowRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflow Runs', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflows
//****************************************************************************
@ObjectType()
export class MJWorkflow_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    WorkflowEngineID: string;
        
    @Field() 
    @MaxLength(200)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean, {description: `If set to 1, the workflow will be run automatically on the interval specified by the AutoRunIntervalType and AutoRunInterval fields`}) 
    AutoRunEnabled: boolean;
        
    @Field({nullable: true, description: `Minutes, Hours, Days, Weeks, Months, Years`}) 
    @MaxLength(40)
    AutoRunIntervalUnits?: string;
        
    @Field(() => Int, {nullable: true, description: `The interval, denominated in the units specified in the AutoRunIntervalUnits column, between auto runs of this workflow.`}) 
    AutoRunInterval?: number;
        
    @Field({nullable: true, description: `If specified, this subclass key, via the ClassFactory, will be instantiated, to execute this workflow. If not specified the WorkflowBase class will be used by default.`}) 
    @MaxLength(400)
    SubclassName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true}) 
    AutoRunIntervalMinutes?: number;
        
    @Field(() => [MJReport_])
    Reports_OutputWorkflowIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJWorkflowRun_])
    WorkflowRuns_WorkflowNameArray: MJWorkflowRun_[]; // Link to WorkflowRuns
    
}

//****************************************************************************
// INPUT TYPE for Workflows
//****************************************************************************
@InputType()
export class UpdateMJWorkflowInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkflowEngineID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    AutoRunEnabled?: boolean;

    @Field({ nullable: true })
    AutoRunIntervalUnits?: string | null;

    @Field(() => Int, { nullable: true })
    AutoRunInterval?: number | null;

    @Field({ nullable: true })
    SubclassName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflows
//****************************************************************************
@ObjectType()
export class RunMJWorkflowViewResult {
    @Field(() => [MJWorkflow_])
    Results: MJWorkflow_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflow_)
export class MJWorkflowResolver extends ResolverBase {
    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflows';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflow_, { nullable: true })
    async MJWorkflow(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflow_ | null> {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workflows', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_OutputWorkflowIDArray(@Root() mjworkflow_: MJWorkflow_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputWorkflowID]='${mjworkflow_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [MJWorkflowRun_])
    async WorkflowRuns_WorkflowNameArray(@Root() mjworkflow_: MJWorkflow_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflow Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowRuns] WHERE [WorkflowName]='${mjworkflow_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workflow Runs', rows);
        return result;
    }
        
    @Mutation(() => MJWorkflow_)
    async UpdateMJWorkflow(
        @Arg('input', () => UpdateMJWorkflowInput) input: UpdateMJWorkflowInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflows', input, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workspace Items
//****************************************************************************
@ObjectType({ description: `Tracks the resources that are active within a given worksapce` })
export class MJWorkspaceItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    WorkspaceID: string;
        
    @Field() 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(4000)
    ResourceRecordID?: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field({nullable: true}) 
    Configuration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Workspace: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for Workspace Items
//****************************************************************************
@InputType()
export class CreateMJWorkspaceItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workspace Items
//****************************************************************************
@InputType()
export class UpdateMJWorkspaceItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workspace Items
//****************************************************************************
@ObjectType()
export class RunMJWorkspaceItemViewResult {
    @Field(() => [MJWorkspaceItem_])
    Results: MJWorkspaceItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkspaceItem_)
export class MJWorkspaceItemResolver extends ResolverBase {
    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workspace Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkspaceItem_, { nullable: true })
    async MJWorkspaceItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkspaceItem_ | null> {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workspace Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => MJWorkspaceItem_)
    async CreateMJWorkspaceItem(
        @Arg('input', () => CreateMJWorkspaceItemInput) input: CreateMJWorkspaceItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workspace Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkspaceItem_)
    async UpdateMJWorkspaceItem(
        @Arg('input', () => UpdateMJWorkspaceItemInput) input: UpdateMJWorkspaceItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workspace Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkspaceItem_)
    async DeleteMJWorkspaceItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workspace Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workspaces
//****************************************************************************
@ObjectType({ description: `A user can have one or more workspaces` })
export class MJWorkspace_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJWorkspaceItem_])
    WorkspaceItems_WorkSpaceIDArray: MJWorkspaceItem_[]; // Link to WorkspaceItems
    
}

//****************************************************************************
// INPUT TYPE for Workspaces
//****************************************************************************
@InputType()
export class CreateMJWorkspaceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Workspaces
//****************************************************************************
@InputType()
export class UpdateMJWorkspaceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workspaces
//****************************************************************************
@ObjectType()
export class RunMJWorkspaceViewResult {
    @Field(() => [MJWorkspace_])
    Results: MJWorkspace_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkspace_)
export class MJWorkspaceResolver extends ResolverBase {
    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workspaces';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkspace_, { nullable: true })
    async MJWorkspace(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkspace_ | null> {
        this.CheckUserReadPermissions('Workspaces', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaces] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workspaces', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [MJWorkspaceItem_])
    async WorkspaceItems_WorkSpaceIDArray(@Root() mjworkspace_: MJWorkspace_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [WorkSpaceID]='${mjworkspace_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workspace Items', rows);
        return result;
    }
        
    @Mutation(() => MJWorkspace_)
    async CreateMJWorkspace(
        @Arg('input', () => CreateMJWorkspaceInput) input: CreateMJWorkspaceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workspaces', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkspace_)
    async UpdateMJWorkspace(
        @Arg('input', () => UpdateMJWorkspaceInput) input: UpdateMJWorkspaceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workspaces', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkspace_)
    async DeleteMJWorkspace(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workspaces', key, options, provider, userPayload, pubSub);
    }
    
}