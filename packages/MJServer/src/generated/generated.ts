/********************************************************************************
* ALL ENTITIES - TypeGraphQL Type Class Definition - AUTO GENERATED FILE
* Generated Entities and Resolvers for Server
*
*   >>> DO NOT MODIFY THIS FILE!!!!!!!!!!!!
*   >>> YOUR CHANGES WILL BE OVERWRITTEN
*   >>> THE NEXT TIME THIS FILE IS GENERATED
*
**********************************************************************************/
import { Arg, Ctx, Int, Query, Resolver, Field, Float, ObjectType, FieldResolver, Root, InputType, Mutation,
            PubSub, PubSubEngine, ResolverBase, RunViewByIDInput, RunViewByNameInput, RunDynamicViewInput,
            AppContext, KeyValuePairInput, DeleteOptionsInput, GraphQLTimestamp as Timestamp,
            GetReadOnlyDataSource, GetReadWriteDataSource, GetReadOnlyProvider, GetReadWriteProvider } from '@memberjunction/server';
import { SQLServerDataProvider } from '@memberjunction/sqlserver-dataprovider';
import { Metadata, EntityPermissionType, CompositeKey, UserInfo } from '@memberjunction/core'

import { MaxLength } from 'class-validator';
import { mj_core_schema } from '../config.js';



import { ScheduledActionEntity, ScheduledActionParamEntity, ExplorerNavigationItemEntity, GeneratedCodeCategoryEntity, AIAgentModelEntity, ComponentRegistryEntity, AIAgentNoteTypeEntity, ComponentDependencyEntity, AIAgentRunEntity, AIVendorEntity, AIConfigurationEntity, AIAgentEntity, AIAgentStepEntity, AIModelCostEntity, AIPromptModelEntity, AIAgentTypeEntity, AIAgentNoteEntity, AIAgentActionEntity, AIModelPriceTypeEntity, AIPromptEntity, AIResultCacheEntity, AIPromptCategoryEntity, AIPromptTypeEntity, CompanyEntity, EmployeeEntity, UserFavoriteEntity, EmployeeCompanyIntegrationEntity, EmployeeRoleEntity, EmployeeSkillEntity, RoleEntity, SkillEntity, IntegrationURLFormatEntity, IntegrationEntity, CompanyIntegrationEntity, EntityFieldEntity, EntityEntity, UserEntity, EntityRelationshipEntity, UserRecordLogEntity, UserViewEntity, CompanyIntegrationRunEntity, CompanyIntegrationRunDetailEntity, ErrorLogEntity, ApplicationEntity, ApplicationEntityEntity, EntityPermissionEntity, UserApplicationEntityEntity, UserApplicationEntity, CompanyIntegrationRunAPILogEntity, ListEntity, ListDetailEntity, UserViewRunEntity, UserViewRunDetailEntity, WorkflowRunEntity, WorkflowEntity, WorkflowEngineEntity, RecordChangeEntity, UserRoleEntity, RowLevelSecurityFilterEntity, AuditLogEntity, AuthorizationEntity, AuthorizationRoleEntity, AuditLogTypeEntity, EntityFieldValueEntity, AIModelEntity, AIActionEntity, AIModelActionEntity, EntityAIActionEntity, AIModelTypeEntity, QueueTypeEntity, QueueEntity, QueueTaskEntity, DashboardEntity, OutputTriggerTypeEntity, OutputFormatTypeEntity, OutputDeliveryTypeEntity, ReportEntity, ReportSnapshotEntity, ResourceTypeEntity, TagEntity, TaggedItemEntity, WorkspaceEntity, WorkspaceItemEntity, DatasetEntity, DatasetItemEntity, ConversationDetailEntity, ConversationEntity, UserNotificationEntity, SchemaInfoEntity, CompanyIntegrationRecordMapEntity, RecordMergeLogEntity, RecordMergeDeletionLogEntity, QueryFieldEntity, QueryCategoryEntity, QueryEntity, QueryPermissionEntity, VectorIndexEntity, EntityDocumentTypeEntity, EntityDocumentRunEntity, VectorDatabaseEntity, EntityRecordDocumentEntity, EntityDocumentEntity, DataContextItemEntity, DataContextEntity, UserViewCategoryEntity, DashboardCategoryEntity, ReportCategoryEntity, FileStorageProviderEntity, FileEntity, FileCategoryEntity, FileEntityRecordLinkEntity, VersionInstallationEntity, DuplicateRunDetailMatchEntity, EntityDocumentSettingEntity, EntitySettingEntity, DuplicateRunEntity, DuplicateRunDetailEntity, ApplicationSettingEntity, ActionCategoryEntity, EntityActionEntity, EntityActionInvocationEntity, ActionAuthorizationEntity, EntityActionInvocationTypeEntity, ActionEntity, EntityActionFilterEntity, ActionFilterEntity, ActionContextTypeEntity, ActionResultCodeEntity, ActionContextEntity, ActionExecutionLogEntity, ActionParamEntity, ActionLibraryEntity, LibraryEntity, ListCategoryEntity, CommunicationProviderEntity, CommunicationRunEntity, CommunicationProviderMessageTypeEntity, CommunicationLogEntity, CommunicationBaseMessageTypeEntity, TemplateEntity, TemplateCategoryEntity, TemplateContentEntity, TemplateParamEntity, TemplateContentTypeEntity, RecommendationEntity, RecommendationProviderEntity, RecommendationRunEntity, RecommendationItemEntity, EntityCommunicationMessageTypeEntity, EntityCommunicationFieldEntity, RecordChangeReplayRunEntity, LibraryItemEntity, EntityRelationshipDisplayComponentEntity, EntityActionParamEntity, ResourcePermissionEntity, ResourceLinkEntity, ConversationArtifactVersionEntity, AIAgentRequestEntity, AIModelVendorEntity, AIVendorTypeDefinitionEntity, ReportUserStateEntity, QueryEntityEntity, DashboardUserStateEntity, ComponentEntity, ArtifactTypeEntity, AIVendorTypeEntity, ConversationArtifactEntity, AIAgentPromptEntity, ComponentLibraryEntity, DashboardUserPreferenceEntity, QueryParameterEntity, AIAgentRelationshipEntity, ComponentLibraryLinkEntity, ContentProcessRunEntity, ContentSourceEntity, ContentSourceParamEntity, ContentSourceTypeEntity, ContentSourceTypeParamEntity, ContentTypeEntity, ContentTypeAttributeEntity, ContentFileTypeEntity, ContentItemEntity, ContentItemAttributeEntity, ContentItemTagEntity, GeneratedCodeEntity, AIPromptRunEntity, AIAgentRunStepEntity, ConversationArtifactPermissionEntity, AIModelPriceUnitTypeEntity, AIAgentStepPathEntity, AIAgentLearningCycleEntity, ReportVersionEntity, AIConfigurationParamEntity } from '@memberjunction/core-entities';
    

//****************************************************************************
// ENTITY CLASS for Scheduled Actions
//****************************************************************************
@ObjectType({ description: `Track scheduled actions and their details` })
export class ScheduledAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    CreatedByUserID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Type of the scheduled action (Daily, Weekly, Monthly, Yearly, Custom)`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Cron expression defining the schedule, automatically maintained by the system unless Type is Custom, in which case the user directly sets this`}) 
    @MaxLength(200)
    CronExpression?: string;
        
    @Field({description: `Timezone for the scheduled action, if not specified defaults to UTC/Z`}) 
    @MaxLength(200)
    Timezone: string;
        
    @Field({description: `Status of the scheduled action (Pending, Active, Disabled, Expired)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Interval in days for the scheduled action`}) 
    IntervalDays?: number;
        
    @Field({nullable: true, description: `Day of the week for the scheduled action`}) 
    @MaxLength(40)
    DayOfWeek?: string;
        
    @Field(() => Int, {nullable: true, description: `Day of the month for the scheduled action`}) 
    DayOfMonth?: number;
        
    @Field({nullable: true, description: `Month for the scheduled action`}) 
    @MaxLength(40)
    Month?: string;
        
    @Field({nullable: true, description: `Field CustomCronExpression for entity Scheduled Actions.`}) 
    @MaxLength(510)
    CustomCronExpression?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    CreatedByUser: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [ScheduledActionParam_])
    ScheduledActionParams_ScheduledActionIDArray: ScheduledActionParam_[]; // Link to ScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for Scheduled Actions
//****************************************************************************
@InputType()
export class CreateScheduledActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays: number | null;

    @Field({ nullable: true })
    DayOfWeek: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth: number | null;

    @Field({ nullable: true })
    Month: string | null;

    @Field({ nullable: true })
    CustomCronExpression: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Scheduled Actions
//****************************************************************************
@InputType()
export class UpdateScheduledActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression?: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays?: number | null;

    @Field({ nullable: true })
    DayOfWeek?: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth?: number | null;

    @Field({ nullable: true })
    Month?: string | null;

    @Field({ nullable: true })
    CustomCronExpression?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Scheduled Actions
//****************************************************************************
@ObjectType()
export class RunScheduledActionViewResult {
    @Field(() => [ScheduledAction_])
    Results: ScheduledAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ScheduledAction_)
export class ScheduledActionResolver extends ResolverBase {
    @Query(() => RunScheduledActionViewResult)
    async RunScheduledActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunScheduledActionViewResult)
    async RunScheduledActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunScheduledActionViewResult)
    async RunScheduledActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Scheduled Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ScheduledAction_, { nullable: true })
    async ScheduledAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ScheduledAction_ | null> {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Scheduled Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ScheduledActionParam_])
    async ScheduledActionParams_ScheduledActionIDArray(@Root() scheduledaction_: ScheduledAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ScheduledActionID]='${scheduledaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Action Params', rows);
        return result;
    }
        
    @Mutation(() => ScheduledAction_)
    async CreateScheduledAction(
        @Arg('input', () => CreateScheduledActionInput) input: CreateScheduledActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Scheduled Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ScheduledAction_)
    async UpdateScheduledAction(
        @Arg('input', () => UpdateScheduledActionInput) input: UpdateScheduledActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Scheduled Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ScheduledAction_)
    async DeleteScheduledAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Scheduled Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Scheduled Action Params
//****************************************************************************
@ObjectType({ description: `Stores parameter values for scheduled action executions, configuring inputs for automated action runs.` })
export class ScheduledActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ScheduledActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionParamID: string;
        
    @Field({description: `Field ValueType for entity Scheduled Action Params.`}) 
    @MaxLength(40)
    ValueType: string;
        
    @Field({nullable: true, description: `Field Value for entity Scheduled Action Params.`}) 
    Value?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ScheduledAction: string;
        
    @Field() 
    @MaxLength(510)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for Scheduled Action Params
//****************************************************************************
@InputType()
export class CreateScheduledActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Scheduled Action Params
//****************************************************************************
@InputType()
export class UpdateScheduledActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Scheduled Action Params
//****************************************************************************
@ObjectType()
export class RunScheduledActionParamViewResult {
    @Field(() => [ScheduledActionParam_])
    Results: ScheduledActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ScheduledActionParam_)
export class ScheduledActionParamResolver extends ResolverBase {
    @Query(() => RunScheduledActionParamViewResult)
    async RunScheduledActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunScheduledActionParamViewResult)
    async RunScheduledActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunScheduledActionParamViewResult)
    async RunScheduledActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Scheduled Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ScheduledActionParam_, { nullable: true })
    async ScheduledActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ScheduledActionParam_ | null> {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Scheduled Action Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ScheduledActionParam_)
    async CreateScheduledActionParam(
        @Arg('input', () => CreateScheduledActionParamInput) input: CreateScheduledActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Scheduled Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ScheduledActionParam_)
    async UpdateScheduledActionParam(
        @Arg('input', () => UpdateScheduledActionParamInput) input: UpdateScheduledActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Scheduled Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ScheduledActionParam_)
    async DeleteScheduledActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Scheduled Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Explorer Navigation Items
//****************************************************************************
@ObjectType({ description: `Table to store navigation items for MemberJunction Explorer` })
export class ExplorerNavigationItem_ {
    @Field({description: `Unique identifier for each navigation item`}) 
    @MaxLength(16)
    ID: string;
        
    @Field(() => Int, {description: `Sequence number for the navigation item, must be unique and greater than 0`}) 
    Sequence: number;
        
    @Field({description: `Unique name of the navigation item displayed to the user`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The route for the navigation item relative to the app main URL, using Angular syntax like "entity/:entityName"`}) 
    @MaxLength(510)
    Route: string;
        
    @Field(() => Boolean, {description: `Indicates if the navigation item is active; allows turning off items in the UI without deleting them from the metadata`}) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `Controls if the navigation item is shown on the Home screen for MJ Explorer`}) 
    ShowInHomeScreen: boolean;
        
    @Field(() => Boolean, {description: `Controls if the item is shown in the left navigation drawer in the MJ Explorer app or not.`}) 
    ShowInNavigationDrawer: boolean;
        
    @Field({nullable: true, description: `Optional, CSS class for an icon to be displayed with the navigation item`}) 
    @MaxLength(200)
    IconCSSClass?: string;
        
    @Field({nullable: true, description: `Description of the navigation item, shown to the user on hover or in larger displays`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Administrator comments, not shown to the end user in MJ Explorer app`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Explorer Navigation Items
//****************************************************************************
@InputType()
export class CreateExplorerNavigationItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Explorer Navigation Items
//****************************************************************************
@InputType()
export class UpdateExplorerNavigationItemInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Explorer Navigation Items
//****************************************************************************
@ObjectType()
export class RunExplorerNavigationItemViewResult {
    @Field(() => [ExplorerNavigationItem_])
    Results: ExplorerNavigationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ExplorerNavigationItem_)
export class ExplorerNavigationItemResolver extends ResolverBase {
    @Query(() => RunExplorerNavigationItemViewResult)
    async RunExplorerNavigationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunExplorerNavigationItemViewResult)
    async RunExplorerNavigationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunExplorerNavigationItemViewResult)
    async RunExplorerNavigationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Explorer Navigation Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ExplorerNavigationItem_, { nullable: true })
    async ExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ExplorerNavigationItem_ | null> {
        this.CheckUserReadPermissions('Explorer Navigation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwExplorerNavigationItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Explorer Navigation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Explorer Navigation Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ExplorerNavigationItem_)
    async CreateExplorerNavigationItem(
        @Arg('input', () => CreateExplorerNavigationItemInput) input: CreateExplorerNavigationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Explorer Navigation Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ExplorerNavigationItem_)
    async UpdateExplorerNavigationItem(
        @Arg('input', () => UpdateExplorerNavigationItemInput) input: UpdateExplorerNavigationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Explorer Navigation Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ExplorerNavigationItem_)
    async DeleteExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Explorer Navigation Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Generated Code Categories
//****************************************************************************
@ObjectType({ description: `Categorization for generated code, including optional parent-child relationships.` })
export class GeneratedCodeCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Parent category ID, allowing for hierarchical categorization.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [GeneratedCodeCategory_])
    GeneratedCodeCategories_ParentIDArray: GeneratedCodeCategory_[]; // Link to GeneratedCodeCategories
    
    @Field(() => [GeneratedCode_])
    GeneratedCodes_CategoryIDArray: GeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for Generated Code Categories
//****************************************************************************
@InputType()
export class CreateGeneratedCodeCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Generated Code Categories
//****************************************************************************
@InputType()
export class UpdateGeneratedCodeCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Generated Code Categories
//****************************************************************************
@ObjectType()
export class RunGeneratedCodeCategoryViewResult {
    @Field(() => [GeneratedCodeCategory_])
    Results: GeneratedCodeCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(GeneratedCodeCategory_)
export class GeneratedCodeCategoryResolver extends ResolverBase {
    @Query(() => RunGeneratedCodeCategoryViewResult)
    async RunGeneratedCodeCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunGeneratedCodeCategoryViewResult)
    async RunGeneratedCodeCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunGeneratedCodeCategoryViewResult)
    async RunGeneratedCodeCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Generated Code Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => GeneratedCodeCategory_, { nullable: true })
    async GeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<GeneratedCodeCategory_ | null> {
        this.CheckUserReadPermissions('Generated Code Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodeCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Generated Code Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [GeneratedCodeCategory_])
    async GeneratedCodeCategories_ParentIDArray(@Root() generatedcodecategory_: GeneratedCodeCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Code Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodeCategories] WHERE [ParentID]='${generatedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Code Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [GeneratedCode_])
    async GeneratedCodes_CategoryIDArray(@Root() generatedcodecategory_: GeneratedCodeCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [CategoryID]='${generatedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows);
        return result;
    }
        
    @Mutation(() => GeneratedCodeCategory_)
    async CreateGeneratedCodeCategory(
        @Arg('input', () => CreateGeneratedCodeCategoryInput) input: CreateGeneratedCodeCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Generated Code Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => GeneratedCodeCategory_)
    async UpdateGeneratedCodeCategory(
        @Arg('input', () => UpdateGeneratedCodeCategoryInput) input: UpdateGeneratedCodeCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Generated Code Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => GeneratedCodeCategory_)
    async DeleteGeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Generated Code Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Models
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and AI models.` })
export class AIAgentModel_ {
    @Field({description: `The unique identifier for each AI agent-model mapping. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from AIAgent table.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `The unique identifier of the associated AI model.`}) 
    @MaxLength(16)
    ModelID?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether this specific agent-model combination is currently enabled for use in AI operations.`}) 
    Active?: boolean;
        
    @Field(() => Int, {nullable: true, description: `The priority level of the AI model for the agent, where higher values indicate higher priority.`}) 
    Priority?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Model?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Models
//****************************************************************************
@InputType()
export class CreateAIAgentModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    Active: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority: number | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Models
//****************************************************************************
@InputType()
export class UpdateAIAgentModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Models
//****************************************************************************
@ObjectType()
export class RunAIAgentModelViewResult {
    @Field(() => [AIAgentModel_])
    Results: AIAgentModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentModel_)
export class AIAgentModelResolver extends ResolverBase {
    @Query(() => RunAIAgentModelViewResult)
    async RunAIAgentModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentModelViewResult)
    async RunAIAgentModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentModelViewResult)
    async RunAIAgentModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentModel_, { nullable: true })
    async AIAgentModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentModel_ | null> {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Models', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIAgentModel_)
    async CreateAIAgentModel(
        @Arg('input', () => CreateAIAgentModelInput) input: CreateAIAgentModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentModel_)
    async UpdateAIAgentModel(
        @Arg('input', () => UpdateAIAgentModelInput) input: UpdateAIAgentModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentModel_)
    async DeleteAIAgentModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Registries
//****************************************************************************
@ObjectType({ description: `Registry catalog for component sources, similar to NPM registry but supporting multiple sources` })
export class ComponentRegistry_ {
    @Field({description: `Primary key for the component registry`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the registry (e.g., MemberJunction Registry, NPM, Internal Registry)`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the registry and its purpose`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Registry endpoint URI (e.g., https://registry.memberjunction.org)`}) 
    @MaxLength(1000)
    URI?: string;
        
    @Field({nullable: true, description: `Type of registry: public, private, or internal`}) 
    @MaxLength(100)
    Type?: string;
        
    @Field({nullable: true, description: `API version supported by the registry for compatibility`}) 
    @MaxLength(100)
    APIVersion?: string;
        
    @Field({nullable: true, description: `Current status of the registry: active, deprecated, or offline`}) 
    @MaxLength(100)
    Status?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Component_])
    MJ_Components_SourceRegistryIDArray: Component_[]; // Link to MJ_Components
    
}

//****************************************************************************
// INPUT TYPE for MJ: Component Registries
//****************************************************************************
@InputType()
export class CreateComponentRegistryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    URI: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    APIVersion: string | null;

    @Field({ nullable: true })
    Status: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Registries
//****************************************************************************
@InputType()
export class UpdateComponentRegistryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    URI?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    APIVersion?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Registries
//****************************************************************************
@ObjectType()
export class RunComponentRegistryViewResult {
    @Field(() => [ComponentRegistry_])
    Results: ComponentRegistry_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ComponentRegistry_)
export class ComponentRegistryResolver extends ResolverBase {
    @Query(() => RunComponentRegistryViewResult)
    async RunComponentRegistryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentRegistryViewResult)
    async RunComponentRegistryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentRegistryViewResult)
    async RunComponentRegistryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Registries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ComponentRegistry_, { nullable: true })
    async ComponentRegistry(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ComponentRegistry_ | null> {
        this.CheckUserReadPermissions('MJ: Component Registries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentRegistries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Registries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Component Registries', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Component_])
    async MJ_Components_SourceRegistryIDArray(@Root() componentregistry_: ComponentRegistry_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponents] WHERE [SourceRegistryID]='${componentregistry_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Components', rows);
        return result;
    }
        
    @Mutation(() => ComponentRegistry_)
    async CreateComponentRegistry(
        @Arg('input', () => CreateComponentRegistryInput) input: CreateComponentRegistryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Registries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ComponentRegistry_)
    async UpdateComponentRegistry(
        @Arg('input', () => UpdateComponentRegistryInput) input: UpdateComponentRegistryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Registries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ComponentRegistry_)
    async DeleteComponentRegistry(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Registries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Note Types
//****************************************************************************
@ObjectType({ description: `Defines categories and types for AI agent notes, enabling classification and organization of agent-generated observations, recommendations, and learnings.` })
export class AIAgentNoteType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIAgentNote_])
    AIAgentNotes_AgentNoteTypeIDArray: AIAgentNote_[]; // Link to AIAgentNotes
    
}

//****************************************************************************
// INPUT TYPE for AI Agent Note Types
//****************************************************************************
@InputType()
export class CreateAIAgentNoteTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Note Types
//****************************************************************************
@InputType()
export class UpdateAIAgentNoteTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Note Types
//****************************************************************************
@ObjectType()
export class RunAIAgentNoteTypeViewResult {
    @Field(() => [AIAgentNoteType_])
    Results: AIAgentNoteType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentNoteType_)
export class AIAgentNoteTypeResolver extends ResolverBase {
    @Query(() => RunAIAgentNoteTypeViewResult)
    async RunAIAgentNoteTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentNoteTypeViewResult)
    async RunAIAgentNoteTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentNoteTypeViewResult)
    async RunAIAgentNoteTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Note Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentNoteType_, { nullable: true })
    async AIAgentNoteType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentNoteType_ | null> {
        this.CheckUserReadPermissions('AI Agent Note Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNoteTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Note Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Note Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIAgentNote_])
    async AIAgentNotes_AgentNoteTypeIDArray(@Root() aiagentnotetype_: AIAgentNoteType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [AgentNoteTypeID]='${aiagentnotetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows);
        return result;
    }
        
    @Mutation(() => AIAgentNoteType_)
    async CreateAIAgentNoteType(
        @Arg('input', () => CreateAIAgentNoteTypeInput) input: CreateAIAgentNoteTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Note Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentNoteType_)
    async UpdateAIAgentNoteType(
        @Arg('input', () => UpdateAIAgentNoteTypeInput) input: UpdateAIAgentNoteTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Note Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentNoteType_)
    async DeleteAIAgentNoteType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Note Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Dependencies
//****************************************************************************
@ObjectType({ description: `Tracks component-to-component dependencies for composition` })
export class ComponentDependency_ {
    @Field({description: `Primary key for component dependency`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to parent Component that has the dependency`}) 
    @MaxLength(16)
    ComponentID: string;
        
    @Field({description: `Foreign key to the Component that is depended upon`}) 
    @MaxLength(16)
    DependencyComponentID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    Component: string;
        
    @Field() 
    @MaxLength(1000)
    DependencyComponent: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Component Dependencies
//****************************************************************************
@InputType()
export class CreateComponentDependencyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    DependencyComponentID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Dependencies
//****************************************************************************
@InputType()
export class UpdateComponentDependencyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    DependencyComponentID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Dependencies
//****************************************************************************
@ObjectType()
export class RunComponentDependencyViewResult {
    @Field(() => [ComponentDependency_])
    Results: ComponentDependency_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ComponentDependency_)
export class ComponentDependencyResolver extends ResolverBase {
    @Query(() => RunComponentDependencyViewResult)
    async RunComponentDependencyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentDependencyViewResult)
    async RunComponentDependencyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentDependencyViewResult)
    async RunComponentDependencyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Dependencies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ComponentDependency_, { nullable: true })
    async ComponentDependency(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ComponentDependency_ | null> {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentDependencies] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Component Dependencies', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ComponentDependency_)
    async CreateComponentDependency(
        @Arg('input', () => CreateComponentDependencyInput) input: CreateComponentDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Dependencies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ComponentDependency_)
    async UpdateComponentDependency(
        @Arg('input', () => UpdateComponentDependencyInput) input: UpdateComponentDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Dependencies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ComponentDependency_)
    async DeleteComponentDependency(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Dependencies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Runs
//****************************************************************************
@ObjectType({ description: `Tracks individual execution runs of AI agents, including hierarchical sub-agent runs. Provides basic logging, state persistence, and resource tracking for agent executions. Supports pause/resume functionality through state serialization.` })
export class AIAgentRun_ {
    @Field({description: `Unique identifier for this agent run`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the AIAgent that is being executed in this run`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({nullable: true, description: `Reference to the parent agent run if this is a sub-agent execution. NULL for root-level agent runs. Enables hierarchical execution tracking.`}) 
    @MaxLength(16)
    ParentRunID?: string;
        
    @Field({description: `Current status of the agent run. Running -> Completed/Failed/Cancelled`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({description: `Timestamp when the agent run began execution`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the agent run completed (successfully or with failure). NULL while running.`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether the agent run completed successfully. NULL while running, TRUE/FALSE when completed.`}) 
    Success?: boolean;
        
    @Field({nullable: true, description: `Error message if the agent run failed. NULL for successful runs.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `Identifier linking multiple agent runs that are part of the same conversation or user session`}) 
    @MaxLength(16)
    ConversationID?: string;
        
    @Field({nullable: true, description: `User context identifier for authentication and permissions during the agent run`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Final result or output from the agent execution, stored as JSON or text`}) 
    Result?: string;
        
    @Field({nullable: true, description: `JSON serialization of the complete agent state, including conversation context, variables, and execution state. Enables pause/resume functionality.`}) 
    AgentState?: string;
        
    @Field(() => Int, {nullable: true, description: `Total number of tokens consumed by all LLM calls during this agent run`}) 
    TotalTokensUsed?: number;
        
    @Field(() => Float, {nullable: true, description: `Total estimated cost for all AI model usage during this agent run`}) 
    TotalCost?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Total number of prompt/input tokens used across all AIPromptRun executions during this agent run. This provides a breakdown of the TotalTokensUsed field to help analyze the ratio of input vs output tokens consumed by the agent.`}) 
    TotalPromptTokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Total number of completion/output tokens generated across all AIPromptRun executions during this agent run. This provides a breakdown of the TotalTokensUsed field to help analyze the ratio of input vs output tokens consumed by the agent.`}) 
    TotalCompletionTokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Total tokens used including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalTokensUsed. For parent agents, this includes the sum of all descendant agent tokens. Calculated as TotalPromptTokensUsedRollup + TotalCompletionTokensUsedRollup.`}) 
    TotalTokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total prompt/input tokens including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalPromptTokensUsed. For parent agents, this includes the sum of all descendant agent prompt tokens.`}) 
    TotalPromptTokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total completion/output tokens including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalCompletionTokensUsed. For parent agents, this includes the sum of all descendant agent completion tokens.`}) 
    TotalCompletionTokensUsedRollup?: number;
        
    @Field(() => Float, {nullable: true, description: `Total cost including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalCost. For parent agents, this includes the sum of all descendant agent costs. Note: This assumes all costs are in the same currency for accurate rollup.`}) 
    TotalCostRollup?: number;
        
    @Field({nullable: true, description: `Optional tracking of a specific conversation detail (e.g. a specific message) that spawned this agent run`}) 
    @MaxLength(16)
    ConversationDetailID?: string;
        
    @Field(() => Int, {nullable: true, description: `If a conversation detail spawned multiple agent runs, tracks the order of their spawn/execution`}) 
    ConversationDetailSequence?: number;
        
    @Field({nullable: true, description: `Reason for cancellation if the agent run was cancelled`}) 
    @MaxLength(60)
    CancellationReason?: string;
        
    @Field({nullable: true, description: `The final step type that concluded the agent run`}) 
    @MaxLength(60)
    FinalStep?: string;
        
    @Field({nullable: true, description: `JSON serialization of the final Payload state at the end of the agent run`}) 
    FinalPayload?: string;
        
    @Field({nullable: true, description: `Final message from the agent to the end user at the end of a run`}) 
    Message?: string;
        
    @Field({nullable: true, description: `Links to the previous run in a chain. Different from ParentRunID which is for sub-agent hierarchy.`}) 
    @MaxLength(16)
    LastRunID?: string;
        
    @Field({nullable: true, description: `The initial payload provided at the start of this run. Can be populated from the FinalPayload of the LastRun.`}) 
    StartingPayload?: string;
        
    @Field(() => Int, {description: `Total number of prompt iterations executed during this agent run. Incremented
each time the agent processes a prompt step.`}) 
    TotalPromptIterations: number;
        
    @Field({nullable: true, description: `The AI Configuration used for this agent execution. When set, this configuration was used for all prompts executed by this agent and its sub-agents.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field({nullable: true, description: `Runtime model override that was used for this execution. When set, this model took precedence over all other model selection methods.`}) 
    @MaxLength(16)
    OverrideModelID?: string;
        
    @Field({nullable: true, description: `Runtime vendor override that was used for this execution. When set along with OverrideModelID, this vendor was used to provide the model.`}) 
    @MaxLength(16)
    OverrideVendorID?: string;
        
    @Field({nullable: true, description: `JSON serialized data that was passed for template rendering and prompt execution. This data was passed to the agent's prompt as well as all sub-agents.`}) 
    Data?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether verbose logging was enabled during this agent execution. When true, detailed decision-making and execution flow was logged.`}) 
    Verbose?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Effort level that was actually used during this agent run execution (1-100, where 1=minimal effort, 100=maximum effort). This is the resolved effort level after applying the precedence hierarchy: runtime override > agent default > prompt defaults.`}) 
    EffortLevel?: number;
        
    @Field({nullable: true, description: `Optional name for the agent run to help identify and tag runs for easier reference`}) 
    @MaxLength(510)
    RunName?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this agent run`}) 
    Comments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OverrideModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OverrideVendor?: string;
        
    @Field(() => [AIAgentRunStep_])
    MJ_AIAgentRunSteps_AgentRunIDArray: AIAgentRunStep_[]; // Link to MJ_AIAgentRunSteps
    
    @Field(() => [AIAgentRun_])
    MJ_AIAgentRuns_ParentRunIDArray: AIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [AIPromptRun_])
    MJ_AIPromptRuns_AgentRunIDArray: AIPromptRun_[]; // Link to MJ_AIPromptRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Runs
//****************************************************************************
@InputType()
export class CreateAIAgentRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ParentRunID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success: boolean | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ConversationID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    Result: string | null;

    @Field({ nullable: true })
    AgentState: string | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsed?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsedRollup: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostRollup: number | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field(() => Int, { nullable: true })
    ConversationDetailSequence: number | null;

    @Field({ nullable: true })
    CancellationReason: string | null;

    @Field({ nullable: true })
    FinalStep: string | null;

    @Field({ nullable: true })
    FinalPayload: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    LastRunID: string | null;

    @Field({ nullable: true })
    StartingPayload: string | null;

    @Field(() => Int, { nullable: true })
    TotalPromptIterations?: number;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    OverrideModelID: string | null;

    @Field({ nullable: true })
    OverrideVendorID: string | null;

    @Field({ nullable: true })
    Data: string | null;

    @Field(() => Boolean, { nullable: true })
    Verbose?: boolean | null;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;

    @Field({ nullable: true })
    RunName: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Runs
//****************************************************************************
@InputType()
export class UpdateAIAgentRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ParentRunID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ConversationID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    Result?: string | null;

    @Field({ nullable: true })
    AgentState?: string | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsed?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsedRollup?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostRollup?: number | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field(() => Int, { nullable: true })
    ConversationDetailSequence?: number | null;

    @Field({ nullable: true })
    CancellationReason?: string | null;

    @Field({ nullable: true })
    FinalStep?: string | null;

    @Field({ nullable: true })
    FinalPayload?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    LastRunID?: string | null;

    @Field({ nullable: true })
    StartingPayload?: string | null;

    @Field(() => Int, { nullable: true })
    TotalPromptIterations?: number;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    OverrideModelID?: string | null;

    @Field({ nullable: true })
    OverrideVendorID?: string | null;

    @Field({ nullable: true })
    Data?: string | null;

    @Field(() => Boolean, { nullable: true })
    Verbose?: boolean | null;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field({ nullable: true })
    RunName?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Runs
//****************************************************************************
@ObjectType()
export class RunAIAgentRunViewResult {
    @Field(() => [AIAgentRun_])
    Results: AIAgentRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentRun_)
export class AIAgentRunResolver extends ResolverBase {
    @Query(() => RunAIAgentRunViewResult)
    async RunAIAgentRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRunViewResult)
    async RunAIAgentRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRunViewResult)
    async RunAIAgentRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentRun_, { nullable: true })
    async AIAgentRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentRun_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Agent Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIAgentRunStep_])
    async MJ_AIAgentRunSteps_AgentRunIDArray(@Root() aiagentrun_: AIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunSteps] WHERE [AgentRunID]='${aiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRun_])
    async MJ_AIAgentRuns_ParentRunIDArray(@Root() aiagentrun_: AIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ParentRunID]='${aiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptRun_])
    async MJ_AIPromptRuns_AgentRunIDArray(@Root() aiagentrun_: AIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [AgentRunID]='${aiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows);
        return result;
    }
        
    @Mutation(() => AIAgentRun_)
    async CreateAIAgentRun(
        @Arg('input', () => CreateAIAgentRunInput) input: CreateAIAgentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentRun_)
    async UpdateAIAgentRun(
        @Arg('input', () => UpdateAIAgentRunInput) input: UpdateAIAgentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentRun_)
    async DeleteAIAgentRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendors
//****************************************************************************
@ObjectType({ description: `Stores information about AI vendors providing models and/or inference services.` })
export class AIVendor_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The unique name of the vendor.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the vendor and their AI offerings.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIPromptModel_])
    MJ_AIPromptModels_VendorIDArray: AIPromptModel_[]; // Link to MJ_AIPromptModels
    
    @Field(() => [AIResultCache_])
    AIResultCache_VendorIDArray: AIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [AIModelVendor_])
    MJ_AIModelVendors_VendorIDArray: AIModelVendor_[]; // Link to MJ_AIModelVendors
    
    @Field(() => [AIPromptRun_])
    MJ_AIPromptRuns_VendorIDArray: AIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [AIVendorType_])
    MJ_AIVendorTypes_VendorIDArray: AIVendorType_[]; // Link to MJ_AIVendorTypes
    
    @Field(() => [AIModelCost_])
    MJ_AIModelCosts_VendorIDArray: AIModelCost_[]; // Link to MJ_AIModelCosts
    
    @Field(() => [AIAgentRun_])
    MJ_AIAgentRuns_OverrideVendorIDArray: AIAgentRun_[]; // Link to MJ_AIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendors
//****************************************************************************
@InputType()
export class CreateAIVendorInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendors
//****************************************************************************
@InputType()
export class UpdateAIVendorInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendors
//****************************************************************************
@ObjectType()
export class RunAIVendorViewResult {
    @Field(() => [AIVendor_])
    Results: AIVendor_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIVendor_)
export class AIVendorResolver extends ResolverBase {
    @Query(() => RunAIVendorViewResult)
    async RunAIVendorViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIVendorViewResult)
    async RunAIVendorViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIVendorViewResult)
    async RunAIVendorDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendors';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIVendor_, { nullable: true })
    async AIVendor(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIVendor_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendors] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Vendors', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIPromptModel_])
    async MJ_AIPromptModels_VendorIDArray(@Root() aivendor_: AIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [VendorID]='${aivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows);
        return result;
    }
        
    @FieldResolver(() => [AIResultCache_])
    async AIResultCache_VendorIDArray(@Root() aivendor_: AIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [VendorID]='${aivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows);
        return result;
    }
        
    @FieldResolver(() => [AIModelVendor_])
    async MJ_AIModelVendors_VendorIDArray(@Root() aivendor_: AIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelVendors] WHERE [VendorID]='${aivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptRun_])
    async MJ_AIPromptRuns_VendorIDArray(@Root() aivendor_: AIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [VendorID]='${aivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIVendorType_])
    async MJ_AIVendorTypes_VendorIDArray(@Root() aivendor_: AIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendorTypes] WHERE [VendorID]='${aivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Vendor Types', rows);
        return result;
    }
        
    @FieldResolver(() => [AIModelCost_])
    async MJ_AIModelCosts_VendorIDArray(@Root() aivendor_: AIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [VendorID]='${aivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRun_])
    async MJ_AIAgentRuns_OverrideVendorIDArray(@Root() aivendor_: AIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [OverrideVendorID]='${aivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows);
        return result;
    }
        
    @Mutation(() => AIVendor_)
    async CreateAIVendor(
        @Arg('input', () => CreateAIVendorInput) input: CreateAIVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendors', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIVendor_)
    async UpdateAIVendor(
        @Arg('input', () => UpdateAIVendorInput) input: UpdateAIVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendors', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIVendor_)
    async DeleteAIVendor(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendors', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Configurations
//****************************************************************************
@ObjectType({ description: `Stores configurations for AI prompt execution environments and settings.` })
export class AIConfiguration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The name of the configuration.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the configuration.`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this is the default configuration to use when none is specified.`}) 
    IsDefault: boolean;
        
    @Field({description: `The current status of the configuration. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Default prompt to use for context compression when not specified at the agent level.`}) 
    @MaxLength(16)
    DefaultPromptForContextCompressionID?: string;
        
    @Field({nullable: true, description: `Default prompt to use for context summarization when not specified at the agent level.`}) 
    @MaxLength(16)
    DefaultPromptForContextSummarizationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DefaultPromptForContextCompression?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DefaultPromptForContextSummarization?: string;
        
    @Field(() => [AIConfigurationParam_])
    MJ_AIConfigurationParams_ConfigurationIDArray: AIConfigurationParam_[]; // Link to MJ_AIConfigurationParams
    
    @Field(() => [AIAgentPrompt_])
    MJ_AIAgentPrompts_ConfigurationIDArray: AIAgentPrompt_[]; // Link to MJ_AIAgentPrompts
    
    @Field(() => [AIPromptModel_])
    MJ_AIPromptModels_ConfigurationIDArray: AIPromptModel_[]; // Link to MJ_AIPromptModels
    
    @Field(() => [AIResultCache_])
    AIResultCache_ConfigurationIDArray: AIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [AIPromptRun_])
    MJ_AIPromptRuns_ConfigurationIDArray: AIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [AIAgentRun_])
    MJ_AIAgentRuns_ConfigurationIDArray: AIAgentRun_[]; // Link to MJ_AIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Configurations
//****************************************************************************
@InputType()
export class CreateAIConfigurationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DefaultPromptForContextCompressionID: string | null;

    @Field({ nullable: true })
    DefaultPromptForContextSummarizationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Configurations
//****************************************************************************
@InputType()
export class UpdateAIConfigurationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DefaultPromptForContextCompressionID?: string | null;

    @Field({ nullable: true })
    DefaultPromptForContextSummarizationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Configurations
//****************************************************************************
@ObjectType()
export class RunAIConfigurationViewResult {
    @Field(() => [AIConfiguration_])
    Results: AIConfiguration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIConfiguration_)
export class AIConfigurationResolver extends ResolverBase {
    @Query(() => RunAIConfigurationViewResult)
    async RunAIConfigurationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIConfigurationViewResult)
    async RunAIConfigurationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIConfigurationViewResult)
    async RunAIConfigurationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Configurations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIConfiguration_, { nullable: true })
    async AIConfiguration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIConfiguration_ | null> {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Configurations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIConfigurationParam_])
    async MJ_AIConfigurationParams_ConfigurationIDArray(@Root() aiconfiguration_: AIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configuration Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurationParams] WHERE [ConfigurationID]='${aiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configuration Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Configuration Params', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentPrompt_])
    async MJ_AIAgentPrompts_ConfigurationIDArray(@Root() aiconfiguration_: AIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPrompts] WHERE [ConfigurationID]='${aiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptModel_])
    async MJ_AIPromptModels_ConfigurationIDArray(@Root() aiconfiguration_: AIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [ConfigurationID]='${aiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows);
        return result;
    }
        
    @FieldResolver(() => [AIResultCache_])
    async AIResultCache_ConfigurationIDArray(@Root() aiconfiguration_: AIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [ConfigurationID]='${aiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptRun_])
    async MJ_AIPromptRuns_ConfigurationIDArray(@Root() aiconfiguration_: AIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [ConfigurationID]='${aiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRun_])
    async MJ_AIAgentRuns_ConfigurationIDArray(@Root() aiconfiguration_: AIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ConfigurationID]='${aiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows);
        return result;
    }
        
    @Mutation(() => AIConfiguration_)
    async CreateAIConfiguration(
        @Arg('input', () => CreateAIConfigurationInput) input: CreateAIConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Configurations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIConfiguration_)
    async UpdateAIConfiguration(
        @Arg('input', () => UpdateAIConfigurationInput) input: UpdateAIConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Configurations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIConfiguration_)
    async DeleteAIConfiguration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Configurations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agents
//****************************************************************************
@ObjectType({ description: `Table to store information about AI agents.` })
export class AIAgent_ {
    @Field({description: `The unique identifier for each AI agent. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `The name of the AI agent.`}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true, description: `A detailed description of the AI agent.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `URL to an image file or base64 data URI (e.g., data:image/png;base64,...) for the agent logo. Takes precedence over IconClass in UI display.`}) 
    @MaxLength(510)
    LogoURL?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `References the parent agent in the hierarchical structure. If NULL, this is a root (top-level) agent.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field(() => Boolean, {description: `When true, this agent can be exposed as an action for use by other agents. Only valid for root agents.`}) 
    ExposeAsAction: boolean;
        
    @Field(() => Int, {description: `The order in which this agent should be executed among its siblings under the same parent.`}) 
    ExecutionOrder: number;
        
    @Field({description: `Controls how this agent's child agents are executed. Sequential runs children in order, Parallel runs them simultaneously.`}) 
    @MaxLength(40)
    ExecutionMode: string;
        
    @Field(() => Boolean, {description: `When true, enables automatic compression of conversation context when the message threshold is reached.`}) 
    EnableContextCompression: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of messages that triggers context compression when EnableContextCompression is true.`}) 
    ContextCompressionMessageThreshold?: number;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ContextCompressionPromptID?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of recent messages to keep uncompressed when context compression is applied.`}) 
    ContextCompressionMessageRetentionCount?: number;
        
    @Field({nullable: true, description: `Reference to the AIAgentType that defines the category and system-level behavior for this agent. Cannot be null.`}) 
    @MaxLength(16)
    TypeID?: string;
        
    @Field({nullable: true, description: `Current status of the AI agent. Active agents can be executed, Disabled agents are inactive, and Pending agents are awaiting configuration or approval. Allowed values: Active, Disabled, Pending.`}) 
    @MaxLength(40)
    Status?: string;
        
    @Field({nullable: true, description: `Optional override for the class name used by the MemberJunction class factory to instantiate this specific agent. If specified, this overrides the agent type's DriverClass. Useful for specialized agent implementations.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class (e.g., fa-robot, fa-brain) for the agent. Used as fallback when LogoURL is not set or fails to load.`}) 
    @MaxLength(200)
    IconClass?: string;
        
    @Field({description: `Controls whether model selection is driven by the Agent Type's system prompt or the Agent's specific prompt. Default is Agent Type for backward compatibility.`}) 
    @MaxLength(100)
    ModelSelectionMode: string;
        
    @Field({description: `JSON array of paths that define which parts of the payload should be sent downstream to sub-agents. Use ["*"] to send entire payload, or specify paths like ["customer.id", "campaign.*", "analysis.sentiment"]`}) 
    PayloadDownstreamPaths: string;
        
    @Field({description: `JSON array of paths that define which parts of the payload sub-agents are allowed to write back upstream. Use ["*"] to allow all writes, or specify paths like ["analysis.results", "recommendations.*"]`}) 
    PayloadUpstreamPaths: string;
        
    @Field({nullable: true, description: `JSON array of paths that specify what parts of the payload the agent's own prompt can read. Controls downstream data 
flow when the agent executes its own prompt step.`}) 
    PayloadSelfReadPaths?: string;
        
    @Field({nullable: true, description: `JSON array of paths that specify what parts of the payload the agent's own prompt can write back. Controls upstream 
data flow when the agent executes its own prompt step.`}) 
    PayloadSelfWritePaths?: string;
        
    @Field({nullable: true, description: `Defines the scope/path within the parent payload that this sub-agent operates on. When set, the sub-agent receives only this portion of the payload and all change requests are relative to this scope. Format: /path/to/scope (e.g. /PropA/SubProp1)`}) 
    PayloadScope?: string;
        
    @Field({nullable: true, description: `Optional JSON schema or requirements that define the expected structure and content of the agent's final payload. Used to validate the output when the agent declares success. Similar to OutputExample in AI Prompts.`}) 
    FinalPayloadValidation?: string;
        
    @Field({description: `Determines how to handle validation failures when FinalPayloadValidation is specified. Options: Retry (default) - retry the agent with validation feedback, Fail - fail the agent run immediately, Warn - log a warning but allow success.`}) 
    @MaxLength(50)
    FinalPayloadValidationMode: string;
        
    @Field(() => Int, {description: `Maximum number of retry attempts allowed when FinalPayloadValidation fails with
Retry mode. After reaching this limit, the validation will fail permanently.`}) 
    FinalPayloadValidationMaxRetries: number;
        
    @Field(() => Float, {nullable: true, description: `Maximum cost in dollars allowed for a single agent run. Run will be terminated
if this limit is exceeded.`}) 
    MaxCostPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum total tokens (input + output) allowed for a single agent run. Run will
be terminated if this limit is exceeded.`}) 
    MaxTokensPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of prompt iterations allowed for a single agent run. Run will be
terminated if this limit is exceeded.`}) 
    MaxIterationsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum time in seconds allowed for a single agent run. Run will be terminated
if this limit is exceeded.`}) 
    MaxTimePerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `When acting as a sub-agent, minimum number of times this agent must be executed per parent agent run`}) 
    MinExecutionsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `When acting as a sub-agent, maximum number of times this agent can be executed per parent agent run`}) 
    MaxExecutionsPerRun?: number;
        
    @Field({nullable: true, description: `Optional JSON schema validation to apply to the input payload before agent execution begins. Uses the same JSONValidator format as FinalPayloadValidation.`}) 
    StartingPayloadValidation?: string;
        
    @Field({description: `Determines how to handle StartingPayloadValidation failures. Fail = reject invalid input, Warn = log warning but proceed.`}) 
    @MaxLength(50)
    StartingPayloadValidationMode: string;
        
    @Field(() => Int, {nullable: true, description: `Default effort level for all prompts executed by this agent (1-100, where 1=minimal effort, 100=maximum effort). Takes precedence over individual prompt EffortLevel settings but can be overridden by runtime parameters. Inherited by sub-agents unless explicitly overridden.`}) 
    DefaultPromptEffortLevel?: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContextCompressionPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Type?: string;
        
    @Field(() => [AIAgentModel_])
    AIAgentModels_AgentIDArray: AIAgentModel_[]; // Link to AIAgentModels
    
    @Field(() => [AIAgentAction_])
    AIAgentActions_AgentIDArray: AIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [AIAgentLearningCycle_])
    AIAgentLearningCycles_AgentIDArray: AIAgentLearningCycle_[]; // Link to AIAgentLearningCycles
    
    @Field(() => [AIAgentRequest_])
    AIAgentRequests_AgentIDArray: AIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [AIAgentStep_])
    MJ_AIAgentSteps_AgentIDArray: AIAgentStep_[]; // Link to MJ_AIAgentSteps
    
    @Field(() => [AIAgentRelationship_])
    MJ_AIAgentRelationships_AgentIDArray: AIAgentRelationship_[]; // Link to MJ_AIAgentRelationships
    
    @Field(() => [AIAgentNote_])
    AIAgentNotes_AgentIDArray: AIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [AIAgentPrompt_])
    MJ_AIAgentPrompts_AgentIDArray: AIAgentPrompt_[]; // Link to MJ_AIAgentPrompts
    
    @Field(() => [AIAgentRun_])
    MJ_AIAgentRuns_AgentIDArray: AIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [AIAgentStep_])
    MJ_AIAgentSteps_SubAgentIDArray: AIAgentStep_[]; // Link to MJ_AIAgentSteps
    
    @Field(() => [AIAgentRelationship_])
    MJ_AIAgentRelationships_SubAgentIDArray: AIAgentRelationship_[]; // Link to MJ_AIAgentRelationships
    
    @Field(() => [AIResultCache_])
    AIResultCache_AgentIDArray: AIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [AIPromptRun_])
    MJ_AIPromptRuns_AgentIDArray: AIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [AIAgent_])
    AIAgents_ParentIDArray: AIAgent_[]; // Link to AIAgents
    
}

//****************************************************************************
// INPUT TYPE for AI Agents
//****************************************************************************
@InputType()
export class CreateAIAgentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field(() => Boolean, { nullable: true })
    ExposeAsAction?: boolean;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ExecutionMode?: string;

    @Field(() => Boolean, { nullable: true })
    EnableContextCompression?: boolean;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageThreshold: number | null;

    @Field({ nullable: true })
    ContextCompressionPromptID: string | null;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageRetentionCount: number | null;

    @Field({ nullable: true })
    TypeID: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    ModelSelectionMode?: string;

    @Field({ nullable: true })
    PayloadDownstreamPaths?: string;

    @Field({ nullable: true })
    PayloadUpstreamPaths?: string;

    @Field({ nullable: true })
    PayloadSelfReadPaths: string | null;

    @Field({ nullable: true })
    PayloadSelfWritePaths: string | null;

    @Field({ nullable: true })
    PayloadScope: string | null;

    @Field({ nullable: true })
    FinalPayloadValidation: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    FinalPayloadValidationMaxRetries?: number;

    @Field(() => Float, { nullable: true })
    MaxCostPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxTokensPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxIterationsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxTimePerRun: number | null;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun: number | null;

    @Field({ nullable: true })
    StartingPayloadValidation: string | null;

    @Field({ nullable: true })
    StartingPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    DefaultPromptEffortLevel: number | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agents
//****************************************************************************
@InputType()
export class UpdateAIAgentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => Boolean, { nullable: true })
    ExposeAsAction?: boolean;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ExecutionMode?: string;

    @Field(() => Boolean, { nullable: true })
    EnableContextCompression?: boolean;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageThreshold?: number | null;

    @Field({ nullable: true })
    ContextCompressionPromptID?: string | null;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageRetentionCount?: number | null;

    @Field({ nullable: true })
    TypeID?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    ModelSelectionMode?: string;

    @Field({ nullable: true })
    PayloadDownstreamPaths?: string;

    @Field({ nullable: true })
    PayloadUpstreamPaths?: string;

    @Field({ nullable: true })
    PayloadSelfReadPaths?: string | null;

    @Field({ nullable: true })
    PayloadSelfWritePaths?: string | null;

    @Field({ nullable: true })
    PayloadScope?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidation?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    FinalPayloadValidationMaxRetries?: number;

    @Field(() => Float, { nullable: true })
    MaxCostPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxTokensPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxIterationsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxTimePerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun?: number | null;

    @Field({ nullable: true })
    StartingPayloadValidation?: string | null;

    @Field({ nullable: true })
    StartingPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    DefaultPromptEffortLevel?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agents
//****************************************************************************
@ObjectType()
export class RunAIAgentViewResult {
    @Field(() => [AIAgent_])
    Results: AIAgent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgent_)
export class AIAgentResolver extends ResolverBase {
    @Query(() => RunAIAgentViewResult)
    async RunAIAgentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentViewResult)
    async RunAIAgentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentViewResult)
    async RunAIAgentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgent_, { nullable: true })
    async AIAgent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgent_ | null> {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agents', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIAgentModel_])
    async AIAgentModels_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Models', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentAction_])
    async AIAgentActions_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentLearningCycle_])
    async AIAgentLearningCycles_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Learning Cycles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentLearningCycles] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Learning Cycles', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRequest_])
    async AIAgentRequests_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentStep_])
    async MJ_AIAgentSteps_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRelationship_])
    async MJ_AIAgentRelationships_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRelationships] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentNote_])
    async AIAgentNotes_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentPrompt_])
    async MJ_AIAgentPrompts_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPrompts] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRun_])
    async MJ_AIAgentRuns_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentStep_])
    async MJ_AIAgentSteps_SubAgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [SubAgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRelationship_])
    async MJ_AIAgentRelationships_SubAgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRelationships] WHERE [SubAgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows);
        return result;
    }
        
    @FieldResolver(() => [AIResultCache_])
    async AIResultCache_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptRun_])
    async MJ_AIPromptRuns_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgent_])
    async AIAgents_ParentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [ParentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agents', rows);
        return result;
    }
        
    @Mutation(() => AIAgent_)
    async CreateAIAgent(
        @Arg('input', () => CreateAIAgentInput) input: CreateAIAgentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgent_)
    async UpdateAIAgent(
        @Arg('input', () => UpdateAIAgentInput) input: UpdateAIAgentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgent_)
    async DeleteAIAgent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Steps
//****************************************************************************
@ObjectType({ description: `Defines individual steps (nodes) in a flow-based AI agent execution graph` })
export class AIAgentStep_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AgentID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Type of step: Action (execute an action), Sub-Agent (delegate to another agent), or Prompt (run an AI prompt)`}) 
    @MaxLength(40)
    StepType: string;
        
    @Field(() => Boolean, {description: `If true, this step is executed when the agent starts`}) 
    StartingStep: boolean;
        
    @Field(() => Int, {nullable: true}) 
    TimeoutSeconds?: number;
        
    @Field(() => Int) 
    RetryCount: number;
        
    @Field() 
    @MaxLength(40)
    OnErrorBehavior: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ActionID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SubAgentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    PromptID?: string;
        
    @Field({nullable: true, description: `JSON configuration for mapping action output parameters to payload paths. Example: {"outputParam1": "payload.customer.status", "*": "payload.lastResult"}`}) 
    ActionOutputMapping?: string;
        
    @Field(() => Int) 
    PositionX: number;
        
    @Field(() => Int) 
    PositionY: number;
        
    @Field(() => Int) 
    Width: number;
        
    @Field(() => Int) 
    Height: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Controls whether this step is executed. Active=normal execution, Pending=skip but may activate later, Disabled=never execute`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `JSON configuration for mapping static values or payload paths to action input parameters. Example: {"param1": "staticValue", "param2": "payload.dynamicValue"}`}) 
    ActionInputMapping?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    Action?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SubAgent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Prompt?: string;
        
    @Field(() => [AIAgentStepPath_])
    MJ_AIAgentStepPaths_DestinationStepIDArray: AIAgentStepPath_[]; // Link to MJ_AIAgentStepPaths
    
    @Field(() => [AIAgentStepPath_])
    MJ_AIAgentStepPaths_OriginStepIDArray: AIAgentStepPath_[]; // Link to MJ_AIAgentStepPaths
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Steps
//****************************************************************************
@InputType()
export class CreateAIAgentStepInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    StepType?: string;

    @Field(() => Boolean, { nullable: true })
    StartingStep?: boolean;

    @Field(() => Int, { nullable: true })
    TimeoutSeconds?: number | null;

    @Field(() => Int, { nullable: true })
    RetryCount?: number;

    @Field({ nullable: true })
    OnErrorBehavior?: string;

    @Field({ nullable: true })
    ActionID: string | null;

    @Field({ nullable: true })
    SubAgentID: string | null;

    @Field({ nullable: true })
    PromptID: string | null;

    @Field({ nullable: true })
    ActionOutputMapping: string | null;

    @Field(() => Int, { nullable: true })
    PositionX?: number;

    @Field(() => Int, { nullable: true })
    PositionY?: number;

    @Field(() => Int, { nullable: true })
    Width?: number;

    @Field(() => Int, { nullable: true })
    Height?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActionInputMapping: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Steps
//****************************************************************************
@InputType()
export class UpdateAIAgentStepInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    StepType?: string;

    @Field(() => Boolean, { nullable: true })
    StartingStep?: boolean;

    @Field(() => Int, { nullable: true })
    TimeoutSeconds?: number | null;

    @Field(() => Int, { nullable: true })
    RetryCount?: number;

    @Field({ nullable: true })
    OnErrorBehavior?: string;

    @Field({ nullable: true })
    ActionID?: string | null;

    @Field({ nullable: true })
    SubAgentID?: string | null;

    @Field({ nullable: true })
    PromptID?: string | null;

    @Field({ nullable: true })
    ActionOutputMapping?: string | null;

    @Field(() => Int, { nullable: true })
    PositionX?: number;

    @Field(() => Int, { nullable: true })
    PositionY?: number;

    @Field(() => Int, { nullable: true })
    Width?: number;

    @Field(() => Int, { nullable: true })
    Height?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActionInputMapping?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Steps
//****************************************************************************
@ObjectType()
export class RunAIAgentStepViewResult {
    @Field(() => [AIAgentStep_])
    Results: AIAgentStep_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentStep_)
export class AIAgentStepResolver extends ResolverBase {
    @Query(() => RunAIAgentStepViewResult)
    async RunAIAgentStepViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentStepViewResult)
    async RunAIAgentStepViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentStepViewResult)
    async RunAIAgentStepDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Steps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentStep_, { nullable: true })
    async AIAgentStep(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentStep_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Agent Steps', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIAgentStepPath_])
    async MJ_AIAgentStepPaths_DestinationStepIDArray(@Root() aiagentstep_: AIAgentStep_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentStepPaths] WHERE [DestinationStepID]='${aiagentstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentStepPath_])
    async MJ_AIAgentStepPaths_OriginStepIDArray(@Root() aiagentstep_: AIAgentStep_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentStepPaths] WHERE [OriginStepID]='${aiagentstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows);
        return result;
    }
        
    @Mutation(() => AIAgentStep_)
    async CreateAIAgentStep(
        @Arg('input', () => CreateAIAgentStepInput) input: CreateAIAgentStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Steps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentStep_)
    async UpdateAIAgentStep(
        @Arg('input', () => UpdateAIAgentStepInput) input: UpdateAIAgentStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Steps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentStep_)
    async DeleteAIAgentStep(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Steps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Costs
//****************************************************************************
@ObjectType({ description: `Stores historical and current pricing information for AI models across different vendors, with optional temporal tracking and support for different processing types` })
export class AIModelCost_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ModelID: string;
        
    @Field() 
    @MaxLength(16)
    VendorID: string;
        
    @Field({nullable: true, description: `Date and time with timezone when this pricing became effective. NULL disables temporal tracking. Defaults to current UTC time when record is created`}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Date and time with timezone when this pricing expired or will expire. NULL indicates currently active pricing`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Current status of this pricing record. Active=currently in use, Pending=scheduled for future, Expired=no longer valid, Invalid=data error`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `ISO 4217 three-letter currency code (e.g., USD, EUR, GBP) in uppercase`}) 
    @MaxLength(6)
    Currency: string;
        
    @Field() 
    @MaxLength(16)
    PriceTypeID: string;
        
    @Field(() => Float, {description: `Price per unit for input tokens/requests. Must be non-negative. Precision allows for micro-pricing scenarios`}) 
    InputPricePerUnit: number;
        
    @Field(() => Float, {description: `Price per unit for output tokens/responses. Must be non-negative. Often higher than input pricing`}) 
    OutputPricePerUnit: number;
        
    @Field() 
    @MaxLength(16)
    UnitTypeID: string;
        
    @Field({description: `Processing method that affects pricing. Realtime=immediate response, Batch=delayed processing often with discounts`}) 
    @MaxLength(40)
    ProcessingType: string;
        
    @Field({nullable: true, description: `Optional notes about pricing context, source, special conditions, or vendor-specific details`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field() 
    @MaxLength(100)
    Vendor: string;
        
    @Field() 
    @MaxLength(200)
    PriceType: string;
        
    @Field() 
    @MaxLength(200)
    UnitType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Costs
//****************************************************************************
@InputType()
export class CreateAIModelCostInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Currency?: string;

    @Field({ nullable: true })
    PriceTypeID?: string;

    @Field(() => Float, { nullable: true })
    InputPricePerUnit?: number;

    @Field(() => Float, { nullable: true })
    OutputPricePerUnit?: number;

    @Field({ nullable: true })
    UnitTypeID?: string;

    @Field({ nullable: true })
    ProcessingType?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Costs
//****************************************************************************
@InputType()
export class UpdateAIModelCostInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Currency?: string;

    @Field({ nullable: true })
    PriceTypeID?: string;

    @Field(() => Float, { nullable: true })
    InputPricePerUnit?: number;

    @Field(() => Float, { nullable: true })
    OutputPricePerUnit?: number;

    @Field({ nullable: true })
    UnitTypeID?: string;

    @Field({ nullable: true })
    ProcessingType?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Costs
//****************************************************************************
@ObjectType()
export class RunAIModelCostViewResult {
    @Field(() => [AIModelCost_])
    Results: AIModelCost_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModelCost_)
export class AIModelCostResolver extends ResolverBase {
    @Query(() => RunAIModelCostViewResult)
    async RunAIModelCostViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelCostViewResult)
    async RunAIModelCostViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelCostViewResult)
    async RunAIModelCostDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Costs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIModelCost_, { nullable: true })
    async AIModelCost(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModelCost_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Model Costs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIModelCost_)
    async CreateAIModelCost(
        @Arg('input', () => CreateAIModelCostInput) input: CreateAIModelCostInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Costs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIModelCost_)
    async UpdateAIModelCost(
        @Arg('input', () => UpdateAIModelCostInput) input: UpdateAIModelCostInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Costs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIModelCost_)
    async DeleteAIModelCost(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Costs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Models
//****************************************************************************
@ObjectType({ description: `Associates AI prompts with specific models and configurations, including execution details.` })
export class AIPromptModel_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `References the AI prompt this model association applies to.`}) 
    @MaxLength(16)
    PromptID: string;
        
    @Field({description: `References the AI model to use for this prompt.`}) 
    @MaxLength(16)
    ModelID: string;
        
    @Field({nullable: true, description: `Optional reference to a specific vendor for the model. If NULL, uses the highest priority vendor for the model.`}) 
    @MaxLength(16)
    VendorID?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific configuration. If NULL, this model is available in all configurations.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field(() => Int, {description: `Priority of this model for the prompt. Higher values indicate higher priority.`}) 
    Priority: number;
        
    @Field(() => Int, {description: `Execution group for parallel processing. Models with the same group are executed in parallel.`}) 
    ExecutionGroup: number;
        
    @Field({nullable: true, description: `JSON-formatted parameters specific to this model (temperature, max tokens, etc.).`}) 
    ModelParameters?: string;
        
    @Field({description: `The current status of this model configuration. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Controls how this model participates in parallelization: None, StaticCount, or ConfigParam.`}) 
    @MaxLength(40)
    ParallelizationMode: string;
        
    @Field(() => Int, {description: `Number of parallel executions to perform with this model when ParallelizationMode is StaticCount.`}) 
    ParallelCount: number;
        
    @Field({nullable: true, description: `Name of a configuration parameter that contains the parallel count when ParallelizationMode is ConfigParam.`}) 
    @MaxLength(200)
    ParallelConfigParam?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Prompt: string;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Models
//****************************************************************************
@InputType()
export class CreateAIPromptModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Int, { nullable: true })
    ExecutionGroup?: number;

    @Field({ nullable: true })
    ModelParameters: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number;

    @Field({ nullable: true })
    ParallelConfigParam: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Models
//****************************************************************************
@InputType()
export class UpdateAIPromptModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Int, { nullable: true })
    ExecutionGroup?: number;

    @Field({ nullable: true })
    ModelParameters?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number;

    @Field({ nullable: true })
    ParallelConfigParam?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Models
//****************************************************************************
@ObjectType()
export class RunAIPromptModelViewResult {
    @Field(() => [AIPromptModel_])
    Results: AIPromptModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIPromptModel_)
export class AIPromptModelResolver extends ResolverBase {
    @Query(() => RunAIPromptModelViewResult)
    async RunAIPromptModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptModelViewResult)
    async RunAIPromptModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptModelViewResult)
    async RunAIPromptModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIPromptModel_, { nullable: true })
    async AIPromptModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIPromptModel_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Prompt Models', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIPromptModel_)
    async CreateAIPromptModel(
        @Arg('input', () => CreateAIPromptModelInput) input: CreateAIPromptModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIPromptModel_)
    async UpdateAIPromptModel(
        @Arg('input', () => UpdateAIPromptModelInput) input: UpdateAIPromptModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIPromptModel_)
    async DeleteAIPromptModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Types
//****************************************************************************
@ObjectType({ description: `Defines types of AI agents with their system prompts and behavioral characteristics. Each agent type represents a category of agents that share common system-level instructions and capabilities.` })
export class AIAgentType_ {
    @Field({description: `Unique identifier for the agent type`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name of the agent type (e.g., "Base", "CustomerSupport", "DataAnalysis"). Used for programmatic identification and factory instantiation.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the agent type, its purpose, and typical use cases`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Reference to the AI Prompt that contains the system-level instructions for all agents of this type. This prompt will be blended with individual agent prompts.`}) 
    @MaxLength(16)
    SystemPromptID?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this agent type is available for use. Inactive types cannot be assigned to new agents.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The placeholder name used in the system prompt template where the agent prompt result should be injected. For example, if the system prompt contains "{{ agentPrompt }}", this field should contain "agentPrompt". This enables proper hierarchical prompt execution where the agent type's system prompt acts as the parent and the agent's specific prompt acts as the child.`}) 
    @MaxLength(510)
    AgentPromptPlaceholder?: string;
        
    @Field({nullable: true, description: `The class name used by the MemberJunction class factory to instantiate the specific agent type implementation. For example, "LoopAgentType" for a looping agent pattern. If not specified, defaults to using the agent type Name for the DriverClass lookup key.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Optional Angular component key name for a subclass of BaseFormSectionComponent that provides a custom form section for this agent type. When specified, this component will be dynamically loaded and displayed as the first expandable section in the AI Agent form. This allows agent types to have specialized UI elements. The class must be registered with the MemberJunction class factory via @RegisterClass`}) 
    @MaxLength(1000)
    UIFormSectionKey?: string;
        
    @Field({nullable: true, description: `Optional Angular component key name for a subclass of BaseFormComponent that will completely overrides the default AI Agent form for this agent type. When specified, this component will be used instead of the standard AI Agent form, allowing for completely custom form implementations. The class must be registered with the MemberJunction class factory via @RegisterClass. If both UIFormClass and UIFormSectionClass are specified, UIFormClass takes precedence.`}) 
    @MaxLength(1000)
    UIFormKey?: string;
        
    @Field(() => Boolean, {description: `Determines whether the custom form section (specified by UIFormSectionClass) should be expanded by default when the AI Agent form loads. True means the section starts expanded, False means it starts collapsed. Only applies when UIFormSectionClass is specified. Defaults to 1 (expanded).`}) 
    UIFormSectionExpandedByDefault: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SystemPrompt?: string;
        
    @Field(() => [AIAgent_])
    AIAgents_TypeIDArray: AIAgent_[]; // Link to AIAgents
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Types
//****************************************************************************
@InputType()
export class CreateAIAgentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SystemPromptID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    AgentPromptPlaceholder: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    UIFormSectionKey: string | null;

    @Field({ nullable: true })
    UIFormKey: string | null;

    @Field(() => Boolean, { nullable: true })
    UIFormSectionExpandedByDefault?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Types
//****************************************************************************
@InputType()
export class UpdateAIAgentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SystemPromptID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    AgentPromptPlaceholder?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    UIFormSectionKey?: string | null;

    @Field({ nullable: true })
    UIFormKey?: string | null;

    @Field(() => Boolean, { nullable: true })
    UIFormSectionExpandedByDefault?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Types
//****************************************************************************
@ObjectType()
export class RunAIAgentTypeViewResult {
    @Field(() => [AIAgentType_])
    Results: AIAgentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentType_)
export class AIAgentTypeResolver extends ResolverBase {
    @Query(() => RunAIAgentTypeViewResult)
    async RunAIAgentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentTypeViewResult)
    async RunAIAgentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentTypeViewResult)
    async RunAIAgentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentType_, { nullable: true })
    async AIAgentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Agent Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIAgent_])
    async AIAgents_TypeIDArray(@Root() aiagenttype_: AIAgentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [TypeID]='${aiagenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agents', rows);
        return result;
    }
        
    @Mutation(() => AIAgentType_)
    async CreateAIAgentType(
        @Arg('input', () => CreateAIAgentTypeInput) input: CreateAIAgentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentType_)
    async UpdateAIAgentType(
        @Arg('input', () => UpdateAIAgentTypeInput) input: UpdateAIAgentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentType_)
    async DeleteAIAgentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Notes
//****************************************************************************
@ObjectType({ description: `Stores notes, observations, and learnings generated by AI agents during their operations, linked to specific agent runs and categorized by note type. Can be user-specific or general.` })
export class AIAgentNote_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentNoteTypeID?: string;
        
    @Field({nullable: true, description: `The content of the note, observation, or learning captured by the AI agent during its execution.`}) 
    Note?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates the type of note, either User-specific or Global.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Foreign key referencing the ID column in the User table, indicating the user associated with the note. Used when Type=User`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AgentNoteType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Notes
//****************************************************************************
@InputType()
export class CreateAIAgentNoteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID: string | null;

    @Field({ nullable: true })
    Note: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Notes
//****************************************************************************
@InputType()
export class UpdateAIAgentNoteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID?: string | null;

    @Field({ nullable: true })
    Note?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Notes
//****************************************************************************
@ObjectType()
export class RunAIAgentNoteViewResult {
    @Field(() => [AIAgentNote_])
    Results: AIAgentNote_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentNote_)
export class AIAgentNoteResolver extends ResolverBase {
    @Query(() => RunAIAgentNoteViewResult)
    async RunAIAgentNoteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentNoteViewResult)
    async RunAIAgentNoteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentNoteViewResult)
    async RunAIAgentNoteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Notes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentNote_, { nullable: true })
    async AIAgentNote(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentNote_ | null> {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Notes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIAgentNote_)
    async CreateAIAgentNote(
        @Arg('input', () => CreateAIAgentNoteInput) input: CreateAIAgentNoteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Notes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentNote_)
    async UpdateAIAgentNote(
        @Arg('input', () => UpdateAIAgentNoteInput) input: UpdateAIAgentNoteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Notes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentNote_)
    async DeleteAIAgentNote(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Notes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Actions
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and actions.` })
export class AIAgentAction_ {
    @Field({description: `The unique identifier for each AI agent-action mapping. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from the AIAgent table.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated action from the Action table.`}) 
    @MaxLength(16)
    ActionID?: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Minimum number of times this action must be executed per agent run`}) 
    MinExecutionsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of times this action can be executed per agent run`}) 
    MaxExecutionsPerRun?: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    Action?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Actions
//****************************************************************************
@InputType()
export class CreateAIAgentActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ActionID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun: number | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Actions
//****************************************************************************
@InputType()
export class UpdateAIAgentActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ActionID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Actions
//****************************************************************************
@ObjectType()
export class RunAIAgentActionViewResult {
    @Field(() => [AIAgentAction_])
    Results: AIAgentAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentAction_)
export class AIAgentActionResolver extends ResolverBase {
    @Query(() => RunAIAgentActionViewResult)
    async RunAIAgentActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentActionViewResult)
    async RunAIAgentActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentActionViewResult)
    async RunAIAgentActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentAction_, { nullable: true })
    async AIAgentAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentAction_ | null> {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIAgentAction_)
    async CreateAIAgentAction(
        @Arg('input', () => CreateAIAgentActionInput) input: CreateAIAgentActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentAction_)
    async UpdateAIAgentAction(
        @Arg('input', () => UpdateAIAgentActionInput) input: UpdateAIAgentActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentAction_)
    async DeleteAIAgentAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Price Types
//****************************************************************************
@ObjectType({ description: `Defines the different types of pricing metrics used by AI model vendors (e.g., Tokens, Minutes, Characters, API Calls)` })
export class AIModelPriceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Short, descriptive name for the price type (e.g., "Tokens", "Minutes", "Characters")`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this price type represents and how it is measured`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIModelCost_])
    MJ_AIModelCosts_PriceTypeIDArray: AIModelCost_[]; // Link to MJ_AIModelCosts
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Types
//****************************************************************************
@InputType()
export class CreateAIModelPriceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Types
//****************************************************************************
@InputType()
export class UpdateAIModelPriceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Price Types
//****************************************************************************
@ObjectType()
export class RunAIModelPriceTypeViewResult {
    @Field(() => [AIModelPriceType_])
    Results: AIModelPriceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModelPriceType_)
export class AIModelPriceTypeResolver extends ResolverBase {
    @Query(() => RunAIModelPriceTypeViewResult)
    async RunAIModelPriceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelPriceTypeViewResult)
    async RunAIModelPriceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelPriceTypeViewResult)
    async RunAIModelPriceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Price Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIModelPriceType_, { nullable: true })
    async AIModelPriceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModelPriceType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Price Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelPriceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Price Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Model Price Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIModelCost_])
    async MJ_AIModelCosts_PriceTypeIDArray(@Root() aimodelpricetype_: AIModelPriceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [PriceTypeID]='${aimodelpricetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows);
        return result;
    }
        
    @Mutation(() => AIModelPriceType_)
    async CreateAIModelPriceType(
        @Arg('input', () => CreateAIModelPriceTypeInput) input: CreateAIModelPriceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Price Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIModelPriceType_)
    async UpdateAIModelPriceType(
        @Arg('input', () => UpdateAIModelPriceTypeInput) input: UpdateAIModelPriceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Price Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIModelPriceType_)
    async DeleteAIModelPriceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Price Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompts
//****************************************************************************
@ObjectType({ description: `Stores AI prompts, including references to categories, types, and templates.` })
export class AIPrompt_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Reference to the template used for the prompt.`}) 
    @MaxLength(16)
    TemplateID: string;
        
    @Field({nullable: true, description: `Reference to the category the prompt belongs to.`}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `Reference to the type of the prompt.`}) 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Specifies the expected response format for the AI model. Options include Any, Text, Markdown, JSON, and ModelSpecific. Defaults to Any if not specified.`}) 
    @MaxLength(40)
    ResponseFormat: string;
        
    @Field({nullable: true, description: `A JSON-formatted string containing model-specific response format instructions. This will be parsed and provided as a JSON object to the model.`}) 
    ModelSpecificResponseFormat?: string;
        
    @Field({nullable: true, description: `References the type of AI model this prompt is designed for (LLM, Image, Audio, etc.).`}) 
    @MaxLength(16)
    AIModelTypeID?: string;
        
    @Field(() => Int, {nullable: true, description: `The minimum power rank required for models to be considered for this prompt.`}) 
    MinPowerRank?: number;
        
    @Field({description: `Determines how models are selected for this prompt (Default, Specific, ByPower).`}) 
    @MaxLength(40)
    SelectionStrategy: string;
        
    @Field({description: `When using ByPower selection strategy, determines whether to prefer highest, lowest, or balanced power models.`}) 
    @MaxLength(40)
    PowerPreference: string;
        
    @Field({description: `Controls parallelization: None (no parallelization), StaticCount (use AIPrompt.ParallelCount for total runs), ConfigParam (use config param specified in ParallelConfigParam for total runs), or ModelSpecific (check each AIPromptModel's individual settings).`}) 
    @MaxLength(40)
    ParallelizationMode: string;
        
    @Field(() => Int, {nullable: true, description: `When ParallelizationMode is StaticCount, specifies the number of parallel executions.`}) 
    ParallelCount?: number;
        
    @Field({nullable: true, description: `When ParallelizationMode is ConfigParam, specifies the name of the configuration parameter that contains the parallel count.`}) 
    @MaxLength(200)
    ParallelConfigParam?: string;
        
    @Field({description: `The expected data type of the prompt output: string, number, boolean, date, or object.`}) 
    @MaxLength(100)
    OutputType: string;
        
    @Field({nullable: true, description: `JSON example output when OutputType is "object", used for validating structured outputs.`}) 
    OutputExample?: string;
        
    @Field({description: `Determines how validation failures are handled: Strict (fail), Warn (log warning), or None (ignore).`}) 
    @MaxLength(100)
    ValidationBehavior: string;
        
    @Field(() => Int, {description: `Maximum number of retry attempts for API failures.`}) 
    MaxRetries: number;
        
    @Field(() => Int, {description: `Delay between retry attempts in milliseconds.`}) 
    RetryDelayMS: number;
        
    @Field({description: `Strategy for calculating retry delays: Fixed (same delay each time), Exponential (doubling delay), or Linear (linearly increasing delay).`}) 
    @MaxLength(40)
    RetryStrategy: string;
        
    @Field({nullable: true, description: `References another prompt that selects the best result from multiple parallel executions.`}) 
    @MaxLength(16)
    ResultSelectorPromptID?: string;
        
    @Field(() => Boolean, {description: `When true, results from this prompt will be cached for potential reuse.`}) 
    EnableCaching: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time-to-live in seconds for cached results. NULL means results never expire.`}) 
    CacheTTLSeconds?: number;
        
    @Field({description: `Method for matching cached results: Exact (string matching) or Vector (embedding similarity).`}) 
    @MaxLength(40)
    CacheMatchType: string;
        
    @Field(() => Float, {nullable: true, description: `Threshold (0-1) for vector similarity matching. Higher values require closer matches.`}) 
    CacheSimilarityThreshold?: number;
        
    @Field(() => Boolean, {description: `When true, the AI model must match for a cache hit. When false, results from any model can be used.`}) 
    CacheMustMatchModel: boolean;
        
    @Field(() => Boolean, {description: `When true, the vendor must match for a cache hit. When false, results from any vendor can be used.`}) 
    CacheMustMatchVendor: boolean;
        
    @Field(() => Boolean, {description: `When true, the agent context must match for a cache hit. When false, agent-specific and non-agent results can be used interchangeably.`}) 
    CacheMustMatchAgent: boolean;
        
    @Field(() => Boolean, {description: `When true, the configuration must match for a cache hit. When false, results from any configuration can be used.`}) 
    CacheMustMatchConfig: boolean;
        
    @Field({description: `Determines how the prompt is used in conversation: System (always first message), User (positioned by PromptPosition), Assistant (positioned by PromptPosition), or SystemOrUser (try system first, fallback to user last if system slot taken)`}) 
    @MaxLength(40)
    PromptRole: string;
        
    @Field({description: `Controls message placement for User and Assistant role prompts: First (beginning of conversation) or Last (end of conversation). Not used for System role prompts which are always first`}) 
    @MaxLength(40)
    PromptPosition: string;
        
    @Field(() => Float, {nullable: true, description: `Default temperature setting for this prompt. Controls randomness in the output. 0 = more focused and deterministic, 2 = more random and creative. Can be overridden at runtime.`}) 
    Temperature?: number;
        
    @Field(() => Float, {nullable: true, description: `Default TopP (nucleus sampling) for this prompt. Only consider tokens with cumulative probability up to this value. 1 = consider all tokens. Can be overridden at runtime.`}) 
    TopP?: number;
        
    @Field(() => Int, {nullable: true, description: `Default TopK sampling for this prompt. Only sample from the top K tokens. Lower values reduce randomness. Can be overridden at runtime.`}) 
    TopK?: number;
        
    @Field(() => Float, {nullable: true, description: `Default MinP (minimum probability) for this prompt. Tokens with probability below this threshold are filtered out. Can be overridden at runtime.`}) 
    MinP?: number;
        
    @Field(() => Float, {nullable: true, description: `Default frequency penalty for this prompt. Penalizes tokens based on their frequency in the text. Positive values decrease likelihood of repetition. Can be overridden at runtime.`}) 
    FrequencyPenalty?: number;
        
    @Field(() => Float, {nullable: true, description: `Default presence penalty for this prompt. Penalizes tokens that have appeared in the text. Positive values increase topic diversity. Can be overridden at runtime.`}) 
    PresencePenalty?: number;
        
    @Field(() => Int, {nullable: true, description: `Default random seed for this prompt. Used for deterministic generation. Same seed produces same output. Can be overridden at runtime.`}) 
    Seed?: number;
        
    @Field({nullable: true, description: `Default stop sequences for this prompt. Comma-delimited list of sequences that will stop generation when encountered. Can be overridden at runtime.`}) 
    @MaxLength(2000)
    StopSequences?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Default setting for including log probabilities in the response. Can be overridden at runtime.`}) 
    IncludeLogProbs?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Default number of top log probabilities to include when IncludeLogProbs is true. Can be overridden at runtime.`}) 
    TopLogProbs?: number;
        
    @Field({description: `Failover strategy to use when the primary model fails. Options: SameModelDifferentVendor, NextBestModel, PowerRank, None`}) 
    @MaxLength(100)
    FailoverStrategy: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of failover attempts before giving up`}) 
    FailoverMaxAttempts?: number;
        
    @Field(() => Int, {nullable: true, description: `Initial delay in seconds between failover attempts`}) 
    FailoverDelaySeconds?: number;
        
    @Field({description: `Strategy for selecting failover models. Options: PreferSameModel, PreferDifferentModel, RequireSameModel`}) 
    @MaxLength(100)
    FailoverModelStrategy: string;
        
    @Field({description: `Types of errors that should trigger failover. Options: All, NetworkOnly, RateLimitOnly, ServiceErrorOnly`}) 
    @MaxLength(100)
    FailoverErrorScope: string;
        
    @Field(() => Int, {nullable: true, description: `Effort level for this specific prompt (1-100, where 1=minimal effort, 100=maximum effort). Higher values request more thorough reasoning and analysis. Can be overridden by agent DefaultPromptEffortLevel or runtime parameters.`}) 
    EffortLevel?: number;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    AIModelType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ResultSelectorPrompt?: string;
        
    @Field(() => [AIResultCache_])
    AIResultCache_AIPromptIDArray: AIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [AIConfiguration_])
    MJ_AIConfigurations_DefaultPromptForContextCompressionIDArray: AIConfiguration_[]; // Link to MJ_AIConfigurations
    
    @Field(() => [AIAgentType_])
    MJ_AIAgentTypes_SystemPromptIDArray: AIAgentType_[]; // Link to MJ_AIAgentTypes
    
    @Field(() => [AIConfiguration_])
    MJ_AIConfigurations_DefaultPromptForContextSummarizationIDArray: AIConfiguration_[]; // Link to MJ_AIConfigurations
    
    @Field(() => [AIPrompt_])
    AIPrompts_ResultSelectorPromptIDArray: AIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [AIPromptModel_])
    MJ_AIPromptModels_PromptIDArray: AIPromptModel_[]; // Link to MJ_AIPromptModels
    
    @Field(() => [AIAgentPrompt_])
    MJ_AIAgentPrompts_PromptIDArray: AIAgentPrompt_[]; // Link to MJ_AIAgentPrompts
    
    @Field(() => [AIAgentStep_])
    MJ_AIAgentSteps_PromptIDArray: AIAgentStep_[]; // Link to MJ_AIAgentSteps
    
    @Field(() => [AIPromptRun_])
    MJ_AIPromptRuns_PromptIDArray: AIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [AIAgent_])
    AIAgents_ContextCompressionPromptIDArray: AIAgent_[]; // Link to AIAgents
    
}

//****************************************************************************
// INPUT TYPE for AI Prompts
//****************************************************************************
@InputType()
export class CreateAIPromptInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat: string | null;

    @Field({ nullable: true })
    AIModelTypeID: string | null;

    @Field(() => Int, { nullable: true })
    MinPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string;

    @Field({ nullable: true })
    PowerPreference?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount: number | null;

    @Field({ nullable: true })
    ParallelConfigParam: string | null;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputExample: string | null;

    @Field({ nullable: true })
    ValidationBehavior?: string;

    @Field(() => Int, { nullable: true })
    MaxRetries?: number;

    @Field(() => Int, { nullable: true })
    RetryDelayMS?: number;

    @Field({ nullable: true })
    RetryStrategy?: string;

    @Field({ nullable: true })
    ResultSelectorPromptID: string | null;

    @Field(() => Boolean, { nullable: true })
    EnableCaching?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLSeconds: number | null;

    @Field({ nullable: true })
    CacheMatchType?: string;

    @Field(() => Float, { nullable: true })
    CacheSimilarityThreshold: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchModel?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchVendor?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchAgent?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchConfig?: boolean;

    @Field({ nullable: true })
    PromptRole?: string;

    @Field({ nullable: true })
    PromptPosition?: string;

    @Field(() => Float, { nullable: true })
    Temperature: number | null;

    @Field(() => Float, { nullable: true })
    TopP: number | null;

    @Field(() => Int, { nullable: true })
    TopK: number | null;

    @Field(() => Float, { nullable: true })
    MinP: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty: number | null;

    @Field(() => Int, { nullable: true })
    Seed: number | null;

    @Field({ nullable: true })
    StopSequences: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeLogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs: number | null;

    @Field({ nullable: true })
    FailoverStrategy?: string;

    @Field(() => Int, { nullable: true })
    FailoverMaxAttempts?: number | null;

    @Field(() => Int, { nullable: true })
    FailoverDelaySeconds?: number | null;

    @Field({ nullable: true })
    FailoverModelStrategy?: string;

    @Field({ nullable: true })
    FailoverErrorScope?: string;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompts
//****************************************************************************
@InputType()
export class UpdateAIPromptInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat?: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string | null;

    @Field(() => Int, { nullable: true })
    MinPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string;

    @Field({ nullable: true })
    PowerPreference?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number | null;

    @Field({ nullable: true })
    ParallelConfigParam?: string | null;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputExample?: string | null;

    @Field({ nullable: true })
    ValidationBehavior?: string;

    @Field(() => Int, { nullable: true })
    MaxRetries?: number;

    @Field(() => Int, { nullable: true })
    RetryDelayMS?: number;

    @Field({ nullable: true })
    RetryStrategy?: string;

    @Field({ nullable: true })
    ResultSelectorPromptID?: string | null;

    @Field(() => Boolean, { nullable: true })
    EnableCaching?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLSeconds?: number | null;

    @Field({ nullable: true })
    CacheMatchType?: string;

    @Field(() => Float, { nullable: true })
    CacheSimilarityThreshold?: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchModel?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchVendor?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchAgent?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchConfig?: boolean;

    @Field({ nullable: true })
    PromptRole?: string;

    @Field({ nullable: true })
    PromptPosition?: string;

    @Field(() => Float, { nullable: true })
    Temperature?: number | null;

    @Field(() => Float, { nullable: true })
    TopP?: number | null;

    @Field(() => Int, { nullable: true })
    TopK?: number | null;

    @Field(() => Float, { nullable: true })
    MinP?: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty?: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty?: number | null;

    @Field(() => Int, { nullable: true })
    Seed?: number | null;

    @Field({ nullable: true })
    StopSequences?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeLogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs?: number | null;

    @Field({ nullable: true })
    FailoverStrategy?: string;

    @Field(() => Int, { nullable: true })
    FailoverMaxAttempts?: number | null;

    @Field(() => Int, { nullable: true })
    FailoverDelaySeconds?: number | null;

    @Field({ nullable: true })
    FailoverModelStrategy?: string;

    @Field({ nullable: true })
    FailoverErrorScope?: string;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompts
//****************************************************************************
@ObjectType()
export class RunAIPromptViewResult {
    @Field(() => [AIPrompt_])
    Results: AIPrompt_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIPrompt_)
export class AIPromptResolver extends ResolverBase {
    @Query(() => RunAIPromptViewResult)
    async RunAIPromptViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptViewResult)
    async RunAIPromptViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptViewResult)
    async RunAIPromptDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIPrompt_, { nullable: true })
    async AIPrompt(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIPrompt_ | null> {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Prompts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIResultCache_])
    async AIResultCache_AIPromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AIPromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows);
        return result;
    }
        
    @FieldResolver(() => [AIConfiguration_])
    async MJ_AIConfigurations_DefaultPromptForContextCompressionIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurations] WHERE [DefaultPromptForContextCompressionID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentType_])
    async MJ_AIAgentTypes_SystemPromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentTypes] WHERE [SystemPromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Types', rows);
        return result;
    }
        
    @FieldResolver(() => [AIConfiguration_])
    async MJ_AIConfigurations_DefaultPromptForContextSummarizationIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurations] WHERE [DefaultPromptForContextSummarizationID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPrompt_])
    async AIPrompts_ResultSelectorPromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [ResultSelectorPromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptModel_])
    async MJ_AIPromptModels_PromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [PromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentPrompt_])
    async MJ_AIAgentPrompts_PromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPrompts] WHERE [PromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentStep_])
    async MJ_AIAgentSteps_PromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [PromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptRun_])
    async MJ_AIPromptRuns_PromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [PromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgent_])
    async AIAgents_ContextCompressionPromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [ContextCompressionPromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agents', rows);
        return result;
    }
        
    @Mutation(() => AIPrompt_)
    async CreateAIPrompt(
        @Arg('input', () => CreateAIPromptInput) input: CreateAIPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIPrompt_)
    async UpdateAIPrompt(
        @Arg('input', () => UpdateAIPromptInput) input: UpdateAIPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIPrompt_)
    async DeleteAIPrompt(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Result Cache
//****************************************************************************
@ObjectType({ description: `Stores cached results of AI prompts, including multiple runs for history and tracking purposes.` })
export class AIResultCache_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the AI prompt this result corresponds to.`}) 
    @MaxLength(16)
    AIPromptID: string;
        
    @Field({description: `Reference to the AI model that generated this result.`}) 
    @MaxLength(16)
    AIModelID: string;
        
    @Field({description: `Timestamp of when this result was generated.`}) 
    @MaxLength(10)
    RunAt: Date;
        
    @Field({description: `The prompt text used to generate this result.`}) 
    PromptText: string;
        
    @Field({nullable: true, description: `The text of the result generated by the AI model.`}) 
    ResultText?: string;
        
    @Field({description: `The status of this result, indicating whether it is currently active or expired.`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp of when this result was marked as expired.`}) 
    @MaxLength(10)
    ExpiredOn?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The vendor that provided this result.`}) 
    @MaxLength(16)
    VendorID?: string;
        
    @Field({nullable: true, description: `The agent that initiated the request, if any.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `The configuration used for this execution.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field(() => Int, {nullable: true, description: `Vector representation of the prompt for similarity matching.`}) 
    PromptEmbedding?: number;
        
    @Field({nullable: true, description: `Reference to the AIPromptRun that created this cache entry.`}) 
    @MaxLength(16)
    PromptRunID?: string;
        
    @Field() 
    @MaxLength(510)
    AIPrompt: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Result Cache
//****************************************************************************
@InputType()
export class CreateAIResultCacheInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn: Date | null;

    @Field({ nullable: true })
    VendorID: string | null;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field(() => Int, { nullable: true })
    PromptEmbedding: number | null;

    @Field({ nullable: true })
    PromptRunID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Result Cache
//****************************************************************************
@InputType()
export class UpdateAIResultCacheInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn?: Date | null;

    @Field({ nullable: true })
    VendorID?: string | null;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field(() => Int, { nullable: true })
    PromptEmbedding?: number | null;

    @Field({ nullable: true })
    PromptRunID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Result Cache
//****************************************************************************
@ObjectType()
export class RunAIResultCacheViewResult {
    @Field(() => [AIResultCache_])
    Results: AIResultCache_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIResultCache_)
export class AIResultCacheResolver extends ResolverBase {
    @Query(() => RunAIResultCacheViewResult)
    async RunAIResultCacheViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIResultCacheViewResult)
    async RunAIResultCacheViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIResultCacheViewResult)
    async RunAIResultCacheDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Result Cache';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIResultCache_, { nullable: true })
    async AIResultCache(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIResultCache_ | null> {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Result Cache', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIResultCache_)
    async CreateAIResultCache(
        @Arg('input', () => CreateAIResultCacheInput) input: CreateAIResultCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Result Cache', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIResultCache_)
    async UpdateAIResultCache(
        @Arg('input', () => UpdateAIResultCacheInput) input: UpdateAIResultCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Result Cache', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIResultCache_)
    async DeleteAIResultCache(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Result Cache', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompt Categories
//****************************************************************************
@ObjectType({ description: `Categories for organizing AI prompts in a hierarchical structure.` })
export class AIPromptCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Parent category ID for hierarchical organization.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [AIPrompt_])
    AIPrompts_CategoryIDArray: AIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [AIPromptCategory_])
    AIPromptCategories_ParentIDArray: AIPromptCategory_[]; // Link to AIPromptCategories
    
}

//****************************************************************************
// INPUT TYPE for AI Prompt Categories
//****************************************************************************
@InputType()
export class CreateAIPromptCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompt Categories
//****************************************************************************
@InputType()
export class UpdateAIPromptCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompt Categories
//****************************************************************************
@ObjectType()
export class RunAIPromptCategoryViewResult {
    @Field(() => [AIPromptCategory_])
    Results: AIPromptCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIPromptCategory_)
export class AIPromptCategoryResolver extends ResolverBase {
    @Query(() => RunAIPromptCategoryViewResult)
    async RunAIPromptCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptCategoryViewResult)
    async RunAIPromptCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptCategoryViewResult)
    async RunAIPromptCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompt Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIPromptCategory_, { nullable: true })
    async AIPromptCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIPromptCategory_ | null> {
        this.CheckUserReadPermissions('AI Prompt Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Prompt Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIPrompt_])
    async AIPrompts_CategoryIDArray(@Root() aipromptcategory_: AIPromptCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [CategoryID]='${aipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptCategory_])
    async AIPromptCategories_ParentIDArray(@Root() aipromptcategory_: AIPromptCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompt Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptCategories] WHERE [ParentID]='${aipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompt Categories', rows);
        return result;
    }
        
    @Mutation(() => AIPromptCategory_)
    async CreateAIPromptCategory(
        @Arg('input', () => CreateAIPromptCategoryInput) input: CreateAIPromptCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompt Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIPromptCategory_)
    async UpdateAIPromptCategory(
        @Arg('input', () => UpdateAIPromptCategoryInput) input: UpdateAIPromptCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompt Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIPromptCategory_)
    async DeleteAIPromptCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompt Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompt Types
//****************************************************************************
@ObjectType({ description: `Types of AI prompts such as Chat, Text-to-Image, Text-to-Video, etc.` })
export class AIPromptType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIPrompt_])
    AIPrompts_TypeIDArray: AIPrompt_[]; // Link to AIPrompts
    
}

//****************************************************************************
// INPUT TYPE for AI Prompt Types
//****************************************************************************
@InputType()
export class CreateAIPromptTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompt Types
//****************************************************************************
@InputType()
export class UpdateAIPromptTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompt Types
//****************************************************************************
@ObjectType()
export class RunAIPromptTypeViewResult {
    @Field(() => [AIPromptType_])
    Results: AIPromptType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIPromptType_)
export class AIPromptTypeResolver extends ResolverBase {
    @Query(() => RunAIPromptTypeViewResult)
    async RunAIPromptTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptTypeViewResult)
    async RunAIPromptTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptTypeViewResult)
    async RunAIPromptTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompt Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIPromptType_, { nullable: true })
    async AIPromptType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIPromptType_ | null> {
        this.CheckUserReadPermissions('AI Prompt Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Prompt Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIPrompt_])
    async AIPrompts_TypeIDArray(@Root() aiprompttype_: AIPromptType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [TypeID]='${aiprompttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows);
        return result;
    }
        
    @Mutation(() => AIPromptType_)
    async CreateAIPromptType(
        @Arg('input', () => CreateAIPromptTypeInput) input: CreateAIPromptTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompt Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIPromptType_)
    async UpdateAIPromptType(
        @Arg('input', () => UpdateAIPromptTypeInput) input: UpdateAIPromptTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompt Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIPromptType_)
    async DeleteAIPromptType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompt Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Companies
//****************************************************************************
@ObjectType({ description: `A list of organizational units within your business. These can be subsidiaries or divisions or other units. Companies are used to organizae employee records and also for separating integrations if you have multiple integrations of the same type of system.` })
export class Company_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field() 
    @MaxLength(400)
    Description: string;
        
    @Field({nullable: true, description: `The primary website URL for this company or division.`}) 
    @MaxLength(200)
    Website?: string;
        
    @Field({nullable: true, description: `URL pointing to the company's logo image, used for branding in the UI.`}) 
    @MaxLength(1000)
    LogoURL?: string;
        
    @Field({nullable: true, description: `The primary email domain associated with this company, used for employee email validation and SSO configuration.`}) 
    @MaxLength(510)
    Domain?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Employee_])
    Employees_CompanyIDArray: Employee_[]; // Link to Employees
    
    @Field(() => [CompanyIntegration_])
    CompanyIntegrations_CompanyNameArray: CompanyIntegration_[]; // Link to CompanyIntegrations
    
    @Field(() => [Workflow_])
    Workflows_CompanyNameArray: Workflow_[]; // Link to Workflows
    
}

//****************************************************************************
// INPUT TYPE for Companies
//****************************************************************************
@InputType()
export class CreateCompanyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;

    @Field({ nullable: true })
    Domain: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Companies
//****************************************************************************
@InputType()
export class UpdateCompanyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field({ nullable: true })
    Domain?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Companies
//****************************************************************************
@ObjectType()
export class RunCompanyViewResult {
    @Field(() => [Company_])
    Results: Company_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Company_)
export class CompanyResolver extends ResolverBase {
    @Query(() => RunCompanyViewResult)
    async RunCompanyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyViewResult)
    async RunCompanyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyViewResult)
    async RunCompanyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Companies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Company_, { nullable: true })
    async Company(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Company_ | null> {
        this.CheckUserReadPermissions('Companies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanies] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Companies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Companies', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [Company_])
    async AllCompanies(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Companies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanies]` + this.getRowLevelSecurityWhereClause(provider, 'Companies', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Companies', rows);
        return result;
    }
    
    @FieldResolver(() => [Employee_])
    async Employees_CompanyIDArray(@Root() company_: Company_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [CompanyID]='${company_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', rows);
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegration_])
    async CompanyIntegrations_CompanyNameArray(@Root() company_: Company_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [CompanyName]='${company_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integrations', rows);
        return result;
    }
        
    @FieldResolver(() => [Workflow_])
    async Workflows_CompanyNameArray(@Root() company_: Company_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [CompanyName]='${company_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workflows', rows);
        return result;
    }
        
    @Mutation(() => Company_)
    async CreateCompany(
        @Arg('input', () => CreateCompanyInput) input: CreateCompanyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Companies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Company_)
    async UpdateCompany(
        @Arg('input', () => UpdateCompanyInput) input: UpdateCompanyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Companies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Company_)
    async DeleteCompany(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Companies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employees
//****************************************************************************
@ObjectType({ description: `A list of employees across all units of your organization` })
export class Employee_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Business Central Management ID - unique identifier for cross-system employee tracking.`}) 
    @MaxLength(16)
    BCMID: string;
        
    @Field({description: `Employee's first name or given name.`}) 
    @MaxLength(60)
    FirstName: string;
        
    @Field({description: `Employee's last name or surname.`}) 
    @MaxLength(100)
    LastName: string;
        
    @Field() 
    @MaxLength(16)
    CompanyID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SupervisorID?: string;
        
    @Field({nullable: true, description: `Employee's job title or position within the organization.`}) 
    @MaxLength(100)
    Title?: string;
        
    @Field({description: `Employee's primary email address, must be unique across the system.`}) 
    @MaxLength(200)
    Email: string;
        
    @Field({nullable: true, description: `Employee's primary phone number for business contact.`}) 
    @MaxLength(40)
    Phone?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the employee is currently active in the organization.`}) 
    Active: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    Supervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(60)
    SupervisorFirstName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SupervisorLastName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SupervisorEmail?: string;
        
    @Field(() => [Employee_])
    Employees_SupervisorIDArray: Employee_[]; // Link to Employees
    
    @Field(() => [EmployeeCompanyIntegration_])
    EmployeeCompanyIntegrations_EmployeeIDArray: EmployeeCompanyIntegration_[]; // Link to EmployeeCompanyIntegrations
    
    @Field(() => [EmployeeRole_])
    EmployeeRoles_EmployeeIDArray: EmployeeRole_[]; // Link to EmployeeRoles
    
    @Field(() => [EmployeeSkill_])
    EmployeeSkills_EmployeeIDArray: EmployeeSkill_[]; // Link to EmployeeSkills
    
    @Field(() => [User_])
    Users_EmployeeIDArray: User_[]; // Link to Users
    
}

//****************************************************************************
// INPUT TYPE for Employees
//****************************************************************************
@InputType()
export class CreateEmployeeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Employees
//****************************************************************************
@InputType()
export class UpdateEmployeeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employees
//****************************************************************************
@ObjectType()
export class RunEmployeeViewResult {
    @Field(() => [Employee_])
    Results: Employee_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Employee_)
export class EmployeeResolver extends ResolverBase {
    @Query(() => RunEmployeeViewResult)
    async RunEmployeeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEmployeeViewResult)
    async RunEmployeeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEmployeeViewResult)
    async RunEmployeeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employees';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Employee_, { nullable: true })
    async Employee(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Employee_ | null> {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Employees', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [Employee_])
    async AllEmployees(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees]` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', rows);
        return result;
    }
    
    @FieldResolver(() => [Employee_])
    async Employees_SupervisorIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [SupervisorID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', rows);
        return result;
    }
        
    @FieldResolver(() => [EmployeeCompanyIntegration_])
    async EmployeeCompanyIntegrations_EmployeeIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [EmployeeID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Company Integrations', rows);
        return result;
    }
        
    @FieldResolver(() => [EmployeeRole_])
    async EmployeeRoles_EmployeeIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [EmployeeID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [EmployeeSkill_])
    async EmployeeSkills_EmployeeIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [EmployeeID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Skills', rows);
        return result;
    }
        
    @FieldResolver(() => [User_])
    async Users_EmployeeIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [EmployeeID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Users', rows);
        return result;
    }
        
    @Mutation(() => Employee_)
    async CreateEmployee(
        @Arg('input', () => CreateEmployeeInput) input: CreateEmployeeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employees', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Employee_)
    async UpdateEmployee(
        @Arg('input', () => UpdateEmployeeInput) input: UpdateEmployeeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employees', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Employee_)
    async DeleteEmployee(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employees', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Favorites
//****************************************************************************
@ObjectType({ description: `Records that each user can mark as a favorite for easy access` })
export class UserFavorite_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the favorited record.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
}

//****************************************************************************
// INPUT TYPE for User Favorites
//****************************************************************************
@InputType()
export class CreateUserFavoriteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User Favorites
//****************************************************************************
@InputType()
export class UpdateUserFavoriteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Favorites
//****************************************************************************
@ObjectType()
export class RunUserFavoriteViewResult {
    @Field(() => [UserFavorite_])
    Results: UserFavorite_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserFavorite_)
export class UserFavoriteResolverBase extends ResolverBase {
    @Query(() => RunUserFavoriteViewResult)
    async RunUserFavoriteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserFavoriteViewResult)
    async RunUserFavoriteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserFavoriteViewResult)
    async RunUserFavoriteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Favorites';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserFavorite_, { nullable: true })
    async UserFavorite(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserFavorite_ | null> {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Favorites', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => UserFavorite_)
    async CreateUserFavorite(
        @Arg('input', () => CreateUserFavoriteInput) input: CreateUserFavoriteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Favorites', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserFavorite_)
    async UpdateUserFavorite(
        @Arg('input', () => UpdateUserFavoriteInput) input: UpdateUserFavoriteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Favorites', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserFavorite_)
    async DeleteUserFavorite(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Favorites', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Company Integrations
//****************************************************************************
@ObjectType({ description: `Maps employees to their external identifiers in integrated systems, maintaining synchronization across platforms.` })
export class EmployeeCompanyIntegration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field({description: `The employee's unique identifier in the external integrated system.`}) 
    @MaxLength(1500)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean, {description: `Indicates if this employee integration mapping is currently active.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CompanyIntegration: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Company Integrations
//****************************************************************************
@InputType()
export class CreateEmployeeCompanyIntegrationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Employee Company Integrations
//****************************************************************************
@InputType()
export class UpdateEmployeeCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Company Integrations
//****************************************************************************
@ObjectType()
export class RunEmployeeCompanyIntegrationViewResult {
    @Field(() => [EmployeeCompanyIntegration_])
    Results: EmployeeCompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EmployeeCompanyIntegration_)
export class EmployeeCompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunEmployeeCompanyIntegrationViewResult)
    async RunEmployeeCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEmployeeCompanyIntegrationViewResult)
    async RunEmployeeCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEmployeeCompanyIntegrationViewResult)
    async RunEmployeeCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Company Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EmployeeCompanyIntegration_, { nullable: true })
    async EmployeeCompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EmployeeCompanyIntegration_ | null> {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Employee Company Integrations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EmployeeCompanyIntegration_)
    async CreateEmployeeCompanyIntegration(
        @Arg('input', () => CreateEmployeeCompanyIntegrationInput) input: CreateEmployeeCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employee Company Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EmployeeCompanyIntegration_)
    async UpdateEmployeeCompanyIntegration(
        @Arg('input', () => UpdateEmployeeCompanyIntegrationInput) input: UpdateEmployeeCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Company Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EmployeeCompanyIntegration_)
    async DeleteEmployeeCompanyIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Company Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Roles
//****************************************************************************
@ObjectType({ description: `Links employees to their assigned roles within the organization, managing role-based permissions and responsibilities.` })
export class EmployeeRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Roles
//****************************************************************************
@InputType()
export class CreateEmployeeRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Employee Roles
//****************************************************************************
@InputType()
export class UpdateEmployeeRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Roles
//****************************************************************************
@ObjectType()
export class RunEmployeeRoleViewResult {
    @Field(() => [EmployeeRole_])
    Results: EmployeeRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EmployeeRole_)
export class EmployeeRoleResolver extends ResolverBase {
    @Query(() => RunEmployeeRoleViewResult)
    async RunEmployeeRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEmployeeRoleViewResult)
    async RunEmployeeRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEmployeeRoleViewResult)
    async RunEmployeeRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EmployeeRole_, { nullable: true })
    async EmployeeRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EmployeeRole_ | null> {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Employee Roles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EmployeeRole_)
    async CreateEmployeeRole(
        @Arg('input', () => CreateEmployeeRoleInput) input: CreateEmployeeRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employee Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EmployeeRole_)
    async UpdateEmployeeRole(
        @Arg('input', () => UpdateEmployeeRoleInput) input: UpdateEmployeeRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EmployeeRole_)
    async DeleteEmployeeRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Skills
//****************************************************************************
@ObjectType({ description: `Tracks skills, competencies, and certifications associated with employees for resource planning and team composition.` })
export class EmployeeSkill_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    SkillID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Skill: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Skills
//****************************************************************************
@InputType()
export class CreateEmployeeSkillInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    SkillID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Employee Skills
//****************************************************************************
@InputType()
export class UpdateEmployeeSkillInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    SkillID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Skills
//****************************************************************************
@ObjectType()
export class RunEmployeeSkillViewResult {
    @Field(() => [EmployeeSkill_])
    Results: EmployeeSkill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EmployeeSkill_)
export class EmployeeSkillResolver extends ResolverBase {
    @Query(() => RunEmployeeSkillViewResult)
    async RunEmployeeSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEmployeeSkillViewResult)
    async RunEmployeeSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEmployeeSkillViewResult)
    async RunEmployeeSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Skills';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EmployeeSkill_, { nullable: true })
    async EmployeeSkill(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EmployeeSkill_ | null> {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Employee Skills', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EmployeeSkill_)
    async CreateEmployeeSkill(
        @Arg('input', () => CreateEmployeeSkillInput) input: CreateEmployeeSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employee Skills', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EmployeeSkill_)
    async UpdateEmployeeSkill(
        @Arg('input', () => UpdateEmployeeSkillInput) input: UpdateEmployeeSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Skills', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EmployeeSkill_)
    async DeleteEmployeeSkill(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Skills', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Roles
//****************************************************************************
@ObjectType({ description: `Roles are used for security administration and can have zero to many Users as members` })
export class Role_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Description of the role`}) 
    Description?: string;
        
    @Field({nullable: true, description: `The unique ID of the role in the directory being used for authentication, for example an ID in Azure.`}) 
    @MaxLength(500)
    DirectoryID?: string;
        
    @Field({nullable: true, description: `The name of the role in the database, this is used for auto-generating permission statements by CodeGen`}) 
    @MaxLength(500)
    SQLName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EmployeeRole_])
    EmployeeRoles_RoleIDArray: EmployeeRole_[]; // Link to EmployeeRoles
    
    @Field(() => [EntityPermission_])
    EntityPermissions_RoleNameArray: EntityPermission_[]; // Link to EntityPermissions
    
    @Field(() => [UserRole_])
    UserRoles_RoleNameArray: UserRole_[]; // Link to UserRoles
    
    @Field(() => [AuthorizationRole_])
    AuthorizationRoles_RoleNameArray: AuthorizationRole_[]; // Link to AuthorizationRoles
    
    @Field(() => [QueryPermission_])
    QueryPermissions_RoleNameArray: QueryPermission_[]; // Link to QueryPermissions
    
    @Field(() => [ResourcePermission_])
    ResourcePermissions_RoleIDArray: ResourcePermission_[]; // Link to ResourcePermissions
    
}

//****************************************************************************
// INPUT TYPE for Roles
//****************************************************************************
@InputType()
export class CreateRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DirectoryID: string | null;

    @Field({ nullable: true })
    SQLName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Roles
//****************************************************************************
@InputType()
export class UpdateRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DirectoryID?: string | null;

    @Field({ nullable: true })
    SQLName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Roles
//****************************************************************************
@ObjectType()
export class RunRoleViewResult {
    @Field(() => [Role_])
    Results: Role_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Role_)
export class RoleResolver extends ResolverBase {
    @Query(() => RunRoleViewResult)
    async RunRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRoleViewResult)
    async RunRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRoleViewResult)
    async RunRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Role_, { nullable: true })
    async Role(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Role_ | null> {
        this.CheckUserReadPermissions('Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Roles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [Role_])
    async AllRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRoles]` + this.getRowLevelSecurityWhereClause(provider, 'Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Roles', rows);
        return result;
    }
    
    @FieldResolver(() => [EmployeeRole_])
    async EmployeeRoles_RoleIDArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [RoleID]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityPermission_])
    async EntityPermissions_RoleNameArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [RoleName]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [UserRole_])
    async UserRoles_RoleNameArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [RoleName]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [AuthorizationRole_])
    async AuthorizationRoles_RoleNameArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [RoleName]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [QueryPermission_])
    async QueryPermissions_RoleNameArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [RoleName]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [ResourcePermission_])
    async ResourcePermissions_RoleIDArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [RoleID]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows);
        return result;
    }
        
    @Mutation(() => Role_)
    async CreateRole(
        @Arg('input', () => CreateRoleInput) input: CreateRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Role_)
    async UpdateRole(
        @Arg('input', () => UpdateRoleInput) input: UpdateRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Role_)
    async DeleteRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Skills
//****************************************************************************
@ObjectType({ description: `A hierarchical list of possible skills that are linked to Employees and can also be linked to any other entity` })
export class Skill_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field(() => [EmployeeSkill_])
    EmployeeSkills_SkillIDArray: EmployeeSkill_[]; // Link to EmployeeSkills
    
    @Field(() => [Skill_])
    Skills_ParentIDArray: Skill_[]; // Link to Skills
    
}

//****************************************************************************
// INPUT TYPE for Skills
//****************************************************************************
@InputType()
export class CreateSkillInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Skills
//****************************************************************************
@InputType()
export class UpdateSkillInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Skills
//****************************************************************************
@ObjectType()
export class RunSkillViewResult {
    @Field(() => [Skill_])
    Results: Skill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Skill_)
export class SkillResolver extends ResolverBase {
    @Query(() => RunSkillViewResult)
    async RunSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunSkillViewResult)
    async RunSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunSkillViewResult)
    async RunSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Skills';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Skill_, { nullable: true })
    async Skill(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Skill_ | null> {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Skills', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [Skill_])
    async AllSkills(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills]` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Skills', rows);
        return result;
    }
    
    @FieldResolver(() => [EmployeeSkill_])
    async EmployeeSkills_SkillIDArray(@Root() skill_: Skill_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [SkillID]='${skill_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Skills', rows);
        return result;
    }
        
    @FieldResolver(() => [Skill_])
    async Skills_ParentIDArray(@Root() skill_: Skill_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills] WHERE [ParentID]='${skill_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Skills', rows);
        return result;
    }
        
    @Mutation(() => Skill_)
    async CreateSkill(
        @Arg('input', () => CreateSkillInput) input: CreateSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Skills', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Skill_)
    async UpdateSkill(
        @Arg('input', () => UpdateSkillInput) input: UpdateSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Skills', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Skill_)
    async DeleteSkill(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Skills', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Integration URL Formats
//****************************************************************************
@ObjectType({ description: `Used to generate web links for end users to easily access resources in a source system. URL Formats support templating to inject various field values at run-time to take a user directly to a resource in a source system.` })
export class IntegrationURLFormat_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    IntegrationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The URL Format for the given integration including the ability to include markup with fields from the integration`}) 
    @MaxLength(1000)
    URLFormat: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    NavigationBaseURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    FullURLFormat?: string;
        
}

//****************************************************************************
// INPUT TYPE for Integration URL Formats
//****************************************************************************
@InputType()
export class CreateIntegrationURLFormatInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    URLFormat?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Integration URL Formats
//****************************************************************************
@InputType()
export class UpdateIntegrationURLFormatInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    URLFormat?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Integration URL Formats
//****************************************************************************
@ObjectType()
export class RunIntegrationURLFormatViewResult {
    @Field(() => [IntegrationURLFormat_])
    Results: IntegrationURLFormat_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(IntegrationURLFormat_)
export class IntegrationURLFormatResolver extends ResolverBase {
    @Query(() => RunIntegrationURLFormatViewResult)
    async RunIntegrationURLFormatViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunIntegrationURLFormatViewResult)
    async RunIntegrationURLFormatViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunIntegrationURLFormatViewResult)
    async RunIntegrationURLFormatDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Integration URL Formats';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => IntegrationURLFormat_, { nullable: true })
    async IntegrationURLFormat(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<IntegrationURLFormat_ | null> {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Integration URL Formats', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [IntegrationURLFormat_])
    async AllIntegrationURLFormats(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats]` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows);
        return result;
    }
    
    @Mutation(() => IntegrationURLFormat_)
    async CreateIntegrationURLFormat(
        @Arg('input', () => CreateIntegrationURLFormatInput) input: CreateIntegrationURLFormatInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Integration URL Formats', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => IntegrationURLFormat_)
    async UpdateIntegrationURLFormat(
        @Arg('input', () => UpdateIntegrationURLFormatInput) input: UpdateIntegrationURLFormatInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Integration URL Formats', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => IntegrationURLFormat_)
    async DeleteIntegrationURLFormat(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Integration URL Formats', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Integrations
//****************************************************************************
@ObjectType({ description: `Catalog of all integrations that have been configured in the system.` })
export class Integration_ {
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Description?: string;
        
    @Field({nullable: true, description: `Base URL for navigating to records in the external system from MemberJunction.`}) 
    @MaxLength(1000)
    NavigationBaseURL?: string;
        
    @Field({nullable: true, description: `The TypeScript/JavaScript class name implementing this integration.`}) 
    @MaxLength(200)
    ClassName?: string;
        
    @Field({nullable: true, description: `Module import path for the integration class in the codebase.`}) 
    @MaxLength(200)
    ImportPath?: string;
        
    @Field(() => Int, {description: `Maximum number of API requests to batch together, -1 for no limit.`}) 
    BatchMaxRequestCount: number;
        
    @Field(() => Int, {description: `Milliseconds to wait before sending a batch of requests, -1 to disable batching.`}) 
    BatchRequestWaitTime: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field(() => [IntegrationURLFormat_])
    IntegrationURLFormats_IntegrationIDArray: IntegrationURLFormat_[]; // Link to IntegrationURLFormats
    
    @Field(() => [CompanyIntegration_])
    CompanyIntegrations_IntegrationNameArray: CompanyIntegration_[]; // Link to CompanyIntegrations
    
    @Field(() => [RecordChange_])
    RecordChanges_IntegrationIDArray: RecordChange_[]; // Link to RecordChanges
    
}

//****************************************************************************
// INPUT TYPE for Integrations
//****************************************************************************
@InputType()
export class CreateIntegrationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    NavigationBaseURL: string | null;

    @Field({ nullable: true })
    ClassName: string | null;

    @Field({ nullable: true })
    ImportPath: string | null;

    @Field(() => Int, { nullable: true })
    BatchMaxRequestCount?: number;

    @Field(() => Int, { nullable: true })
    BatchRequestWaitTime?: number;

    @Field({ nullable: true })
    ID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Integrations
//****************************************************************************
@InputType()
export class UpdateIntegrationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    NavigationBaseURL?: string | null;

    @Field({ nullable: true })
    ClassName?: string | null;

    @Field({ nullable: true })
    ImportPath?: string | null;

    @Field(() => Int, { nullable: true })
    BatchMaxRequestCount?: number;

    @Field(() => Int, { nullable: true })
    BatchRequestWaitTime?: number;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Integrations
//****************************************************************************
@ObjectType()
export class RunIntegrationViewResult {
    @Field(() => [Integration_])
    Results: Integration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Integration_)
export class IntegrationResolver extends ResolverBase {
    @Query(() => RunIntegrationViewResult)
    async RunIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunIntegrationViewResult)
    async RunIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunIntegrationViewResult)
    async RunIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Integration_, { nullable: true })
    async Integration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Integration_ | null> {
        this.CheckUserReadPermissions('Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Integrations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [Integration_])
    async AllIntegrations(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrations]` + this.getRowLevelSecurityWhereClause(provider, 'Integrations', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Integrations', rows);
        return result;
    }
    
    @FieldResolver(() => [IntegrationURLFormat_])
    async IntegrationURLFormats_IntegrationIDArray(@Root() integration_: Integration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [IntegrationID]='${integration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows);
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegration_])
    async CompanyIntegrations_IntegrationNameArray(@Root() integration_: Integration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [IntegrationName]='${integration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integrations', rows);
        return result;
    }
        
    @FieldResolver(() => [RecordChange_])
    async RecordChanges_IntegrationIDArray(@Root() integration_: Integration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [IntegrationID]='${integration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', rows);
        return result;
    }
        
    @Mutation(() => Integration_)
    async CreateIntegration(
        @Arg('input', () => CreateIntegrationInput) input: CreateIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Integration_)
    async UpdateIntegration(
        @Arg('input', () => UpdateIntegrationInput) input: UpdateIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Integration_)
    async DeleteIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integrations
//****************************************************************************
@ObjectType({ description: `Links individual company records to specific integrations` })
export class CompanyIntegration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyID: string;
        
    @Field() 
    @MaxLength(16)
    IntegrationID: string;
        
    @Field(() => Boolean, {nullable: true, description: `Controls whether this integration is currently active for the company.`}) 
    IsActive?: boolean;
        
    @Field({nullable: true, description: `OAuth access token for authenticating with the external system.`}) 
    @MaxLength(510)
    AccessToken?: string;
        
    @Field({nullable: true, description: `OAuth refresh token used to obtain new access tokens when they expire.`}) 
    @MaxLength(510)
    RefreshToken?: string;
        
    @Field({nullable: true, description: `Timestamp when the current access token expires and needs to be refreshed.`}) 
    @MaxLength(8)
    TokenExpirationDate?: Date;
        
    @Field({nullable: true, description: `API key for systems using key-based authentication instead of OAuth.`}) 
    @MaxLength(510)
    APIKey?: string;
        
    @Field({nullable: true, description: `The company's identifier in the external system, used for API calls.`}) 
    @MaxLength(200)
    ExternalSystemID?: string;
        
    @Field(() => Boolean, {description: `Indicates if data can only be read from the external system, not written back.`}) 
    IsExternalSystemReadOnly: boolean;
        
    @Field({nullable: true, description: `OAuth client ID for this integration instance.`}) 
    @MaxLength(510)
    ClientID?: string;
        
    @Field({nullable: true, description: `OAuth client secret for authentication, should be encrypted at rest.`}) 
    @MaxLength(510)
    ClientSecret?: string;
        
    @Field({nullable: true, description: `Flexible field for storing integration-specific configuration or metadata.`}) 
    @MaxLength(510)
    CustomAttribute1?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `User-friendly name for the company integration instance, typically in the format "Company: Integration".`}) 
    @MaxLength(510)
    Name: string;
        
    @Field() 
    @MaxLength(100)
    Company: string;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverImportPath?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LastRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    LastRunStartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    LastRunEndedAt?: Date;
        
    @Field(() => [List_])
    Lists_CompanyIntegrationIDArray: List_[]; // Link to Lists
    
    @Field(() => [EmployeeCompanyIntegration_])
    EmployeeCompanyIntegrations_CompanyIntegrationIDArray: EmployeeCompanyIntegration_[]; // Link to EmployeeCompanyIntegrations
    
    @Field(() => [CompanyIntegrationRun_])
    CompanyIntegrationRuns_CompanyIntegrationIDArray: CompanyIntegrationRun_[]; // Link to CompanyIntegrationRuns
    
    @Field(() => [CompanyIntegrationRecordMap_])
    CompanyIntegrationRecordMaps_CompanyIntegrationIDArray: CompanyIntegrationRecordMap_[]; // Link to CompanyIntegrationRecordMaps
    
}

//****************************************************************************
// INPUT TYPE for Company Integrations
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive: boolean | null;

    @Field({ nullable: true })
    AccessToken: string | null;

    @Field({ nullable: true })
    RefreshToken: string | null;

    @Field({ nullable: true })
    TokenExpirationDate: Date | null;

    @Field({ nullable: true })
    APIKey: string | null;

    @Field({ nullable: true })
    ExternalSystemID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsExternalSystemReadOnly?: boolean;

    @Field({ nullable: true })
    ClientID: string | null;

    @Field({ nullable: true })
    ClientSecret: string | null;

    @Field({ nullable: true })
    CustomAttribute1: string | null;

    @Field({ nullable: true })
    Name?: string;
}
    

//****************************************************************************
// INPUT TYPE for Company Integrations
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean | null;

    @Field({ nullable: true })
    AccessToken?: string | null;

    @Field({ nullable: true })
    RefreshToken?: string | null;

    @Field({ nullable: true })
    TokenExpirationDate?: Date | null;

    @Field({ nullable: true })
    APIKey?: string | null;

    @Field({ nullable: true })
    ExternalSystemID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsExternalSystemReadOnly?: boolean;

    @Field({ nullable: true })
    ClientID?: string | null;

    @Field({ nullable: true })
    ClientSecret?: string | null;

    @Field({ nullable: true })
    CustomAttribute1?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integrations
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationViewResult {
    @Field(() => [CompanyIntegration_])
    Results: CompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegration_)
export class CompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationViewResult)
    async RunCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationViewResult)
    async RunCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationViewResult)
    async RunCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CompanyIntegration_, { nullable: true })
    async CompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegration_ | null> {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integrations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [List_])
    async Lists_CompanyIntegrationIDArray(@Root() companyintegration_: CompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [CompanyIntegrationID]='${companyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', rows);
        return result;
    }
        
    @FieldResolver(() => [EmployeeCompanyIntegration_])
    async EmployeeCompanyIntegrations_CompanyIntegrationIDArray(@Root() companyintegration_: CompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [CompanyIntegrationID]='${companyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Company Integrations', rows);
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRun_])
    async CompanyIntegrationRuns_CompanyIntegrationIDArray(@Root() companyintegration_: CompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [CompanyIntegrationID]='${companyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRecordMap_])
    async CompanyIntegrationRecordMaps_CompanyIntegrationIDArray(@Root() companyintegration_: CompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [CompanyIntegrationID]='${companyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Record Maps', rows);
        return result;
    }
        
    @Mutation(() => CompanyIntegration_)
    async CreateCompanyIntegration(
        @Arg('input', () => CreateCompanyIntegrationInput) input: CreateCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegration_)
    async UpdateCompanyIntegration(
        @Arg('input', () => UpdateCompanyIntegrationInput) input: UpdateCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CompanyIntegration_)
    async DeleteCompanyIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Fields
//****************************************************************************
@ObjectType({ description: `List of all fields within each entity with metadata about each field` })
export class EntityField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of the field within the entity`}) 
    Sequence: number;
        
    @Field({description: `Name of the field within the database table`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `A user friendly alternative to the field name`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({nullable: true, description: `Descriptive text explaining the purpose of the field`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the column within the underlying view (first choice) or table (second choice), the Description column in the entity field definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity field definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field is part of the primary key for the entity (auto maintained by CodeGen)`}) 
    IsPrimaryKey: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field must have unique values within the entity.`}) 
    IsUnique: boolean;
        
    @Field({nullable: true, description: `Used for generating custom tabs in the generated forms, only utilized if GeneratedFormSection=Category`}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({description: `SQL Data type (auto maintained by CodeGen)`}) 
    @MaxLength(200)
    Type: string;
        
    @Field(() => Int, {nullable: true, description: `SQL data length (auto maintained by CodeGen)`}) 
    Length?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL precision (auto maintained by CodeGen)`}) 
    Precision?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL scale (auto maintained by CodeGen)`}) 
    Scale?: number;
        
    @Field(() => Boolean, {description: `Does the column allow null or not (auto maintained by CodeGen)`}) 
    AllowsNull: boolean;
        
    @Field({nullable: true, description: `If a default value is defined for the field it is stored here (auto maintained by CodeGen)`}) 
    @MaxLength(510)
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `If this field automatically increments within the table, this field is set to 1 (auto maintained by CodeGen)`}) 
    AutoIncrement: boolean;
        
    @Field({description: `Possible Values of None, List, ListOrUserEntry - the last option meaning that the list of possible values are options, but a user can enter anything else desired too.`}) 
    @MaxLength(40)
    ValueListType: string;
        
    @Field({nullable: true, description: `Defines extended behaviors for a field such as for Email, Web URLs, Code, etc.`}) 
    @MaxLength(100)
    ExtendedType?: string;
        
    @Field({nullable: true, description: `The type of code associated with this field. Only used when the ExtendedType field is set to "Code"`}) 
    @MaxLength(100)
    CodeType?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included by default in any new view created by a user.`}) 
    DefaultInView: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    ViewCellTemplate?: string;
        
    @Field(() => Int, {nullable: true, description: `Determines the default width for this field when included in a view`}) 
    DefaultColumnWidth?: number;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be considered updateable by the API and object model. For this field to have effect, the column type must be updateable (e.g. not part of the primary key and not auto-increment)`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, and if AllowUpdateAPI=1, the field can be edited within a view when the view is in edit mode.`}) 
    AllowUpdateInView: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be included in user search queries for both traditional and full text search`}) 
    IncludeInUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, CodeGen will automatically generate a Full Text Catalog/Index in the database and include this field in the search index.`}) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    @MaxLength(1000)
    UserSearchParamFormatAPI?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included in the generated form by CodeGen. If set to 0, this field will be excluded from the generated form. For custom forms, this field has no effect as the layout is controlled independently.`}) 
    IncludeInGeneratedForm: boolean;
        
    @Field({description: `When set to Top, the field will be placed in a "top area" on the top of a generated form and visible regardless of which tab is displayed. When set to "category" Options: Top, Category, Details`}) 
    @MaxLength(20)
    GeneratedFormSection: string;
        
    @Field(() => Boolean, {description: `NULL`}) 
    IsVirtual: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be used as the "Name" field for the entity and will be used to display the name of the record in various places in the UI.`}) 
    IsNameField: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RelatedEntityID?: string;
        
    @Field({nullable: true, description: `Name of the field in the Related Entity that this field links to (auto maintained by CodeGen)`}) 
    @MaxLength(510)
    RelatedEntityFieldName?: string;
        
    @Field(() => Boolean, {description: `If set to 1, the "Name" field of the Related Entity will be included in this entity as a virtual field`}) 
    IncludeRelatedEntityNameFieldInBaseView: boolean;
        
    @Field({nullable: true, description: `For foreign key fields, maps which field in the related entity contains the display name. This is used by CodeGen to automatically add in virtual fields for the "Name Field" of the related entity.`}) 
    @MaxLength(510)
    RelatedEntityNameFieldMap?: string;
        
    @Field({description: `Controls the generated form in the MJ Explorer UI - defaults to a search box, other option is a drop down. Possible values are Search and Dropdown`}) 
    @MaxLength(40)
    RelatedEntityDisplayType: string;
        
    @Field({nullable: true, description: `Optional, used for "Soft Keys" to link records to different entity/record combinations on a per-record basis (for example the FileEntityRecordLink table has an EntityID/RecordID field pair. For that entity, the RecordID specifies "EntityID" for this field. This information allows MJ to detect soft keys/links for dependency detection, merging and for preventing orphaned soft-linked records during delete operations.`}) 
    @MaxLength(200)
    EntityIDFieldName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `A comma-delimited string indicating the default scope for field visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for a simple method of filtering field defaults for visibility, not security enforcement.`}) 
    @MaxLength(200)
    ScopeDefault?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the related entity information should be automatically updated from the database schema. When set to 0, relationships not part of the database schema can be manually defined at the application and AI agent level. Defaults to 1.`}) 
    AutoUpdateRelatedEntityInfo: boolean;
        
    @Field({description: `Determines whether values for the field should be included when the schema is packed. Options: Auto (include manually set or auto-derived values), None (exclude all values), All (include all distinct values from the table). Defaults to Auto.`}) 
    @MaxLength(20)
    ValuesToPackWithSchema: string;
        
    @Field({description: `Current status of the entity field - Active fields are available for use, Deprecated fields are discouraged but still functional, Disabled fields are not available for use`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({nullable: true}) 
    FieldCodeName?: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    SchemaName: string;
        
    @Field() 
    @MaxLength(510)
    BaseTable: string;
        
    @Field() 
    @MaxLength(510)
    BaseView: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntitySchemaName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityBaseView?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field(() => [EntityFieldValue_])
    EntityFieldValues_EntityFieldIDArray: EntityFieldValue_[]; // Link to EntityFieldValues
    
}

//****************************************************************************
// INPUT TYPE for Entity Fields
//****************************************************************************
@InputType()
export class CreateEntityFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType: string | null;

    @Field({ nullable: true })
    CodeType: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Fields
//****************************************************************************
@InputType()
export class UpdateEntityFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType?: string | null;

    @Field({ nullable: true })
    CodeType?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate?: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth?: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID?: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap?: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Fields
//****************************************************************************
@ObjectType()
export class RunEntityFieldViewResult {
    @Field(() => [EntityField_])
    Results: EntityField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityField_)
export class EntityFieldResolver extends ResolverBase {
    @Query(() => RunEntityFieldViewResult)
    async RunEntityFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityFieldViewResult)
    async RunEntityFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityFieldViewResult)
    async RunEntityFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityField_, { nullable: true })
    async EntityField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityField_ | null> {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Fields', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [EntityField_])
    async AllEntityFields(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Fields', rows);
        return result;
    }
    
    @FieldResolver(() => [EntityFieldValue_])
    async EntityFieldValues_EntityFieldIDArray(@Root() entityfield_: EntityField_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues] WHERE [EntityFieldID]='${entityfield_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Field Values', rows);
        return result;
    }
        
    @Mutation(() => EntityField_)
    async CreateEntityField(
        @Arg('input', () => CreateEntityFieldInput) input: CreateEntityFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityField_)
    async UpdateEntityField(
        @Arg('input', () => UpdateEntityFieldInput) input: UpdateEntityFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityField_)
    async DeleteEntityField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entities
//****************************************************************************
@ObjectType({ description: `Catalog of all entities across all schemas` })
export class Entity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Optional suffix appended to entity names for display purposes.`}) 
    @MaxLength(510)
    NameSuffix?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the underlying view (first choice) or table (second choice), the Description column in the entity definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field({description: `The underlying database table name for this entity.`}) 
    @MaxLength(510)
    BaseTable: string;
        
    @Field({description: `The "wrapper" database view used for querying this entity with joins and computed fields.`}) 
    @MaxLength(510)
    BaseView: string;
        
    @Field(() => Boolean, {description: `When set to 0, CodeGen no longer generates a base view for the entity.`}) 
    BaseViewGenerated: boolean;
        
    @Field({description: `Database schema containing this entity's table and view.`}) 
    @MaxLength(510)
    SchemaName: string;
        
    @Field(() => Boolean, {description: `Indicates if this is a virtual entity without a physical database table.`}) 
    VirtualEntity: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, changes made via the MemberJunction architecture will result in tracking records being created in the RecordChange table. In addition, when turned on CodeGen will ensure that your table has two fields: __mj_CreatedAt and __mj_UpdatedAt which are special fields used in conjunction with the RecordChange table to track changes to rows in your entity.`}) 
    TrackRecordChanges: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, accessing a record by an end-user will result in an Audit Log record being created`}) 
    AuditRecordAccess: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, users running a view against this entity will result in an Audit Log record being created.`}) 
    AuditViewRuns: boolean;
        
    @Field(() => Boolean, {description: `If set to 0, the entity will not be available at all in the GraphQL API or the object model.`}) 
    IncludeInAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, a GraphQL query will be enabled that allows access to all rows in the entity.`}) 
    AllowAllRowsAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if updates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if creates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowCreateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if deletes are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowDeleteAPI: boolean;
        
    @Field(() => Boolean, {description: `Set to 1 if a custom resolver has been created for the entity.`}) 
    CustomResolverAPI: boolean;
        
    @Field(() => Boolean, {description: `Enabling this bit will result in search being possible at the API and UI layers`}) 
    AllowUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `Whether full-text search indexing is enabled for this entity.`}) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true, description: `Name of the SQL Server full-text catalog if search is enabled.`}) 
    @MaxLength(510)
    FullTextCatalog?: string;
        
    @Field(() => Boolean, {description: `Indicates if the full-text catalog was auto-generated by CodeGen.`}) 
    FullTextCatalogGenerated: boolean;
        
    @Field({nullable: true, description: `Name of the full-text index on this entity's table.`}) 
    @MaxLength(510)
    FullTextIndex?: string;
        
    @Field(() => Boolean, {description: `Indicates if the full-text index was auto-generated by CodeGen.`}) 
    FullTextIndexGenerated: boolean;
        
    @Field({nullable: true, description: `Name of the function used for full-text searching this entity.`}) 
    @MaxLength(510)
    FullTextSearchFunction?: string;
        
    @Field(() => Boolean, {description: `Indicates if the search function was auto-generated by CodeGen.`}) 
    FullTextSearchFunctionGenerated: boolean;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of rows to return in user-created views for this entity.`}) 
    UserViewMaxRows?: number;
        
    @Field({nullable: true, description: `Name of the stored procedure for creating records in this entity.`}) 
    @MaxLength(510)
    spCreate?: string;
        
    @Field({nullable: true, description: `Name of the stored procedure for updating records in this entity.`}) 
    @MaxLength(510)
    spUpdate?: string;
        
    @Field({nullable: true, description: `Name of the stored procedure for deleting records in this entity.`}) 
    @MaxLength(510)
    spDelete?: string;
        
    @Field(() => Boolean, {description: `Indicates if the create procedure was auto-generated by CodeGen.`}) 
    spCreateGenerated: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the update procedure was auto-generated by CodeGen.`}) 
    spUpdateGenerated: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the delete procedure was auto-generated by CodeGen.`}) 
    spDeleteGenerated: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, the deleted spDelete will pre-process deletion to related entities that have 1:M cardinality with this entity. This does not have effect if spDeleteGenerated = 0`}) 
    CascadeDeletes: boolean;
        
    @Field({description: `Hard deletes physically remove rows from the underlying BaseTable. Soft deletes do not remove rows but instead mark the row as deleted by using the special field __mj_DeletedAt which will automatically be added to the entity's basetable by the CodeGen tool.`}) 
    @MaxLength(20)
    DeleteType: string;
        
    @Field(() => Boolean, {description: `This field must be turned on in order to enable merging of records for the entity. For AllowRecordMerge to be turned on, AllowDeleteAPI must be set to 1, and DeleteType must be set to Soft`}) 
    AllowRecordMerge: boolean;
        
    @Field({nullable: true, description: `When specified, this stored procedure is used to find matching records in this particular entity. The convention is to pass in the primary key(s) columns for the given entity to the procedure and the return will be zero to many rows where there is a column for each primary key field(s) and a ProbabilityScore (numeric(1,12)) column that has a 0 to 1 value of the probability of a match.`}) 
    @MaxLength(510)
    spMatch?: string;
        
    @Field({description: `When another entity links to this entity with a foreign key, this is the default component type that will be used in the UI. CodeGen will populate the RelatedEntityDisplayType column in the Entity Fields entity with whatever is provided here whenever a new foreign key is detected by CodeGen. The selection can be overridden on a per-foreign-key basis in each row of the Entity Fields entity.`}) 
    @MaxLength(40)
    RelationshipDefaultDisplayType: string;
        
    @Field(() => Boolean, {description: `Indicates if the default user form was auto-generated for this entity.`}) 
    UserFormGenerated: boolean;
        
    @Field({nullable: true, description: `TypeScript class name for the entity subclass in the codebase.`}) 
    @MaxLength(510)
    EntityObjectSubclassName?: string;
        
    @Field({nullable: true, description: `Import path for the entity subclass in the TypeScript codebase.`}) 
    @MaxLength(510)
    EntityObjectSubclassImport?: string;
        
    @Field({nullable: true, description: `Used to specify a field within the entity that in turn contains the field name that will be used for record-level communication preferences. For example in a hypothetical entity called Contacts, say there is a field called PreferredComm and that field had possible values of Email1, SMS, and Phone, and those value in turn corresponded to field names in the entity. Each record in the Contacts entity could have a specific preference for which field would be used for communication. The MJ Communication Framework will use this information when available, as a priority ahead of the data in the Entity Communication Fields entity which is entity-level and not record-level.`}) 
    @MaxLength(510)
    PreferredCommunicationField?: string;
        
    @Field({nullable: true, description: `Optional, specify an icon (CSS Class) for each entity for display in the UI`}) 
    @MaxLength(1000)
    Icon?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional, comma-delimited string indicating the default scope for entity visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for simple defaults for filtering entity visibility, not security enforcement.`}) 
    @MaxLength(200)
    ScopeDefault?: string;
        
    @Field({description: `Determines how entity rows should be packaged for external use. Options include None, Sample, and All. Defaults to None.`}) 
    @MaxLength(40)
    RowsToPackWithSchema: string;
        
    @Field({description: `Defines the sampling method for row packing when RowsToPackWithSchema is set to Sample. Options include random, top n, and bottom n. Defaults to random.`}) 
    @MaxLength(40)
    RowsToPackSampleMethod: string;
        
    @Field(() => Int, {description: `The number of rows to pack when RowsToPackWithSchema is set to Sample, based on the designated sampling method. Defaults to 0.`}) 
    RowsToPackSampleCount: number;
        
    @Field({nullable: true, description: `An optional ORDER BY clause for row packing when RowsToPackWithSchema is set to Sample. Allows custom ordering for selected entity data when using top n and bottom n.`}) 
    RowsToPackSampleOrder?: string;
        
    @Field(() => Int, {nullable: true, description: `Frequency in hours for automatically performing row counts on this entity. If NULL, automatic row counting is disabled. If greater than 0, schedules recurring SELECT COUNT(*) queries at the specified interval.`}) 
    AutoRowCountFrequency?: number;
        
    @Field(() => Int, {nullable: true, description: `Cached row count for this entity, populated by automatic row count processes when AutoRowCountFrequency is configured.`}) 
    RowCount?: number;
        
    @Field({nullable: true, description: `Timestamp indicating when the last automatic row count was performed for this entity.`}) 
    @MaxLength(10)
    RowCountRunAt?: Date;
        
    @Field({description: `Status of the entity. Active: fully functional; Deprecated: functional but generates console warnings when used; Disabled: not available for use even though metadata and physical table remain.`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({nullable: true, description: `Optional display name for the entity. If not provided, the entity Name will be used for display purposes.`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({nullable: true}) 
    CodeName?: string;
        
    @Field({nullable: true}) 
    ClassName?: string;
        
    @Field({nullable: true}) 
    BaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentBaseView?: string;
        
    @Field(() => [EntityPermission_])
    EntityPermissions_EntityIDArray: EntityPermission_[]; // Link to EntityPermissions
    
    @Field(() => [EntityRelationship_])
    EntityRelationships_EntityIDArray: EntityRelationship_[]; // Link to EntityRelationships
    
    @Field(() => [EntityField_])
    EntityFields_EntityIDArray: EntityField_[]; // Link to EntityFields
    
    @Field(() => [EntityAIAction_])
    EntityAIActions_EntityIDArray: EntityAIAction_[]; // Link to EntityAIActions
    
    @Field(() => [UserRecordLog_])
    UserRecordLogs_EntityIDArray: UserRecordLog_[]; // Link to UserRecordLogs
    
    @Field(() => [IntegrationURLFormat_])
    IntegrationURLFormats_EntityIDArray: IntegrationURLFormat_[]; // Link to IntegrationURLFormats
    
    @Field(() => [Entity_])
    Entities_ParentIDArray: Entity_[]; // Link to Entities
    
    @Field(() => [UserFavorite_])
    UserFavorites_EntityIDArray: UserFavorite_[]; // Link to UserFavorites
    
    @Field(() => [CompanyIntegrationRunDetail_])
    CompanyIntegrationRunDetails_EntityIDArray: CompanyIntegrationRunDetail_[]; // Link to CompanyIntegrationRunDetails
    
    @Field(() => [ApplicationEntity_])
    ApplicationEntities_EntityIDArray: ApplicationEntity_[]; // Link to ApplicationEntities
    
    @Field(() => [UserApplicationEntity_])
    UserApplicationEntities_EntityIDArray: UserApplicationEntity_[]; // Link to UserApplicationEntities
    
    @Field(() => [List_])
    Lists_EntityIDArray: List_[]; // Link to Lists
    
    @Field(() => [UserView_])
    UserViews_EntityIDArray: UserView_[]; // Link to UserViews
    
    @Field(() => [RecordChange_])
    RecordChanges_EntityIDArray: RecordChange_[]; // Link to RecordChanges
    
    @Field(() => [AuditLog_])
    AuditLogs_EntityIDArray: AuditLog_[]; // Link to AuditLogs
    
    @Field(() => [ResourceType_])
    ResourceTypes_EntityIDArray: ResourceType_[]; // Link to ResourceTypes
    
    @Field(() => [TaggedItem_])
    TaggedItems_EntityIDArray: TaggedItem_[]; // Link to TaggedItems
    
    @Field(() => [DatasetItem_])
    DatasetItems_EntityIDArray: DatasetItem_[]; // Link to DatasetItems
    
    @Field(() => [CompanyIntegrationRecordMap_])
    CompanyIntegrationRecordMaps_EntityIDArray: CompanyIntegrationRecordMap_[]; // Link to CompanyIntegrationRecordMaps
    
    @Field(() => [RecordMergeLog_])
    RecordMergeLogs_EntityIDArray: RecordMergeLog_[]; // Link to RecordMergeLogs
    
    @Field(() => [QueryField_])
    QueryFields_SourceEntityIDArray: QueryField_[]; // Link to QueryFields
    
    @Field(() => [Conversation_])
    Conversations_LinkedEntityIDArray: Conversation_[]; // Link to Conversations
    
    @Field(() => [EntityDocument_])
    EntityDocuments_EntityIDArray: EntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [DataContextItem_])
    DataContextItems_EntityIDArray: DataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [User_])
    Users_LinkedEntityIDArray: User_[]; // Link to Users
    
    @Field(() => [EntityRecordDocument_])
    EntityRecordDocuments_EntityIDArray: EntityRecordDocument_[]; // Link to EntityRecordDocuments
    
    @Field(() => [FileEntityRecordLink_])
    FileEntityRecordLinks_EntityIDArray: FileEntityRecordLink_[]; // Link to FileEntityRecordLinks
    
    @Field(() => [UserViewCategory_])
    UserViewCategories_EntityIDArray: UserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [EntitySetting_])
    EntitySettings_EntityIDArray: EntitySetting_[]; // Link to EntitySettings
    
    @Field(() => [DuplicateRun_])
    DuplicateRuns_EntityIDArray: DuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [EntityAction_])
    EntityActions_EntityIDArray: EntityAction_[]; // Link to EntityActions
    
    @Field(() => [TemplateParam_])
    TemplateParams_EntityIDArray: TemplateParam_[]; // Link to TemplateParams
    
    @Field(() => [Recommendation_])
    Recommendations_SourceEntityIDArray: Recommendation_[]; // Link to Recommendations
    
    @Field(() => [RecommendationItem_])
    RecommendationItems_DestinationEntityIDArray: RecommendationItem_[]; // Link to RecommendationItems
    
    @Field(() => [EntityCommunicationMessageType_])
    EntityCommunicationMessageTypes_EntityIDArray: EntityCommunicationMessageType_[]; // Link to EntityCommunicationMessageTypes
    
    @Field(() => [QueryEntity_])
    QueryEntities_EntityIDArray: QueryEntity_[]; // Link to QueryEntities
    
    @Field(() => [GeneratedCode_])
    GeneratedCodes_LinkedEntityIDArray: GeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for Entities
//****************************************************************************
@InputType()
export class CreateEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate: string | null;

    @Field({ nullable: true })
    spUpdate: string | null;

    @Field({ nullable: true })
    spDelete: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder: string | null;

    @Field(() => Int, { nullable: true })
    AutoRowCountFrequency: number | null;

    @Field(() => Int, { nullable: true })
    RowCount: number | null;

    @Field({ nullable: true })
    RowCountRunAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DisplayName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entities
//****************************************************************************
@InputType()
export class UpdateEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate?: string | null;

    @Field({ nullable: true })
    spUpdate?: string | null;

    @Field({ nullable: true })
    spDelete?: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch?: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName?: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport?: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder?: string | null;

    @Field(() => Int, { nullable: true })
    AutoRowCountFrequency?: number | null;

    @Field(() => Int, { nullable: true })
    RowCount?: number | null;

    @Field({ nullable: true })
    RowCountRunAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entities
//****************************************************************************
@ObjectType()
export class RunEntityViewResult {
    @Field(() => [Entity_])
    Results: Entity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Entity_)
export class EntityResolverBase extends ResolverBase {
    @Query(() => RunEntityViewResult)
    async RunEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityViewResult)
    async RunEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityViewResult)
    async RunEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Entity_, { nullable: true })
    async Entity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Entity_ | null> {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entities', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [Entity_])
    async AllEntities(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities]` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entities', rows);
        return result;
    }
    
    @FieldResolver(() => [EntityPermission_])
    async EntityPermissions_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityRelationship_])
    async EntityRelationships_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityField_])
    async EntityFields_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Fields', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityAIAction_])
    async EntityAIActions_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [UserRecordLog_])
    async UserRecordLogs_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Record Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [IntegrationURLFormat_])
    async IntegrationURLFormats_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows);
        return result;
    }
        
    @FieldResolver(() => [Entity_])
    async Entities_ParentIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities] WHERE [ParentID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [UserFavorite_])
    async UserFavorites_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Favorites', rows);
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRunDetail_])
    async CompanyIntegrationRunDetails_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run Details', rows);
        return result;
    }
        
    @FieldResolver(() => [ApplicationEntity_])
    async ApplicationEntities_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Application Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [UserApplicationEntity_])
    async UserApplicationEntities_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Application Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [List_])
    async Lists_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', rows);
        return result;
    }
        
    @FieldResolver(() => [UserView_])
    async UserViews_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', rows);
        return result;
    }
        
    @FieldResolver(() => [RecordChange_])
    async RecordChanges_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', rows);
        return result;
    }
        
    @FieldResolver(() => [AuditLog_])
    async AuditLogs_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [ResourceType_])
    async ResourceTypes_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceTypes] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Types', rows);
        return result;
    }
        
    @FieldResolver(() => [TaggedItem_])
    async TaggedItems_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Tagged Items', rows);
        return result;
    }
        
    @FieldResolver(() => [DatasetItem_])
    async DatasetItems_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dataset Items', rows);
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRecordMap_])
    async CompanyIntegrationRecordMaps_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Record Maps', rows);
        return result;
    }
        
    @FieldResolver(() => [RecordMergeLog_])
    async RecordMergeLogs_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [QueryField_])
    async QueryFields_SourceEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [SourceEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Fields', rows);
        return result;
    }
        
    @FieldResolver(() => [Conversation_])
    async Conversations_LinkedEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [LinkedEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @FieldResolver(() => [DataContextItem_])
    async DataContextItems_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows);
        return result;
    }
        
    @FieldResolver(() => [User_])
    async Users_LinkedEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [LinkedEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Users', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityRecordDocument_])
    async EntityRecordDocuments_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows);
        return result;
    }
        
    @FieldResolver(() => [FileEntityRecordLink_])
    async FileEntityRecordLinks_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('File Entity Record Links', rows);
        return result;
    }
        
    @FieldResolver(() => [UserViewCategory_])
    async UserViewCategories_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [EntitySetting_])
    async EntitySettings_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntitySettings] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Settings', rows);
        return result;
    }
        
    @FieldResolver(() => [DuplicateRun_])
    async DuplicateRuns_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityAction_])
    async EntityActions_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [TemplateParam_])
    async TemplateParams_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Params', rows);
        return result;
    }
        
    @FieldResolver(() => [Recommendation_])
    async Recommendations_SourceEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [SourceEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendations', rows);
        return result;
    }
        
    @FieldResolver(() => [RecommendationItem_])
    async RecommendationItems_DestinationEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [DestinationEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Items', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityCommunicationMessageType_])
    async EntityCommunicationMessageTypes_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Message Types', rows);
        return result;
    }
        
    @FieldResolver(() => [QueryEntity_])
    async QueryEntities_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [GeneratedCode_])
    async GeneratedCodes_LinkedEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [LinkedEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows);
        return result;
    }
        
    @Mutation(() => Entity_)
    async CreateEntity(
        @Arg('input', () => CreateEntityInput) input: CreateEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Entity_)
    async UpdateEntity(
        @Arg('input', () => UpdateEntityInput) input: UpdateEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Entity_)
    async DeleteEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Users
//****************************************************************************
@ObjectType({ description: `A list of all users who have or had access to the system` })
export class User_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `User's first name or given name.`}) 
    @MaxLength(100)
    FirstName?: string;
        
    @Field({nullable: true, description: `User's last name or surname.`}) 
    @MaxLength(100)
    LastName?: string;
        
    @Field({nullable: true, description: `User's professional title or salutation.`}) 
    @MaxLength(100)
    Title?: string;
        
    @Field({description: `Unique email address for the user. This field must be unique across all users in the system.`}) 
    @MaxLength(200)
    Email: string;
        
    @Field({description: `User account type (User, Guest, System, API).`}) 
    @MaxLength(30)
    Type: string;
        
    @Field(() => Boolean, {description: `Whether this user account is currently active and can log in.`}) 
    IsActive: boolean;
        
    @Field({description: `Type of record this user is linked to (None, Employee, Contact, etc.).`}) 
    @MaxLength(20)
    LinkedRecordType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `ID of the specific record this user is linked to.`}) 
    @MaxLength(900)
    LinkedEntityRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EmployeeID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    EmployeeFirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    EmployeeEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmployeeTitle?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    EmployeeSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    EmployeeSupervisorEmail?: string;
        
    @Field(() => [UserApplication_])
    UserApplications_UserIDArray: UserApplication_[]; // Link to UserApplications
    
    @Field(() => [UserRole_])
    UserRoles_UserIDArray: UserRole_[]; // Link to UserRoles
    
    @Field(() => [Workspace_])
    Workspaces_UserIDArray: Workspace_[]; // Link to Workspaces
    
    @Field(() => [Report_])
    Reports_UserIDArray: Report_[]; // Link to Reports
    
    @Field(() => [ReportSnapshot_])
    ReportSnapshots_UserIDArray: ReportSnapshot_[]; // Link to ReportSnapshots
    
    @Field(() => [RecordChange_])
    RecordChanges_UserIDArray: RecordChange_[]; // Link to RecordChanges
    
    @Field(() => [Dashboard_])
    Dashboards_UserIDArray: Dashboard_[]; // Link to Dashboards
    
    @Field(() => [UserViewRun_])
    UserViewRuns_RunByUserIDArray: UserViewRun_[]; // Link to UserViewRuns
    
    @Field(() => [AuditLog_])
    AuditLogs_UserIDArray: AuditLog_[]; // Link to AuditLogs
    
    @Field(() => [List_])
    Lists_UserIDArray: List_[]; // Link to Lists
    
    @Field(() => [UserFavorite_])
    UserFavorites_UserIDArray: UserFavorite_[]; // Link to UserFavorites
    
    @Field(() => [UserRecordLog_])
    UserRecordLogs_UserIDArray: UserRecordLog_[]; // Link to UserRecordLogs
    
    @Field(() => [UserView_])
    UserViews_UserIDArray: UserView_[]; // Link to UserViews
    
    @Field(() => [CompanyIntegrationRun_])
    CompanyIntegrationRuns_RunByUserIDArray: CompanyIntegrationRun_[]; // Link to CompanyIntegrationRuns
    
    @Field(() => [UserNotification_])
    UserNotifications_UserIDArray: UserNotification_[]; // Link to UserNotifications
    
    @Field(() => [Conversation_])
    Conversations_UserIDArray: Conversation_[]; // Link to Conversations
    
    @Field(() => [RecordMergeLog_])
    RecordMergeLogs_InitiatedByUserIDArray: RecordMergeLog_[]; // Link to RecordMergeLogs
    
    @Field(() => [DataContext_])
    DataContexts_UserIDArray: DataContext_[]; // Link to DataContexts
    
    @Field(() => [ReportCategory_])
    ReportCategories_UserIDArray: ReportCategory_[]; // Link to ReportCategories
    
    @Field(() => [UserViewCategory_])
    UserViewCategories_UserIDArray: UserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [DashboardCategory_])
    DashboardCategories_UserIDArray: DashboardCategory_[]; // Link to DashboardCategories
    
    @Field(() => [QueryCategory_])
    QueryCategories_UserIDArray: QueryCategory_[]; // Link to QueryCategories
    
    @Field(() => [DuplicateRun_])
    DuplicateRuns_StartedByUserIDArray: DuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [ActionExecutionLog_])
    ActionExecutionLogs_UserIDArray: ActionExecutionLog_[]; // Link to ActionExecutionLogs
    
    @Field(() => [Action_])
    Actions_CodeApprovedByUserIDArray: Action_[]; // Link to Actions
    
    @Field(() => [CommunicationRun_])
    CommunicationRuns_UserIDArray: CommunicationRun_[]; // Link to CommunicationRuns
    
    @Field(() => [Template_])
    Templates_UserIDArray: Template_[]; // Link to Templates
    
    @Field(() => [TemplateCategory_])
    TemplateCategories_UserIDArray: TemplateCategory_[]; // Link to TemplateCategories
    
    @Field(() => [RecommendationRun_])
    RecommendationRuns_RunByUserIDArray: RecommendationRun_[]; // Link to RecommendationRuns
    
    @Field(() => [RecordChangeReplayRun_])
    RecordChangeReplayRuns_UserIDArray: RecordChangeReplayRun_[]; // Link to RecordChangeReplayRuns
    
    @Field(() => [ListCategory_])
    ListCategories_UserIDArray: ListCategory_[]; // Link to ListCategories
    
    @Field(() => [ScheduledAction_])
    ScheduledActions_CreatedByUserIDArray: ScheduledAction_[]; // Link to ScheduledActions
    
    @Field(() => [ResourceLink_])
    ResourceLinks_UserIDArray: ResourceLink_[]; // Link to ResourceLinks
    
    @Field(() => [AIAgentRequest_])
    AIAgentRequests_ResponseByUserIDArray: AIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [AIAgentNote_])
    AIAgentNotes_UserIDArray: AIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [ReportUserState_])
    MJ_ReportUserStates_UserIDArray: ReportUserState_[]; // Link to MJ_ReportUserStates
    
    @Field(() => [DashboardUserPreference_])
    MJ_DashboardUserPreferences_UserIDArray: DashboardUserPreference_[]; // Link to MJ_DashboardUserPreferences
    
    @Field(() => [DashboardUserState_])
    MJ_DashboardUserStates_UserIDArray: DashboardUserState_[]; // Link to MJ_DashboardUserStates
    
    @Field(() => [ResourcePermission_])
    ResourcePermissions_UserIDArray: ResourcePermission_[]; // Link to ResourcePermissions
    
    @Field(() => [AIAgentRequest_])
    AIAgentRequests_RequestForUserIDArray: AIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [ConversationDetail_])
    ConversationDetails_UserIDArray: ConversationDetail_[]; // Link to ConversationDetails
    
    @Field(() => [AIAgentRun_])
    MJ_AIAgentRuns_UserIDArray: AIAgentRun_[]; // Link to MJ_AIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for Users
//****************************************************************************
@InputType()
export class CreateUserInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName: string | null;

    @Field({ nullable: true })
    LastName: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID: string | null;

    @Field({ nullable: true })
    EmployeeID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Users
//****************************************************************************
@InputType()
export class UpdateUserInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName?: string | null;

    @Field({ nullable: true })
    LastName?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID?: string | null;

    @Field({ nullable: true })
    EmployeeID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Users
//****************************************************************************
@ObjectType()
export class RunUserViewResult {
    @Field(() => [User_])
    Results: User_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(User_)
export class UserResolverBase extends ResolverBase {
    @Query(() => RunUserViewResult)
    async RunUserViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewResult)
    async RunUserViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewResult)
    async RunUserDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Users';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => User_, { nullable: true })
    async User(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<User_ | null> {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Users', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [User_])
    async AllUsers(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers]` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Users', rows);
        return result;
    }
    
    @FieldResolver(() => [UserApplication_])
    async UserApplications_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Applications', rows);
        return result;
    }
        
    @FieldResolver(() => [UserRole_])
    async UserRoles_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [Workspace_])
    async Workspaces_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspaces', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaces] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workspaces', rows);
        return result;
    }
        
    @FieldResolver(() => [Report_])
    async Reports_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [ReportSnapshot_])
    async ReportSnapshots_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Report Snapshots', rows);
        return result;
    }
        
    @FieldResolver(() => [RecordChange_])
    async RecordChanges_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', rows);
        return result;
    }
        
    @FieldResolver(() => [Dashboard_])
    async Dashboards_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboards', rows);
        return result;
    }
        
    @FieldResolver(() => [UserViewRun_])
    async UserViewRuns_RunByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [RunByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AuditLog_])
    async AuditLogs_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [List_])
    async Lists_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', rows);
        return result;
    }
        
    @FieldResolver(() => [UserFavorite_])
    async UserFavorites_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Favorites', rows);
        return result;
    }
        
    @FieldResolver(() => [UserRecordLog_])
    async UserRecordLogs_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Record Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [UserView_])
    async UserViews_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', rows);
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRun_])
    async CompanyIntegrationRuns_RunByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [RunByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [UserNotification_])
    async UserNotifications_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Notifications', rows);
        return result;
    }
        
    @FieldResolver(() => [Conversation_])
    async Conversations_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', rows);
        return result;
    }
        
    @FieldResolver(() => [RecordMergeLog_])
    async RecordMergeLogs_InitiatedByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [InitiatedByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [DataContext_])
    async DataContexts_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContexts] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Contexts', rows);
        return result;
    }
        
    @FieldResolver(() => [ReportCategory_])
    async ReportCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Report Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [UserViewCategory_])
    async UserViewCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [DashboardCategory_])
    async DashboardCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboard Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [QueryCategory_])
    async QueryCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [DuplicateRun_])
    async DuplicateRuns_StartedByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [StartedByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [ActionExecutionLog_])
    async ActionExecutionLogs_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Execution Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [Action_])
    async Actions_CodeApprovedByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [CodeApprovedByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [CommunicationRun_])
    async CommunicationRuns_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationRuns] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [Template_])
    async Templates_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Templates', rows);
        return result;
    }
        
    @FieldResolver(() => [TemplateCategory_])
    async TemplateCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [RecommendationRun_])
    async RecommendationRuns_RunByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [RunByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [RecordChangeReplayRun_])
    async RecordChangeReplayRuns_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Change Replay Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChangeReplayRuns] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Change Replay Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [ListCategory_])
    async ListCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('List Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [ScheduledAction_])
    async ScheduledActions_CreatedByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [CreatedByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [ResourceLink_])
    async ResourceLinks_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Links', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRequest_])
    async AIAgentRequests_ResponseByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [ResponseByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentNote_])
    async AIAgentNotes_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows);
        return result;
    }
        
    @FieldResolver(() => [ReportUserState_])
    async MJ_ReportUserStates_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', rows);
        return result;
    }
        
    @FieldResolver(() => [DashboardUserPreference_])
    async MJ_DashboardUserPreferences_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserPreferences] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows);
        return result;
    }
        
    @FieldResolver(() => [DashboardUserState_])
    async MJ_DashboardUserStates_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserStates] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User States', rows);
        return result;
    }
        
    @FieldResolver(() => [ResourcePermission_])
    async ResourcePermissions_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRequest_])
    async AIAgentRequests_RequestForUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [RequestForUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows);
        return result;
    }
        
    @FieldResolver(() => [ConversationDetail_])
    async ConversationDetails_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRun_])
    async MJ_AIAgentRuns_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows);
        return result;
    }
        
    @Mutation(() => User_)
    async CreateUser(
        @Arg('input', () => CreateUserInput) input: CreateUserInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Users', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => User_)
    async UpdateUser(
        @Arg('input', () => UpdateUserInput) input: UpdateUserInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Users', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => User_)
    async DeleteUser(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Users', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Relationships
//****************************************************************************
@ObjectType({ description: `Metadata about relationships between entities including display preferences for the UI` })
export class EntityRelationship_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Used for display order in generated forms and in other places in the UI where relationships for an entity are shown`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(16)
    RelatedEntityID: string;
        
    @Field(() => Boolean, {description: `Whether to include related records when fetching the parent entity via API.`}) 
    BundleInAPI: boolean;
        
    @Field(() => Boolean, {description: `Whether to include this relationship when querying all fields of the parent entity.`}) 
    IncludeInParentAllQuery: boolean;
        
    @Field({description: `The cardinality of the relationship (One To Many, Many To Many, One To One).`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `The primary key field of the parent entity in this relationship.`}) 
    @MaxLength(510)
    EntityKeyField?: string;
        
    @Field({description: `The foreign key field in the related entity that references the parent.`}) 
    @MaxLength(510)
    RelatedEntityJoinField: string;
        
    @Field({nullable: true, description: `For many-to-many relationships, the view containing the junction data.`}) 
    @MaxLength(510)
    JoinView?: string;
        
    @Field({nullable: true, description: `For many-to-many, the field in the junction table linking to the parent entity.`}) 
    @MaxLength(510)
    JoinEntityJoinField?: string;
        
    @Field({nullable: true, description: `For many-to-many, the field in the junction table linking to the related entity.`}) 
    @MaxLength(510)
    JoinEntityInverseJoinField?: string;
        
    @Field(() => Boolean, {description: `When unchecked the relationship will NOT be displayed on the generated form`}) 
    DisplayInForm: boolean;
        
    @Field({description: `Where to display this relationship in the UI relative to other entity elements.`}) 
    @MaxLength(100)
    DisplayLocation: string;
        
    @Field({nullable: true, description: `Optional, when specified this value overrides the related entity name for the label on the tab`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({description: `When Related Entity Icon - uses the icon from the related entity, if one exists. When Custom, uses the value in the DisplayIcon field in this record, and when None, no icon is displayed`}) 
    @MaxLength(100)
    DisplayIconType: string;
        
    @Field({nullable: true, description: `If specified, the icon `}) 
    @MaxLength(510)
    DisplayIcon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DisplayUserViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DisplayComponentID?: string;
        
    @Field({nullable: true, description: `If DisplayComponentID is specified, this field can optionally be used to track component-specific and relationship-specific configuration details that will be used by CodeGen to provide to the display component selected.`}) 
    DisplayComponentConfiguration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this relationship should be automatically updated by CodeGen. When set to 0, the record will not be modified by CodeGen. Defaults to 1.`}) 
    AutoUpdateFromSchema: boolean;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntity: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityBaseView: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityBaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DisplayUserViewName?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Relationships
//****************************************************************************
@InputType()
export class CreateEntityRelationshipInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon: string | null;

    @Field({ nullable: true })
    DisplayComponentID: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Entity Relationships
//****************************************************************************
@InputType()
export class UpdateEntityRelationshipInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField?: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView?: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField?: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField?: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon?: string | null;

    @Field({ nullable: true })
    DisplayComponentID?: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Relationships
//****************************************************************************
@ObjectType()
export class RunEntityRelationshipViewResult {
    @Field(() => [EntityRelationship_])
    Results: EntityRelationship_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityRelationship_)
export class EntityRelationshipResolver extends ResolverBase {
    @Query(() => RunEntityRelationshipViewResult)
    async RunEntityRelationshipViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityRelationshipViewResult)
    async RunEntityRelationshipViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityRelationshipViewResult)
    async RunEntityRelationshipDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Relationships';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityRelationship_, { nullable: true })
    async EntityRelationship(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityRelationship_ | null> {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Relationships', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [EntityRelationship_])
    async AllEntityRelationships(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows);
        return result;
    }
    
    @Mutation(() => EntityRelationship_)
    async CreateEntityRelationship(
        @Arg('input', () => CreateEntityRelationshipInput) input: CreateEntityRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Relationships', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityRelationship_)
    async UpdateEntityRelationship(
        @Arg('input', () => UpdateEntityRelationshipInput) input: UpdateEntityRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Relationships', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityRelationship_)
    async DeleteEntityRelationship(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Relationships', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Record Logs
//****************************************************************************
@ObjectType({ description: `Tracks user interactions with specific records, maintaining an audit trail of views or other operations. Changes are managed separately in the Record Changes entity.` })
export class UserRecordLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the accessed record.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field({description: `Field EarliestAt for entity User Record Logs.`}) 
    @MaxLength(8)
    EarliestAt: Date;
        
    @Field({description: `Field LatestAt for entity User Record Logs.`}) 
    @MaxLength(8)
    LatestAt: Date;
        
    @Field(() => Int, {description: `Field TotalCount for entity User Record Logs.`}) 
    TotalCount: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(200)
    UserEmail: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    UserSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    UserSupervisorEmail?: string;
        
}

//****************************************************************************
// INPUT TYPE for User Record Logs
//****************************************************************************
@InputType()
export class CreateUserRecordLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EarliestAt?: Date;

    @Field({ nullable: true })
    LatestAt?: Date;

    @Field(() => Int, { nullable: true })
    TotalCount?: number;
}
    

//****************************************************************************
// INPUT TYPE for User Record Logs
//****************************************************************************
@InputType()
export class UpdateUserRecordLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EarliestAt?: Date;

    @Field({ nullable: true })
    LatestAt?: Date;

    @Field(() => Int, { nullable: true })
    TotalCount?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Record Logs
//****************************************************************************
@ObjectType()
export class RunUserRecordLogViewResult {
    @Field(() => [UserRecordLog_])
    Results: UserRecordLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserRecordLog_)
export class UserRecordLogResolver extends ResolverBase {
    @Query(() => RunUserRecordLogViewResult)
    async RunUserRecordLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserRecordLogViewResult)
    async RunUserRecordLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserRecordLogViewResult)
    async RunUserRecordLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Record Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserRecordLog_, { nullable: true })
    async UserRecordLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserRecordLog_ | null> {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Record Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => UserRecordLog_)
    async CreateUserRecordLog(
        @Arg('input', () => CreateUserRecordLogInput) input: CreateUserRecordLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Record Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserRecordLog_)
    async UpdateUserRecordLog(
        @Arg('input', () => UpdateUserRecordLogInput) input: UpdateUserRecordLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Record Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserRecordLog_)
    async DeleteUserRecordLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Record Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Views
//****************************************************************************
@ObjectType({ description: `Views are sets of records within a given entity defined by filtering rules. Views can be used programatically to retrieve dynamic sets of data and in user interfaces like MJ Explorer for end-user consumption.` })
export class UserView_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field(() => Boolean, {description: `Whether this view is shared with other users.`}) 
    IsShared: boolean;
        
    @Field(() => Boolean, {description: `Whether this is the user's default view for the entity.`}) 
    IsDefault: boolean;
        
    @Field({nullable: true, description: `JSON storing complete grid configuration including columns, widths, and formatting.`}) 
    GridState?: string;
        
    @Field({nullable: true, description: `JSON storing the view's filter configuration.`}) 
    FilterState?: string;
        
    @Field(() => Boolean, {description: `Indicates if custom filters beyond standard options are applied.`}) 
    CustomFilterState: boolean;
        
    @Field(() => Boolean, {description: `Whether AI-powered smart filtering is enabled for this view.`}) 
    SmartFilterEnabled: boolean;
        
    @Field({nullable: true, description: `Natural language prompt for AI-powered filtering.`}) 
    SmartFilterPrompt?: string;
        
    @Field({nullable: true, description: `Generated WHERE clause from smart filter processing.`}) 
    SmartFilterWhereClause?: string;
        
    @Field({nullable: true, description: `AI-generated explanation of what the smart filter does.`}) 
    SmartFilterExplanation?: string;
        
    @Field({nullable: true, description: `Direct SQL WHERE clause for the view filter.`}) 
    WhereClause?: string;
        
    @Field(() => Boolean, {description: `Indicates if a custom WHERE clause is used instead of standard filters.`}) 
    CustomWhereClause: boolean;
        
    @Field({nullable: true, description: `JSON storing the view's sort configuration.`}) 
    SortState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Thumbnail image for the user view that can be displayed in gallery views. Can contain either a URL to an image file or a Base64-encoded image string.`}) 
    Thumbnail?: string;
        
    @Field() 
    @MaxLength(200)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(200)
    UserEmail: string;
        
    @Field() 
    @MaxLength(30)
    UserType: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
    @Field(() => [EntityRelationship_])
    EntityRelationships_DisplayUserViewGUIDArray: EntityRelationship_[]; // Link to EntityRelationships
    
    @Field(() => [UserViewRun_])
    UserViewRuns_UserViewIDArray: UserViewRun_[]; // Link to UserViewRuns
    
    @Field(() => [DataContextItem_])
    DataContextItems_ViewIDArray: DataContextItem_[]; // Link to DataContextItems
    
}

//****************************************************************************
// INPUT TYPE for User Views
//****************************************************************************
@InputType()
export class CreateUserViewInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState: string | null;

    @Field({ nullable: true })
    FilterState: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation: string | null;

    @Field({ nullable: true })
    WhereClause: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState: string | null;

    @Field({ nullable: true })
    Thumbnail: string | null;
}
    

//****************************************************************************
// INPUT TYPE for User Views
//****************************************************************************
@InputType()
export class UpdateUserViewInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState?: string | null;

    @Field({ nullable: true })
    FilterState?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt?: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause?: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation?: string | null;

    @Field({ nullable: true })
    WhereClause?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState?: string | null;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Views
//****************************************************************************
@ObjectType()
export class RunUserViewViewResult {
    @Field(() => [UserView_])
    Results: UserView_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserView_)
export class UserViewResolverBase extends ResolverBase {
    @Query(() => RunUserViewViewResult)
    async RunUserViewViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewViewResult)
    async RunUserViewViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewViewResult)
    async RunUserViewDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Views';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserView_, { nullable: true })
    async UserView(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserView_ | null> {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Views', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [UserView_])
    async AllUserViews(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews]` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', rows);
        return result;
    }
    
    @FieldResolver(() => [EntityRelationship_])
    async EntityRelationships_DisplayUserViewGUIDArray(@Root() userview_: UserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [DisplayUserViewGUID]='${userview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows);
        return result;
    }
        
    @FieldResolver(() => [UserViewRun_])
    async UserViewRuns_UserViewIDArray(@Root() userview_: UserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [UserViewID]='${userview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [DataContextItem_])
    async DataContextItems_ViewIDArray(@Root() userview_: UserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [ViewID]='${userview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows);
        return result;
    }
        
    @Mutation(() => UserView_)
    async CreateUserView(
        @Arg('input', () => CreateUserViewInput) input: CreateUserViewInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Views', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserView_)
    async UpdateUserView(
        @Arg('input', () => UpdateUserViewInput) input: UpdateUserViewInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Views', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserView_)
    async DeleteUserView(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Views', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Runs
//****************************************************************************
@ObjectType({ description: `Records execution history of company integrations, including start/end times, overall status, and aggregate statistics for monitoring and troubleshooting.` })
export class CompanyIntegrationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field(() => Int, {description: `The total number of records processed during this integration run.`}) 
    TotalRecords: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the integration run. Possible values: Pending, In Progress, Success, Failed.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Optional error log information for the integration run.`}) 
    ErrorLog?: string;
        
    @Field({nullable: true, description: `Optional configuration data in JSON format for the request that started the integration run for audit purposes.`}) 
    ConfigData?: string;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field() 
    @MaxLength(100)
    Company: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [CompanyIntegrationRunAPILog_])
    CompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray: CompanyIntegrationRunAPILog_[]; // Link to CompanyIntegrationRunAPILogs
    
    @Field(() => [ErrorLog_])
    ErrorLogs_CompanyIntegrationRunIDArray: ErrorLog_[]; // Link to ErrorLogs
    
    @Field(() => [CompanyIntegrationRunDetail_])
    CompanyIntegrationRunDetails_CompanyIntegrationRunIDArray: CompanyIntegrationRunDetail_[]; // Link to CompanyIntegrationRunDetails
    
}

//****************************************************************************
// INPUT TYPE for Company Integration Runs
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ConfigData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Runs
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ConfigData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Runs
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationRunViewResult {
    @Field(() => [CompanyIntegrationRun_])
    Results: CompanyIntegrationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegrationRun_)
export class CompanyIntegrationRunResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationRunViewResult)
    async RunCompanyIntegrationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunViewResult)
    async RunCompanyIntegrationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunViewResult)
    async RunCompanyIntegrationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CompanyIntegrationRun_, { nullable: true })
    async CompanyIntegrationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegrationRun_ | null> {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integration Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [CompanyIntegrationRunAPILog_])
    async CompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray(@Root() companyintegrationrun_: CompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run API Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunAPILogs] WHERE [CompanyIntegrationRunID]='${companyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run API Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [ErrorLog_])
    async ErrorLogs_CompanyIntegrationRunIDArray(@Root() companyintegrationrun_: CompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [CompanyIntegrationRunID]='${companyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Error Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRunDetail_])
    async CompanyIntegrationRunDetails_CompanyIntegrationRunIDArray(@Root() companyintegrationrun_: CompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [CompanyIntegrationRunID]='${companyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run Details', rows);
        return result;
    }
        
    @Mutation(() => CompanyIntegrationRun_)
    async CreateCompanyIntegrationRun(
        @Arg('input', () => CreateCompanyIntegrationRunInput) input: CreateCompanyIntegrationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegrationRun_)
    async UpdateCompanyIntegrationRun(
        @Arg('input', () => UpdateCompanyIntegrationRunInput) input: UpdateCompanyIntegrationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CompanyIntegrationRun_)
    async DeleteCompanyIntegrationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integration Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Run Details
//****************************************************************************
@ObjectType({ description: `Tracks individual record-level operations within an integration run, including success/failure status and error details for each processed item.` })
export class CompanyIntegrationRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationRunID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the specific record being processed in this integration operation.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field({description: `The type of operation performed (INSERT, UPDATE, DELETE, SYNC).`}) 
    @MaxLength(40)
    Action: string;
        
    @Field({description: `Timestamp when this specific record operation was executed.`}) 
    @MaxLength(8)
    ExecutedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this individual record operation succeeded or failed.`}) 
    IsSuccess: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    RunStartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    RunEndedAt?: Date;
        
    @Field(() => [ErrorLog_])
    ErrorLogs_CompanyIntegrationRunDetailIDArray: ErrorLog_[]; // Link to ErrorLogs
    
}

//****************************************************************************
// INPUT TYPE for Company Integration Run Details
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Run Details
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Run Details
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationRunDetailViewResult {
    @Field(() => [CompanyIntegrationRunDetail_])
    Results: CompanyIntegrationRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegrationRunDetail_)
export class CompanyIntegrationRunDetailResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationRunDetailViewResult)
    async RunCompanyIntegrationRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunDetailViewResult)
    async RunCompanyIntegrationRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunDetailViewResult)
    async RunCompanyIntegrationRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CompanyIntegrationRunDetail_, { nullable: true })
    async CompanyIntegrationRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegrationRunDetail_ | null> {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integration Run Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ErrorLog_])
    async ErrorLogs_CompanyIntegrationRunDetailIDArray(@Root() companyintegrationrundetail_: CompanyIntegrationRunDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [CompanyIntegrationRunDetailID]='${companyintegrationrundetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Error Logs', rows);
        return result;
    }
        
    @Mutation(() => CompanyIntegrationRunDetail_)
    async CreateCompanyIntegrationRunDetail(
        @Arg('input', () => CreateCompanyIntegrationRunDetailInput) input: CreateCompanyIntegrationRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegrationRunDetail_)
    async UpdateCompanyIntegrationRunDetail(
        @Arg('input', () => UpdateCompanyIntegrationRunDetailInput) input: UpdateCompanyIntegrationRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CompanyIntegrationRunDetail_)
    async DeleteCompanyIntegrationRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integration Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Error Logs
//****************************************************************************
@ObjectType({ description: `Captures system errors, exceptions, and failures with stack traces, context, and debugging info.` })
export class ErrorLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationRunDetailID?: string;
        
    @Field({nullable: true, description: `Error code for categorizing and handling specific error types.`}) 
    @MaxLength(40)
    Code?: string;
        
    @Field({nullable: true, description: `The primary error message describing what went wrong.`}) 
    Message?: string;
        
    @Field({nullable: true, description: `User or system process that encountered this error.`}) 
    @MaxLength(100)
    CreatedBy?: string;
        
    @Field({nullable: true}) 
    @MaxLength(20)
    Status?: string;
        
    @Field({nullable: true, description: `High-level category for grouping related errors (Database, API, Validation, etc.).`}) 
    @MaxLength(40)
    Category?: string;
        
    @Field({nullable: true, description: `Full error details including stack trace, inner exceptions, and context data.`}) 
    Details?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Error Logs
//****************************************************************************
@InputType()
export class CreateErrorLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    Details: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Error Logs
//****************************************************************************
@InputType()
export class UpdateErrorLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Error Logs
//****************************************************************************
@ObjectType()
export class RunErrorLogViewResult {
    @Field(() => [ErrorLog_])
    Results: ErrorLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ErrorLog_)
export class ErrorLogResolver extends ResolverBase {
    @Query(() => RunErrorLogViewResult)
    async RunErrorLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunErrorLogViewResult)
    async RunErrorLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunErrorLogViewResult)
    async RunErrorLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Error Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ErrorLog_, { nullable: true })
    async ErrorLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ErrorLog_ | null> {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Error Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ErrorLog_)
    async CreateErrorLog(
        @Arg('input', () => CreateErrorLogInput) input: CreateErrorLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Error Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ErrorLog_)
    async UpdateErrorLog(
        @Arg('input', () => UpdateErrorLogInput) input: UpdateErrorLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Error Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ErrorLog_)
    async DeleteErrorLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Error Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Applications
//****************************************************************************
@ObjectType({ description: `Applications are used to group entities in the user interface for ease of user access` })
export class Application_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Specify the CSS class information for the display icon for each application.`}) 
    @MaxLength(1000)
    Icon?: string;
        
    @Field(() => Boolean, {description: `If turned on, when a new user first uses the MJ Explorer app, the application records with this turned on will have this application included in their selected application list.`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Comma-delimited list of schema names where entities will be automatically added to the application when created in those schemas`}) 
    SchemaAutoAddNewEntities?: string;
        
    @Field(() => [ApplicationEntity_])
    ApplicationEntities_ApplicationIDArray: ApplicationEntity_[]; // Link to ApplicationEntities
    
    @Field(() => [UserApplication_])
    UserApplications_ApplicationIDArray: UserApplication_[]; // Link to UserApplications
    
    @Field(() => [ApplicationSetting_])
    ApplicationSettings_ApplicationIDArray: ApplicationSetting_[]; // Link to ApplicationSettings
    
    @Field(() => [Dashboard_])
    Dashboards_ApplicationIDArray: Dashboard_[]; // Link to Dashboards
    
    @Field(() => [DashboardUserPreference_])
    MJ_DashboardUserPreferences_ApplicationIDArray: DashboardUserPreference_[]; // Link to MJ_DashboardUserPreferences
    
}

//****************************************************************************
// INPUT TYPE for Applications
//****************************************************************************
@InputType()
export class CreateApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field({ nullable: true })
    SchemaAutoAddNewEntities: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Applications
//****************************************************************************
@InputType()
export class UpdateApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field({ nullable: true })
    SchemaAutoAddNewEntities?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Applications
//****************************************************************************
@ObjectType()
export class RunApplicationViewResult {
    @Field(() => [Application_])
    Results: Application_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Application_)
export class ApplicationResolver extends ResolverBase {
    @Query(() => RunApplicationViewResult)
    async RunApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunApplicationViewResult)
    async RunApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunApplicationViewResult)
    async RunApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Application_, { nullable: true })
    async Application(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Application_ | null> {
        this.CheckUserReadPermissions('Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Applications', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [Application_])
    async AllApplications(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplications]` + this.getRowLevelSecurityWhereClause(provider, 'Applications', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Applications', rows);
        return result;
    }
    
    @FieldResolver(() => [ApplicationEntity_])
    async ApplicationEntities_ApplicationIDArray(@Root() application_: Application_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [ApplicationID]='${application_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Application Entities', rows);
        return result;
    }
        
    @FieldResolver(() => [UserApplication_])
    async UserApplications_ApplicationIDArray(@Root() application_: Application_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [ApplicationID]='${application_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Applications', rows);
        return result;
    }
        
    @FieldResolver(() => [ApplicationSetting_])
    async ApplicationSettings_ApplicationIDArray(@Root() application_: Application_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationSettings] WHERE [ApplicationID]='${application_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Application Settings', rows);
        return result;
    }
        
    @FieldResolver(() => [Dashboard_])
    async Dashboards_ApplicationIDArray(@Root() application_: Application_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [ApplicationID]='${application_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboards', rows);
        return result;
    }
        
    @FieldResolver(() => [DashboardUserPreference_])
    async MJ_DashboardUserPreferences_ApplicationIDArray(@Root() application_: Application_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserPreferences] WHERE [ApplicationID]='${application_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows);
        return result;
    }
        
    @Mutation(() => Application_)
    async CreateApplication(
        @Arg('input', () => CreateApplicationInput) input: CreateApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Application_)
    async UpdateApplication(
        @Arg('input', () => UpdateApplicationInput) input: UpdateApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Application_)
    async DeleteApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Application Entities
//****************************************************************************
@ObjectType({ description: `List of entities within each application. An application can have any number of entities and an entity can be part of any number of applications.` })
export class ApplicationEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of this entity within the application, lower numbers appear first in navigation and menus.`}) 
    Sequence: number;
        
    @Field(() => Boolean, {description: `When set to 1, the entity will be included by default for a new user when they first access the application in question`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    EntityBaseTableCodeName?: string;
        
}

//****************************************************************************
// INPUT TYPE for Application Entities
//****************************************************************************
@InputType()
export class CreateApplicationEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Application Entities
//****************************************************************************
@InputType()
export class UpdateApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Application Entities
//****************************************************************************
@ObjectType()
export class RunApplicationEntityViewResult {
    @Field(() => [ApplicationEntity_])
    Results: ApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ApplicationEntity_)
export class ApplicationEntityResolver extends ResolverBase {
    @Query(() => RunApplicationEntityViewResult)
    async RunApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunApplicationEntityViewResult)
    async RunApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunApplicationEntityViewResult)
    async RunApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Application Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ApplicationEntity_, { nullable: true })
    async ApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ApplicationEntity_ | null> {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Application Entities', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ApplicationEntity_)
    async CreateApplicationEntity(
        @Arg('input', () => CreateApplicationEntityInput) input: CreateApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Application Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ApplicationEntity_)
    async UpdateApplicationEntity(
        @Arg('input', () => UpdateApplicationEntityInput) input: UpdateApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Application Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ApplicationEntity_)
    async DeleteApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Application Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Permissions
//****************************************************************************
@ObjectType({ description: `Security settings for each entity` })
export class EntityPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field(() => Boolean, {description: `Whether the role/user can create new records in this entity.`}) 
    CanCreate: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can read/view records in this entity.`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can update existing records in this entity.`}) 
    CanUpdate: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can delete records from this entity.`}) 
    CanDelete: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ReadRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CreateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UpdateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DeleteRLSFilterID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    RoleName: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    RoleSQLName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CreateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ReadRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    UpdateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DeleteRLSFilter?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Permissions
//****************************************************************************
@InputType()
export class CreateEntityPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Permissions
//****************************************************************************
@InputType()
export class UpdateEntityPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID?: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID?: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID?: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Permissions
//****************************************************************************
@ObjectType()
export class RunEntityPermissionViewResult {
    @Field(() => [EntityPermission_])
    Results: EntityPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityPermission_)
export class EntityPermissionResolver extends ResolverBase {
    @Query(() => RunEntityPermissionViewResult)
    async RunEntityPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityPermissionViewResult)
    async RunEntityPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityPermissionViewResult)
    async RunEntityPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityPermission_, { nullable: true })
    async EntityPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityPermission_ | null> {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Permissions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [EntityPermission_])
    async AllEntityPermissions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows);
        return result;
    }
    
    @Mutation(() => EntityPermission_)
    async CreateEntityPermission(
        @Arg('input', () => CreateEntityPermissionInput) input: CreateEntityPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityPermission_)
    async UpdateEntityPermission(
        @Arg('input', () => UpdateEntityPermissionInput) input: UpdateEntityPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityPermission_)
    async DeleteEntityPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Application Entities
//****************************************************************************
@ObjectType({ description: `Links users to specific entities within applications, managing entity-level personalization.` })
export class UserApplicationEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserApplicationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of this entity for the user within the application.`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for User Application Entities
//****************************************************************************
@InputType()
export class CreateUserApplicationEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for User Application Entities
//****************************************************************************
@InputType()
export class UpdateUserApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Application Entities
//****************************************************************************
@ObjectType()
export class RunUserApplicationEntityViewResult {
    @Field(() => [UserApplicationEntity_])
    Results: UserApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserApplicationEntity_)
export class UserApplicationEntityResolver extends ResolverBase {
    @Query(() => RunUserApplicationEntityViewResult)
    async RunUserApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserApplicationEntityViewResult)
    async RunUserApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserApplicationEntityViewResult)
    async RunUserApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Application Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserApplicationEntity_, { nullable: true })
    async UserApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserApplicationEntity_ | null> {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Application Entities', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => UserApplicationEntity_)
    async CreateUserApplicationEntity(
        @Arg('input', () => CreateUserApplicationEntityInput) input: CreateUserApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Application Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserApplicationEntity_)
    async UpdateUserApplicationEntity(
        @Arg('input', () => UpdateUserApplicationEntityInput) input: UpdateUserApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Application Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserApplicationEntity_)
    async DeleteUserApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Application Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Applications
//****************************************************************************
@ObjectType({ description: `Tracks which applications users have configured to display.` })
export class UserApplication_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field(() => Int, {description: `Display order of this application in the user's navigation.`}) 
    Sequence: number;
        
    @Field(() => Boolean, {description: `Whether this application is currently visible to the user.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field(() => [UserApplicationEntity_])
    UserApplicationEntities_UserApplicationIDArray: UserApplicationEntity_[]; // Link to UserApplicationEntities
    
}

//****************************************************************************
// INPUT TYPE for User Applications
//****************************************************************************
@InputType()
export class CreateUserApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for User Applications
//****************************************************************************
@InputType()
export class UpdateUserApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Applications
//****************************************************************************
@ObjectType()
export class RunUserApplicationViewResult {
    @Field(() => [UserApplication_])
    Results: UserApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserApplication_)
export class UserApplicationResolver extends ResolverBase {
    @Query(() => RunUserApplicationViewResult)
    async RunUserApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserApplicationViewResult)
    async RunUserApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserApplicationViewResult)
    async RunUserApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserApplication_, { nullable: true })
    async UserApplication(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserApplication_ | null> {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Applications', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [UserApplicationEntity_])
    async UserApplicationEntities_UserApplicationIDArray(@Root() userapplication_: UserApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [UserApplicationID]='${userapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Application Entities', rows);
        return result;
    }
        
    @Mutation(() => UserApplication_)
    async CreateUserApplication(
        @Arg('input', () => CreateUserApplicationInput) input: CreateUserApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserApplication_)
    async UpdateUserApplication(
        @Arg('input', () => UpdateUserApplicationInput) input: UpdateUserApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserApplication_)
    async DeleteUserApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Run API Logs
//****************************************************************************
@ObjectType({ description: `Logs detailed API calls and responses during integration runs, including request/response payloads, status codes, and timing information.` })
export class CompanyIntegrationRunAPILog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationRunID: string;
        
    @Field({description: `Timestamp when this API call was executed during the integration run.`}) 
    @MaxLength(8)
    ExecutedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether the API call completed successfully or encountered an error.`}) 
    IsSuccess: boolean;
        
    @Field({nullable: true, description: `HTTP method used for the API call (GET, POST, PUT, DELETE, PATCH).`}) 
    @MaxLength(24)
    RequestMethod?: string;
        
    @Field({nullable: true, description: `The complete URL that was called, including query parameters.`}) 
    URL?: string;
        
    @Field({nullable: true, description: `JSON-formatted request body or parameters sent with the API call.`}) 
    Parameters?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Company Integration Run API Logs
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationRunAPILogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod: string | null;

    @Field({ nullable: true })
    URL: string | null;

    @Field({ nullable: true })
    Parameters: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Run API Logs
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationRunAPILogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod?: string | null;

    @Field({ nullable: true })
    URL?: string | null;

    @Field({ nullable: true })
    Parameters?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Run API Logs
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationRunAPILogViewResult {
    @Field(() => [CompanyIntegrationRunAPILog_])
    Results: CompanyIntegrationRunAPILog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegrationRunAPILog_)
export class CompanyIntegrationRunAPILogResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationRunAPILogViewResult)
    async RunCompanyIntegrationRunAPILogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunAPILogViewResult)
    async RunCompanyIntegrationRunAPILogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunAPILogViewResult)
    async RunCompanyIntegrationRunAPILogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Run API Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CompanyIntegrationRunAPILog_, { nullable: true })
    async CompanyIntegrationRunAPILog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegrationRunAPILog_ | null> {
        this.CheckUserReadPermissions('Company Integration Run API Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunAPILogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integration Run API Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => CompanyIntegrationRunAPILog_)
    async CreateCompanyIntegrationRunAPILog(
        @Arg('input', () => CreateCompanyIntegrationRunAPILogInput) input: CreateCompanyIntegrationRunAPILogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Run API Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegrationRunAPILog_)
    async UpdateCompanyIntegrationRunAPILog(
        @Arg('input', () => UpdateCompanyIntegrationRunAPILogInput) input: UpdateCompanyIntegrationRunAPILogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Run API Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CompanyIntegrationRunAPILog_)
    async DeleteCompanyIntegrationRunAPILog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integration Run API Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Lists
//****************************************************************************
@ObjectType({ description: `Static lists are useful for controlling a set of data for a given entity. These can be used programatically for applications like logging and tracking long-running tasks and also by end users for tracking any particular list of records they want to directly control the set.` })
export class List_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true, description: `Identifier for this list in an external system, used for synchronization.`}) 
    @MaxLength(200)
    ExternalSystemRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CompanyIntegration?: string;
        
    @Field(() => [ListDetail_])
    ListDetails_ListIDArray: ListDetail_[]; // Link to ListDetails
    
    @Field(() => [DuplicateRun_])
    DuplicateRuns_SourceListIDArray: DuplicateRun_[]; // Link to DuplicateRuns
    
}

//****************************************************************************
// INPUT TYPE for Lists
//****************************************************************************
@InputType()
export class CreateListInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Lists
//****************************************************************************
@InputType()
export class UpdateListInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Lists
//****************************************************************************
@ObjectType()
export class RunListViewResult {
    @Field(() => [List_])
    Results: List_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(List_)
export class ListResolver extends ResolverBase {
    @Query(() => RunListViewResult)
    async RunListViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunListViewResult)
    async RunListViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunListViewResult)
    async RunListDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Lists';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => List_, { nullable: true })
    async List(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<List_ | null> {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Lists', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ListDetail_])
    async ListDetails_ListIDArray(@Root() list_: List_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListDetails] WHERE [ListID]='${list_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('List Details', rows);
        return result;
    }
        
    @FieldResolver(() => [DuplicateRun_])
    async DuplicateRuns_SourceListIDArray(@Root() list_: List_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [SourceListID]='${list_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows);
        return result;
    }
        
    @Mutation(() => List_)
    async CreateList(
        @Arg('input', () => CreateListInput) input: CreateListInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Lists', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => List_)
    async UpdateList(
        @Arg('input', () => UpdateListInput) input: UpdateListInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Lists', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => List_)
    async DeleteList(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Lists', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for List Details
//****************************************************************************
@ObjectType({ description: `Tracks the records within each list.` })
export class ListDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ListID: string;
        
    @Field({description: `The ID of the record included in this list.`}) 
    @MaxLength(890)
    RecordID: string;
        
    @Field(() => Int, {description: `Order of this record within the list, for maintaining user-defined sorting.`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Tracks the status of each individual list detail row to enable processing of various types and the use of the status column for filtering list detail rows within a list that are in a particular state.`}) 
    @MaxLength(60)
    Status: string;
        
    @Field({nullable: true, description: `Optional column that allows for tracking any additional data for each ListDetail row`}) 
    AdditionalData?: string;
        
    @Field() 
    @MaxLength(200)
    List: string;
        
}

//****************************************************************************
// INPUT TYPE for List Details
//****************************************************************************
@InputType()
export class CreateListDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for List Details
//****************************************************************************
@InputType()
export class UpdateListDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for List Details
//****************************************************************************
@ObjectType()
export class RunListDetailViewResult {
    @Field(() => [ListDetail_])
    Results: ListDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ListDetail_)
export class ListDetailResolver extends ResolverBase {
    @Query(() => RunListDetailViewResult)
    async RunListDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunListDetailViewResult)
    async RunListDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunListDetailViewResult)
    async RunListDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'List Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ListDetail_, { nullable: true })
    async ListDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ListDetail_ | null> {
        this.CheckUserReadPermissions('List Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('List Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ListDetail_)
    async CreateListDetail(
        @Arg('input', () => CreateListDetailInput) input: CreateListDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('List Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ListDetail_)
    async UpdateListDetail(
        @Arg('input', () => UpdateListDetailInput) input: UpdateListDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('List Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ListDetail_)
    async DeleteListDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('List Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Runs
//****************************************************************************
@ObjectType({ description: `User Views can be logged when run to capture the date and user that ran the view as well as the output results.` })
export class UserViewRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserViewID: string;
        
    @Field({description: `Timestamp when the view was executed.`}) 
    @MaxLength(8)
    RunAt: Date;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    UserView: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [UserViewRunDetail_])
    UserViewRunDetails_UserViewRunIDArray: UserViewRunDetail_[]; // Link to UserViewRunDetails
    
}

//****************************************************************************
// INPUT TYPE for User View Runs
//****************************************************************************
@InputType()
export class CreateUserViewRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Runs
//****************************************************************************
@InputType()
export class UpdateUserViewRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Runs
//****************************************************************************
@ObjectType()
export class RunUserViewRunViewResult {
    @Field(() => [UserViewRun_])
    Results: UserViewRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserViewRun_)
export class UserViewRunResolver extends ResolverBase {
    @Query(() => RunUserViewRunViewResult)
    async RunUserViewRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewRunViewResult)
    async RunUserViewRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewRunViewResult)
    async RunUserViewRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserViewRun_, { nullable: true })
    async UserViewRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserViewRun_ | null> {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User View Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [UserViewRunDetail_])
    async UserViewRunDetails_UserViewRunIDArray(@Root() userviewrun_: UserViewRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRunDetails] WHERE [UserViewRunID]='${userviewrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Run Details', rows);
        return result;
    }
        
    @Mutation(() => UserViewRun_)
    async CreateUserViewRun(
        @Arg('input', () => CreateUserViewRunInput) input: CreateUserViewRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserViewRun_)
    async UpdateUserViewRun(
        @Arg('input', () => UpdateUserViewRunInput) input: UpdateUserViewRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserViewRun_)
    async DeleteUserViewRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User View Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Run Details
//****************************************************************************
@ObjectType({ description: `Tracks the set of records that were included in each run of a given user view.` })
export class UserViewRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserViewRunID: string;
        
    @Field({description: `Field RecordID for entity User View Run Details.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    UserViewID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for User View Run Details
//****************************************************************************
@InputType()
export class CreateUserViewRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Run Details
//****************************************************************************
@InputType()
export class UpdateUserViewRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Run Details
//****************************************************************************
@ObjectType()
export class RunUserViewRunDetailViewResult {
    @Field(() => [UserViewRunDetail_])
    Results: UserViewRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserViewRunDetail_)
export class UserViewRunDetailResolver extends ResolverBase {
    @Query(() => RunUserViewRunDetailViewResult)
    async RunUserViewRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewRunDetailViewResult)
    async RunUserViewRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewRunDetailViewResult)
    async RunUserViewRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserViewRunDetail_, { nullable: true })
    async UserViewRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserViewRunDetail_ | null> {
        this.CheckUserReadPermissions('User View Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User View Run Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => UserViewRunDetail_)
    async CreateUserViewRunDetail(
        @Arg('input', () => CreateUserViewRunDetailInput) input: CreateUserViewRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserViewRunDetail_)
    async UpdateUserViewRunDetail(
        @Arg('input', () => UpdateUserViewRunDetailInput) input: UpdateUserViewRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserViewRunDetail_)
    async DeleteUserViewRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User View Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflow Runs
//****************************************************************************
@ObjectType({ description: `Tracks execution instances of workflows including status, timing, context data, and detailed step-by-step results.` })
export class WorkflowRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    WorkflowID: string;
        
    @Field({description: `Field ExternalSystemRecordID for entity Workflow Runs.`}) 
    @MaxLength(1000)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `JSON-formatted detailed results from the workflow execution, including outputs from each step and any error information.`}) 
    Results?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Workflow: string;
        
    @Field() 
    @MaxLength(200)
    WorkflowEngineName: string;
        
}

//****************************************************************************
// INPUT TYPE for Workflow Runs
//****************************************************************************
@InputType()
export class CreateWorkflowRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    WorkflowID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Results: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workflow Runs
//****************************************************************************
@InputType()
export class UpdateWorkflowRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    WorkflowID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Results?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflow Runs
//****************************************************************************
@ObjectType()
export class RunWorkflowRunViewResult {
    @Field(() => [WorkflowRun_])
    Results: WorkflowRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(WorkflowRun_)
export class WorkflowRunResolver extends ResolverBase {
    @Query(() => RunWorkflowRunViewResult)
    async RunWorkflowRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkflowRunViewResult)
    async RunWorkflowRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkflowRunViewResult)
    async RunWorkflowRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflow Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => WorkflowRun_, { nullable: true })
    async WorkflowRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<WorkflowRun_ | null> {
        this.CheckUserReadPermissions('Workflow Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workflow Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => WorkflowRun_)
    async CreateWorkflowRun(
        @Arg('input', () => CreateWorkflowRunInput) input: CreateWorkflowRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workflow Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => WorkflowRun_)
    async UpdateWorkflowRun(
        @Arg('input', () => UpdateWorkflowRunInput) input: UpdateWorkflowRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflow Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => WorkflowRun_)
    async DeleteWorkflowRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workflow Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflows
//****************************************************************************
@ObjectType({ description: `Defines automated workflows with steps, conditions, and actions for orchestrating complex business processes.` })
export class Workflow_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    WorkflowEngineID: string;
        
    @Field({description: `The unique identifier of this workflow in an external system, used for synchronization with external workflow engines.`}) 
    @MaxLength(200)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean, {description: `If set to 1, the workflow will be run automatically on the interval specified by the AutoRunIntervalType and AutoRunInterval fields`}) 
    AutoRunEnabled: boolean;
        
    @Field({nullable: true, description: `Minutes, Hours, Days, Weeks, Months, Years`}) 
    @MaxLength(40)
    AutoRunIntervalUnits?: string;
        
    @Field(() => Int, {nullable: true, description: `The interval, denominated in the units specified in the AutoRunIntervalUnits column, between auto runs of this workflow.`}) 
    AutoRunInterval?: number;
        
    @Field({nullable: true, description: `If specified, this subclass key, via the ClassFactory, will be instantiated, to execute this workflow. If not specified the WorkflowBase class will be used by default.`}) 
    @MaxLength(400)
    SubclassName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true}) 
    AutoRunIntervalMinutes?: number;
        
    @Field(() => [Report_])
    Reports_OutputWorkflowIDArray: Report_[]; // Link to Reports
    
    @Field(() => [WorkflowRun_])
    WorkflowRuns_WorkflowNameArray: WorkflowRun_[]; // Link to WorkflowRuns
    
}

//****************************************************************************
// INPUT TYPE for Workflows
//****************************************************************************
@InputType()
export class CreateWorkflowInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    WorkflowEngineID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    AutoRunEnabled?: boolean;

    @Field({ nullable: true })
    AutoRunIntervalUnits: string | null;

    @Field(() => Int, { nullable: true })
    AutoRunInterval: number | null;

    @Field({ nullable: true })
    SubclassName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workflows
//****************************************************************************
@InputType()
export class UpdateWorkflowInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkflowEngineID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    AutoRunEnabled?: boolean;

    @Field({ nullable: true })
    AutoRunIntervalUnits?: string | null;

    @Field(() => Int, { nullable: true })
    AutoRunInterval?: number | null;

    @Field({ nullable: true })
    SubclassName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflows
//****************************************************************************
@ObjectType()
export class RunWorkflowViewResult {
    @Field(() => [Workflow_])
    Results: Workflow_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Workflow_)
export class WorkflowResolver extends ResolverBase {
    @Query(() => RunWorkflowViewResult)
    async RunWorkflowViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkflowViewResult)
    async RunWorkflowViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkflowViewResult)
    async RunWorkflowDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflows';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Workflow_, { nullable: true })
    async Workflow(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Workflow_ | null> {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workflows', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_OutputWorkflowIDArray(@Root() workflow_: Workflow_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputWorkflowID]='${workflow_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [WorkflowRun_])
    async WorkflowRuns_WorkflowNameArray(@Root() workflow_: Workflow_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflow Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowRuns] WHERE [WorkflowName]='${workflow_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workflow Runs', rows);
        return result;
    }
        
    @Mutation(() => Workflow_)
    async CreateWorkflow(
        @Arg('input', () => CreateWorkflowInput) input: CreateWorkflowInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workflows', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Workflow_)
    async UpdateWorkflow(
        @Arg('input', () => UpdateWorkflowInput) input: UpdateWorkflowInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflows', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Workflow_)
    async DeleteWorkflow(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workflows', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflow Engines
//****************************************************************************
@ObjectType({ description: `Registers available workflow execution engines with their capabilities, configuration, and supported workflow types.` })
export class WorkflowEngine_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Import path for the workflow engine driver.`}) 
    @MaxLength(1000)
    DriverPath: string;
        
    @Field({description: `Class name implementing the workflow engine interface.`}) 
    @MaxLength(200)
    DriverClass: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Workflow_])
    Workflows_WorkflowEngineNameArray: Workflow_[]; // Link to Workflows
    
}

//****************************************************************************
// INPUT TYPE for Workflow Engines
//****************************************************************************
@InputType()
export class CreateWorkflowEngineInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverPath?: string;

    @Field({ nullable: true })
    DriverClass?: string;
}
    

//****************************************************************************
// INPUT TYPE for Workflow Engines
//****************************************************************************
@InputType()
export class UpdateWorkflowEngineInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverPath?: string;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflow Engines
//****************************************************************************
@ObjectType()
export class RunWorkflowEngineViewResult {
    @Field(() => [WorkflowEngine_])
    Results: WorkflowEngine_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(WorkflowEngine_)
export class WorkflowEngineResolver extends ResolverBase {
    @Query(() => RunWorkflowEngineViewResult)
    async RunWorkflowEngineViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkflowEngineViewResult)
    async RunWorkflowEngineViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkflowEngineViewResult)
    async RunWorkflowEngineDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflow Engines';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => WorkflowEngine_, { nullable: true })
    async WorkflowEngine(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<WorkflowEngine_ | null> {
        this.CheckUserReadPermissions('Workflow Engines', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowEngines] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Engines', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workflow Engines', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Workflow_])
    async Workflows_WorkflowEngineNameArray(@Root() workflowengine_: WorkflowEngine_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [WorkflowEngineName]='${workflowengine_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workflows', rows);
        return result;
    }
        
    @Mutation(() => WorkflowEngine_)
    async CreateWorkflowEngine(
        @Arg('input', () => CreateWorkflowEngineInput) input: CreateWorkflowEngineInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workflow Engines', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => WorkflowEngine_)
    async UpdateWorkflowEngine(
        @Arg('input', () => UpdateWorkflowEngineInput) input: UpdateWorkflowEngineInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflow Engines', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => WorkflowEngine_)
    async DeleteWorkflowEngine(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workflow Engines', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Changes
//****************************************************************************
@ObjectType({ description: `For entities that have TrackRecordChanges=1, Record Changes will store the history of all changes made within the system. For integrations you can directly add values here if you have inbound signals indicating records were changed in a source system. This entity only automatically captures Record Changes if they were made within the system.` })
export class RecordChange_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `Field RecordID for entity Record Changes.`}) 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Create, Update, or Delete`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({description: `Internal or External`}) 
    @MaxLength(40)
    Source: string;
        
    @Field({description: `The date/time that the change occured.`}) 
    @MaxLength(10)
    ChangedAt: Date;
        
    @Field({description: `JSON structure that describes what was changed in a structured format.`}) 
    ChangesJSON: string;
        
    @Field({description: `A generated, human-readable description of what was changed.`}) 
    ChangesDescription: string;
        
    @Field({description: `A complete snapshot of the record AFTER the change was applied in a JSON format that can be parsed.`}) 
    FullRecordJSON: string;
        
    @Field({description: `For internal record changes generated within MJ, the status is immediately Complete. For external changes that are detected, the workflow starts off as Pending, then In Progress and finally either Complete or Error`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true, description: `Field ErrorLog for entity Record Changes.`}) 
    ErrorLog?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ReplayRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    IntegrationID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field({description: `Field CreatedAt for entity Record Changes.`}) 
    @MaxLength(10)
    CreatedAt: Date;
        
    @Field({description: `Field UpdatedAt for entity Record Changes.`}) 
    @MaxLength(10)
    UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Integration?: string;
        
}

//****************************************************************************
// INPUT TYPE for Record Changes
//****************************************************************************
@InputType()
export class CreateRecordChangeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ReplayRunID: string | null;

    @Field({ nullable: true })
    IntegrationID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Changes
//****************************************************************************
@InputType()
export class UpdateRecordChangeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ReplayRunID?: string | null;

    @Field({ nullable: true })
    IntegrationID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Changes
//****************************************************************************
@ObjectType()
export class RunRecordChangeViewResult {
    @Field(() => [RecordChange_])
    Results: RecordChange_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecordChange_)
export class RecordChangeResolver extends ResolverBase {
    @Query(() => RunRecordChangeViewResult)
    async RunRecordChangeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecordChangeViewResult)
    async RunRecordChangeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecordChangeViewResult)
    async RunRecordChangeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Changes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => RecordChange_, { nullable: true })
    async RecordChange(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecordChange_ | null> {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Record Changes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => RecordChange_)
    async CreateRecordChange(
        @Arg('input', () => CreateRecordChangeInput) input: CreateRecordChangeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Changes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => RecordChange_)
    async UpdateRecordChange(
        @Arg('input', () => UpdateRecordChangeInput) input: UpdateRecordChangeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Changes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => RecordChange_)
    async DeleteRecordChange(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Record Changes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Roles
//****************************************************************************
@ObjectType({ description: `Associates users with roles in the system, managing role-based access control and permission inheritance.` })
export class UserRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for User Roles
//****************************************************************************
@InputType()
export class CreateUserRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User Roles
//****************************************************************************
@InputType()
export class UpdateUserRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Roles
//****************************************************************************
@ObjectType()
export class RunUserRoleViewResult {
    @Field(() => [UserRole_])
    Results: UserRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserRole_)
export class UserRoleResolver extends ResolverBase {
    @Query(() => RunUserRoleViewResult)
    async RunUserRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserRoleViewResult)
    async RunUserRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserRoleViewResult)
    async RunUserRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserRole_, { nullable: true })
    async UserRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserRole_ | null> {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Roles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [UserRole_])
    async AllUserRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles]` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', rows);
        return result;
    }
    
    @Mutation(() => UserRole_)
    async CreateUserRole(
        @Arg('input', () => CreateUserRoleInput) input: CreateUserRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserRole_)
    async UpdateUserRole(
        @Arg('input', () => UpdateUserRoleInput) input: UpdateUserRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserRole_)
    async DeleteUserRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Row Level Security Filters
//****************************************************************************
@ObjectType({ description: `Defines data access rules that filter records based on user context, implementing fine-grained security at the row level.` })
export class RowLevelSecurityFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `SQL WHERE clause template that filters records based on user context variables.`}) 
    FilterText?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityPermission_])
    EntityPermissions_ReadRLSFilterIDArray: EntityPermission_[]; // Link to EntityPermissions
    
}

//****************************************************************************
// INPUT TYPE for Row Level Security Filters
//****************************************************************************
@InputType()
export class CreateRowLevelSecurityFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    FilterText: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Row Level Security Filters
//****************************************************************************
@InputType()
export class UpdateRowLevelSecurityFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    FilterText?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Row Level Security Filters
//****************************************************************************
@ObjectType()
export class RunRowLevelSecurityFilterViewResult {
    @Field(() => [RowLevelSecurityFilter_])
    Results: RowLevelSecurityFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RowLevelSecurityFilter_)
export class RowLevelSecurityFilterResolver extends ResolverBase {
    @Query(() => RunRowLevelSecurityFilterViewResult)
    async RunRowLevelSecurityFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRowLevelSecurityFilterViewResult)
    async RunRowLevelSecurityFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRowLevelSecurityFilterViewResult)
    async RunRowLevelSecurityFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Row Level Security Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => RowLevelSecurityFilter_, { nullable: true })
    async RowLevelSecurityFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RowLevelSecurityFilter_ | null> {
        this.CheckUserReadPermissions('Row Level Security Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRowLevelSecurityFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Row Level Security Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Row Level Security Filters', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [RowLevelSecurityFilter_])
    async AllRowLevelSecurityFilters(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Row Level Security Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRowLevelSecurityFilters]` + this.getRowLevelSecurityWhereClause(provider, 'Row Level Security Filters', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Row Level Security Filters', rows);
        return result;
    }
    
    @FieldResolver(() => [EntityPermission_])
    async EntityPermissions_ReadRLSFilterIDArray(@Root() rowlevelsecurityfilter_: RowLevelSecurityFilter_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [ReadRLSFilterID]='${rowlevelsecurityfilter_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows);
        return result;
    }
        
    @Mutation(() => RowLevelSecurityFilter_)
    async CreateRowLevelSecurityFilter(
        @Arg('input', () => CreateRowLevelSecurityFilterInput) input: CreateRowLevelSecurityFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Row Level Security Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => RowLevelSecurityFilter_)
    async UpdateRowLevelSecurityFilter(
        @Arg('input', () => UpdateRowLevelSecurityFilterInput) input: UpdateRowLevelSecurityFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Row Level Security Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => RowLevelSecurityFilter_)
    async DeleteRowLevelSecurityFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Row Level Security Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Audit Logs
//****************************************************************************
@ObjectType({ description: `Tracks system events and user actions for security, compliance, and debugging purposes, providing a complete audit trail. Any application can write entries to this entity.` })
export class AuditLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    AuditLogTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `JSON-formatted additional context about the audited event, including before/after values, parameters, or other relevant data.`}) 
    Details?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `The primary key value of the record that was affected by this audited action, enabling direct lookup of the modified data.`}) 
    @MaxLength(900)
    RecordID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(100)
    AuditLogType: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Authorization?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Audit Logs
//****************************************************************************
@InputType()
export class CreateAuditLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Details: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Audit Logs
//****************************************************************************
@InputType()
export class UpdateAuditLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Audit Logs
//****************************************************************************
@ObjectType()
export class RunAuditLogViewResult {
    @Field(() => [AuditLog_])
    Results: AuditLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AuditLog_)
export class AuditLogResolver extends ResolverBase {
    @Query(() => RunAuditLogViewResult)
    async RunAuditLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAuditLogViewResult)
    async RunAuditLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAuditLogViewResult)
    async RunAuditLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Audit Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AuditLog_, { nullable: true })
    async AuditLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AuditLog_ | null> {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Audit Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AuditLog_)
    async CreateAuditLog(
        @Arg('input', () => CreateAuditLogInput) input: CreateAuditLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Audit Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AuditLog_)
    async UpdateAuditLog(
        @Arg('input', () => UpdateAuditLogInput) input: UpdateAuditLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Audit Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AuditLog_)
    async DeleteAuditLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Audit Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Authorizations
//****************************************************************************
@ObjectType({ description: `Stores the fundamental permissions and access rights that can be granted to users and roles throughout the system.` })
export class Authorization_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field(() => Boolean, {description: `Indicates whether this authorization is currently active and can be granted to users or roles.`}) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, Audit Log records are created whenever this authorization is invoked for a user`}) 
    UseAuditLog: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field(() => [AuthorizationRole_])
    AuthorizationRoles_AuthorizationIDArray: AuthorizationRole_[]; // Link to AuthorizationRoles
    
    @Field(() => [Authorization_])
    Authorizations_ParentIDArray: Authorization_[]; // Link to Authorizations
    
    @Field(() => [AuditLogType_])
    AuditLogTypes_AuthorizationNameArray: AuditLogType_[]; // Link to AuditLogTypes
    
    @Field(() => [AuditLog_])
    AuditLogs_AuthorizationNameArray: AuditLog_[]; // Link to AuditLogs
    
    @Field(() => [ActionAuthorization_])
    ActionAuthorizations_AuthorizationIDArray: ActionAuthorization_[]; // Link to ActionAuthorizations
    
}

//****************************************************************************
// INPUT TYPE for Authorizations
//****************************************************************************
@InputType()
export class CreateAuthorizationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    UseAuditLog?: boolean;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Authorizations
//****************************************************************************
@InputType()
export class UpdateAuthorizationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    UseAuditLog?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Authorizations
//****************************************************************************
@ObjectType()
export class RunAuthorizationViewResult {
    @Field(() => [Authorization_])
    Results: Authorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Authorization_)
export class AuthorizationResolver extends ResolverBase {
    @Query(() => RunAuthorizationViewResult)
    async RunAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAuthorizationViewResult)
    async RunAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAuthorizationViewResult)
    async RunAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Authorizations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Authorization_, { nullable: true })
    async Authorization(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Authorization_ | null> {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Authorizations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [Authorization_])
    async AllAuthorizations(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations]` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorizations', rows);
        return result;
    }
    
    @FieldResolver(() => [AuthorizationRole_])
    async AuthorizationRoles_AuthorizationIDArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [AuthorizationID]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows);
        return result;
    }
        
    @FieldResolver(() => [Authorization_])
    async Authorizations_ParentIDArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations] WHERE [ParentID]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorizations', rows);
        return result;
    }
        
    @FieldResolver(() => [AuditLogType_])
    async AuditLogTypes_AuthorizationNameArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [AuthorizationName]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows);
        return result;
    }
        
    @FieldResolver(() => [AuditLog_])
    async AuditLogs_AuthorizationNameArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [AuthorizationName]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [ActionAuthorization_])
    async ActionAuthorizations_AuthorizationIDArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [AuthorizationID]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Authorizations', rows);
        return result;
    }
        
    @Mutation(() => Authorization_)
    async CreateAuthorization(
        @Arg('input', () => CreateAuthorizationInput) input: CreateAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Authorizations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Authorization_)
    async UpdateAuthorization(
        @Arg('input', () => UpdateAuthorizationInput) input: UpdateAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Authorizations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Authorization_)
    async DeleteAuthorization(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Authorizations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Authorization Roles
//****************************************************************************
@ObjectType({ description: `Links authorizations to roles, defining which permissions are granted to users assigned to specific roles in the system.` })
export class AuthorizationRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AuthorizationID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field({description: `Specifies whether this authorization is granted to ('grant') or explicitly denied ('deny') for the role.`}) 
    @MaxLength(20)
    Type: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Authorization: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Authorization Roles
//****************************************************************************
@InputType()
export class CreateAuthorizationRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field({ nullable: true })
    Type?: string;
}
    

//****************************************************************************
// INPUT TYPE for Authorization Roles
//****************************************************************************
@InputType()
export class UpdateAuthorizationRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Authorization Roles
//****************************************************************************
@ObjectType()
export class RunAuthorizationRoleViewResult {
    @Field(() => [AuthorizationRole_])
    Results: AuthorizationRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AuthorizationRole_)
export class AuthorizationRoleResolver extends ResolverBase {
    @Query(() => RunAuthorizationRoleViewResult)
    async RunAuthorizationRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAuthorizationRoleViewResult)
    async RunAuthorizationRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAuthorizationRoleViewResult)
    async RunAuthorizationRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Authorization Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AuthorizationRole_, { nullable: true })
    async AuthorizationRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AuthorizationRole_ | null> {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Authorization Roles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [AuthorizationRole_])
    async AllAuthorizationRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles]` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows);
        return result;
    }
    
    @Mutation(() => AuthorizationRole_)
    async CreateAuthorizationRole(
        @Arg('input', () => CreateAuthorizationRoleInput) input: CreateAuthorizationRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Authorization Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AuthorizationRole_)
    async UpdateAuthorizationRole(
        @Arg('input', () => UpdateAuthorizationRoleInput) input: UpdateAuthorizationRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Authorization Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AuthorizationRole_)
    async DeleteAuthorizationRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Authorization Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Audit Log Types
//****************************************************************************
@ObjectType({ description: `Defines the types of events that can be recorded in the audit log, enabling categorization and filtering of system activities.` })
export class AuditLogType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Authorization?: string;
        
    @Field(() => [AuditLog_])
    AuditLogs_AuditLogTypeNameArray: AuditLog_[]; // Link to AuditLogs
    
    @Field(() => [AuditLogType_])
    AuditLogTypes_ParentIDArray: AuditLogType_[]; // Link to AuditLogTypes
    
}

//****************************************************************************
// INPUT TYPE for Audit Log Types
//****************************************************************************
@InputType()
export class CreateAuditLogTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    AuthorizationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Audit Log Types
//****************************************************************************
@InputType()
export class UpdateAuditLogTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    AuthorizationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Audit Log Types
//****************************************************************************
@ObjectType()
export class RunAuditLogTypeViewResult {
    @Field(() => [AuditLogType_])
    Results: AuditLogType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AuditLogType_)
export class AuditLogTypeResolver extends ResolverBase {
    @Query(() => RunAuditLogTypeViewResult)
    async RunAuditLogTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAuditLogTypeViewResult)
    async RunAuditLogTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAuditLogTypeViewResult)
    async RunAuditLogTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Audit Log Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AuditLogType_, { nullable: true })
    async AuditLogType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AuditLogType_ | null> {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Audit Log Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [AuditLogType_])
    async AllAuditLogTypes(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes]` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows);
        return result;
    }
    
    @FieldResolver(() => [AuditLog_])
    async AuditLogs_AuditLogTypeNameArray(@Root() auditlogtype_: AuditLogType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [AuditLogTypeName]='${auditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [AuditLogType_])
    async AuditLogTypes_ParentIDArray(@Root() auditlogtype_: AuditLogType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [ParentID]='${auditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows);
        return result;
    }
        
    @Mutation(() => AuditLogType_)
    async CreateAuditLogType(
        @Arg('input', () => CreateAuditLogTypeInput) input: CreateAuditLogTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Audit Log Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AuditLogType_)
    async UpdateAuditLogType(
        @Arg('input', () => UpdateAuditLogTypeInput) input: UpdateAuditLogTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Audit Log Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AuditLogType_)
    async DeleteAuditLogType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Audit Log Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Field Values
//****************************************************************************
@ObjectType({ description: `Defines allowed values for entity fields with value lists, supporting dropdowns, validations, and data integrity constraints. MJ CodeGen automatically maintains this for columns that have CHECK constraints with IN lists such as "Status IN (A, B, C)"` })
export class EntityFieldValue_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityFieldID: string;
        
    @Field(() => Int, {description: `Display order for this value in dropdown lists and UI elements.`}) 
    Sequence: number;
        
    @Field({description: `The actual value stored in the database for this option.`}) 
    @MaxLength(510)
    Value: string;
        
    @Field({nullable: true, description: `Optional code identifier for this value, useful for programmatic access. If not specified, same as Value`}) 
    @MaxLength(100)
    Code?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    EntityField: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Field Values
//****************************************************************************
@InputType()
export class CreateEntityFieldValueInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityFieldID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Field Values
//****************************************************************************
@InputType()
export class UpdateEntityFieldValueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityFieldID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Field Values
//****************************************************************************
@ObjectType()
export class RunEntityFieldValueViewResult {
    @Field(() => [EntityFieldValue_])
    Results: EntityFieldValue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityFieldValue_)
export class EntityFieldValueResolver extends ResolverBase {
    @Query(() => RunEntityFieldValueViewResult)
    async RunEntityFieldValueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityFieldValueViewResult)
    async RunEntityFieldValueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityFieldValueViewResult)
    async RunEntityFieldValueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Field Values';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityFieldValue_, { nullable: true })
    async EntityFieldValue(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityFieldValue_ | null> {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Field Values', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [EntityFieldValue_])
    async AllEntityFieldValues(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Field Values', rows);
        return result;
    }
    
    @Mutation(() => EntityFieldValue_)
    async CreateEntityFieldValue(
        @Arg('input', () => CreateEntityFieldValueInput) input: CreateEntityFieldValueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Field Values', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityFieldValue_)
    async UpdateEntityFieldValue(
        @Arg('input', () => UpdateEntityFieldValueInput) input: UpdateEntityFieldValueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Field Values', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityFieldValue_)
    async DeleteEntityFieldValue(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Field Values', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Models
//****************************************************************************
@ObjectType({ description: `Catalog of all AI Models configured in the system` })
export class AIModel_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    AIModelTypeID: string;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the power of the AI model. Default is 0 and should be non-negative.`}) 
    PowerRank?: number;
        
    @Field(() => Boolean, {description: `Controls whether this AI model is available for use in the system.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the speed of the AI model. Default is 0 and should be non-negative.`}) 
    SpeedRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the cost of the AI model. Default is 0 and should be non-negative.`}) 
    CostRank?: number;
        
    @Field({nullable: true, description: `This column stores unstructured text notes that provide insights into what the model is particularly good at and areas where it may not perform as well. These notes can be used by a human or an AI to determine if the model is a good fit for various purposes.`}) 
    ModelSelectionInsights?: string;
        
    @Field() 
    @MaxLength(100)
    AIModelType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DriverImportPath?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    APIName?: string;
        
    @Field(() => Int, {nullable: true}) 
    InputTokenLimit?: number;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SupportedResponseFormats?: string;
        
    @Field(() => Boolean, {nullable: true}) 
    SupportsEffortLevel?: boolean;
        
    @Field(() => [AIAction_])
    AIActions_DefaultModelIDArray: AIAction_[]; // Link to AIActions
    
    @Field(() => [AIModelAction_])
    AIModelActions_AIModelIDArray: AIModelAction_[]; // Link to AIModelActions
    
    @Field(() => [VectorIndex_])
    VectorIndexes_EmbeddingModelIDArray: VectorIndex_[]; // Link to VectorIndexes
    
    @Field(() => [EntityDocument_])
    EntityDocuments_AIModelIDArray: EntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [EntityAIAction_])
    EntityAIActions_AIModelIDArray: EntityAIAction_[]; // Link to EntityAIActions
    
    @Field(() => [ContentType_])
    ContentTypes_AIModelIDArray: ContentType_[]; // Link to ContentTypes
    
    @Field(() => [AIResultCache_])
    AIResultCache_AIModelIDArray: AIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [AIAgentModel_])
    AIAgentModels_ModelIDArray: AIAgentModel_[]; // Link to AIAgentModels
    
    @Field(() => [AIModelVendor_])
    MJ_AIModelVendors_ModelIDArray: AIModelVendor_[]; // Link to MJ_AIModelVendors
    
    @Field(() => [GeneratedCode_])
    GeneratedCodes_GeneratedByModelIDArray: GeneratedCode_[]; // Link to GeneratedCodes
    
    @Field(() => [AIModelCost_])
    MJ_AIModelCosts_ModelIDArray: AIModelCost_[]; // Link to MJ_AIModelCosts
    
    @Field(() => [AIPromptModel_])
    MJ_AIPromptModels_ModelIDArray: AIPromptModel_[]; // Link to MJ_AIPromptModels
    
    @Field(() => [AIPromptRun_])
    MJ_AIPromptRuns_ModelIDArray: AIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [AIAgentRun_])
    MJ_AIAgentRuns_OverrideModelIDArray: AIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [Query_])
    Queries_EmbeddingModelIDArray: Query_[]; // Link to Queries
    
}

//****************************************************************************
// INPUT TYPE for AI Models
//****************************************************************************
@InputType()
export class CreateAIModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Models
//****************************************************************************
@InputType()
export class UpdateAIModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Models
//****************************************************************************
@ObjectType()
export class RunAIModelViewResult {
    @Field(() => [AIModel_])
    Results: AIModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModel_)
export class AIModelResolver extends ResolverBase {
    @Query(() => RunAIModelViewResult)
    async RunAIModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelViewResult)
    async RunAIModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelViewResult)
    async RunAIModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIModel_, { nullable: true })
    async AIModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModel_ | null> {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Models', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [AIModel_])
    async AllAIModels(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels]` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Models', rows);
        return result;
    }
    
    @FieldResolver(() => [AIAction_])
    async AIActions_DefaultModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions] WHERE [DefaultModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [AIModelAction_])
    async AIModelActions_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [VectorIndex_])
    async VectorIndexes_EmbeddingModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [EmbeddingModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Vector Indexes', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityAIAction_])
    async EntityAIActions_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [ContentType_])
    async ContentTypes_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypes] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Types', rows);
        return result;
    }
        
    @FieldResolver(() => [AIResultCache_])
    async AIResultCache_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentModel_])
    async AIAgentModels_ModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [ModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Models', rows);
        return result;
    }
        
    @FieldResolver(() => [AIModelVendor_])
    async MJ_AIModelVendors_ModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelVendors] WHERE [ModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows);
        return result;
    }
        
    @FieldResolver(() => [GeneratedCode_])
    async GeneratedCodes_GeneratedByModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [GeneratedByModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows);
        return result;
    }
        
    @FieldResolver(() => [AIModelCost_])
    async MJ_AIModelCosts_ModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [ModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptModel_])
    async MJ_AIPromptModels_ModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [ModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPromptRun_])
    async MJ_AIPromptRuns_ModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [ModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRun_])
    async MJ_AIAgentRuns_OverrideModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [OverrideModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [Query_])
    async Queries_EmbeddingModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [EmbeddingModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Queries', rows);
        return result;
    }
        
    @Mutation(() => AIModel_)
    async CreateAIModel(
        @Arg('input', () => CreateAIModelInput) input: CreateAIModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIModel_)
    async UpdateAIModel(
        @Arg('input', () => UpdateAIModelInput) input: UpdateAIModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIModel_)
    async DeleteAIModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Actions
//****************************************************************************
@ObjectType({ description: `List of all actions that are possible across all AI Models` })
export class AIAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `The standard prompt template used when invoking this AI action, can include placeholders for dynamic values.`}) 
    DefaultPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DefaultModelID?: string;
        
    @Field(() => Boolean, {description: `Controls whether this AI action is currently available for use across the system.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DefaultModel?: string;
        
    @Field(() => [AIModelAction_])
    AIModelActions_AIActionIDArray: AIModelAction_[]; // Link to AIModelActions
    
    @Field(() => [EntityAIAction_])
    EntityAIActions_AIActionIDArray: EntityAIAction_[]; // Link to EntityAIActions
    
}

//****************************************************************************
// INPUT TYPE for AI Actions
//****************************************************************************
@InputType()
export class CreateAIActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultPrompt: string | null;

    @Field({ nullable: true })
    DefaultModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for AI Actions
//****************************************************************************
@InputType()
export class UpdateAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultPrompt?: string | null;

    @Field({ nullable: true })
    DefaultModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Actions
//****************************************************************************
@ObjectType()
export class RunAIActionViewResult {
    @Field(() => [AIAction_])
    Results: AIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAction_)
export class AIActionResolver extends ResolverBase {
    @Query(() => RunAIActionViewResult)
    async RunAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIActionViewResult)
    async RunAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIActionViewResult)
    async RunAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAction_, { nullable: true })
    async AIAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAction_ | null> {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [AIAction_])
    async AllAIActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions]` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Actions', rows);
        return result;
    }
    
    @FieldResolver(() => [AIModelAction_])
    async AIModelActions_AIActionIDArray(@Root() aiaction_: AIAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [AIActionID]='${aiaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityAIAction_])
    async EntityAIActions_AIActionIDArray(@Root() aiaction_: AIAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [AIActionID]='${aiaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows);
        return result;
    }
        
    @Mutation(() => AIAction_)
    async CreateAIAction(
        @Arg('input', () => CreateAIActionInput) input: CreateAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAction_)
    async UpdateAIAction(
        @Arg('input', () => UpdateAIActionInput) input: UpdateAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAction_)
    async DeleteAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Model Actions
//****************************************************************************
@ObjectType({ description: `Tracks the actions supported by each AI Model` })
export class AIModelAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field() 
    @MaxLength(16)
    AIActionID: string;
        
    @Field(() => Boolean, {description: `Determines if this specific action is currently enabled for the associated AI model.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field() 
    @MaxLength(100)
    AIAction: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Model Actions
//****************************************************************************
@InputType()
export class CreateAIModelActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for AI Model Actions
//****************************************************************************
@InputType()
export class UpdateAIModelActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Model Actions
//****************************************************************************
@ObjectType()
export class RunAIModelActionViewResult {
    @Field(() => [AIModelAction_])
    Results: AIModelAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModelAction_)
export class AIModelActionResolver extends ResolverBase {
    @Query(() => RunAIModelActionViewResult)
    async RunAIModelActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelActionViewResult)
    async RunAIModelActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelActionViewResult)
    async RunAIModelActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Model Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIModelAction_, { nullable: true })
    async AIModelAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModelAction_ | null> {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Model Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [AIModelAction_])
    async AllAIModelActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions]` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows);
        return result;
    }
    
    @Mutation(() => AIModelAction_)
    async CreateAIModelAction(
        @Arg('input', () => CreateAIModelActionInput) input: CreateAIModelActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Model Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIModelAction_)
    async UpdateAIModelAction(
        @Arg('input', () => UpdateAIModelActionInput) input: UpdateAIModelActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Model Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIModelAction_)
    async DeleteAIModelAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Model Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity AI Actions
//****************************************************************************
@ObjectType({ description: `Tracks the AI actions that should be invoked based on changes to records within a given entity.` })
export class EntityAIAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field() 
    @MaxLength(16)
    AIActionID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `The AI prompt template used when this action is triggered by entity changes.`}) 
    Prompt?: string;
        
    @Field({description: `The entity event that triggers this AI action (After Save, Before Delete, etc.).`}) 
    @MaxLength(30)
    TriggerEvent: string;
        
    @Field({description: `Message shown to users when this AI action is executed.`}) 
    UserMessage: string;
        
    @Field({description: `Where the AI output should be stored (Field, Message, File).`}) 
    @MaxLength(20)
    OutputType: string;
        
    @Field({nullable: true, description: `The field name where AI output should be stored if OutputType is Field.`}) 
    @MaxLength(100)
    OutputField?: string;
        
    @Field(() => Boolean, {description: `Whether to skip AI processing if the output field already contains data.`}) 
    SkipIfOutputFieldNotEmpty: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputEntityID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field() 
    @MaxLength(100)
    AIAction: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity AI Actions
//****************************************************************************
@InputType()
export class CreateEntityAIActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity AI Actions
//****************************************************************************
@InputType()
export class UpdateEntityAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField?: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity AI Actions
//****************************************************************************
@ObjectType()
export class RunEntityAIActionViewResult {
    @Field(() => [EntityAIAction_])
    Results: EntityAIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityAIAction_)
export class EntityAIActionResolver extends ResolverBase {
    @Query(() => RunEntityAIActionViewResult)
    async RunEntityAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityAIActionViewResult)
    async RunEntityAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityAIActionViewResult)
    async RunEntityAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity AI Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityAIAction_, { nullable: true })
    async EntityAIAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityAIAction_ | null> {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity AI Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [EntityAIAction_])
    async AllEntityAIActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions]` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows);
        return result;
    }
    
    @Mutation(() => EntityAIAction_)
    async CreateEntityAIAction(
        @Arg('input', () => CreateEntityAIActionInput) input: CreateEntityAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity AI Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityAIAction_)
    async UpdateEntityAIAction(
        @Arg('input', () => UpdateEntityAIActionInput) input: UpdateEntityAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity AI Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityAIAction_)
    async DeleteEntityAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity AI Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Model Types
//****************************************************************************
@ObjectType({ description: `Types of AI Models` })
export class AIModelType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIModel_])
    AIModels_AIModelTypeIDArray: AIModel_[]; // Link to AIModels
    
    @Field(() => [AIPrompt_])
    AIPrompts_AIModelTypeIDArray: AIPrompt_[]; // Link to AIPrompts
    
}

//****************************************************************************
// INPUT TYPE for AI Model Types
//****************************************************************************
@InputType()
export class CreateAIModelTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Model Types
//****************************************************************************
@InputType()
export class UpdateAIModelTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Model Types
//****************************************************************************
@ObjectType()
export class RunAIModelTypeViewResult {
    @Field(() => [AIModelType_])
    Results: AIModelType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModelType_)
export class AIModelTypeResolver extends ResolverBase {
    @Query(() => RunAIModelTypeViewResult)
    async RunAIModelTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelTypeViewResult)
    async RunAIModelTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelTypeViewResult)
    async RunAIModelTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Model Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIModelType_, { nullable: true })
    async AIModelType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModelType_ | null> {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Model Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Query(() => [AIModelType_])
    async AllAIModelTypes(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes]` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Types', rows);
        return result;
    }
    
    @FieldResolver(() => [AIModel_])
    async AIModels_AIModelTypeIDArray(@Root() aimodeltype_: AIModelType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [AIModelTypeID]='${aimodeltype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Models', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPrompt_])
    async AIPrompts_AIModelTypeIDArray(@Root() aimodeltype_: AIModelType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [AIModelTypeID]='${aimodeltype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows);
        return result;
    }
        
    @Mutation(() => AIModelType_)
    async CreateAIModelType(
        @Arg('input', () => CreateAIModelTypeInput) input: CreateAIModelTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Model Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIModelType_)
    async UpdateAIModelType(
        @Arg('input', () => UpdateAIModelTypeInput) input: UpdateAIModelTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Model Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIModelType_)
    async DeleteAIModelType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Model Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queue Types
//****************************************************************************
@ObjectType({ description: `Defines different types of processing queues with specific behaviors, priorities, and processing rules for task management.` })
export class QueueType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Field DriverClass for entity Queue Types.`}) 
    @MaxLength(200)
    DriverClass: string;
        
    @Field({nullable: true, description: `Field DriverImportPath for entity Queue Types.`}) 
    @MaxLength(400)
    DriverImportPath?: string;
        
    @Field(() => Boolean, {description: `Field IsActive for entity Queue Types.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Queue_])
    Queues_QueueTypeIDArray: Queue_[]; // Link to Queues
    
}

//****************************************************************************
// INPUT TYPE for Queue Types
//****************************************************************************
@InputType()
export class CreateQueueTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Queue Types
//****************************************************************************
@InputType()
export class UpdateQueueTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queue Types
//****************************************************************************
@ObjectType()
export class RunQueueTypeViewResult {
    @Field(() => [QueueType_])
    Results: QueueType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueueType_)
export class QueueTypeResolver extends ResolverBase {
    @Query(() => RunQueueTypeViewResult)
    async RunQueueTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueueTypeViewResult)
    async RunQueueTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueueTypeViewResult)
    async RunQueueTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queue Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => QueueType_, { nullable: true })
    async QueueType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueueType_ | null> {
        this.CheckUserReadPermissions('Queue Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Queue Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Queue_])
    async Queues_QueueTypeIDArray(@Root() queuetype_: QueueType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queues', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueues] WHERE [QueueTypeID]='${queuetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queues', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Queues', rows);
        return result;
    }
        
    @Mutation(() => QueueType_)
    async CreateQueueType(
        @Arg('input', () => CreateQueueTypeInput) input: CreateQueueTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queue Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => QueueType_)
    async UpdateQueueType(
        @Arg('input', () => UpdateQueueTypeInput) input: UpdateQueueTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queue Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => QueueType_)
    async DeleteQueueType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queue Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queues
//****************************************************************************
@ObjectType({ description: `Queues can be used to async execute long running tasks` })
export class Queue_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    QueueTypeID: string;
        
    @Field(() => Boolean, {description: `Field IsActive for entity Queues.`}) 
    IsActive: boolean;
        
    @Field(() => Int, {nullable: true, description: `Field ProcessPID for entity Queues.`}) 
    ProcessPID?: number;
        
    @Field({nullable: true, description: `Field ProcessPlatform for entity Queues.`}) 
    @MaxLength(60)
    ProcessPlatform?: string;
        
    @Field({nullable: true, description: `Field ProcessVersion for entity Queues.`}) 
    @MaxLength(30)
    ProcessVersion?: string;
        
    @Field({nullable: true, description: `Field ProcessCwd for entity Queues.`}) 
    @MaxLength(200)
    ProcessCwd?: string;
        
    @Field({nullable: true, description: `Field ProcessIPAddress for entity Queues.`}) 
    @MaxLength(100)
    ProcessIPAddress?: string;
        
    @Field({nullable: true, description: `Field ProcessMacAddress for entity Queues.`}) 
    @MaxLength(100)
    ProcessMacAddress?: string;
        
    @Field({nullable: true, description: `Field ProcessOSName for entity Queues.`}) 
    @MaxLength(50)
    ProcessOSName?: string;
        
    @Field({nullable: true, description: `Field ProcessOSVersion for entity Queues.`}) 
    @MaxLength(20)
    ProcessOSVersion?: string;
        
    @Field({nullable: true, description: `Field ProcessHostName for entity Queues.`}) 
    @MaxLength(100)
    ProcessHostName?: string;
        
    @Field({nullable: true, description: `Field ProcessUserID for entity Queues.`}) 
    @MaxLength(50)
    ProcessUserID?: string;
        
    @Field({nullable: true, description: `Field ProcessUserName for entity Queues.`}) 
    @MaxLength(100)
    ProcessUserName?: string;
        
    @Field({description: `Field LastHeartbeat for entity Queues.`}) 
    @MaxLength(8)
    LastHeartbeat: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    QueueType: string;
        
    @Field(() => [QueueTask_])
    QueueTasks_QueueIDArray: QueueTask_[]; // Link to QueueTasks
    
}

//****************************************************************************
// INPUT TYPE for Queues
//****************************************************************************
@InputType()
export class CreateQueueInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID: number | null;

    @Field({ nullable: true })
    ProcessPlatform: string | null;

    @Field({ nullable: true })
    ProcessVersion: string | null;

    @Field({ nullable: true })
    ProcessCwd: string | null;

    @Field({ nullable: true })
    ProcessIPAddress: string | null;

    @Field({ nullable: true })
    ProcessMacAddress: string | null;

    @Field({ nullable: true })
    ProcessOSName: string | null;

    @Field({ nullable: true })
    ProcessOSVersion: string | null;

    @Field({ nullable: true })
    ProcessHostName: string | null;

    @Field({ nullable: true })
    ProcessUserID: string | null;

    @Field({ nullable: true })
    ProcessUserName: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Queues
//****************************************************************************
@InputType()
export class UpdateQueueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID?: number | null;

    @Field({ nullable: true })
    ProcessPlatform?: string | null;

    @Field({ nullable: true })
    ProcessVersion?: string | null;

    @Field({ nullable: true })
    ProcessCwd?: string | null;

    @Field({ nullable: true })
    ProcessIPAddress?: string | null;

    @Field({ nullable: true })
    ProcessMacAddress?: string | null;

    @Field({ nullable: true })
    ProcessOSName?: string | null;

    @Field({ nullable: true })
    ProcessOSVersion?: string | null;

    @Field({ nullable: true })
    ProcessHostName?: string | null;

    @Field({ nullable: true })
    ProcessUserID?: string | null;

    @Field({ nullable: true })
    ProcessUserName?: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queues
//****************************************************************************
@ObjectType()
export class RunQueueViewResult {
    @Field(() => [Queue_])
    Results: Queue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Queue_)
export class QueueResolver extends ResolverBase {
    @Query(() => RunQueueViewResult)
    async RunQueueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueueViewResult)
    async RunQueueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueueViewResult)
    async RunQueueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queues';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Queue_, { nullable: true })
    async Queue(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Queue_ | null> {
        this.CheckUserReadPermissions('Queues', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueues] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queues', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Queues', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [QueueTask_])
    async QueueTasks_QueueIDArray(@Root() queue_: Queue_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queue Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTasks] WHERE [QueueID]='${queue_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Queue Tasks', rows);
        return result;
    }
        
    @Mutation(() => Queue_)
    async CreateQueue(
        @Arg('input', () => CreateQueueInput) input: CreateQueueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queues', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Queue_)
    async UpdateQueue(
        @Arg('input', () => UpdateQueueInput) input: UpdateQueueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queues', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Queue_)
    async DeleteQueue(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queues', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queue Tasks
//****************************************************************************
@ObjectType({ description: `Manages asynchronous tasks in processing queues, tracking status, priority, and execution details for background operations.` })
export class QueueTask_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueueID: string;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({nullable: true, description: `JSON payload containing the data needed to process this task.`}) 
    Data?: string;
        
    @Field({nullable: true, description: `JSON configuration options for how this task should be processed.`}) 
    Options?: string;
        
    @Field({nullable: true, description: `Result data from task execution, typically in JSON format.`}) 
    Output?: string;
        
    @Field({nullable: true, description: `Error details if the task failed during processing.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Queue: string;
        
}

//****************************************************************************
// INPUT TYPE for Queue Tasks
//****************************************************************************
@InputType()
export class CreateQueueTaskInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Data: string | null;

    @Field({ nullable: true })
    Options: string | null;

    @Field({ nullable: true })
    Output: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Queue Tasks
//****************************************************************************
@InputType()
export class UpdateQueueTaskInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Data?: string | null;

    @Field({ nullable: true })
    Options?: string | null;

    @Field({ nullable: true })
    Output?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queue Tasks
//****************************************************************************
@ObjectType()
export class RunQueueTaskViewResult {
    @Field(() => [QueueTask_])
    Results: QueueTask_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueueTask_)
export class QueueTaskResolver extends ResolverBase {
    @Query(() => RunQueueTaskViewResult)
    async RunQueueTaskViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueueTaskViewResult)
    async RunQueueTaskViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueueTaskViewResult)
    async RunQueueTaskDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queue Tasks';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => QueueTask_, { nullable: true })
    async QueueTask(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueueTask_ | null> {
        this.CheckUserReadPermissions('Queue Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTasks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Queue Tasks', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => QueueTask_)
    async CreateQueueTask(
        @Arg('input', () => CreateQueueTaskInput) input: CreateQueueTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queue Tasks', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => QueueTask_)
    async UpdateQueueTask(
        @Arg('input', () => UpdateQueueTaskInput) input: UpdateQueueTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queue Tasks', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => QueueTask_)
    async DeleteQueueTask(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queue Tasks', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dashboards
//****************************************************************************
@ObjectType({ description: `Dashboards are used to group resources into a single display pane for an end-user` })
export class Dashboard_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `JSON configuration defining the dashboard layout, widgets, data sources, and display options.`}) 
    UIConfigDetails: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Dashboard type supporting Config (metadata-driven), Code (compiled TypeScript), and Dynamic Code (Skip-generated runtime JavaScript/React) options`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Base64 encoded image or URL to an image thumbnail for the dashboard`}) 
    Thumbnail?: string;
        
    @Field({description: `Scope of the dashboard: Global or App-specific`}) 
    @MaxLength(40)
    Scope: string;
        
    @Field({nullable: true, description: `Associated Application ID if Scope is App, otherwise NULL`}) 
    @MaxLength(16)
    ApplicationID?: string;
        
    @Field({nullable: true, description: `Specifies the runtime class that will be used for the Dashboard when Type is set to 'Code'. This class contains the custom logic and implementation for code-based dashboards.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Used to identify the dashboard for code-base dashboards. Allows reuse of the same DriverClass for multiple dashboards that can be rendered differently.`}) 
    @MaxLength(510)
    Code?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Application?: string;
        
    @Field(() => [DashboardUserState_])
    MJ_DashboardUserStates_DashboardIDArray: DashboardUserState_[]; // Link to MJ_DashboardUserStates
    
    @Field(() => [DashboardUserPreference_])
    MJ_DashboardUserPreferences_DashboardIDArray: DashboardUserPreference_[]; // Link to MJ_DashboardUserPreferences
    
}

//****************************************************************************
// INPUT TYPE for Dashboards
//****************************************************************************
@InputType()
export class CreateDashboardInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Thumbnail: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    Code: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Dashboards
//****************************************************************************
@InputType()
export class UpdateDashboardInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dashboards
//****************************************************************************
@ObjectType()
export class RunDashboardViewResult {
    @Field(() => [Dashboard_])
    Results: Dashboard_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Dashboard_)
export class DashboardResolver extends ResolverBase {
    @Query(() => RunDashboardViewResult)
    async RunDashboardViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDashboardViewResult)
    async RunDashboardViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDashboardViewResult)
    async RunDashboardDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dashboards';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Dashboard_, { nullable: true })
    async Dashboard(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Dashboard_ | null> {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Dashboards', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [DashboardUserState_])
    async MJ_DashboardUserStates_DashboardIDArray(@Root() dashboard_: Dashboard_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserStates] WHERE [DashboardID]='${dashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User States', rows);
        return result;
    }
        
    @FieldResolver(() => [DashboardUserPreference_])
    async MJ_DashboardUserPreferences_DashboardIDArray(@Root() dashboard_: Dashboard_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserPreferences] WHERE [DashboardID]='${dashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows);
        return result;
    }
        
    @Mutation(() => Dashboard_)
    async CreateDashboard(
        @Arg('input', () => CreateDashboardInput) input: CreateDashboardInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Dashboards', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Dashboard_)
    async UpdateDashboard(
        @Arg('input', () => UpdateDashboardInput) input: UpdateDashboardInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Dashboards', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Dashboard_)
    async DeleteDashboard(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dashboards', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Output Trigger Types
//****************************************************************************
@ObjectType({ description: `Defines events that can trigger output generation such as schedules, data changes, or manual requests.` })
export class OutputTriggerType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Report_])
    Reports_OutputTriggerTypeIDArray: Report_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Output Trigger Types
//****************************************************************************
@InputType()
export class CreateOutputTriggerTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Output Trigger Types
//****************************************************************************
@InputType()
export class UpdateOutputTriggerTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Output Trigger Types
//****************************************************************************
@ObjectType()
export class RunOutputTriggerTypeViewResult {
    @Field(() => [OutputTriggerType_])
    Results: OutputTriggerType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(OutputTriggerType_)
export class OutputTriggerTypeResolver extends ResolverBase {
    @Query(() => RunOutputTriggerTypeViewResult)
    async RunOutputTriggerTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunOutputTriggerTypeViewResult)
    async RunOutputTriggerTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunOutputTriggerTypeViewResult)
    async RunOutputTriggerTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Trigger Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => OutputTriggerType_, { nullable: true })
    async OutputTriggerType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<OutputTriggerType_ | null> {
        this.CheckUserReadPermissions('Output Trigger Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputTriggerTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Trigger Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Output Trigger Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_OutputTriggerTypeIDArray(@Root() outputtriggertype_: OutputTriggerType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputTriggerTypeID]='${outputtriggertype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @Mutation(() => OutputTriggerType_)
    async CreateOutputTriggerType(
        @Arg('input', () => CreateOutputTriggerTypeInput) input: CreateOutputTriggerTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Output Trigger Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => OutputTriggerType_)
    async UpdateOutputTriggerType(
        @Arg('input', () => UpdateOutputTriggerTypeInput) input: UpdateOutputTriggerTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Output Trigger Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => OutputTriggerType_)
    async DeleteOutputTriggerType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Output Trigger Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Output Format Types
//****************************************************************************
@ObjectType({ description: `Specifies available output formats for generated content including PDF, Excel, CSV, JSON, and custom formats.` })
export class OutputFormatType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Configuration or template for how data should be formatted in this output type.`}) 
    DisplayFormat?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Report_])
    Reports_OutputFormatTypeIDArray: Report_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Output Format Types
//****************************************************************************
@InputType()
export class CreateOutputFormatTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DisplayFormat: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Output Format Types
//****************************************************************************
@InputType()
export class UpdateOutputFormatTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DisplayFormat?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Output Format Types
//****************************************************************************
@ObjectType()
export class RunOutputFormatTypeViewResult {
    @Field(() => [OutputFormatType_])
    Results: OutputFormatType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(OutputFormatType_)
export class OutputFormatTypeResolver extends ResolverBase {
    @Query(() => RunOutputFormatTypeViewResult)
    async RunOutputFormatTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunOutputFormatTypeViewResult)
    async RunOutputFormatTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunOutputFormatTypeViewResult)
    async RunOutputFormatTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Format Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => OutputFormatType_, { nullable: true })
    async OutputFormatType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<OutputFormatType_ | null> {
        this.CheckUserReadPermissions('Output Format Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputFormatTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Format Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Output Format Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_OutputFormatTypeIDArray(@Root() outputformattype_: OutputFormatType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputFormatTypeID]='${outputformattype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @Mutation(() => OutputFormatType_)
    async CreateOutputFormatType(
        @Arg('input', () => CreateOutputFormatTypeInput) input: CreateOutputFormatTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Output Format Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => OutputFormatType_)
    async UpdateOutputFormatType(
        @Arg('input', () => UpdateOutputFormatTypeInput) input: UpdateOutputFormatTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Output Format Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => OutputFormatType_)
    async DeleteOutputFormatType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Output Format Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Output Delivery Types
//****************************************************************************
@ObjectType({ description: `Defines methods for delivering generated outputs such as email, file storage, API endpoints, or messaging platforms.` })
export class OutputDeliveryType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Report_])
    Reports_OutputDeliveryTypeIDArray: Report_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Output Delivery Types
//****************************************************************************
@InputType()
export class CreateOutputDeliveryTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Output Delivery Types
//****************************************************************************
@InputType()
export class UpdateOutputDeliveryTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Output Delivery Types
//****************************************************************************
@ObjectType()
export class RunOutputDeliveryTypeViewResult {
    @Field(() => [OutputDeliveryType_])
    Results: OutputDeliveryType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(OutputDeliveryType_)
export class OutputDeliveryTypeResolver extends ResolverBase {
    @Query(() => RunOutputDeliveryTypeViewResult)
    async RunOutputDeliveryTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunOutputDeliveryTypeViewResult)
    async RunOutputDeliveryTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunOutputDeliveryTypeViewResult)
    async RunOutputDeliveryTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Delivery Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => OutputDeliveryType_, { nullable: true })
    async OutputDeliveryType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<OutputDeliveryType_ | null> {
        this.CheckUserReadPermissions('Output Delivery Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputDeliveryTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Delivery Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Output Delivery Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_OutputDeliveryTypeIDArray(@Root() outputdeliverytype_: OutputDeliveryType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputDeliveryTypeID]='${outputdeliverytype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @Mutation(() => OutputDeliveryType_)
    async CreateOutputDeliveryType(
        @Arg('input', () => CreateOutputDeliveryTypeInput) input: CreateOutputDeliveryTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Output Delivery Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => OutputDeliveryType_)
    async UpdateOutputDeliveryType(
        @Arg('input', () => UpdateOutputDeliveryTypeInput) input: UpdateOutputDeliveryTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Output Delivery Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => OutputDeliveryType_)
    async DeleteOutputDeliveryType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Output Delivery Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Reports
//****************************************************************************
@ObjectType({ description: `Defines report configurations including data sources, layouts, filters, and scheduling for automated report generation.` })
export class Report_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Field SharingScope for entity Reports.`}) 
    @MaxLength(40)
    SharingScope: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DataContextID?: string;
        
    @Field({nullable: true, description: `Field Configuration for entity Reports.`}) 
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputTriggerTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputFormatTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputDeliveryTypeID?: string;
        
    @Field({nullable: true, description: `For scheduled reports, the frequency of generation (Daily, Weekly, Monthly, etc.).`}) 
    @MaxLength(100)
    OutputFrequency?: string;
        
    @Field({nullable: true, description: `Email address(es) to send the report to when using email delivery.`}) 
    @MaxLength(510)
    OutputTargetEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputWorkflowID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Thumbnail image for the report that can be displayed in gallery views. Can contain either a URL to an image file or a Base64-encoded image string.`}) 
    Thumbnail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DataContext?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputTriggerType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputFormatType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputDeliveryType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    OutputWorkflow?: string;
        
    @Field(() => [ReportSnapshot_])
    ReportSnapshots_ReportIDArray: ReportSnapshot_[]; // Link to ReportSnapshots
    
    @Field(() => [ReportVersion_])
    MJ_ReportVersions_ReportIDArray: ReportVersion_[]; // Link to MJ_ReportVersions
    
    @Field(() => [ReportUserState_])
    MJ_ReportUserStates_ReportIDArray: ReportUserState_[]; // Link to MJ_ReportUserStates
    
}

//****************************************************************************
// INPUT TYPE for Reports
//****************************************************************************
@InputType()
export class CreateReportInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID: string | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID: string | null;

    @Field({ nullable: true })
    OutputFrequency: string | null;

    @Field({ nullable: true })
    OutputTargetEmail: string | null;

    @Field({ nullable: true })
    OutputWorkflowID: string | null;

    @Field({ nullable: true })
    Thumbnail: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Reports
//****************************************************************************
@InputType()
export class UpdateReportInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID?: string | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID?: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID?: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID?: string | null;

    @Field({ nullable: true })
    OutputFrequency?: string | null;

    @Field({ nullable: true })
    OutputTargetEmail?: string | null;

    @Field({ nullable: true })
    OutputWorkflowID?: string | null;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Reports
//****************************************************************************
@ObjectType()
export class RunReportViewResult {
    @Field(() => [Report_])
    Results: Report_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Report_)
export class ReportResolver extends ResolverBase {
    @Query(() => RunReportViewResult)
    async RunReportViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportViewResult)
    async RunReportViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportViewResult)
    async RunReportDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Reports';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Report_, { nullable: true })
    async Report(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Report_ | null> {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Reports', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ReportSnapshot_])
    async ReportSnapshots_ReportIDArray(@Root() report_: Report_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [ReportID]='${report_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Report Snapshots', rows);
        return result;
    }
        
    @FieldResolver(() => [ReportVersion_])
    async MJ_ReportVersions_ReportIDArray(@Root() report_: Report_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportVersions] WHERE [ReportID]='${report_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report Versions', rows);
        return result;
    }
        
    @FieldResolver(() => [ReportUserState_])
    async MJ_ReportUserStates_ReportIDArray(@Root() report_: Report_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [ReportID]='${report_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', rows);
        return result;
    }
        
    @Mutation(() => Report_)
    async CreateReport(
        @Arg('input', () => CreateReportInput) input: CreateReportInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Reports', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Report_)
    async UpdateReport(
        @Arg('input', () => UpdateReportInput) input: UpdateReportInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Reports', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Report_)
    async DeleteReport(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Reports', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Report Snapshots
//****************************************************************************
@ObjectType({ description: `Stores point-in-time captures of report outputs, preserving historical data and enabling comparison over time.` })
export class ReportSnapshot_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field({description: `Field ResultSet for entity Report Snapshots.`}) 
    ResultSet: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for Report Snapshots
//****************************************************************************
@InputType()
export class CreateReportSnapshotInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Report Snapshots
//****************************************************************************
@InputType()
export class UpdateReportSnapshotInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Report Snapshots
//****************************************************************************
@ObjectType()
export class RunReportSnapshotViewResult {
    @Field(() => [ReportSnapshot_])
    Results: ReportSnapshot_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ReportSnapshot_)
export class ReportSnapshotResolver extends ResolverBase {
    @Query(() => RunReportSnapshotViewResult)
    async RunReportSnapshotViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportSnapshotViewResult)
    async RunReportSnapshotViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportSnapshotViewResult)
    async RunReportSnapshotDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Report Snapshots';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ReportSnapshot_, { nullable: true })
    async ReportSnapshot(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ReportSnapshot_ | null> {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Report Snapshots', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ReportSnapshot_)
    async CreateReportSnapshot(
        @Arg('input', () => CreateReportSnapshotInput) input: CreateReportSnapshotInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Report Snapshots', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ReportSnapshot_)
    async UpdateReportSnapshot(
        @Arg('input', () => UpdateReportSnapshotInput) input: UpdateReportSnapshotInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Report Snapshots', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ReportSnapshot_)
    async DeleteReportSnapshot(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Report Snapshots', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Types
//****************************************************************************
@ObjectType({ description: `Tracks types of system resources such as records, dashboards, and reports.` })
export class ResourceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `Field DisplayName for entity Resource Types.`}) 
    @MaxLength(510)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Icon identifier for displaying this resource type in the UI.`}) 
    @MaxLength(200)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Nullable foreign key to the ID column in Entities entity, representing the category entity. ASSUMPTION: If provided, the assumption is there is a self-referencing/recursive foreign key establishing a hierarchy within the Category Entity, commonly called ParentID, but it can be named anything.`}) 
    @MaxLength(16)
    CategoryEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CategoryEntity?: string;
        
    @Field(() => [WorkspaceItem_])
    WorkspaceItems_ResourceTypeIDArray: WorkspaceItem_[]; // Link to WorkspaceItems
    
    @Field(() => [UserNotification_])
    UserNotifications_ResourceTypeIDArray: UserNotification_[]; // Link to UserNotifications
    
    @Field(() => [ResourceLink_])
    ResourceLinks_ResourceTypeIDArray: ResourceLink_[]; // Link to ResourceLinks
    
    @Field(() => [ResourcePermission_])
    ResourcePermissions_ResourceTypeIDArray: ResourcePermission_[]; // Link to ResourcePermissions
    
}

//****************************************************************************
// INPUT TYPE for Resource Types
//****************************************************************************
@InputType()
export class CreateResourceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    CategoryEntityID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Resource Types
//****************************************************************************
@InputType()
export class UpdateResourceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    CategoryEntityID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Types
//****************************************************************************
@ObjectType()
export class RunResourceTypeViewResult {
    @Field(() => [ResourceType_])
    Results: ResourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ResourceType_)
export class ResourceTypeResolver extends ResolverBase {
    @Query(() => RunResourceTypeViewResult)
    async RunResourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunResourceTypeViewResult)
    async RunResourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunResourceTypeViewResult)
    async RunResourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ResourceType_, { nullable: true })
    async ResourceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ResourceType_ | null> {
        this.CheckUserReadPermissions('Resource Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Resource Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [WorkspaceItem_])
    async WorkspaceItems_ResourceTypeIDArray(@Root() resourcetype_: ResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [ResourceTypeID]='${resourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workspace Items', rows);
        return result;
    }
        
    @FieldResolver(() => [UserNotification_])
    async UserNotifications_ResourceTypeIDArray(@Root() resourcetype_: ResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [ResourceTypeID]='${resourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Notifications', rows);
        return result;
    }
        
    @FieldResolver(() => [ResourceLink_])
    async ResourceLinks_ResourceTypeIDArray(@Root() resourcetype_: ResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [ResourceTypeID]='${resourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Links', rows);
        return result;
    }
        
    @FieldResolver(() => [ResourcePermission_])
    async ResourcePermissions_ResourceTypeIDArray(@Root() resourcetype_: ResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [ResourceTypeID]='${resourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows);
        return result;
    }
        
    @Mutation(() => ResourceType_)
    async CreateResourceType(
        @Arg('input', () => CreateResourceTypeInput) input: CreateResourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Resource Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ResourceType_)
    async UpdateResourceType(
        @Arg('input', () => UpdateResourceTypeInput) input: UpdateResourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Resource Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ResourceType_)
    async DeleteResourceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Tags
//****************************************************************************
@ObjectType({ description: `Tags are used to arbitrarily associate any record in any entity with addtional information.` })
export class Tag_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Field DisplayName for entity Tags.`}) 
    @MaxLength(510)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [Tag_])
    Tags_ParentIDArray: Tag_[]; // Link to Tags
    
    @Field(() => [TaggedItem_])
    TaggedItems_TagIDArray: TaggedItem_[]; // Link to TaggedItems
    
}

//****************************************************************************
// INPUT TYPE for Tags
//****************************************************************************
@InputType()
export class CreateTagInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Tags
//****************************************************************************
@InputType()
export class UpdateTagInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Tags
//****************************************************************************
@ObjectType()
export class RunTagViewResult {
    @Field(() => [Tag_])
    Results: Tag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Tag_)
export class TagResolver extends ResolverBase {
    @Query(() => RunTagViewResult)
    async RunTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTagViewResult)
    async RunTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTagViewResult)
    async RunTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Tags';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Tag_, { nullable: true })
    async Tag(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Tag_ | null> {
        this.CheckUserReadPermissions('Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTags] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Tags', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Tag_])
    async Tags_ParentIDArray(@Root() tag_: Tag_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTags] WHERE [ParentID]='${tag_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Tags', rows);
        return result;
    }
        
    @FieldResolver(() => [TaggedItem_])
    async TaggedItems_TagIDArray(@Root() tag_: Tag_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [TagID]='${tag_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Tagged Items', rows);
        return result;
    }
        
    @Mutation(() => Tag_)
    async CreateTag(
        @Arg('input', () => CreateTagInput) input: CreateTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Tags', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Tag_)
    async UpdateTag(
        @Arg('input', () => UpdateTagInput) input: UpdateTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Tags', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Tag_)
    async DeleteTag(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Tags', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Tagged Items
//****************************************************************************
@ObjectType({ description: `Tracks the links between any record in any entity with Tags` })
export class TaggedItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TagID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `Field RecordID for entity Tagged Items.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Tag: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Tagged Items
//****************************************************************************
@InputType()
export class CreateTaggedItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TagID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Tagged Items
//****************************************************************************
@InputType()
export class UpdateTaggedItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TagID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Tagged Items
//****************************************************************************
@ObjectType()
export class RunTaggedItemViewResult {
    @Field(() => [TaggedItem_])
    Results: TaggedItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TaggedItem_)
export class TaggedItemResolver extends ResolverBase {
    @Query(() => RunTaggedItemViewResult)
    async RunTaggedItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTaggedItemViewResult)
    async RunTaggedItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTaggedItemViewResult)
    async RunTaggedItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Tagged Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => TaggedItem_, { nullable: true })
    async TaggedItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TaggedItem_ | null> {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Tagged Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => TaggedItem_)
    async CreateTaggedItem(
        @Arg('input', () => CreateTaggedItemInput) input: CreateTaggedItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Tagged Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => TaggedItem_)
    async UpdateTaggedItem(
        @Arg('input', () => UpdateTaggedItemInput) input: UpdateTaggedItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Tagged Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => TaggedItem_)
    async DeleteTaggedItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Tagged Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workspaces
//****************************************************************************
@ObjectType({ description: `A user can have one or more workspaces` })
export class Workspace_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [WorkspaceItem_])
    WorkspaceItems_WorkSpaceIDArray: WorkspaceItem_[]; // Link to WorkspaceItems
    
}

//****************************************************************************
// INPUT TYPE for Workspaces
//****************************************************************************
@InputType()
export class CreateWorkspaceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Workspaces
//****************************************************************************
@InputType()
export class UpdateWorkspaceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workspaces
//****************************************************************************
@ObjectType()
export class RunWorkspaceViewResult {
    @Field(() => [Workspace_])
    Results: Workspace_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Workspace_)
export class WorkspaceResolver extends ResolverBase {
    @Query(() => RunWorkspaceViewResult)
    async RunWorkspaceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkspaceViewResult)
    async RunWorkspaceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkspaceViewResult)
    async RunWorkspaceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workspaces';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Workspace_, { nullable: true })
    async Workspace(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Workspace_ | null> {
        this.CheckUserReadPermissions('Workspaces', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaces] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workspaces', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [WorkspaceItem_])
    async WorkspaceItems_WorkSpaceIDArray(@Root() workspace_: Workspace_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [WorkSpaceID]='${workspace_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Workspace Items', rows);
        return result;
    }
        
    @Mutation(() => Workspace_)
    async CreateWorkspace(
        @Arg('input', () => CreateWorkspaceInput) input: CreateWorkspaceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workspaces', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Workspace_)
    async UpdateWorkspace(
        @Arg('input', () => UpdateWorkspaceInput) input: UpdateWorkspaceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workspaces', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Workspace_)
    async DeleteWorkspace(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workspaces', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workspace Items
//****************************************************************************
@ObjectType({ description: `Tracks the resources that are active within a given worksapce` })
export class WorkspaceItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    WorkspaceID: string;
        
    @Field() 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({nullable: true, description: `The ID of the resource (such as a view, dashboard, or other entity record) that is included in this workspace.`}) 
    @MaxLength(4000)
    ResourceRecordID?: string;
        
    @Field(() => Int, {description: `The display order of this item within the workspace, used for arranging resources in the user interface.`}) 
    Sequence: number;
        
    @Field({nullable: true, description: `JSON configuration data specific to this workspace item, storing custom settings and state information.`}) 
    Configuration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Workspace: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for Workspace Items
//****************************************************************************
@InputType()
export class CreateWorkspaceItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workspace Items
//****************************************************************************
@InputType()
export class UpdateWorkspaceItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workspace Items
//****************************************************************************
@ObjectType()
export class RunWorkspaceItemViewResult {
    @Field(() => [WorkspaceItem_])
    Results: WorkspaceItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(WorkspaceItem_)
export class WorkspaceItemResolver extends ResolverBase {
    @Query(() => RunWorkspaceItemViewResult)
    async RunWorkspaceItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkspaceItemViewResult)
    async RunWorkspaceItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunWorkspaceItemViewResult)
    async RunWorkspaceItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workspace Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => WorkspaceItem_, { nullable: true })
    async WorkspaceItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<WorkspaceItem_ | null> {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Workspace Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => WorkspaceItem_)
    async CreateWorkspaceItem(
        @Arg('input', () => CreateWorkspaceItemInput) input: CreateWorkspaceItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workspace Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => WorkspaceItem_)
    async UpdateWorkspaceItem(
        @Arg('input', () => UpdateWorkspaceItemInput) input: UpdateWorkspaceItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workspace Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => WorkspaceItem_)
    async DeleteWorkspaceItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workspace Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Datasets
//****************************************************************************
@ObjectType({ description: `Cacheable sets of data that can span one or more items` })
export class Dataset_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [DatasetItem_])
    DatasetItems_DatasetNameArray: DatasetItem_[]; // Link to DatasetItems
    
}

//****************************************************************************
// INPUT TYPE for Datasets
//****************************************************************************
@InputType()
export class CreateDatasetInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Datasets
//****************************************************************************
@InputType()
export class UpdateDatasetInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Datasets
//****************************************************************************
@ObjectType()
export class RunDatasetViewResult {
    @Field(() => [Dataset_])
    Results: Dataset_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Dataset_)
export class DatasetResolver extends ResolverBase {
    @Query(() => RunDatasetViewResult)
    async RunDatasetViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDatasetViewResult)
    async RunDatasetViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDatasetViewResult)
    async RunDatasetDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Datasets';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Dataset_, { nullable: true })
    async Dataset(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Dataset_ | null> {
        this.CheckUserReadPermissions('Datasets', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasets] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Datasets', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Datasets', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [DatasetItem_])
    async DatasetItems_DatasetNameArray(@Root() dataset_: Dataset_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [DatasetName]='${dataset_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dataset Items', rows);
        return result;
    }
        
    @Mutation(() => Dataset_)
    async CreateDataset(
        @Arg('input', () => CreateDatasetInput) input: CreateDatasetInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Datasets', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Dataset_)
    async UpdateDataset(
        @Arg('input', () => UpdateDatasetInput) input: UpdateDatasetInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Datasets', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Dataset_)
    async DeleteDataset(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Datasets', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dataset Items
//****************************************************************************
@ObjectType({ description: `A single item in a Dataset and can be sourced from multiple methods.` })
export class DatasetItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique code identifier for this dataset item within its parent dataset.`}) 
    @MaxLength(100)
    Code: string;
        
    @Field() 
    @MaxLength(16)
    DatasetID: string;
        
    @Field(() => Int, {description: `Order in which this item should be processed or displayed within the dataset.`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({nullable: true, description: `SQL WHERE clause to filter data when this dataset item is sourced from a query.`}) 
    WhereClause?: string;
        
    @Field({description: `The date field name used for incremental updates and change detection.`}) 
    @MaxLength(200)
    DateFieldToCheck: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional column to store a comma-delimited list of columns for the DatasetItem`}) 
    Columns?: string;
        
    @Field() 
    @MaxLength(200)
    Dataset: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Dataset Items
//****************************************************************************
@InputType()
export class CreateDatasetItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    DatasetID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    WhereClause: string | null;

    @Field({ nullable: true })
    DateFieldToCheck?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Columns: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Dataset Items
//****************************************************************************
@InputType()
export class UpdateDatasetItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    DatasetID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    WhereClause?: string | null;

    @Field({ nullable: true })
    DateFieldToCheck?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Columns?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dataset Items
//****************************************************************************
@ObjectType()
export class RunDatasetItemViewResult {
    @Field(() => [DatasetItem_])
    Results: DatasetItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DatasetItem_)
export class DatasetItemResolver extends ResolverBase {
    @Query(() => RunDatasetItemViewResult)
    async RunDatasetItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDatasetItemViewResult)
    async RunDatasetItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDatasetItemViewResult)
    async RunDatasetItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dataset Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DatasetItem_, { nullable: true })
    async DatasetItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DatasetItem_ | null> {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Dataset Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => DatasetItem_)
    async CreateDatasetItem(
        @Arg('input', () => CreateDatasetItemInput) input: CreateDatasetItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Dataset Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DatasetItem_)
    async UpdateDatasetItem(
        @Arg('input', () => UpdateDatasetItemInput) input: UpdateDatasetItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Dataset Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DatasetItem_)
    async DeleteDatasetItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dataset Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Conversation Details
//****************************************************************************
@ObjectType({ description: `Stores individual messages, responses, and interactions within a conversation, maintaining the complete dialogue history with timestamps.` })
export class ConversationDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ConversationID: string;
        
    @Field({nullable: true, description: `External system identifier for this message, used for integration scenarios.`}) 
    @MaxLength(200)
    ExternalID?: string;
        
    @Field({description: `The role of the message sender (user, assistant, system, function).`}) 
    @MaxLength(40)
    Role: string;
        
    @Field({description: `The actual content of the message in the conversation.`}) 
    Message: string;
        
    @Field({nullable: true, description: `Error message if this conversation turn encountered a problem.`}) 
    Error?: string;
        
    @Field(() => Boolean, {description: `Flag indicating if this message should be hidden from end users (system messages, function calls, etc.).`}) 
    HiddenToUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `This column is used to capture user feedback as a rating scale. The scale ranges from 1 to 10, where 1 might represent thumbs down, and 10 might represent thumbs up or the highest rating in a star-based scale.`}) 
    UserRating?: number;
        
    @Field({nullable: true, description: `This column is used to store user text feedback about a given AI response, describing what they liked or disliked.`}) 
    UserFeedback?: string;
        
    @Field({nullable: true, description: `This column stores human or AI-generated reflections on how to improve future responses based on the user feedback and the AI output generated for prior messages in the conversation.`}) 
    ReflectionInsights?: string;
        
    @Field({nullable: true, description: `This column optionally stores a summary of the entire conversation leading up to this particular conversation detail record. It is used in long-running conversations to optimize performance by summarizing earlier parts.`}) 
    SummaryOfEarlierConversation?: string;
        
    @Field({nullable: true, description: `This field, when populated, overrides the UserID at the Conversation level to specify a different user created the message.`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Optional reference to a conversation artifact associated with this conversation detail`}) 
    @MaxLength(16)
    ArtifactID?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific version of a conversation artifact associated with this conversation detail`}) 
    @MaxLength(16)
    ArtifactVersionID?: string;
        
    @Field(() => Int, {nullable: true, description: `Duration in milliseconds representing how long the AI response processing took to complete for this conversation detail.`}) 
    CompletionTime?: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Artifact?: string;
        
    @Field(() => [Report_])
    Reports_ConversationDetailIDArray: Report_[]; // Link to Reports
    
    @Field(() => [AIAgentRun_])
    MJ_AIAgentRuns_ConversationDetailIDArray: AIAgentRun_[]; // Link to MJ_AIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for Conversation Details
//****************************************************************************
@InputType()
export class CreateConversationDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating: number | null;

    @Field({ nullable: true })
    UserFeedback: string | null;

    @Field({ nullable: true })
    ReflectionInsights: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    ArtifactID: string | null;

    @Field({ nullable: true })
    ArtifactVersionID: string | null;

    @Field(() => Int, { nullable: true })
    CompletionTime: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Conversation Details
//****************************************************************************
@InputType()
export class UpdateConversationDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error?: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating?: number | null;

    @Field({ nullable: true })
    UserFeedback?: string | null;

    @Field({ nullable: true })
    ReflectionInsights?: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    ArtifactID?: string | null;

    @Field({ nullable: true })
    ArtifactVersionID?: string | null;

    @Field(() => Int, { nullable: true })
    CompletionTime?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Conversation Details
//****************************************************************************
@ObjectType()
export class RunConversationDetailViewResult {
    @Field(() => [ConversationDetail_])
    Results: ConversationDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ConversationDetail_)
export class ConversationDetailResolver extends ResolverBase {
    @Query(() => RunConversationDetailViewResult)
    async RunConversationDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationDetailViewResult)
    async RunConversationDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationDetailViewResult)
    async RunConversationDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Conversation Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ConversationDetail_, { nullable: true })
    async ConversationDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ConversationDetail_ | null> {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Conversation Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_ConversationDetailIDArray(@Root() conversationdetail_: ConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ConversationDetailID]='${conversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRun_])
    async MJ_AIAgentRuns_ConversationDetailIDArray(@Root() conversationdetail_: ConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ConversationDetailID]='${conversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows);
        return result;
    }
        
    @Mutation(() => ConversationDetail_)
    async CreateConversationDetail(
        @Arg('input', () => CreateConversationDetailInput) input: CreateConversationDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Conversation Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ConversationDetail_)
    async UpdateConversationDetail(
        @Arg('input', () => UpdateConversationDetailInput) input: UpdateConversationDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Conversation Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ConversationDetail_)
    async DeleteConversationDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Conversation Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Conversations
//****************************************************************************
@ObjectType({ description: `Tracks conversation sessions between users and AI agents or between users, including context, participants, and metadata.` })
export class Conversation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `External system identifier for cross-system conversation tracking.`}) 
    @MaxLength(1000)
    ExternalID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The type or category of conversation (Skip, Support, Chat, etc.).`}) 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates if this conversation has been archived and should not appear in active lists.`}) 
    IsArchived: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `ID of a related record this conversation is about (support ticket, order, etc.).`}) 
    @MaxLength(1000)
    LinkedRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DataContextID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Tracks the processing status of the conversation: Available, Processing`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LinkedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DataContext?: string;
        
    @Field(() => [ConversationDetail_])
    ConversationDetails_ConversationIDArray: ConversationDetail_[]; // Link to ConversationDetails
    
    @Field(() => [Report_])
    Reports_ConversationIDArray: Report_[]; // Link to Reports
    
    @Field(() => [ConversationArtifact_])
    MJ_ConversationArtifacts_ConversationIDArray: ConversationArtifact_[]; // Link to MJ_ConversationArtifacts
    
    @Field(() => [AIAgentRun_])
    MJ_AIAgentRuns_ConversationIDArray: AIAgentRun_[]; // Link to MJ_AIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for Conversations
//****************************************************************************
@InputType()
export class CreateConversationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Conversations
//****************************************************************************
@InputType()
export class UpdateConversationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Conversations
//****************************************************************************
@ObjectType()
export class RunConversationViewResult {
    @Field(() => [Conversation_])
    Results: Conversation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Conversation_)
export class ConversationResolver extends ResolverBase {
    @Query(() => RunConversationViewResult)
    async RunConversationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationViewResult)
    async RunConversationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationViewResult)
    async RunConversationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Conversations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Conversation_, { nullable: true })
    async Conversation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Conversation_ | null> {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Conversations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ConversationDetail_])
    async ConversationDetails_ConversationIDArray(@Root() conversation_: Conversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ConversationID]='${conversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows);
        return result;
    }
        
    @FieldResolver(() => [Report_])
    async Reports_ConversationIDArray(@Root() conversation_: Conversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ConversationID]='${conversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [ConversationArtifact_])
    async MJ_ConversationArtifacts_ConversationIDArray(@Root() conversation_: Conversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ConversationID]='${conversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentRun_])
    async MJ_AIAgentRuns_ConversationIDArray(@Root() conversation_: Conversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ConversationID]='${conversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows);
        return result;
    }
        
    @Mutation(() => Conversation_)
    async CreateConversation(
        @Arg('input', () => CreateConversationInput) input: CreateConversationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Conversations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Conversation_)
    async UpdateConversation(
        @Arg('input', () => UpdateConversationInput) input: UpdateConversationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Conversations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Conversation_)
    async DeleteConversation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Conversations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Notifications
//****************************************************************************
@ObjectType({ description: `Manages notifications sent to users including alerts, messages, and system updates with read status and priority.` })
export class UserNotification_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `Brief title or subject of the notification.`}) 
    @MaxLength(510)
    Title?: string;
        
    @Field({nullable: true, description: `Full notification message content.`}) 
    Message?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ResourceTypeID?: string;
        
    @Field({nullable: true, description: `Field ResourceConfiguration for entity User Notifications.`}) 
    ResourceConfiguration?: string;
        
    @Field(() => Boolean, {description: `Field Unread for entity User Notifications.`}) 
    Unread: boolean;
        
    @Field({nullable: true, description: `Timestamp when the user read this notification.`}) 
    @MaxLength(8)
    ReadAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `ID of the specific record this notification is about.`}) 
    @MaxLength(16)
    ResourceRecordID?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ResourceType?: string;
        
}

//****************************************************************************
// INPUT TYPE for User Notifications
//****************************************************************************
@InputType()
export class CreateUserNotificationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    ResourceTypeID: string | null;

    @Field({ nullable: true })
    ResourceConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt: Date | null;

    @Field({ nullable: true })
    ResourceRecordID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for User Notifications
//****************************************************************************
@InputType()
export class UpdateUserNotificationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    ResourceTypeID?: string | null;

    @Field({ nullable: true })
    ResourceConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt?: Date | null;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Notifications
//****************************************************************************
@ObjectType()
export class RunUserNotificationViewResult {
    @Field(() => [UserNotification_])
    Results: UserNotification_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserNotification_)
export class UserNotificationResolver extends ResolverBase {
    @Query(() => RunUserNotificationViewResult)
    async RunUserNotificationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserNotificationViewResult)
    async RunUserNotificationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserNotificationViewResult)
    async RunUserNotificationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Notifications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserNotification_, { nullable: true })
    async UserNotification(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserNotification_ | null> {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User Notifications', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => UserNotification_)
    async CreateUserNotification(
        @Arg('input', () => CreateUserNotificationInput) input: CreateUserNotificationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Notifications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserNotification_)
    async UpdateUserNotification(
        @Arg('input', () => UpdateUserNotificationInput) input: UpdateUserNotificationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Notifications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserNotification_)
    async DeleteUserNotification(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Notifications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Schema Info
//****************************************************************************
@ObjectType({ description: `Tracks the schemas in the system and the ID ranges that are valid for entities within each schema.` })
export class SchemaInfo_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The database schema this information applies to.`}) 
    @MaxLength(100)
    SchemaName: string;
        
    @Field(() => Int, {description: `Field EntityIDMin for entity Schema Info.`}) 
    EntityIDMin: number;
        
    @Field(() => Int, {description: `Field EntityIDMax for entity Schema Info.`}) 
    EntityIDMax: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Schema Info
//****************************************************************************
@InputType()
export class CreateSchemaInfoInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Schema Info
//****************************************************************************
@InputType()
export class UpdateSchemaInfoInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Schema Info
//****************************************************************************
@ObjectType()
export class RunSchemaInfoViewResult {
    @Field(() => [SchemaInfo_])
    Results: SchemaInfo_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(SchemaInfo_)
export class SchemaInfoResolver extends ResolverBase {
    @Query(() => RunSchemaInfoViewResult)
    async RunSchemaInfoViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunSchemaInfoViewResult)
    async RunSchemaInfoViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunSchemaInfoViewResult)
    async RunSchemaInfoDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Schema Info';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => SchemaInfo_, { nullable: true })
    async SchemaInfo(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<SchemaInfo_ | null> {
        this.CheckUserReadPermissions('Schema Info', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSchemaInfos] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Schema Info', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Schema Info', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => SchemaInfo_)
    async CreateSchemaInfo(
        @Arg('input', () => CreateSchemaInfoInput) input: CreateSchemaInfoInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Schema Info', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => SchemaInfo_)
    async UpdateSchemaInfo(
        @Arg('input', () => UpdateSchemaInfoInput) input: UpdateSchemaInfoInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Schema Info', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => SchemaInfo_)
    async DeleteSchemaInfo(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Schema Info', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Record Maps
//****************************************************************************
@ObjectType({ description: `Maps records between internal entities and external system identifiers, maintaining synchronization between MemberJunction and integrated platforms.` })
export class CompanyIntegrationRecordMap_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field({description: `The unique identifier for this record in the external integrated system.`}) 
    @MaxLength(1500)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The internal MemberJunction record ID that corresponds to the external system record.`}) 
    @MaxLength(1500)
    EntityRecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CompanyIntegration: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Company Integration Record Maps
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationRecordMapInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Record Maps
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationRecordMapInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Record Maps
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationRecordMapViewResult {
    @Field(() => [CompanyIntegrationRecordMap_])
    Results: CompanyIntegrationRecordMap_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegrationRecordMap_)
export class CompanyIntegrationRecordMapResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationRecordMapViewResult)
    async RunCompanyIntegrationRecordMapViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRecordMapViewResult)
    async RunCompanyIntegrationRecordMapViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRecordMapViewResult)
    async RunCompanyIntegrationRecordMapDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Record Maps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CompanyIntegrationRecordMap_, { nullable: true })
    async CompanyIntegrationRecordMap(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegrationRecordMap_ | null> {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Company Integration Record Maps', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => CompanyIntegrationRecordMap_)
    async CreateCompanyIntegrationRecordMap(
        @Arg('input', () => CreateCompanyIntegrationRecordMapInput) input: CreateCompanyIntegrationRecordMapInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Record Maps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegrationRecordMap_)
    async UpdateCompanyIntegrationRecordMap(
        @Arg('input', () => UpdateCompanyIntegrationRecordMapInput) input: UpdateCompanyIntegrationRecordMapInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Record Maps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CompanyIntegrationRecordMap_)
    async DeleteCompanyIntegrationRecordMap(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integration Record Maps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Merge Logs
//****************************************************************************
@ObjectType({ description: `Records the history of record merge operations including source records, target records, and merge rules applied.` })
export class RecordMergeLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the record that survived the merge and contains the consolidated data.`}) 
    @MaxLength(900)
    SurvivingRecordID: string;
        
    @Field() 
    @MaxLength(16)
    InitiatedByUserID: string;
        
    @Field({description: `Field ApprovalStatus for entity Record Merge Logs.`}) 
    @MaxLength(20)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ApprovedByUserID?: string;
        
    @Field({description: `Field ProcessingStatus for entity Record Merge Logs.`}) 
    @MaxLength(20)
    ProcessingStatus: string;
        
    @Field({description: `Field ProcessingStartedAt for entity Record Merge Logs.`}) 
    @MaxLength(8)
    ProcessingStartedAt: Date;
        
    @Field({nullable: true, description: `Field ProcessingEndedAt for entity Record Merge Logs.`}) 
    @MaxLength(8)
    ProcessingEndedAt?: Date;
        
    @Field({nullable: true, description: `Detailed log of the merge process including field mappings and decisions.`}) 
    ProcessingLog?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    InitiatedByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ApprovedByUser?: string;
        
    @Field(() => [RecordMergeDeletionLog_])
    RecordMergeDeletionLogs_RecordMergeLogIDArray: RecordMergeDeletionLog_[]; // Link to RecordMergeDeletionLogs
    
    @Field(() => [DuplicateRunDetailMatch_])
    DuplicateRunDetailMatches_RecordMergeLogIDArray: DuplicateRunDetailMatch_[]; // Link to DuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for Record Merge Logs
//****************************************************************************
@InputType()
export class CreateRecordMergeLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt: Date | null;

    @Field({ nullable: true })
    ProcessingLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Merge Logs
//****************************************************************************
@InputType()
export class UpdateRecordMergeLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt?: Date | null;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Merge Logs
//****************************************************************************
@ObjectType()
export class RunRecordMergeLogViewResult {
    @Field(() => [RecordMergeLog_])
    Results: RecordMergeLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecordMergeLog_)
export class RecordMergeLogResolver extends ResolverBase {
    @Query(() => RunRecordMergeLogViewResult)
    async RunRecordMergeLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecordMergeLogViewResult)
    async RunRecordMergeLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecordMergeLogViewResult)
    async RunRecordMergeLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Merge Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => RecordMergeLog_, { nullable: true })
    async RecordMergeLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecordMergeLog_ | null> {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Record Merge Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [RecordMergeDeletionLog_])
    async RecordMergeDeletionLogs_RecordMergeLogIDArray(@Root() recordmergelog_: RecordMergeLog_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Deletion Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeDeletionLogs] WHERE [RecordMergeLogID]='${recordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Deletion Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [DuplicateRunDetailMatch_])
    async DuplicateRunDetailMatches_RecordMergeLogIDArray(@Root() recordmergelog_: RecordMergeLog_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [RecordMergeLogID]='${recordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows);
        return result;
    }
        
    @Mutation(() => RecordMergeLog_)
    async CreateRecordMergeLog(
        @Arg('input', () => CreateRecordMergeLogInput) input: CreateRecordMergeLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Merge Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => RecordMergeLog_)
    async UpdateRecordMergeLog(
        @Arg('input', () => UpdateRecordMergeLogInput) input: UpdateRecordMergeLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Merge Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => RecordMergeLog_)
    async DeleteRecordMergeLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Record Merge Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Merge Deletion Logs
//****************************************************************************
@ObjectType({ description: `Tracks records deleted during merge operations, maintaining an audit trail of data consolidation activities.` })
export class RecordMergeDeletionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecordMergeLogID: string;
        
    @Field({description: `Field DeletedRecordID for entity Record Merge Deletion Logs.`}) 
    @MaxLength(1500)
    DeletedRecordID: string;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Field ProcessingLog for entity Record Merge Deletion Logs.`}) 
    ProcessingLog?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class CreateRecordMergeDeletionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class UpdateRecordMergeDeletionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Merge Deletion Logs
//****************************************************************************
@ObjectType()
export class RunRecordMergeDeletionLogViewResult {
    @Field(() => [RecordMergeDeletionLog_])
    Results: RecordMergeDeletionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecordMergeDeletionLog_)
export class RecordMergeDeletionLogResolver extends ResolverBase {
    @Query(() => RunRecordMergeDeletionLogViewResult)
    async RunRecordMergeDeletionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecordMergeDeletionLogViewResult)
    async RunRecordMergeDeletionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecordMergeDeletionLogViewResult)
    async RunRecordMergeDeletionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Merge Deletion Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => RecordMergeDeletionLog_, { nullable: true })
    async RecordMergeDeletionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecordMergeDeletionLog_ | null> {
        this.CheckUserReadPermissions('Record Merge Deletion Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeDeletionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Record Merge Deletion Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => RecordMergeDeletionLog_)
    async CreateRecordMergeDeletionLog(
        @Arg('input', () => CreateRecordMergeDeletionLogInput) input: CreateRecordMergeDeletionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Merge Deletion Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => RecordMergeDeletionLog_)
    async UpdateRecordMergeDeletionLog(
        @Arg('input', () => UpdateRecordMergeDeletionLogInput) input: UpdateRecordMergeDeletionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Merge Deletion Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => RecordMergeDeletionLog_)
    async DeleteRecordMergeDeletionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Record Merge Deletion Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Fields
//****************************************************************************
@ObjectType({ description: `Stores field-level metadata for queries including display names, data types, and formatting rules for result presentation.` })
export class QueryField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Int, {description: `Display order of this field in query results.`}) 
    Sequence: number;
        
    @Field({description: `The base type, not including parameters, in SQL. For example this field would be nvarchar or decimal, and wouldn't include type parameters. The SQLFullType field provides that information.`}) 
    @MaxLength(100)
    SQLBaseType: string;
        
    @Field({description: `The full SQL type for the field, for example datetime or nvarchar(10) etc.`}) 
    @MaxLength(200)
    SQLFullType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SourceEntityID?: string;
        
    @Field({nullable: true, description: `The original field name from the SQL query if different from the display name.`}) 
    @MaxLength(510)
    SourceFieldName?: string;
        
    @Field(() => Boolean, {description: `Indicates if this field is calculated from other fields rather than directly from the database.`}) 
    IsComputed: boolean;
        
    @Field({nullable: true, description: `Explanation of how this computed field is calculated.`}) 
    ComputationDescription?: string;
        
    @Field(() => Boolean, {description: `Whether this field represents an aggregate or summary value.`}) 
    IsSummary: boolean;
        
    @Field({nullable: true, description: `Description of what this summary field represents and how it's aggregated.`}) 
    SummaryDescription?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates how this field was identified in the query output. "AI" means the QueryEntityServer used LLM analysis to parse the SELECT clause and determine field names, types, and their source entities/columns. This includes handling aliased columns, computed expressions, aggregations, and CASE statements. "Manual" means a user explicitly defined this output field. AI detection ensures the field list stays synchronized with query changes.`}) 
    @MaxLength(100)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was about this field detection. Only populated when DetectionMethod="AI". Factors include: clarity of the SELECT clause, complexity of any expressions or transformations, confidence in type inference, and ability to trace back to source entity/column. Complex computed fields or ambiguous aliases result in lower scores. This helps identify fields that may need manual verification.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Fields
//****************************************************************************
@InputType()
export class CreateQueryFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID: string | null;

    @Field({ nullable: true })
    SourceFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Query Fields
//****************************************************************************
@InputType()
export class UpdateQueryFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID?: string | null;

    @Field({ nullable: true })
    SourceFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription?: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Fields
//****************************************************************************
@ObjectType()
export class RunQueryFieldViewResult {
    @Field(() => [QueryField_])
    Results: QueryField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryField_)
export class QueryFieldResolver extends ResolverBase {
    @Query(() => RunQueryFieldViewResult)
    async RunQueryFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryFieldViewResult)
    async RunQueryFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryFieldViewResult)
    async RunQueryFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => QueryField_, { nullable: true })
    async QueryField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryField_ | null> {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Query Fields', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => QueryField_)
    async CreateQueryField(
        @Arg('input', () => CreateQueryFieldInput) input: CreateQueryFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => QueryField_)
    async UpdateQueryField(
        @Arg('input', () => UpdateQueryFieldInput) input: UpdateQueryFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => QueryField_)
    async DeleteQueryField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Categories
//****************************************************************************
@ObjectType({ description: `Organizes saved queries into categories for discovery and management, supporting folder-like organization of queries.` })
export class QueryCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Default cache setting for queries in this category`}) 
    DefaultCacheEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Default TTL in minutes for cached results of queries in this category`}) 
    DefaultCacheTTLMinutes?: number;
        
    @Field(() => Int, {nullable: true, description: `Default maximum cache size for queries in this category`}) 
    DefaultCacheMaxSize?: number;
        
    @Field(() => Boolean, {description: `When true, queries without cache config will inherit from this category`}) 
    CacheInheritanceEnabled: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [QueryCategory_])
    QueryCategories_ParentIDArray: QueryCategory_[]; // Link to QueryCategories
    
    @Field(() => [Query_])
    Queries_CategoryIDArray: Query_[]; // Link to Queries
    
}

//****************************************************************************
// INPUT TYPE for Query Categories
//****************************************************************************
@InputType()
export class CreateQueryCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    DefaultCacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    DefaultCacheTTLMinutes: number | null;

    @Field(() => Int, { nullable: true })
    DefaultCacheMaxSize: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheInheritanceEnabled?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Query Categories
//****************************************************************************
@InputType()
export class UpdateQueryCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    DefaultCacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    DefaultCacheTTLMinutes?: number | null;

    @Field(() => Int, { nullable: true })
    DefaultCacheMaxSize?: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheInheritanceEnabled?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Categories
//****************************************************************************
@ObjectType()
export class RunQueryCategoryViewResult {
    @Field(() => [QueryCategory_])
    Results: QueryCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryCategory_)
export class QueryCategoryResolver extends ResolverBase {
    @Query(() => RunQueryCategoryViewResult)
    async RunQueryCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryCategoryViewResult)
    async RunQueryCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryCategoryViewResult)
    async RunQueryCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => QueryCategory_, { nullable: true })
    async QueryCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryCategory_ | null> {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Query Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [QueryCategory_])
    async QueryCategories_ParentIDArray(@Root() querycategory_: QueryCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [ParentID]='${querycategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [Query_])
    async Queries_CategoryIDArray(@Root() querycategory_: QueryCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [CategoryID]='${querycategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Queries', rows);
        return result;
    }
        
    @Mutation(() => QueryCategory_)
    async CreateQueryCategory(
        @Arg('input', () => CreateQueryCategoryInput) input: CreateQueryCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => QueryCategory_)
    async UpdateQueryCategory(
        @Arg('input', () => UpdateQueryCategoryInput) input: UpdateQueryCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => QueryCategory_)
    async DeleteQueryCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queries
//****************************************************************************
@ObjectType({ description: `Catalog of stored queries. This is useful for any arbitrary query that is known to be performant and correct and can be reused. Queries can be viewed/run by a user, used programatically via RunQuery, and also used by AI systems for improved reliability instead of dynamically generated SQL. Queries can also improve security since they store the SQL instead of using dynamic SQL.` })
export class Query_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true, description: `The natural language question this query answers, used for AI query selection.`}) 
    UserQuestion?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `The actual SQL query text to execute, may include parameters.`}) 
    SQL?: string;
        
    @Field({nullable: true, description: `Technical documentation of the query logic, performance considerations, and parameter usage.`}) 
    TechnicalDescription?: string;
        
    @Field({nullable: true, description: `The original SQL before any optimization or modification, kept for reference.`}) 
    OriginalSQL?: string;
        
    @Field({nullable: true, description: `User feedback on query accuracy, performance, or suggested improvements.`}) 
    Feedback?: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Value indicating the quality of the query, higher values mean a better quality`}) 
    QualityRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Higher numbers indicate more execution overhead/time required. Useful for planning which queries to use in various scenarios.`}) 
    ExecutionCostRank?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Automatically set to true when the SQL column contains Nunjucks template markers (e.g., {{ paramName }}). This flag is maintained by the QueryEntityServer for performance optimization and discovery purposes. It allows quick filtering of parameterized queries and enables the UI to show parameter inputs only when needed. The system will automatically update this flag when the SQL content changes.`}) 
    UsesTemplate?: boolean;
        
    @Field(() => Boolean, {description: `When true, all executions of this query will be logged to the Audit Log system for tracking and compliance`}) 
    AuditQueryRuns: boolean;
        
    @Field(() => Boolean, {description: `When true, query results will be cached in memory with TTL expiration`}) 
    CacheEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time-to-live in minutes for cached query results. NULL uses default TTL.`}) 
    CacheTTLMinutes?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of cached result sets for this query. NULL uses default size limit.`}) 
    CacheMaxSize?: number;
        
    @Field({nullable: true, description: `Optional JSON-serialized embedding vector for the query, used for similarity search and query analysis`}) 
    EmbeddingVector?: string;
        
    @Field({nullable: true, description: `The AI Model used to generate the embedding vector for this query. Required for vector similarity comparisons.`}) 
    @MaxLength(16)
    EmbeddingModelID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmbeddingModel?: string;
        
    @Field(() => [QueryField_])
    QueryFields_QueryIDArray: QueryField_[]; // Link to QueryFields
    
    @Field(() => [QueryPermission_])
    QueryPermissions_QueryIDArray: QueryPermission_[]; // Link to QueryPermissions
    
    @Field(() => [DataContextItem_])
    DataContextItems_QueryIDArray: DataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [QueryParameter_])
    MJ_QueryParameters_QueryIDArray: QueryParameter_[]; // Link to MJ_QueryParameters
    
    @Field(() => [QueryEntity_])
    QueryEntities_QueryIDArray: QueryEntity_[]; // Link to QueryEntities
    
}

//****************************************************************************
// INPUT TYPE for Queries
//****************************************************************************
@InputType()
export class CreateQueryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserQuestion: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    TechnicalDescription: string | null;

    @Field({ nullable: true })
    OriginalSQL: string | null;

    @Field({ nullable: true })
    Feedback: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank: number | null;

    @Field(() => Boolean, { nullable: true })
    UsesTemplate?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    AuditQueryRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLMinutes: number | null;

    @Field(() => Int, { nullable: true })
    CacheMaxSize: number | null;

    @Field({ nullable: true })
    EmbeddingVector: string | null;

    @Field({ nullable: true })
    EmbeddingModelID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Queries
//****************************************************************************
@InputType()
export class UpdateQueryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserQuestion?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    TechnicalDescription?: string | null;

    @Field({ nullable: true })
    OriginalSQL?: string | null;

    @Field({ nullable: true })
    Feedback?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    UsesTemplate?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    AuditQueryRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLMinutes?: number | null;

    @Field(() => Int, { nullable: true })
    CacheMaxSize?: number | null;

    @Field({ nullable: true })
    EmbeddingVector?: string | null;

    @Field({ nullable: true })
    EmbeddingModelID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queries
//****************************************************************************
@ObjectType()
export class RunQueryViewResult {
    @Field(() => [Query_])
    Results: Query_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Query_)
export class QueryResolver extends ResolverBase {
    @Query(() => RunQueryViewResult)
    async RunQueryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryViewResult)
    async RunQueryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryViewResult)
    async RunQueryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Query_, { nullable: true })
    async Query(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Query_ | null> {
        this.CheckUserReadPermissions('Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Queries', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [QueryField_])
    async QueryFields_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Fields', rows);
        return result;
    }
        
    @FieldResolver(() => [QueryPermission_])
    async QueryPermissions_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [DataContextItem_])
    async DataContextItems_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows);
        return result;
    }
        
    @FieldResolver(() => [QueryParameter_])
    async MJ_QueryParameters_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Parameters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryParameters] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Parameters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Query Parameters', rows);
        return result;
    }
        
    @FieldResolver(() => [QueryEntity_])
    async QueryEntities_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Query Entities', rows);
        return result;
    }
        
    @Mutation(() => Query_)
    async CreateQuery(
        @Arg('input', () => CreateQueryInput) input: CreateQueryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Query_)
    async UpdateQuery(
        @Arg('input', () => UpdateQueryInput) input: UpdateQueryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Query_)
    async DeleteQuery(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Permissions
//****************************************************************************
@ObjectType({ description: `Controls access to queries by defining which users and roles can run specific queries.` })
export class QueryPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Permissions
//****************************************************************************
@InputType()
export class CreateQueryPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Query Permissions
//****************************************************************************
@InputType()
export class UpdateQueryPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Permissions
//****************************************************************************
@ObjectType()
export class RunQueryPermissionViewResult {
    @Field(() => [QueryPermission_])
    Results: QueryPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryPermission_)
export class QueryPermissionResolver extends ResolverBase {
    @Query(() => RunQueryPermissionViewResult)
    async RunQueryPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryPermissionViewResult)
    async RunQueryPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryPermissionViewResult)
    async RunQueryPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => QueryPermission_, { nullable: true })
    async QueryPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryPermission_ | null> {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Query Permissions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => QueryPermission_)
    async CreateQueryPermission(
        @Arg('input', () => CreateQueryPermissionInput) input: CreateQueryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => QueryPermission_)
    async UpdateQueryPermission(
        @Arg('input', () => UpdateQueryPermissionInput) input: UpdateQueryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => QueryPermission_)
    async DeleteQueryPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Vector Indexes
//****************************************************************************
@ObjectType({ description: `Defines vector indexes within a given Vector Database.` })
export class VectorIndex_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(16)
    EmbeddingModelID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(100)
    EmbeddingModel: string;
        
    @Field(() => [EntityRecordDocument_])
    EntityRecordDocuments_VectorIndexIDArray: EntityRecordDocument_[]; // Link to EntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for Vector Indexes
//****************************************************************************
@InputType()
export class CreateVectorIndexInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Vector Indexes
//****************************************************************************
@InputType()
export class UpdateVectorIndexInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Vector Indexes
//****************************************************************************
@ObjectType()
export class RunVectorIndexViewResult {
    @Field(() => [VectorIndex_])
    Results: VectorIndex_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(VectorIndex_)
export class VectorIndexResolver extends ResolverBase {
    @Query(() => RunVectorIndexViewResult)
    async RunVectorIndexViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunVectorIndexViewResult)
    async RunVectorIndexViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunVectorIndexViewResult)
    async RunVectorIndexDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Vector Indexes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => VectorIndex_, { nullable: true })
    async VectorIndex(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<VectorIndex_ | null> {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Vector Indexes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityRecordDocument_])
    async EntityRecordDocuments_VectorIndexIDArray(@Root() vectorindex_: VectorIndex_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [VectorIndexID]='${vectorindex_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows);
        return result;
    }
        
    @Mutation(() => VectorIndex_)
    async CreateVectorIndex(
        @Arg('input', () => CreateVectorIndexInput) input: CreateVectorIndexInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Vector Indexes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => VectorIndex_)
    async UpdateVectorIndex(
        @Arg('input', () => UpdateVectorIndexInput) input: UpdateVectorIndexInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Vector Indexes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => VectorIndex_)
    async DeleteVectorIndex(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Vector Indexes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Types
//****************************************************************************
@ObjectType({ description: `Defines types of documents that can be generated from entity data.` })
export class EntityDocumentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityDocument_])
    EntityDocuments_TypeIDArray: EntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Entity Document Types
//****************************************************************************
@InputType()
export class CreateEntityDocumentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Types
//****************************************************************************
@InputType()
export class UpdateEntityDocumentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Types
//****************************************************************************
@ObjectType()
export class RunEntityDocumentTypeViewResult {
    @Field(() => [EntityDocumentType_])
    Results: EntityDocumentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityDocumentType_)
export class EntityDocumentTypeResolver extends ResolverBase {
    @Query(() => RunEntityDocumentTypeViewResult)
    async RunEntityDocumentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentTypeViewResult)
    async RunEntityDocumentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentTypeViewResult)
    async RunEntityDocumentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityDocumentType_, { nullable: true })
    async EntityDocumentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityDocumentType_ | null> {
        this.CheckUserReadPermissions('Entity Document Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Document Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_TypeIDArray(@Root() entitydocumenttype_: EntityDocumentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [TypeID]='${entitydocumenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @Mutation(() => EntityDocumentType_)
    async CreateEntityDocumentType(
        @Arg('input', () => CreateEntityDocumentTypeInput) input: CreateEntityDocumentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityDocumentType_)
    async UpdateEntityDocumentType(
        @Arg('input', () => UpdateEntityDocumentTypeInput) input: UpdateEntityDocumentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityDocumentType_)
    async DeleteEntityDocumentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Runs
//****************************************************************************
@ObjectType({ description: `Records execution history of document generation processes for entity records, tracking status, timing, and output details.` })
export class EntityDocumentRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({description: `Can be Pending, In Progress, Completed, or Failed`}) 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Document Runs
//****************************************************************************
@InputType()
export class CreateEntityDocumentRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Runs
//****************************************************************************
@InputType()
export class UpdateEntityDocumentRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Runs
//****************************************************************************
@ObjectType()
export class RunEntityDocumentRunViewResult {
    @Field(() => [EntityDocumentRun_])
    Results: EntityDocumentRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityDocumentRun_)
export class EntityDocumentRunResolver extends ResolverBase {
    @Query(() => RunEntityDocumentRunViewResult)
    async RunEntityDocumentRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentRunViewResult)
    async RunEntityDocumentRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentRunViewResult)
    async RunEntityDocumentRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityDocumentRun_, { nullable: true })
    async EntityDocumentRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityDocumentRun_ | null> {
        this.CheckUserReadPermissions('Entity Document Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Document Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EntityDocumentRun_)
    async CreateEntityDocumentRun(
        @Arg('input', () => CreateEntityDocumentRunInput) input: CreateEntityDocumentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityDocumentRun_)
    async UpdateEntityDocumentRun(
        @Arg('input', () => UpdateEntityDocumentRunInput) input: UpdateEntityDocumentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityDocumentRun_)
    async DeleteEntityDocumentRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Vector Databases
//****************************************************************************
@ObjectType({ description: `Configures connections to vector database systems for AI embeddings, similarity search, and semantic operations.` })
export class VectorDatabase_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Field DefaultURL for entity Vector Databases.`}) 
    @MaxLength(510)
    DefaultURL?: string;
        
    @Field({nullable: true, description: `Field ClassKey for entity Vector Databases.`}) 
    @MaxLength(200)
    ClassKey?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [VectorIndex_])
    VectorIndexes_VectorDatabaseIDArray: VectorIndex_[]; // Link to VectorIndexes
    
    @Field(() => [EntityDocument_])
    EntityDocuments_IDArray: EntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Vector Databases
//****************************************************************************
@InputType()
export class CreateVectorDatabaseInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultURL: string | null;

    @Field({ nullable: true })
    ClassKey: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Vector Databases
//****************************************************************************
@InputType()
export class UpdateVectorDatabaseInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultURL?: string | null;

    @Field({ nullable: true })
    ClassKey?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Vector Databases
//****************************************************************************
@ObjectType()
export class RunVectorDatabaseViewResult {
    @Field(() => [VectorDatabase_])
    Results: VectorDatabase_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(VectorDatabase_)
export class VectorDatabaseResolver extends ResolverBase {
    @Query(() => RunVectorDatabaseViewResult)
    async RunVectorDatabaseViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunVectorDatabaseViewResult)
    async RunVectorDatabaseViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunVectorDatabaseViewResult)
    async RunVectorDatabaseDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Vector Databases';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => VectorDatabase_, { nullable: true })
    async VectorDatabase(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<VectorDatabase_ | null> {
        this.CheckUserReadPermissions('Vector Databases', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorDatabases] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Databases', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Vector Databases', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [VectorIndex_])
    async VectorIndexes_VectorDatabaseIDArray(@Root() vectordatabase_: VectorDatabase_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [VectorDatabaseID]='${vectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Vector Indexes', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_IDArray(@Root() vectordatabase_: VectorDatabase_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [ID]='${vectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @Mutation(() => VectorDatabase_)
    async CreateVectorDatabase(
        @Arg('input', () => CreateVectorDatabaseInput) input: CreateVectorDatabaseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Vector Databases', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => VectorDatabase_)
    async UpdateVectorDatabase(
        @Arg('input', () => UpdateVectorDatabaseInput) input: UpdateVectorDatabaseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Vector Databases', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => VectorDatabase_)
    async DeleteVectorDatabase(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Vector Databases', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Record Documents
//****************************************************************************
@ObjectType({ description: `Stores the output for a given entity record for a specific Entity Document. For example if a "Person" entity had a particular template that outputted First and Last name like "#{{FirstName}}\n#{{LastName}}" the Entity Record Document would have a row for each entity record in the Person entity that was run through that particular document and have row values such as "#Jane\n#Doe" and "#Mark\n#Smith".` })
export class EntityRecordDocument_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the entity record this document was generated for.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field({nullable: true, description: `The generated document text after template processing.`}) 
    DocumentText?: string;
        
    @Field() 
    @MaxLength(16)
    VectorIndexID: string;
        
    @Field({nullable: true, description: `Reference to the vector embedding of this document if AI search is enabled.`}) 
    @MaxLength(100)
    VectorID?: string;
        
    @Field({nullable: true, description: `JSON representation of the vector embedding for this document.`}) 
    VectorJSON?: string;
        
    @Field({description: `Timestamp of when the source entity record was last updated.`}) 
    @MaxLength(8)
    EntityRecordUpdatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
    @Field() 
    @MaxLength(510)
    VectorIndex: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Record Documents
//****************************************************************************
@InputType()
export class CreateEntityRecordDocumentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID: string | null;

    @Field({ nullable: true })
    VectorJSON: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Entity Record Documents
//****************************************************************************
@InputType()
export class UpdateEntityRecordDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText?: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID?: string | null;

    @Field({ nullable: true })
    VectorJSON?: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Record Documents
//****************************************************************************
@ObjectType()
export class RunEntityRecordDocumentViewResult {
    @Field(() => [EntityRecordDocument_])
    Results: EntityRecordDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityRecordDocument_)
export class EntityRecordDocumentResolver extends ResolverBase {
    @Query(() => RunEntityRecordDocumentViewResult)
    async RunEntityRecordDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityRecordDocumentViewResult)
    async RunEntityRecordDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityRecordDocumentViewResult)
    async RunEntityRecordDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Record Documents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityRecordDocument_, { nullable: true })
    async EntityRecordDocument(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityRecordDocument_ | null> {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Record Documents', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EntityRecordDocument_)
    async CreateEntityRecordDocument(
        @Arg('input', () => CreateEntityRecordDocumentInput) input: CreateEntityRecordDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Record Documents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityRecordDocument_)
    async UpdateEntityRecordDocument(
        @Arg('input', () => UpdateEntityRecordDocumentInput) input: UpdateEntityRecordDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Record Documents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityRecordDocument_)
    async DeleteEntityRecordDocument(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Record Documents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Documents
//****************************************************************************
@ObjectType({ description: `Stores templates for converting structured entity data into unstructured documents.` })
export class EntityDocument_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(500)
    Name: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered a potential matching record. Value must be <= AbsoluteMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    PotentialMatchThreshold: number;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered an absolute matching record. Value must be >= PotentialMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    AbsoluteMatchThreshold: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field(() => [EntityDocumentRun_])
    EntityDocumentRuns_EntityDocumentIDArray: EntityDocumentRun_[]; // Link to EntityDocumentRuns
    
    @Field(() => [EntityDocumentSetting_])
    EntityDocumentSettings_EntityDocumentIDArray: EntityDocumentSetting_[]; // Link to EntityDocumentSettings
    
    @Field(() => [EntityRecordDocument_])
    EntityRecordDocuments_EntityDocumentIDArray: EntityRecordDocument_[]; // Link to EntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for Entity Documents
//****************************************************************************
@InputType()
export class CreateEntityDocumentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Documents
//****************************************************************************
@InputType()
export class UpdateEntityDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Documents
//****************************************************************************
@ObjectType()
export class RunEntityDocumentViewResult {
    @Field(() => [EntityDocument_])
    Results: EntityDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityDocument_)
export class EntityDocumentResolver extends ResolverBase {
    @Query(() => RunEntityDocumentViewResult)
    async RunEntityDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentViewResult)
    async RunEntityDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentViewResult)
    async RunEntityDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Documents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityDocument_, { nullable: true })
    async EntityDocument(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityDocument_ | null> {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Documents', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityDocumentRun_])
    async EntityDocumentRuns_EntityDocumentIDArray(@Root() entitydocument_: EntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Document Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentRuns] WHERE [EntityDocumentID]='${entitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Document Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityDocumentSetting_])
    async EntityDocumentSettings_EntityDocumentIDArray(@Root() entitydocument_: EntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Document Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentSettings] WHERE [EntityDocumentID]='${entitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Document Settings', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityRecordDocument_])
    async EntityRecordDocuments_EntityDocumentIDArray(@Root() entitydocument_: EntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [EntityDocumentID]='${entitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows);
        return result;
    }
        
    @Mutation(() => EntityDocument_)
    async CreateEntityDocument(
        @Arg('input', () => CreateEntityDocumentInput) input: CreateEntityDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Documents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityDocument_)
    async UpdateEntityDocument(
        @Arg('input', () => UpdateEntityDocumentInput) input: UpdateEntityDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Documents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityDocument_)
    async DeleteEntityDocument(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Documents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Data Context Items
//****************************************************************************
@ObjectType({ description: `Data Context Items store information about each item within a Data Context. Each item stores a link to a view, query, or raw sql statement and can optionally cache the JSON representing the last run of that data object as well.` })
export class DataContextItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DataContextID: string;
        
    @Field({description: `The type of the item, either "view", "query", "full_entity", "single_record", or "sql"`}) 
    @MaxLength(100)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    QueryID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `The Primary Key value for the record, only used when Type='single_record'`}) 
    @MaxLength(900)
    RecordID?: string;
        
    @Field({nullable: true, description: `Only used when Type=sql`}) 
    SQL?: string;
        
    @Field({nullable: true, description: `Optionally used to cache results of an item. This can be used for performance optimization, and also for having snapshots of data for historical comparisons.`}) 
    DataJSON?: string;
        
    @Field({nullable: true, description: `If DataJSON is populated, this field will show the date the the data was captured`}) 
    @MaxLength(8)
    LastRefreshedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Optional programmatic identifier for this data context item. Must be unique within the DataContext and follow JavaScript naming conventions (letters, numbers, underscore, starting with letter or underscore). Used for improved code generation and programmatic access to data context items.`}) 
    @MaxLength(510)
    CodeName?: string;
        
    @Field() 
    @MaxLength(510)
    DataContext: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    View?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Query?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Data Context Items
//****************************************************************************
@InputType()
export class CreateDataContextItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID: string | null;

    @Field({ nullable: true })
    QueryID: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    DataJSON: string | null;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CodeName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Data Context Items
//****************************************************************************
@InputType()
export class UpdateDataContextItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID?: string | null;

    @Field({ nullable: true })
    QueryID?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    DataJSON?: string | null;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CodeName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Data Context Items
//****************************************************************************
@ObjectType()
export class RunDataContextItemViewResult {
    @Field(() => [DataContextItem_])
    Results: DataContextItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DataContextItem_)
export class DataContextItemResolver extends ResolverBase {
    @Query(() => RunDataContextItemViewResult)
    async RunDataContextItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDataContextItemViewResult)
    async RunDataContextItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDataContextItemViewResult)
    async RunDataContextItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Data Context Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DataContextItem_, { nullable: true })
    async DataContextItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DataContextItem_ | null> {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Data Context Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => DataContextItem_)
    async CreateDataContextItem(
        @Arg('input', () => CreateDataContextItemInput) input: CreateDataContextItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Data Context Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DataContextItem_)
    async UpdateDataContextItem(
        @Arg('input', () => UpdateDataContextItemInput) input: UpdateDataContextItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Data Context Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DataContextItem_)
    async DeleteDataContextItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Data Context Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Data Contexts
//****************************************************************************
@ObjectType({ description: `Data Contexts are a primitive within the MemberJunction architecture. They store information about data contexts which are groups of data including views, queries, or raw SQL statements. Data contexts can be used in conversations, reports and more.` })
export class DataContext_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `Timestamp of when the data in this context was last refreshed or recalculated.`}) 
    @MaxLength(8)
    LastRefreshedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [DataContextItem_])
    DataContextItems_DataContextIDArray: DataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [Report_])
    Reports_DataContextIDArray: Report_[]; // Link to Reports
    
    @Field(() => [Conversation_])
    Conversations_DataContextIDArray: Conversation_[]; // Link to Conversations
    
}

//****************************************************************************
// INPUT TYPE for Data Contexts
//****************************************************************************
@InputType()
export class CreateDataContextInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for Data Contexts
//****************************************************************************
@InputType()
export class UpdateDataContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Data Contexts
//****************************************************************************
@ObjectType()
export class RunDataContextViewResult {
    @Field(() => [DataContext_])
    Results: DataContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DataContext_)
export class DataContextResolver extends ResolverBase {
    @Query(() => RunDataContextViewResult)
    async RunDataContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDataContextViewResult)
    async RunDataContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDataContextViewResult)
    async RunDataContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Data Contexts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DataContext_, { nullable: true })
    async DataContext(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DataContext_ | null> {
        this.CheckUserReadPermissions('Data Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContexts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Data Contexts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [DataContextItem_])
    async DataContextItems_DataContextIDArray(@Root() datacontext_: DataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [DataContextID]='${datacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows);
        return result;
    }
        
    @FieldResolver(() => [Report_])
    async Reports_DataContextIDArray(@Root() datacontext_: DataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [DataContextID]='${datacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @FieldResolver(() => [Conversation_])
    async Conversations_DataContextIDArray(@Root() datacontext_: DataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [DataContextID]='${datacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', rows);
        return result;
    }
        
    @Mutation(() => DataContext_)
    async CreateDataContext(
        @Arg('input', () => CreateDataContextInput) input: CreateDataContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Data Contexts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DataContext_)
    async UpdateDataContext(
        @Arg('input', () => UpdateDataContextInput) input: UpdateDataContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Data Contexts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DataContext_)
    async DeleteDataContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Data Contexts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Categories
//****************************************************************************
@ObjectType({ description: `Organizes user-created views into categories for personal organization and sharing within teams.` })
export class UserViewCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [UserViewCategory_])
    UserViewCategories_ParentIDArray: UserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [UserView_])
    UserViews_CategoryIDArray: UserView_[]; // Link to UserViews
    
}

//****************************************************************************
// INPUT TYPE for User View Categories
//****************************************************************************
@InputType()
export class CreateUserViewCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Categories
//****************************************************************************
@InputType()
export class UpdateUserViewCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Categories
//****************************************************************************
@ObjectType()
export class RunUserViewCategoryViewResult {
    @Field(() => [UserViewCategory_])
    Results: UserViewCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserViewCategory_)
export class UserViewCategoryResolver extends ResolverBase {
    @Query(() => RunUserViewCategoryViewResult)
    async RunUserViewCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewCategoryViewResult)
    async RunUserViewCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunUserViewCategoryViewResult)
    async RunUserViewCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => UserViewCategory_, { nullable: true })
    async UserViewCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserViewCategory_ | null> {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('User View Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [UserViewCategory_])
    async UserViewCategories_ParentIDArray(@Root() userviewcategory_: UserViewCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [ParentID]='${userviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [UserView_])
    async UserViews_CategoryIDArray(@Root() userviewcategory_: UserViewCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [CategoryID]='${userviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', rows);
        return result;
    }
        
    @Mutation(() => UserViewCategory_)
    async CreateUserViewCategory(
        @Arg('input', () => CreateUserViewCategoryInput) input: CreateUserViewCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => UserViewCategory_)
    async UpdateUserViewCategory(
        @Arg('input', () => UpdateUserViewCategoryInput) input: UpdateUserViewCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => UserViewCategory_)
    async DeleteUserViewCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User View Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dashboard Categories
//****************************************************************************
@ObjectType({ description: `Organizes dashboards into logical groupings for navigation and access control, supporting hierarchical categorization.` })
export class DashboardCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [Dashboard_])
    Dashboards_CategoryIDArray: Dashboard_[]; // Link to Dashboards
    
    @Field(() => [DashboardCategory_])
    DashboardCategories_ParentIDArray: DashboardCategory_[]; // Link to DashboardCategories
    
}

//****************************************************************************
// INPUT TYPE for Dashboard Categories
//****************************************************************************
@InputType()
export class CreateDashboardCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Dashboard Categories
//****************************************************************************
@InputType()
export class UpdateDashboardCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dashboard Categories
//****************************************************************************
@ObjectType()
export class RunDashboardCategoryViewResult {
    @Field(() => [DashboardCategory_])
    Results: DashboardCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DashboardCategory_)
export class DashboardCategoryResolver extends ResolverBase {
    @Query(() => RunDashboardCategoryViewResult)
    async RunDashboardCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDashboardCategoryViewResult)
    async RunDashboardCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDashboardCategoryViewResult)
    async RunDashboardCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dashboard Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DashboardCategory_, { nullable: true })
    async DashboardCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DashboardCategory_ | null> {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Dashboard Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Dashboard_])
    async Dashboards_CategoryIDArray(@Root() dashboardcategory_: DashboardCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [CategoryID]='${dashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboards', rows);
        return result;
    }
        
    @FieldResolver(() => [DashboardCategory_])
    async DashboardCategories_ParentIDArray(@Root() dashboardcategory_: DashboardCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [ParentID]='${dashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboard Categories', rows);
        return result;
    }
        
    @Mutation(() => DashboardCategory_)
    async CreateDashboardCategory(
        @Arg('input', () => CreateDashboardCategoryInput) input: CreateDashboardCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Dashboard Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DashboardCategory_)
    async UpdateDashboardCategory(
        @Arg('input', () => UpdateDashboardCategoryInput) input: UpdateDashboardCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Dashboard Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DashboardCategory_)
    async DeleteDashboardCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dashboard Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Report Categories
//****************************************************************************
@ObjectType({ description: `Organizes reports into logical groupings for navigation, access control, and discovery within the reporting system.` })
export class ReportCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [ReportCategory_])
    ReportCategories_ParentIDArray: ReportCategory_[]; // Link to ReportCategories
    
    @Field(() => [Report_])
    Reports_CategoryIDArray: Report_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Report Categories
//****************************************************************************
@InputType()
export class CreateReportCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Report Categories
//****************************************************************************
@InputType()
export class UpdateReportCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Report Categories
//****************************************************************************
@ObjectType()
export class RunReportCategoryViewResult {
    @Field(() => [ReportCategory_])
    Results: ReportCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ReportCategory_)
export class ReportCategoryResolver extends ResolverBase {
    @Query(() => RunReportCategoryViewResult)
    async RunReportCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportCategoryViewResult)
    async RunReportCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportCategoryViewResult)
    async RunReportCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Report Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ReportCategory_, { nullable: true })
    async ReportCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ReportCategory_ | null> {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Report Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ReportCategory_])
    async ReportCategories_ParentIDArray(@Root() reportcategory_: ReportCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [ParentID]='${reportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Report Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [Report_])
    async Reports_CategoryIDArray(@Root() reportcategory_: ReportCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [CategoryID]='${reportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', rows);
        return result;
    }
        
    @Mutation(() => ReportCategory_)
    async CreateReportCategory(
        @Arg('input', () => CreateReportCategoryInput) input: CreateReportCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Report Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ReportCategory_)
    async UpdateReportCategory(
        @Arg('input', () => UpdateReportCategoryInput) input: UpdateReportCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Report Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ReportCategory_)
    async DeleteReportCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Report Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Storage Providers
//****************************************************************************
@ObjectType({ description: `Configures connections to file storage systems including local, cloud, and network storage with authentication and access rules.` })
export class FileStorageProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Identifier for the server-side driver implementation for this storage provider.`}) 
    @MaxLength(200)
    ServerDriverKey: string;
        
    @Field({description: `Identifier for the client-side driver implementation for this storage provider.`}) 
    @MaxLength(200)
    ClientDriverKey: string;
        
    @Field(() => Int, {description: `Priority order for selecting storage providers, lower numbers are preferred.`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `Whether this storage provider is currently available for use.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [File_])
    Files_ProviderIDArray: File_[]; // Link to Files
    
}

//****************************************************************************
// INPUT TYPE for File Storage Providers
//****************************************************************************
@InputType()
export class CreateFileStorageProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for File Storage Providers
//****************************************************************************
@InputType()
export class UpdateFileStorageProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Storage Providers
//****************************************************************************
@ObjectType()
export class RunFileStorageProviderViewResult {
    @Field(() => [FileStorageProvider_])
    Results: FileStorageProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(FileStorageProvider_)
export class FileStorageProviderResolver extends ResolverBase {
    @Query(() => RunFileStorageProviderViewResult)
    async RunFileStorageProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunFileStorageProviderViewResult)
    async RunFileStorageProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunFileStorageProviderViewResult)
    async RunFileStorageProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Storage Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => FileStorageProvider_, { nullable: true })
    async FileStorageProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<FileStorageProvider_ | null> {
        this.CheckUserReadPermissions('File Storage Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileStorageProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Storage Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('File Storage Providers', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [File_])
    async Files_ProviderIDArray(@Root() filestorageprovider_: FileStorageProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [ProviderID]='${filestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Files', rows);
        return result;
    }
        
    @Mutation(() => FileStorageProvider_)
    async CreateFileStorageProvider(
        @Arg('input', () => CreateFileStorageProviderInput) input: CreateFileStorageProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Storage Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => FileStorageProvider_)
    async UpdateFileStorageProvider(
        @Arg('input', () => UpdateFileStorageProviderInput) input: UpdateFileStorageProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Storage Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => FileStorageProvider_)
    async DeleteFileStorageProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Storage Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Files
//****************************************************************************
@ObjectType({ description: `Manages file metadata, storage locations, and access control for all files stored within or referenced by the system.` })
export class File_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(1000)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(16)
    ProviderID: string;
        
    @Field({nullable: true, description: `MIME type of the file content (e.g., image/jpeg, application/pdf).`}) 
    @MaxLength(510)
    ContentType?: string;
        
    @Field({nullable: true, description: `Storage provider-specific identifier or path for this file.`}) 
    @MaxLength(1000)
    ProviderKey?: string;
        
    @Field({description: `Pending, Uploading, Uploaded, Deleting, Deleted`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(100)
    Provider: string;
        
    @Field(() => [FileEntityRecordLink_])
    FileEntityRecordLinks_FileIDArray: FileEntityRecordLink_[]; // Link to FileEntityRecordLinks
    
}

//****************************************************************************
// INPUT TYPE for Files
//****************************************************************************
@InputType()
export class CreateFileInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType: string | null;

    @Field({ nullable: true })
    ProviderKey: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Files
//****************************************************************************
@InputType()
export class UpdateFileInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType?: string | null;

    @Field({ nullable: true })
    ProviderKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Files
//****************************************************************************
@ObjectType()
export class RunFileViewResult {
    @Field(() => [File_])
    Results: File_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(File_)
export class FileResolver extends ResolverBase {
    @Query(() => RunFileViewResult)
    async RunFileViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunFileViewResult)
    async RunFileViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunFileViewResult)
    async RunFileDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Files';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => File_, { nullable: true })
    async File(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<File_ | null> {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Files', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [FileEntityRecordLink_])
    async FileEntityRecordLinks_FileIDArray(@Root() file_: File_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [FileID]='${file_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('File Entity Record Links', rows);
        return result;
    }
        
    @Mutation(() => File_)
    async CreateFile(
        @Arg('input', () => CreateFileInput) input: CreateFileInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Files', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => File_)
    async UpdateFile(
        @Arg('input', () => UpdateFileInput) input: UpdateFileInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Files', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => File_)
    async DeleteFile(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Files', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Categories
//****************************************************************************
@ObjectType({ description: `Organizes files into categories for classification, access control, and lifecycle management across the file storage system.` })
export class FileCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [File_])
    Files_CategoryIDArray: File_[]; // Link to Files
    
    @Field(() => [FileCategory_])
    FileCategories_ParentIDArray: FileCategory_[]; // Link to FileCategories
    
}

//****************************************************************************
// INPUT TYPE for File Categories
//****************************************************************************
@InputType()
export class CreateFileCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for File Categories
//****************************************************************************
@InputType()
export class UpdateFileCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Categories
//****************************************************************************
@ObjectType()
export class RunFileCategoryViewResult {
    @Field(() => [FileCategory_])
    Results: FileCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(FileCategory_)
export class FileCategoryResolver extends ResolverBase {
    @Query(() => RunFileCategoryViewResult)
    async RunFileCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunFileCategoryViewResult)
    async RunFileCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunFileCategoryViewResult)
    async RunFileCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => FileCategory_, { nullable: true })
    async FileCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<FileCategory_ | null> {
        this.CheckUserReadPermissions('File Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('File Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [File_])
    async Files_CategoryIDArray(@Root() filecategory_: FileCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [CategoryID]='${filecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Files', rows);
        return result;
    }
        
    @FieldResolver(() => [FileCategory_])
    async FileCategories_ParentIDArray(@Root() filecategory_: FileCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileCategories] WHERE [ParentID]='${filecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('File Categories', rows);
        return result;
    }
        
    @Mutation(() => FileCategory_)
    async CreateFileCategory(
        @Arg('input', () => CreateFileCategoryInput) input: CreateFileCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => FileCategory_)
    async UpdateFileCategory(
        @Arg('input', () => UpdateFileCategoryInput) input: UpdateFileCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => FileCategory_)
    async DeleteFileCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Entity Record Links
//****************************************************************************
@ObjectType({ description: `Associates files with entity records, enabling attachment management and document relationships throughout the system.` })
export class FileEntityRecordLink_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    FileID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the entity record this file is attached to.`}) 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    File: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for File Entity Record Links
//****************************************************************************
@InputType()
export class CreateFileEntityRecordLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for File Entity Record Links
//****************************************************************************
@InputType()
export class UpdateFileEntityRecordLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Entity Record Links
//****************************************************************************
@ObjectType()
export class RunFileEntityRecordLinkViewResult {
    @Field(() => [FileEntityRecordLink_])
    Results: FileEntityRecordLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(FileEntityRecordLink_)
export class FileEntityRecordLinkResolver extends ResolverBase {
    @Query(() => RunFileEntityRecordLinkViewResult)
    async RunFileEntityRecordLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunFileEntityRecordLinkViewResult)
    async RunFileEntityRecordLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunFileEntityRecordLinkViewResult)
    async RunFileEntityRecordLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Entity Record Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => FileEntityRecordLink_, { nullable: true })
    async FileEntityRecordLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<FileEntityRecordLink_ | null> {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('File Entity Record Links', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => FileEntityRecordLink_)
    async CreateFileEntityRecordLink(
        @Arg('input', () => CreateFileEntityRecordLinkInput) input: CreateFileEntityRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Entity Record Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => FileEntityRecordLink_)
    async UpdateFileEntityRecordLink(
        @Arg('input', () => UpdateFileEntityRecordLinkInput) input: UpdateFileEntityRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Entity Record Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => FileEntityRecordLink_)
    async DeleteFileEntityRecordLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Entity Record Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Version Installations
//****************************************************************************
@ObjectType({ description: `Records installation history of system versions, tracking deployments, rollbacks, and version-specific configurations.` })
export class VersionInstallation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field(() => Int, {description: `Major version number installed.`}) 
    MajorVersion: number;
        
    @Field(() => Int, {description: `Minor version number installed.`}) 
    MinorVersion: number;
        
    @Field(() => Int, {description: `Patch version number installed.`}) 
    PatchVersion: number;
        
    @Field({nullable: true, description: `What type of installation was applied`}) 
    @MaxLength(40)
    Type?: string;
        
    @Field({description: `Timestamp when this version was installed.`}) 
    @MaxLength(8)
    InstalledAt: Date;
        
    @Field({description: `Pending, Complete, Failed`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Any logging that was saved from the installation process`}) 
    InstallLog?: string;
        
    @Field({nullable: true, description: `Optional, comments the administrator wants to save for each installed version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(604)
    CompleteVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for Version Installations
//****************************************************************************
@InputType()
export class CreateVersionInstallationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Version Installations
//****************************************************************************
@InputType()
export class UpdateVersionInstallationInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Version Installations
//****************************************************************************
@ObjectType()
export class RunVersionInstallationViewResult {
    @Field(() => [VersionInstallation_])
    Results: VersionInstallation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(VersionInstallation_)
export class VersionInstallationResolver extends ResolverBase {
    @Query(() => RunVersionInstallationViewResult)
    async RunVersionInstallationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunVersionInstallationViewResult)
    async RunVersionInstallationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunVersionInstallationViewResult)
    async RunVersionInstallationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Version Installations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => VersionInstallation_, { nullable: true })
    async VersionInstallation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<VersionInstallation_ | null> {
        this.CheckUserReadPermissions('Version Installations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionInstallations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Version Installations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Version Installations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => VersionInstallation_)
    async CreateVersionInstallation(
        @Arg('input', () => CreateVersionInstallationInput) input: CreateVersionInstallationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Version Installations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => VersionInstallation_)
    async UpdateVersionInstallation(
        @Arg('input', () => UpdateVersionInstallationInput) input: UpdateVersionInstallationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Version Installations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => VersionInstallation_)
    async DeleteVersionInstallation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Version Installations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Run Detail Matches
//****************************************************************************
@ObjectType({ description: `Records individual matching pairs of potentially duplicate records identified during a duplicate detection run with confidence scores.` })
export class DuplicateRunDetailMatch_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DuplicateRunDetailID: string;
        
    @Field({description: `Either Vector or SP`}) 
    @MaxLength(40)
    MatchSource: string;
        
    @Field({description: `The ID of the record identified as a potential duplicate match.`}) 
    @MaxLength(1000)
    MatchRecordID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 designating the computed probability of a match`}) 
    MatchProbability: number;
        
    @Field({description: `Timestamp when this duplicate match was identified.`}) 
    @MaxLength(8)
    MatchedAt: Date;
        
    @Field({description: `The action to take for this match (Ignore, Merge, Delete).`}) 
    @MaxLength(40)
    Action: string;
        
    @Field({description: `Current approval status of the proposed action (Pending, Approved, Rejected).`}) 
    @MaxLength(40)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RecordMergeLogID?: string;
        
    @Field({description: `Status of the merge operation if Action is Merge (Pending, Complete, Failed).`}) 
    @MaxLength(40)
    MergeStatus: string;
        
    @Field({description: `Timestamp when records were merged, if applicable.`}) 
    @MaxLength(8)
    MergedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class CreateDuplicateRunDetailMatchInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class UpdateDuplicateRunDetailMatchInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Run Detail Matches
//****************************************************************************
@ObjectType()
export class RunDuplicateRunDetailMatchViewResult {
    @Field(() => [DuplicateRunDetailMatch_])
    Results: DuplicateRunDetailMatch_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DuplicateRunDetailMatch_)
export class DuplicateRunDetailMatchResolver extends ResolverBase {
    @Query(() => RunDuplicateRunDetailMatchViewResult)
    async RunDuplicateRunDetailMatchViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunDetailMatchViewResult)
    async RunDuplicateRunDetailMatchViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunDetailMatchViewResult)
    async RunDuplicateRunDetailMatchDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Run Detail Matches';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DuplicateRunDetailMatch_, { nullable: true })
    async DuplicateRunDetailMatch(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DuplicateRunDetailMatch_ | null> {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => DuplicateRunDetailMatch_)
    async CreateDuplicateRunDetailMatch(
        @Arg('input', () => CreateDuplicateRunDetailMatchInput) input: CreateDuplicateRunDetailMatchInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Run Detail Matches', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DuplicateRunDetailMatch_)
    async UpdateDuplicateRunDetailMatch(
        @Arg('input', () => UpdateDuplicateRunDetailMatchInput) input: UpdateDuplicateRunDetailMatchInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Run Detail Matches', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DuplicateRunDetailMatch_)
    async DeleteDuplicateRunDetailMatch(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Duplicate Run Detail Matches', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Settings
//****************************************************************************
@ObjectType({ description: `Stores configuration for entity-specific document generation.` })
export class EntityDocumentSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `JSON configuration value for this document generation setting.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Document Settings
//****************************************************************************
@InputType()
export class CreateEntityDocumentSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Settings
//****************************************************************************
@InputType()
export class UpdateEntityDocumentSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Settings
//****************************************************************************
@ObjectType()
export class RunEntityDocumentSettingViewResult {
    @Field(() => [EntityDocumentSetting_])
    Results: EntityDocumentSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityDocumentSetting_)
export class EntityDocumentSettingResolver extends ResolverBase {
    @Query(() => RunEntityDocumentSettingViewResult)
    async RunEntityDocumentSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentSettingViewResult)
    async RunEntityDocumentSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentSettingViewResult)
    async RunEntityDocumentSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityDocumentSetting_, { nullable: true })
    async EntityDocumentSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityDocumentSetting_ | null> {
        this.CheckUserReadPermissions('Entity Document Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Document Settings', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EntityDocumentSetting_)
    async CreateEntityDocumentSetting(
        @Arg('input', () => CreateEntityDocumentSettingInput) input: CreateEntityDocumentSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityDocumentSetting_)
    async UpdateEntityDocumentSetting(
        @Arg('input', () => UpdateEntityDocumentSettingInput) input: UpdateEntityDocumentSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityDocumentSetting_)
    async DeleteEntityDocumentSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Settings
//****************************************************************************
@ObjectType({ description: `Stores entity-specific configuration settings, allowing customization of how entities function.` })
export class EntitySetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The configuration value for this entity setting, often in JSON format.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Settings
//****************************************************************************
@InputType()
export class CreateEntitySettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Settings
//****************************************************************************
@InputType()
export class UpdateEntitySettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Settings
//****************************************************************************
@ObjectType()
export class RunEntitySettingViewResult {
    @Field(() => [EntitySetting_])
    Results: EntitySetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntitySetting_)
export class EntitySettingResolver extends ResolverBase {
    @Query(() => RunEntitySettingViewResult)
    async RunEntitySettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntitySettingViewResult)
    async RunEntitySettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntitySettingViewResult)
    async RunEntitySettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntitySetting_, { nullable: true })
    async EntitySetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntitySetting_ | null> {
        this.CheckUserReadPermissions('Entity Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntitySettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Settings', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EntitySetting_)
    async CreateEntitySetting(
        @Arg('input', () => CreateEntitySettingInput) input: CreateEntitySettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntitySetting_)
    async UpdateEntitySetting(
        @Arg('input', () => UpdateEntitySettingInput) input: UpdateEntitySettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntitySetting_)
    async DeleteEntitySetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Runs
//****************************************************************************
@ObjectType({ description: `Manages execution of duplicate detection processes across entities, tracking configuration, progress, and summary results.` })
export class DuplicateRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    StartedByUserID: string;
        
    @Field() 
    @MaxLength(16)
    SourceListID: string;
        
    @Field() 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({description: `Overall approval status for the duplicate run results (Pending, Approved, Rejected).`}) 
    @MaxLength(40)
    ApprovalStatus: string;
        
    @Field({nullable: true, description: `Comments or notes regarding the approval decision for this duplicate run.`}) 
    ApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ApprovedByUserID?: string;
        
    @Field({description: `Current processing status of the duplicate detection run (Pending, Running, Complete, Failed).`}) 
    @MaxLength(40)
    ProcessingStatus: string;
        
    @Field({nullable: true, description: `Error details if the duplicate detection run failed.`}) 
    ProcessingErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    StartedByUser: string;
        
    @Field() 
    @MaxLength(200)
    SourceList: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ApprovedByUser?: string;
        
    @Field(() => [DuplicateRunDetail_])
    DuplicateRunDetails_DuplicateRunIDArray: DuplicateRunDetail_[]; // Link to DuplicateRunDetails
    
}

//****************************************************************************
// INPUT TYPE for Duplicate Runs
//****************************************************************************
@InputType()
export class CreateDuplicateRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments: string | null;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Runs
//****************************************************************************
@InputType()
export class UpdateDuplicateRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments?: string | null;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Runs
//****************************************************************************
@ObjectType()
export class RunDuplicateRunViewResult {
    @Field(() => [DuplicateRun_])
    Results: DuplicateRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DuplicateRun_)
export class DuplicateRunResolver extends ResolverBase {
    @Query(() => RunDuplicateRunViewResult)
    async RunDuplicateRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunViewResult)
    async RunDuplicateRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunViewResult)
    async RunDuplicateRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DuplicateRun_, { nullable: true })
    async DuplicateRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DuplicateRun_ | null> {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Duplicate Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [DuplicateRunDetail_])
    async DuplicateRunDetails_DuplicateRunIDArray(@Root() duplicaterun_: DuplicateRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetails] WHERE [DuplicateRunID]='${duplicaterun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Details', rows);
        return result;
    }
        
    @Mutation(() => DuplicateRun_)
    async CreateDuplicateRun(
        @Arg('input', () => CreateDuplicateRunInput) input: CreateDuplicateRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DuplicateRun_)
    async UpdateDuplicateRun(
        @Arg('input', () => UpdateDuplicateRunInput) input: UpdateDuplicateRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DuplicateRun_)
    async DeleteDuplicateRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Duplicate Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Run Details
//****************************************************************************
@ObjectType({ description: `Stores detailed results for each record analyzed in a duplicate detection run, including match status and processing metadata.` })
export class DuplicateRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DuplicateRunID: string;
        
    @Field({description: `The ID of the record being analyzed for duplicates.`}) 
    @MaxLength(1000)
    RecordID: string;
        
    @Field({description: `Status of duplicate analysis for this record (Pending, Complete, Error).`}) 
    @MaxLength(40)
    MatchStatus: string;
        
    @Field({nullable: true, description: `If MatchStatus=Skipped, this field can be used to store the reason why the record was skipped`}) 
    SkippedReason?: string;
        
    @Field({nullable: true, description: `If MatchStatus='Error' this field can be used to track the error from that phase of the process for logging/diagnostics.`}) 
    MatchErrorMessage?: string;
        
    @Field({description: `Status of any merge operations for this record (Not Applicable, Pending, Complete, Failed).`}) 
    @MaxLength(40)
    MergeStatus: string;
        
    @Field({nullable: true, description: `Error details if merge operation failed for this record.`}) 
    MergeErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [DuplicateRunDetailMatch_])
    DuplicateRunDetailMatches_DuplicateRunDetailIDArray: DuplicateRunDetailMatch_[]; // Link to DuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for Duplicate Run Details
//****************************************************************************
@InputType()
export class CreateDuplicateRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason: string | null;

    @Field({ nullable: true })
    MatchErrorMessage: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Run Details
//****************************************************************************
@InputType()
export class UpdateDuplicateRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason?: string | null;

    @Field({ nullable: true })
    MatchErrorMessage?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Run Details
//****************************************************************************
@ObjectType()
export class RunDuplicateRunDetailViewResult {
    @Field(() => [DuplicateRunDetail_])
    Results: DuplicateRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DuplicateRunDetail_)
export class DuplicateRunDetailResolver extends ResolverBase {
    @Query(() => RunDuplicateRunDetailViewResult)
    async RunDuplicateRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunDetailViewResult)
    async RunDuplicateRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunDetailViewResult)
    async RunDuplicateRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DuplicateRunDetail_, { nullable: true })
    async DuplicateRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DuplicateRunDetail_ | null> {
        this.CheckUserReadPermissions('Duplicate Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Duplicate Run Details', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [DuplicateRunDetailMatch_])
    async DuplicateRunDetailMatches_DuplicateRunDetailIDArray(@Root() duplicaterundetail_: DuplicateRunDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [DuplicateRunDetailID]='${duplicaterundetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows);
        return result;
    }
        
    @Mutation(() => DuplicateRunDetail_)
    async CreateDuplicateRunDetail(
        @Arg('input', () => CreateDuplicateRunDetailInput) input: CreateDuplicateRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DuplicateRunDetail_)
    async UpdateDuplicateRunDetail(
        @Arg('input', () => UpdateDuplicateRunDetailInput) input: UpdateDuplicateRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DuplicateRunDetail_)
    async DeleteDuplicateRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Duplicate Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Application Settings
//****************************************************************************
@ObjectType({ description: `Stores configuration settings and preferences for applications, including key-value pairs for runtime parameters and user-specific customizations.` })
export class ApplicationSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The setting value, can be simple text, numbers, booleans, or JSON for complex configuration objects.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
}

//****************************************************************************
// INPUT TYPE for Application Settings
//****************************************************************************
@InputType()
export class CreateApplicationSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Application Settings
//****************************************************************************
@InputType()
export class UpdateApplicationSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Application Settings
//****************************************************************************
@ObjectType()
export class RunApplicationSettingViewResult {
    @Field(() => [ApplicationSetting_])
    Results: ApplicationSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ApplicationSetting_)
export class ApplicationSettingResolver extends ResolverBase {
    @Query(() => RunApplicationSettingViewResult)
    async RunApplicationSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunApplicationSettingViewResult)
    async RunApplicationSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunApplicationSettingViewResult)
    async RunApplicationSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Application Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ApplicationSetting_, { nullable: true })
    async ApplicationSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ApplicationSetting_ | null> {
        this.CheckUserReadPermissions('Application Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Application Settings', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ApplicationSetting_)
    async CreateApplicationSetting(
        @Arg('input', () => CreateApplicationSettingInput) input: CreateApplicationSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Application Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ApplicationSetting_)
    async UpdateApplicationSetting(
        @Arg('input', () => UpdateApplicationSettingInput) input: UpdateApplicationSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Application Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ApplicationSetting_)
    async DeleteApplicationSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Application Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Categories
//****************************************************************************
@ObjectType({ description: `Organizes actions into categories, including name, description, and optional parent category for hierarchy.` })
export class ActionCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the action category.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the action category.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Status of the action category (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [ActionCategory_])
    ActionCategories_ParentIDArray: ActionCategory_[]; // Link to ActionCategories
    
    @Field(() => [Action_])
    Actions_CategoryIDArray: Action_[]; // Link to Actions
    
}

//****************************************************************************
// INPUT TYPE for Action Categories
//****************************************************************************
@InputType()
export class CreateActionCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Action Categories
//****************************************************************************
@InputType()
export class UpdateActionCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Categories
//****************************************************************************
@ObjectType()
export class RunActionCategoryViewResult {
    @Field(() => [ActionCategory_])
    Results: ActionCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionCategory_)
export class ActionCategoryResolver extends ResolverBase {
    @Query(() => RunActionCategoryViewResult)
    async RunActionCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionCategoryViewResult)
    async RunActionCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionCategoryViewResult)
    async RunActionCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionCategory_, { nullable: true })
    async ActionCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionCategory_ | null> {
        this.CheckUserReadPermissions('Action Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ActionCategory_])
    async ActionCategories_ParentIDArray(@Root() actioncategory_: ActionCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionCategories] WHERE [ParentID]='${actioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [Action_])
    async Actions_CategoryIDArray(@Root() actioncategory_: ActionCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [CategoryID]='${actioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Actions', rows);
        return result;
    }
        
    @Mutation(() => ActionCategory_)
    async CreateActionCategory(
        @Arg('input', () => CreateActionCategoryInput) input: CreateActionCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionCategory_)
    async UpdateActionCategory(
        @Arg('input', () => UpdateActionCategoryInput) input: UpdateActionCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionCategory_)
    async DeleteActionCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Actions
//****************************************************************************
@ObjectType({ description: `Links entities to actions - this is the main place where you define the actions that part of, or available, for a given entity.` })
export class EntityAction_ {
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Status of the entity action (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [EntityActionInvocation_])
    EntityActionInvocations_EntityActionIDArray: EntityActionInvocation_[]; // Link to EntityActionInvocations
    
    @Field(() => [EntityActionFilter_])
    EntityActionFilters_EntityActionIDArray: EntityActionFilter_[]; // Link to EntityActionFilters
    
    @Field(() => [EntityActionParam_])
    EntityActionParams_EntityActionIDArray: EntityActionParam_[]; // Link to EntityActionParams
    
}

//****************************************************************************
// INPUT TYPE for Entity Actions
//****************************************************************************
@InputType()
export class CreateEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Actions
//****************************************************************************
@InputType()
export class UpdateEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Actions
//****************************************************************************
@ObjectType()
export class RunEntityActionViewResult {
    @Field(() => [EntityAction_])
    Results: EntityAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityAction_)
export class EntityActionResolver extends ResolverBase {
    @Query(() => RunEntityActionViewResult)
    async RunEntityActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionViewResult)
    async RunEntityActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionViewResult)
    async RunEntityActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityAction_, { nullable: true })
    async EntityAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityAction_ | null> {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityActionInvocation_])
    async EntityActionInvocations_EntityActionIDArray(@Root() entityaction_: EntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [EntityActionID]='${entityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Invocations', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityActionFilter_])
    async EntityActionFilters_EntityActionIDArray(@Root() entityaction_: EntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [EntityActionID]='${entityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Filters', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityActionParam_])
    async EntityActionParams_EntityActionIDArray(@Root() entityaction_: EntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [EntityActionID]='${entityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Params', rows);
        return result;
    }
        
    @Mutation(() => EntityAction_)
    async CreateEntityAction(
        @Arg('input', () => CreateEntityActionInput) input: CreateEntityActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityAction_)
    async UpdateEntityAction(
        @Arg('input', () => UpdateEntityActionInput) input: UpdateEntityActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityAction_)
    async DeleteEntityAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Invocations
//****************************************************************************
@ObjectType({ description: `Links invocation types to entity actions – for example you might link a particular EntityAction to just “Create Record” and you might also have a second item in this table allowing the same Entity Action to be invoked from a User View or List, on demand.` })
export class EntityActionInvocation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    InvocationTypeID: string;
        
    @Field({description: `Status of the entity action invocation (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    InvocationType: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Invocations
//****************************************************************************
@InputType()
export class CreateEntityActionInvocationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Invocations
//****************************************************************************
@InputType()
export class UpdateEntityActionInvocationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Invocations
//****************************************************************************
@ObjectType()
export class RunEntityActionInvocationViewResult {
    @Field(() => [EntityActionInvocation_])
    Results: EntityActionInvocation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityActionInvocation_)
export class EntityActionInvocationResolver extends ResolverBase {
    @Query(() => RunEntityActionInvocationViewResult)
    async RunEntityActionInvocationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionInvocationViewResult)
    async RunEntityActionInvocationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionInvocationViewResult)
    async RunEntityActionInvocationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Invocations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityActionInvocation_, { nullable: true })
    async EntityActionInvocation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityActionInvocation_ | null> {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Action Invocations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EntityActionInvocation_)
    async CreateEntityActionInvocation(
        @Arg('input', () => CreateEntityActionInvocationInput) input: CreateEntityActionInvocationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Invocations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityActionInvocation_)
    async UpdateEntityActionInvocation(
        @Arg('input', () => UpdateEntityActionInvocationInput) input: UpdateEntityActionInvocationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Invocations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityActionInvocation_)
    async DeleteEntityActionInvocation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Invocations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Authorizations
//****************************************************************************
@ObjectType({ description: `Links actions to authorizations, one or more of these must be possessed by a user in order to execute the action.` })
export class ActionAuthorization_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(16)
    AuthorizationID: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(200)
    Authorization: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Authorizations
//****************************************************************************
@InputType()
export class CreateActionAuthorizationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Authorizations
//****************************************************************************
@InputType()
export class UpdateActionAuthorizationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Authorizations
//****************************************************************************
@ObjectType()
export class RunActionAuthorizationViewResult {
    @Field(() => [ActionAuthorization_])
    Results: ActionAuthorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionAuthorization_)
export class ActionAuthorizationResolver extends ResolverBase {
    @Query(() => RunActionAuthorizationViewResult)
    async RunActionAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionAuthorizationViewResult)
    async RunActionAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionAuthorizationViewResult)
    async RunActionAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Authorizations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionAuthorization_, { nullable: true })
    async ActionAuthorization(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionAuthorization_ | null> {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Authorizations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ActionAuthorization_)
    async CreateActionAuthorization(
        @Arg('input', () => CreateActionAuthorizationInput) input: CreateActionAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Authorizations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionAuthorization_)
    async UpdateActionAuthorization(
        @Arg('input', () => UpdateActionAuthorizationInput) input: UpdateActionAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Authorizations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionAuthorization_)
    async DeleteActionAuthorization(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Authorizations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Invocation Types
//****************************************************************************
@ObjectType({ description: `Stores the possible invocation types of an action within the context of an entity. Examples would be: Record Created/Updated/Deleted/Accessed as well as things like “View” or “List” where you could run an EntityAction against an entire set of records in a view or list – either by user click or programmatically.` })
export class EntityActionInvocationType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the invocation type such as Record Created/Updated/etc.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the invocation type.`}) 
    Description?: string;
        
    @Field(() => Int, {description: `Order in which this invocation type appears in UI lists and menus.`}) 
    DisplaySequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityActionInvocation_])
    EntityActionInvocations_InvocationTypeIDArray: EntityActionInvocation_[]; // Link to EntityActionInvocations
    
}

//****************************************************************************
// INPUT TYPE for Entity Action Invocation Types
//****************************************************************************
@InputType()
export class CreateEntityActionInvocationTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Invocation Types
//****************************************************************************
@InputType()
export class UpdateEntityActionInvocationTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Invocation Types
//****************************************************************************
@ObjectType()
export class RunEntityActionInvocationTypeViewResult {
    @Field(() => [EntityActionInvocationType_])
    Results: EntityActionInvocationType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityActionInvocationType_)
export class EntityActionInvocationTypeResolver extends ResolverBase {
    @Query(() => RunEntityActionInvocationTypeViewResult)
    async RunEntityActionInvocationTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionInvocationTypeViewResult)
    async RunEntityActionInvocationTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionInvocationTypeViewResult)
    async RunEntityActionInvocationTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Invocation Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityActionInvocationType_, { nullable: true })
    async EntityActionInvocationType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityActionInvocationType_ | null> {
        this.CheckUserReadPermissions('Entity Action Invocation Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocationTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocation Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Action Invocation Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityActionInvocation_])
    async EntityActionInvocations_InvocationTypeIDArray(@Root() entityactioninvocationtype_: EntityActionInvocationType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [InvocationTypeID]='${entityactioninvocationtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Invocations', rows);
        return result;
    }
        
    @Mutation(() => EntityActionInvocationType_)
    async CreateEntityActionInvocationType(
        @Arg('input', () => CreateEntityActionInvocationTypeInput) input: CreateEntityActionInvocationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Invocation Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityActionInvocationType_)
    async UpdateEntityActionInvocationType(
        @Arg('input', () => UpdateEntityActionInvocationTypeInput) input: UpdateEntityActionInvocationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Invocation Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityActionInvocationType_)
    async DeleteEntityActionInvocationType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Invocation Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Actions
//****************************************************************************
@ObjectType({ description: `Stores action definitions, including prompts, generated code, user comments, and status.` })
export class Action_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `The name of the action. Must be unique within the combination of CategoryID and ParentID. Actions with the same name can exist in different categories or under different parents.`}) 
    @MaxLength(850)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Generated or Custom. Generated means the UserPrompt is used to prompt an AI model to automatically create the code for the Action. Custom means that a custom class has been implemented that subclasses the BaseAction class. The custom class needs to use the @RegisterClass decorator and be included in the MJAPI (or other runtime environment) to be available for execution.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `The natural language prompt provided by the user describing what the action should accomplish, used for AI code generation.`}) 
    UserPrompt?: string;
        
    @Field({nullable: true, description: `User's comments not shared with the LLM.`}) 
    UserComments?: string;
        
    @Field({nullable: true, description: `The generated or manually written code that implements the action logic, typically TypeScript/JavaScript that will be executed.`}) 
    Code?: string;
        
    @Field({nullable: true, description: `AI's explanation of the code.`}) 
    CodeComments?: string;
        
    @Field({description: `An action won't be usable until the code is approved.`}) 
    @MaxLength(40)
    CodeApprovalStatus: string;
        
    @Field({nullable: true, description: `Optional comments when an individual (or an AI) reviews and approves the code.`}) 
    CodeApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CodeApprovedByUserID?: string;
        
    @Field({nullable: true, description: `When the code was approved.`}) 
    @MaxLength(8)
    CodeApprovedAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 1, Code will never be generated by the AI system. This overrides all other settings including the ForceCodeGeneration bit`}) 
    CodeLocked: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, the Action will generate code for the provided UserPrompt on the next Save even if the UserPrompt hasn't changed. This is useful to force regeneration when other candidates (such as a change in Action Inputs/Outputs) occurs or on demand by a user.`}) 
    ForceCodeGeneration: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain execution logs; NULL for indefinite.`}) 
    RetentionPeriod?: number;
        
    @Field({description: `Status of the action (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `For actions where Type='Custom', this specifies the fully qualified class name of the BaseAction sub-class that should be instantiated to handle the action execution. This provides a more reliable mechanism than relying on the Name field for class instantiation.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Optional ID of the parent action this action inherits from. Used for hierarchical action composition where child actions can specialize parent actions.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class (e.g., fa-cog, fa-play, fa-search) for visual representation of the action.`}) 
    @MaxLength(200)
    IconClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CodeApprovedByUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    Parent?: string;
        
    @Field(() => [ActionParam_])
    ActionParams_ActionIDArray: ActionParam_[]; // Link to ActionParams
    
    @Field(() => [ActionLibrary_])
    ActionLibraries_ActionIDArray: ActionLibrary_[]; // Link to ActionLibraries
    
    @Field(() => [ActionResultCode_])
    ActionResultCodes_ActionIDArray: ActionResultCode_[]; // Link to ActionResultCodes
    
    @Field(() => [ScheduledAction_])
    ScheduledActions_ActionIDArray: ScheduledAction_[]; // Link to ScheduledActions
    
    @Field(() => [AIAgentAction_])
    AIAgentActions_ActionIDArray: AIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [ActionContext_])
    ActionContexts_ActionIDArray: ActionContext_[]; // Link to ActionContexts
    
    @Field(() => [EntityAction_])
    EntityActions_ActionIDArray: EntityAction_[]; // Link to EntityActions
    
    @Field(() => [AIAgentStep_])
    MJ_AIAgentSteps_ActionIDArray: AIAgentStep_[]; // Link to MJ_AIAgentSteps
    
    @Field(() => [ActionExecutionLog_])
    ActionExecutionLogs_ActionIDArray: ActionExecutionLog_[]; // Link to ActionExecutionLogs
    
    @Field(() => [ActionAuthorization_])
    ActionAuthorizations_ActionIDArray: ActionAuthorization_[]; // Link to ActionAuthorizations
    
    @Field(() => [Action_])
    Actions_ParentIDArray: Action_[]; // Link to Actions
    
}

//****************************************************************************
// INPUT TYPE for Actions
//****************************************************************************
@InputType()
export class CreateActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    CodeComments: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID: string | null;

    @Field({ nullable: true })
    CodeApprovedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    IconClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Actions
//****************************************************************************
@InputType()
export class UpdateActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    CodeComments?: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments?: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID?: string | null;

    @Field({ nullable: true })
    CodeApprovedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Actions
//****************************************************************************
@ObjectType()
export class RunActionViewResult {
    @Field(() => [Action_])
    Results: Action_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Action_)
export class ActionResolver extends ResolverBase {
    @Query(() => RunActionViewResult)
    async RunActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionViewResult)
    async RunActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionViewResult)
    async RunActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Action_, { nullable: true })
    async Action(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Action_ | null> {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Actions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ActionParam_])
    async ActionParams_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionParams] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Params', rows);
        return result;
    }
        
    @FieldResolver(() => [ActionLibrary_])
    async ActionLibraries_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Libraries', rows);
        return result;
    }
        
    @FieldResolver(() => [ActionResultCode_])
    async ActionResultCodes_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Result Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionResultCodes] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Result Codes', rows);
        return result;
    }
        
    @FieldResolver(() => [ScheduledAction_])
    async ScheduledActions_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentAction_])
    async AIAgentActions_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [ActionContext_])
    async ActionContexts_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Contexts', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityAction_])
    async EntityActions_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Actions', rows);
        return result;
    }
        
    @FieldResolver(() => [AIAgentStep_])
    async MJ_AIAgentSteps_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows);
        return result;
    }
        
    @FieldResolver(() => [ActionExecutionLog_])
    async ActionExecutionLogs_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Execution Logs', rows);
        return result;
    }
        
    @FieldResolver(() => [ActionAuthorization_])
    async ActionAuthorizations_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Authorizations', rows);
        return result;
    }
        
    @FieldResolver(() => [Action_])
    async Actions_ParentIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [ParentID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Actions', rows);
        return result;
    }
        
    @Mutation(() => Action_)
    async CreateAction(
        @Arg('input', () => CreateActionInput) input: CreateActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Action_)
    async UpdateAction(
        @Arg('input', () => UpdateActionInput) input: UpdateActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Action_)
    async DeleteAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Filters
//****************************************************************************
@ObjectType({ description: `Optional use. Maps Action Filters to specific EntityAction instances, specifying execution order and status. This allows for “pre-processing” before an Action actually is fired off, to check for various state/dirty/value conditions.` })
export class EntityActionFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionFilterID: string;
        
    @Field(() => Int, {description: `Order of filter execution.`}) 
    Sequence: number;
        
    @Field({description: `Status of the entity action filter (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Filters
//****************************************************************************
@InputType()
export class CreateEntityActionFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Filters
//****************************************************************************
@InputType()
export class UpdateEntityActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Filters
//****************************************************************************
@ObjectType()
export class RunEntityActionFilterViewResult {
    @Field(() => [EntityActionFilter_])
    Results: EntityActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityActionFilter_)
export class EntityActionFilterResolver extends ResolverBase {
    @Query(() => RunEntityActionFilterViewResult)
    async RunEntityActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionFilterViewResult)
    async RunEntityActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionFilterViewResult)
    async RunEntityActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityActionFilter_, { nullable: true })
    async EntityActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityActionFilter_ | null> {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Action Filters', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EntityActionFilter_)
    async CreateEntityActionFilter(
        @Arg('input', () => CreateEntityActionFilterInput) input: CreateEntityActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityActionFilter_)
    async UpdateEntityActionFilter(
        @Arg('input', () => UpdateEntityActionFilterInput) input: UpdateEntityActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityActionFilter_)
    async DeleteEntityActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Filters
//****************************************************************************
@ObjectType({ description: `Defines filters that can be evaluated ahead of executing an action. Action Filters are usable in any code pipeline you can execute them with the same context as the action itself and use the outcome to determine if the action should execute or not.` })
export class ActionFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Human-readable explanation of what this filter checks and when it should prevent action execution, written for non-technical users.`}) 
    UserDescription: string;
        
    @Field({nullable: true, description: `Additional notes or implementation details about the filter logic, including examples or edge cases to consider.`}) 
    UserComments?: string;
        
    @Field({description: `JavaScript code that evaluates to true (allow action) or false (prevent action), executed in the same context as the action.`}) 
    Code: string;
        
    @Field({nullable: true, description: `Technical documentation of the filter code logic, including expected inputs, outputs, and any dependencies or assumptions.`}) 
    CodeExplanation?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityActionFilter_])
    EntityActionFilters_ActionFilterIDArray: EntityActionFilter_[]; // Link to EntityActionFilters
    
}

//****************************************************************************
// INPUT TYPE for Action Filters
//****************************************************************************
@InputType()
export class CreateActionFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Filters
//****************************************************************************
@InputType()
export class UpdateActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Filters
//****************************************************************************
@ObjectType()
export class RunActionFilterViewResult {
    @Field(() => [ActionFilter_])
    Results: ActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionFilter_)
export class ActionFilterResolver extends ResolverBase {
    @Query(() => RunActionFilterViewResult)
    async RunActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionFilterViewResult)
    async RunActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionFilterViewResult)
    async RunActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionFilter_, { nullable: true })
    async ActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionFilter_ | null> {
        this.CheckUserReadPermissions('Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Filters', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityActionFilter_])
    async EntityActionFilters_ActionFilterIDArray(@Root() actionfilter_: ActionFilter_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [ActionFilterID]='${actionfilter_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Filters', rows);
        return result;
    }
        
    @Mutation(() => ActionFilter_)
    async CreateActionFilter(
        @Arg('input', () => CreateActionFilterInput) input: CreateActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionFilter_)
    async UpdateActionFilter(
        @Arg('input', () => UpdateActionFilterInput) input: UpdateActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionFilter_)
    async DeleteActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Context Types
//****************************************************************************
@ObjectType({ description: `Lists possible contexts for action execution with optional descriptions.` })
export class ActionContextType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the context type.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the context type.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ActionContext_])
    ActionContexts_ContextTypeIDArray: ActionContext_[]; // Link to ActionContexts
    
}

//****************************************************************************
// INPUT TYPE for Action Context Types
//****************************************************************************
@InputType()
export class CreateActionContextTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Context Types
//****************************************************************************
@InputType()
export class UpdateActionContextTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Context Types
//****************************************************************************
@ObjectType()
export class RunActionContextTypeViewResult {
    @Field(() => [ActionContextType_])
    Results: ActionContextType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionContextType_)
export class ActionContextTypeResolver extends ResolverBase {
    @Query(() => RunActionContextTypeViewResult)
    async RunActionContextTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionContextTypeViewResult)
    async RunActionContextTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionContextTypeViewResult)
    async RunActionContextTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Context Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionContextType_, { nullable: true })
    async ActionContextType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionContextType_ | null> {
        this.CheckUserReadPermissions('Action Context Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContextTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Context Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Context Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ActionContext_])
    async ActionContexts_ContextTypeIDArray(@Root() actioncontexttype_: ActionContextType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ContextTypeID]='${actioncontexttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Contexts', rows);
        return result;
    }
        
    @Mutation(() => ActionContextType_)
    async CreateActionContextType(
        @Arg('input', () => CreateActionContextTypeInput) input: CreateActionContextTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Context Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionContextType_)
    async UpdateActionContextType(
        @Arg('input', () => UpdateActionContextTypeInput) input: UpdateActionContextTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Context Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionContextType_)
    async DeleteActionContextType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Context Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Result Codes
//****************************************************************************
@ObjectType({ description: `Defines the possible result codes for each action.` })
export class ActionResultCode_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `The unique code string returned by the action to indicate specific outcomes, used for programmatic handling of results.`}) 
    @MaxLength(510)
    ResultCode: string;
        
    @Field(() => Boolean, {description: `Indicates if the result code is a success or not. It is possible an action might have more than one failure condition/result code and same for success conditions.`}) 
    IsSuccess: boolean;
        
    @Field({nullable: true, description: `Description of the result code.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Result Codes
//****************************************************************************
@InputType()
export class CreateActionResultCodeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Result Codes
//****************************************************************************
@InputType()
export class UpdateActionResultCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Result Codes
//****************************************************************************
@ObjectType()
export class RunActionResultCodeViewResult {
    @Field(() => [ActionResultCode_])
    Results: ActionResultCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionResultCode_)
export class ActionResultCodeResolver extends ResolverBase {
    @Query(() => RunActionResultCodeViewResult)
    async RunActionResultCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionResultCodeViewResult)
    async RunActionResultCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionResultCodeViewResult)
    async RunActionResultCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Result Codes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionResultCode_, { nullable: true })
    async ActionResultCode(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionResultCode_ | null> {
        this.CheckUserReadPermissions('Action Result Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionResultCodes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Result Codes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ActionResultCode_)
    async CreateActionResultCode(
        @Arg('input', () => CreateActionResultCodeInput) input: CreateActionResultCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Result Codes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionResultCode_)
    async UpdateActionResultCode(
        @Arg('input', () => UpdateActionResultCodeInput) input: UpdateActionResultCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Result Codes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionResultCode_)
    async DeleteActionResultCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Result Codes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Contexts
//****************************************************************************
@ObjectType({ description: `Links actions to their supported context types enabling a given action to be executable in more than one context.` })
export class ActionContext_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ContextTypeID?: string;
        
    @Field({description: `Status of the action context (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContextType?: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Contexts
//****************************************************************************
@InputType()
export class CreateActionContextInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Action Contexts
//****************************************************************************
@InputType()
export class UpdateActionContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Contexts
//****************************************************************************
@ObjectType()
export class RunActionContextViewResult {
    @Field(() => [ActionContext_])
    Results: ActionContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionContext_)
export class ActionContextResolver extends ResolverBase {
    @Query(() => RunActionContextViewResult)
    async RunActionContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionContextViewResult)
    async RunActionContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionContextViewResult)
    async RunActionContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Contexts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionContext_, { nullable: true })
    async ActionContext(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionContext_ | null> {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Contexts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ActionContext_)
    async CreateActionContext(
        @Arg('input', () => CreateActionContextInput) input: CreateActionContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Contexts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionContext_)
    async UpdateActionContext(
        @Arg('input', () => UpdateActionContextInput) input: UpdateActionContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Contexts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionContext_)
    async DeleteActionContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Contexts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Execution Logs
//****************************************************************************
@ObjectType({ description: `Tracks every execution of an action, including start and end times, inputs, outputs, and result codes.` })
export class ActionExecutionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Timestamp when the action execution started (timezone-aware)`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the action execution ended (timezone-aware)`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({nullable: true, description: `JSON-formatted input parameters passed to the action during execution, storing the exact values used for this specific run.`}) 
    Params?: string;
        
    @Field({nullable: true, description: `The outcome code returned by the action execution, indicating success, failure, or specific error conditions as defined in Action Result Codes.`}) 
    @MaxLength(510)
    ResultCode?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain the log; NULL for indefinite retention.`}) 
    RetentionPeriod?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON-formatted output data or response from the action execution`}) 
    Message?: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Execution Logs
//****************************************************************************
@InputType()
export class CreateActionExecutionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Params: string | null;

    @Field({ nullable: true })
    ResultCode: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;

    @Field({ nullable: true })
    Message: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Execution Logs
//****************************************************************************
@InputType()
export class UpdateActionExecutionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Params?: string | null;

    @Field({ nullable: true })
    ResultCode?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Execution Logs
//****************************************************************************
@ObjectType()
export class RunActionExecutionLogViewResult {
    @Field(() => [ActionExecutionLog_])
    Results: ActionExecutionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionExecutionLog_)
export class ActionExecutionLogResolver extends ResolverBase {
    @Query(() => RunActionExecutionLogViewResult)
    async RunActionExecutionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionExecutionLogViewResult)
    async RunActionExecutionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionExecutionLogViewResult)
    async RunActionExecutionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Execution Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionExecutionLog_, { nullable: true })
    async ActionExecutionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionExecutionLog_ | null> {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Execution Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ActionExecutionLog_)
    async CreateActionExecutionLog(
        @Arg('input', () => CreateActionExecutionLogInput) input: CreateActionExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Execution Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionExecutionLog_)
    async UpdateActionExecutionLog(
        @Arg('input', () => UpdateActionExecutionLogInput) input: UpdateActionExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Execution Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionExecutionLog_)
    async DeleteActionExecutionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Execution Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Params
//****************************************************************************
@ObjectType({ description: `Tracks the input and output parameters for Actions.` })
export class ActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `The default value for this parameter if not provided during action execution, can be a literal value or JSON for complex types.`}) 
    DefaultValue?: string;
        
    @Field({description: `Specifies whether this parameter is used for Input, Output, or Both directions in the action execution flow.`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({description: `Tracks the basic value type of the parameter, additional information can be provided in the Description field`}) 
    @MaxLength(60)
    ValueType: string;
        
    @Field(() => Boolean, {description: `Indicates whether this parameter accepts or returns an array of values rather than a single value.`}) 
    IsArray: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `Determines if this parameter must be provided for input parameters or will always be populated for output parameters.`}) 
    IsRequired: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [EntityActionParam_])
    EntityActionParams_ActionParamIDArray: EntityActionParam_[]; // Link to EntityActionParams
    
    @Field(() => [ScheduledActionParam_])
    ScheduledActionParams_ActionParamIDArray: ScheduledActionParam_[]; // Link to ScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for Action Params
//****************************************************************************
@InputType()
export class CreateActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Action Params
//****************************************************************************
@InputType()
export class UpdateActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Params
//****************************************************************************
@ObjectType()
export class RunActionParamViewResult {
    @Field(() => [ActionParam_])
    Results: ActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionParam_)
export class ActionParamResolver extends ResolverBase {
    @Query(() => RunActionParamViewResult)
    async RunActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionParamViewResult)
    async RunActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionParamViewResult)
    async RunActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionParam_, { nullable: true })
    async ActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionParam_ | null> {
        this.CheckUserReadPermissions('Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityActionParam_])
    async EntityActionParams_ActionParamIDArray(@Root() actionparam_: ActionParam_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [ActionParamID]='${actionparam_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Params', rows);
        return result;
    }
        
    @FieldResolver(() => [ScheduledActionParam_])
    async ScheduledActionParams_ActionParamIDArray(@Root() actionparam_: ActionParam_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ActionParamID]='${actionparam_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Action Params', rows);
        return result;
    }
        
    @Mutation(() => ActionParam_)
    async CreateActionParam(
        @Arg('input', () => CreateActionParamInput) input: CreateActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionParam_)
    async UpdateActionParam(
        @Arg('input', () => UpdateActionParamInput) input: UpdateActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionParam_)
    async DeleteActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Libraries
//****************************************************************************
@ObjectType({ description: `Tracks the list of libraries that a given Action uses, including a list of classes/functions for each library.` })
export class ActionLibrary_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({nullable: true, description: `List of classes and functions used by the action from the library.`}) 
    ItemsUsed?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(510)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Libraries
//****************************************************************************
@InputType()
export class CreateActionLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Libraries
//****************************************************************************
@InputType()
export class UpdateActionLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Libraries
//****************************************************************************
@ObjectType()
export class RunActionLibraryViewResult {
    @Field(() => [ActionLibrary_])
    Results: ActionLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionLibrary_)
export class ActionLibraryResolver extends ResolverBase {
    @Query(() => RunActionLibraryViewResult)
    async RunActionLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionLibraryViewResult)
    async RunActionLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunActionLibraryViewResult)
    async RunActionLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ActionLibrary_, { nullable: true })
    async ActionLibrary(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionLibrary_ | null> {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Action Libraries', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ActionLibrary_)
    async CreateActionLibrary(
        @Arg('input', () => CreateActionLibraryInput) input: CreateActionLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ActionLibrary_)
    async UpdateActionLibrary(
        @Arg('input', () => UpdateActionLibraryInput) input: UpdateActionLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ActionLibrary_)
    async DeleteActionLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Libraries
//****************************************************************************
@ObjectType({ description: `Stores information about the available libraries, including a list of classes/functions, type definitions, and sample code. You can add additional custom libraries here to make them avaialable to code generation features within the system.` })
export class Library_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Status of the library, only libraries marked as Active will be available for use by generated code. If a library was once active but no longer is, existing code that used the library will not be affected.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Code showing the types and functions defined in the library to be used for reference by humans and AI`}) 
    TypeDefinitions?: string;
        
    @Field({nullable: true, description: `Examples of code use of the classes and/or functions from within the library`}) 
    SampleCode?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ActionLibrary_])
    ActionLibraries_LibraryIDArray: ActionLibrary_[]; // Link to ActionLibraries
    
    @Field(() => [LibraryItem_])
    LibraryItems_LibraryIDArray: LibraryItem_[]; // Link to LibraryItems
    
}

//****************************************************************************
// INPUT TYPE for Libraries
//****************************************************************************
@InputType()
export class CreateLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions: string | null;

    @Field({ nullable: true })
    SampleCode: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Libraries
//****************************************************************************
@InputType()
export class UpdateLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions?: string | null;

    @Field({ nullable: true })
    SampleCode?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Libraries
//****************************************************************************
@ObjectType()
export class RunLibraryViewResult {
    @Field(() => [Library_])
    Results: Library_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Library_)
export class LibraryResolver extends ResolverBase {
    @Query(() => RunLibraryViewResult)
    async RunLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunLibraryViewResult)
    async RunLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunLibraryViewResult)
    async RunLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Library_, { nullable: true })
    async Library(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Library_ | null> {
        this.CheckUserReadPermissions('Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Libraries', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ActionLibrary_])
    async ActionLibraries_LibraryIDArray(@Root() library_: Library_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [LibraryID]='${library_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Action Libraries', rows);
        return result;
    }
        
    @FieldResolver(() => [LibraryItem_])
    async LibraryItems_LibraryIDArray(@Root() library_: Library_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Library Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraryItems] WHERE [LibraryID]='${library_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Library Items', rows);
        return result;
    }
        
    @Mutation(() => Library_)
    async CreateLibrary(
        @Arg('input', () => CreateLibraryInput) input: CreateLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Library_)
    async UpdateLibrary(
        @Arg('input', () => UpdateLibraryInput) input: UpdateLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Library_)
    async DeleteLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for List Categories
//****************************************************************************
@ObjectType({ description: `Groups lists into categories for organization and navigation, supporting hierarchical categorization of user-created lists.` })
export class ListCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [ListCategory_])
    ListCategories_ParentIDArray: ListCategory_[]; // Link to ListCategories
    
    @Field(() => [List_])
    Lists_CategoryIDArray: List_[]; // Link to Lists
    
}

//****************************************************************************
// INPUT TYPE for List Categories
//****************************************************************************
@InputType()
export class CreateListCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for List Categories
//****************************************************************************
@InputType()
export class UpdateListCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for List Categories
//****************************************************************************
@ObjectType()
export class RunListCategoryViewResult {
    @Field(() => [ListCategory_])
    Results: ListCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ListCategory_)
export class ListCategoryResolver extends ResolverBase {
    @Query(() => RunListCategoryViewResult)
    async RunListCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunListCategoryViewResult)
    async RunListCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunListCategoryViewResult)
    async RunListCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'List Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ListCategory_, { nullable: true })
    async ListCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ListCategory_ | null> {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('List Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ListCategory_])
    async ListCategories_ParentIDArray(@Root() listcategory_: ListCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [ParentID]='${listcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('List Categories', rows);
        return result;
    }
        
    @FieldResolver(() => [List_])
    async Lists_CategoryIDArray(@Root() listcategory_: ListCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [CategoryID]='${listcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', rows);
        return result;
    }
        
    @Mutation(() => ListCategory_)
    async CreateListCategory(
        @Arg('input', () => CreateListCategoryInput) input: CreateListCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('List Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ListCategory_)
    async UpdateListCategory(
        @Arg('input', () => UpdateListCategoryInput) input: UpdateListCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('List Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ListCategory_)
    async DeleteListCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('List Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Providers
//****************************************************************************
@ObjectType({ description: `All supported communication providers.` })
export class CommunicationProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The status of the communication provider (Disabled or Active).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports sending messages.`}) 
    SupportsSending: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports receiving messages.`}) 
    SupportsReceiving: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports sending messages at a specific time`}) 
    SupportsScheduledSending: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports forwarding messages to another recipient `}) 
    SupportsForwarding: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports replying to messages`}) 
    SupportsReplying: boolean;
        
    @Field(() => [CommunicationProviderMessageType_])
    CommunicationProviderMessageTypes_CommunicationProviderIDArray: CommunicationProviderMessageType_[]; // Link to CommunicationProviderMessageTypes
    
    @Field(() => [CommunicationLog_])
    CommunicationLogs_CommunicationProviderIDArray: CommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Providers
//****************************************************************************
@InputType()
export class CreateCommunicationProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Communication Providers
//****************************************************************************
@InputType()
export class UpdateCommunicationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Providers
//****************************************************************************
@ObjectType()
export class RunCommunicationProviderViewResult {
    @Field(() => [CommunicationProvider_])
    Results: CommunicationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationProvider_)
export class CommunicationProviderResolver extends ResolverBase {
    @Query(() => RunCommunicationProviderViewResult)
    async RunCommunicationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationProviderViewResult)
    async RunCommunicationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationProviderViewResult)
    async RunCommunicationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CommunicationProvider_, { nullable: true })
    async CommunicationProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationProvider_ | null> {
        this.CheckUserReadPermissions('Communication Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Providers', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [CommunicationProviderMessageType_])
    async CommunicationProviderMessageTypes_CommunicationProviderIDArray(@Root() communicationprovider_: CommunicationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [CommunicationProviderID]='${communicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Provider Message Types', rows);
        return result;
    }
        
    @FieldResolver(() => [CommunicationLog_])
    async CommunicationLogs_CommunicationProviderIDArray(@Root() communicationprovider_: CommunicationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationProviderID]='${communicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows);
        return result;
    }
        
    @Mutation(() => CommunicationProvider_)
    async CreateCommunicationProvider(
        @Arg('input', () => CreateCommunicationProviderInput) input: CreateCommunicationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationProvider_)
    async UpdateCommunicationProvider(
        @Arg('input', () => UpdateCommunicationProviderInput) input: UpdateCommunicationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CommunicationProvider_)
    async DeleteCommunicationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Runs
//****************************************************************************
@ObjectType({ description: `Runs of bulk message sends and receives.` })
export class CommunicationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `The direction of the communication run (Sending or Receiving).`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field({description: `The status of the communication run (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field({nullable: true, description: `The error message if the communication run failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [CommunicationLog_])
    CommunicationLogs_CommunicationRunIDArray: CommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Runs
//****************************************************************************
@InputType()
export class CreateCommunicationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Runs
//****************************************************************************
@InputType()
export class UpdateCommunicationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Runs
//****************************************************************************
@ObjectType()
export class RunCommunicationRunViewResult {
    @Field(() => [CommunicationRun_])
    Results: CommunicationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationRun_)
export class CommunicationRunResolver extends ResolverBase {
    @Query(() => RunCommunicationRunViewResult)
    async RunCommunicationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationRunViewResult)
    async RunCommunicationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationRunViewResult)
    async RunCommunicationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CommunicationRun_, { nullable: true })
    async CommunicationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationRun_ | null> {
        this.CheckUserReadPermissions('Communication Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [CommunicationLog_])
    async CommunicationLogs_CommunicationRunIDArray(@Root() communicationrun_: CommunicationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationRunID]='${communicationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows);
        return result;
    }
        
    @Mutation(() => CommunicationRun_)
    async CreateCommunicationRun(
        @Arg('input', () => CreateCommunicationRunInput) input: CreateCommunicationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationRun_)
    async UpdateCommunicationRun(
        @Arg('input', () => UpdateCommunicationRunInput) input: UpdateCommunicationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CommunicationRun_)
    async DeleteCommunicationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Provider Message Types
//****************************************************************************
@ObjectType({ description: `Providers and their supported message types with additional attributes.` })
export class CommunicationProviderMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationBaseMessageTypeID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `The status of the provider message type (Disabled or Active).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Additional attributes specific to the provider message type.`}) 
    AdditionalAttributes?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(200)
    CommunicationBaseMessageType: string;
        
    @Field(() => [CommunicationLog_])
    CommunicationLogs_CommunicationProviderMessageTypeIDArray: CommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Provider Message Types
//****************************************************************************
@InputType()
export class CreateCommunicationProviderMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Provider Message Types
//****************************************************************************
@InputType()
export class UpdateCommunicationProviderMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Provider Message Types
//****************************************************************************
@ObjectType()
export class RunCommunicationProviderMessageTypeViewResult {
    @Field(() => [CommunicationProviderMessageType_])
    Results: CommunicationProviderMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationProviderMessageType_)
export class CommunicationProviderMessageTypeResolver extends ResolverBase {
    @Query(() => RunCommunicationProviderMessageTypeViewResult)
    async RunCommunicationProviderMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationProviderMessageTypeViewResult)
    async RunCommunicationProviderMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationProviderMessageTypeViewResult)
    async RunCommunicationProviderMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Provider Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CommunicationProviderMessageType_, { nullable: true })
    async CommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationProviderMessageType_ | null> {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Provider Message Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [CommunicationLog_])
    async CommunicationLogs_CommunicationProviderMessageTypeIDArray(@Root() communicationprovidermessagetype_: CommunicationProviderMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationProviderMessageTypeID]='${communicationprovidermessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows);
        return result;
    }
        
    @Mutation(() => CommunicationProviderMessageType_)
    async CreateCommunicationProviderMessageType(
        @Arg('input', () => CreateCommunicationProviderMessageTypeInput) input: CreateCommunicationProviderMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Provider Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationProviderMessageType_)
    async UpdateCommunicationProviderMessageType(
        @Arg('input', () => UpdateCommunicationProviderMessageTypeInput) input: UpdateCommunicationProviderMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Provider Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CommunicationProviderMessageType_)
    async DeleteCommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Provider Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Logs
//****************************************************************************
@ObjectType({ description: `Logs of sent and received messages.` })
export class CommunicationLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderMessageTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CommunicationRunID?: string;
        
    @Field({description: `The direction of the communication log (Sending or Receiving).`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field({description: `The date and time when the message was logged.`}) 
    @MaxLength(8)
    MessageDate: Date;
        
    @Field({description: `The status of the logged message (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `The content of the logged message.`}) 
    MessageContent?: string;
        
    @Field({nullable: true, description: `The error message if the message sending failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(510)
    CommunicationProviderMessageType: string;
        
}

//****************************************************************************
// INPUT TYPE for Communication Logs
//****************************************************************************
@InputType()
export class CreateCommunicationLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Logs
//****************************************************************************
@InputType()
export class UpdateCommunicationLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID?: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Logs
//****************************************************************************
@ObjectType()
export class RunCommunicationLogViewResult {
    @Field(() => [CommunicationLog_])
    Results: CommunicationLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationLog_)
export class CommunicationLogResolver extends ResolverBase {
    @Query(() => RunCommunicationLogViewResult)
    async RunCommunicationLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationLogViewResult)
    async RunCommunicationLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationLogViewResult)
    async RunCommunicationLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CommunicationLog_, { nullable: true })
    async CommunicationLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationLog_ | null> {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Logs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => CommunicationLog_)
    async CreateCommunicationLog(
        @Arg('input', () => CreateCommunicationLogInput) input: CreateCommunicationLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationLog_)
    async UpdateCommunicationLog(
        @Arg('input', () => UpdateCommunicationLogInput) input: UpdateCommunicationLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CommunicationLog_)
    async DeleteCommunicationLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Base Message Types
//****************************************************************************
@ObjectType({ description: `Base message types and their supported functionalities.` })
export class CommunicationBaseMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The unique identifier for this message type, used for routing and processing communications.`}) 
    @MaxLength(200)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates if attachments are supported.`}) 
    SupportsAttachments: boolean;
        
    @Field(() => Boolean, {description: `Indicates if a subject line is supported.`}) 
    SupportsSubjectLine: boolean;
        
    @Field(() => Boolean, {description: `Indicates if HTML content is supported.`}) 
    SupportsHtml: boolean;
        
    @Field(() => Int, {nullable: true, description: `The maximum size in bytes for the message.`}) 
    MaxBytes?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [CommunicationProviderMessageType_])
    CommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray: CommunicationProviderMessageType_[]; // Link to CommunicationProviderMessageTypes
    
    @Field(() => [EntityCommunicationMessageType_])
    EntityCommunicationMessageTypes_BaseMessageTypeIDArray: EntityCommunicationMessageType_[]; // Link to EntityCommunicationMessageTypes
    
}

//****************************************************************************
// INPUT TYPE for Communication Base Message Types
//****************************************************************************
@InputType()
export class CreateCommunicationBaseMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Base Message Types
//****************************************************************************
@InputType()
export class UpdateCommunicationBaseMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Base Message Types
//****************************************************************************
@ObjectType()
export class RunCommunicationBaseMessageTypeViewResult {
    @Field(() => [CommunicationBaseMessageType_])
    Results: CommunicationBaseMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationBaseMessageType_)
export class CommunicationBaseMessageTypeResolver extends ResolverBase {
    @Query(() => RunCommunicationBaseMessageTypeViewResult)
    async RunCommunicationBaseMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationBaseMessageTypeViewResult)
    async RunCommunicationBaseMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunCommunicationBaseMessageTypeViewResult)
    async RunCommunicationBaseMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Base Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => CommunicationBaseMessageType_, { nullable: true })
    async CommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationBaseMessageType_ | null> {
        this.CheckUserReadPermissions('Communication Base Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationBaseMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Base Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Communication Base Message Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [CommunicationProviderMessageType_])
    async CommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray(@Root() communicationbasemessagetype_: CommunicationBaseMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [CommunicationBaseMessageTypeID]='${communicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Provider Message Types', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityCommunicationMessageType_])
    async EntityCommunicationMessageTypes_BaseMessageTypeIDArray(@Root() communicationbasemessagetype_: CommunicationBaseMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [BaseMessageTypeID]='${communicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Message Types', rows);
        return result;
    }
        
    @Mutation(() => CommunicationBaseMessageType_)
    async CreateCommunicationBaseMessageType(
        @Arg('input', () => CreateCommunicationBaseMessageTypeInput) input: CreateCommunicationBaseMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Base Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationBaseMessageType_)
    async UpdateCommunicationBaseMessageType(
        @Arg('input', () => UpdateCommunicationBaseMessageTypeInput) input: UpdateCommunicationBaseMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Base Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => CommunicationBaseMessageType_)
    async DeleteCommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Base Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Templates
//****************************************************************************
@ObjectType({ description: `Templates are used for dynamic expansion of a static template with data from a given context. Templates can be used to create documents, messages and anything else that requires dynamic document creation merging together static text, data and lightweight logic` })
export class Template_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true, description: `This prompt will be used by the AI to generate template content as requested by the user.`}) 
    UserPrompt?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use until the specified date. Requires IsActive to be set to 1`}) 
    @MaxLength(8)
    ActiveAt?: Date;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use after the specified date. If IsActive=0, this has no effect.`}) 
    @MaxLength(8)
    DisabledAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 0, the template will be disabled regardless of the values in ActiveAt/DisabledAt. `}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [TemplateParam_])
    TemplateParams_TemplateIDArray: TemplateParam_[]; // Link to TemplateParams
    
    @Field(() => [TemplateContent_])
    TemplateContents_TemplateIDArray: TemplateContent_[]; // Link to TemplateContents
    
    @Field(() => [AIPrompt_])
    AIPrompts_TemplateIDArray: AIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [EntityDocument_])
    EntityDocuments_TemplateIDArray: EntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Templates
//****************************************************************************
@InputType()
export class CreateTemplateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt: Date | null;

    @Field({ nullable: true })
    DisabledAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Templates
//****************************************************************************
@InputType()
export class UpdateTemplateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt?: Date | null;

    @Field({ nullable: true })
    DisabledAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Templates
//****************************************************************************
@ObjectType()
export class RunTemplateViewResult {
    @Field(() => [Template_])
    Results: Template_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Template_)
export class TemplateResolver extends ResolverBase {
    @Query(() => RunTemplateViewResult)
    async RunTemplateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateViewResult)
    async RunTemplateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateViewResult)
    async RunTemplateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Templates';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Template_, { nullable: true })
    async Template(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Template_ | null> {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Templates', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [TemplateParam_])
    async TemplateParams_TemplateIDArray(@Root() template_: Template_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [TemplateID]='${template_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Params', rows);
        return result;
    }
        
    @FieldResolver(() => [TemplateContent_])
    async TemplateContents_TemplateIDArray(@Root() template_: Template_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [TemplateID]='${template_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Contents', rows);
        return result;
    }
        
    @FieldResolver(() => [AIPrompt_])
    async AIPrompts_TemplateIDArray(@Root() template_: Template_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [TemplateID]='${template_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows);
        return result;
    }
        
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_TemplateIDArray(@Root() template_: Template_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [TemplateID]='${template_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows);
        return result;
    }
        
    @Mutation(() => Template_)
    async CreateTemplate(
        @Arg('input', () => CreateTemplateInput) input: CreateTemplateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Templates', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Template_)
    async UpdateTemplate(
        @Arg('input', () => UpdateTemplateInput) input: UpdateTemplateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Templates', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Template_)
    async DeleteTemplate(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Templates', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Categories
//****************************************************************************
@ObjectType({ description: `Template categories for organizing templates` })
export class TemplateCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template category`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template category`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [Template_])
    Templates_CategoryIDArray: Template_[]; // Link to Templates
    
    @Field(() => [TemplateCategory_])
    TemplateCategories_ParentIDArray: TemplateCategory_[]; // Link to TemplateCategories
    
}

//****************************************************************************
// INPUT TYPE for Template Categories
//****************************************************************************
@InputType()
export class CreateTemplateCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Template Categories
//****************************************************************************
@InputType()
export class UpdateTemplateCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Categories
//****************************************************************************
@ObjectType()
export class RunTemplateCategoryViewResult {
    @Field(() => [TemplateCategory_])
    Results: TemplateCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TemplateCategory_)
export class TemplateCategoryResolver extends ResolverBase {
    @Query(() => RunTemplateCategoryViewResult)
    async RunTemplateCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateCategoryViewResult)
    async RunTemplateCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateCategoryViewResult)
    async RunTemplateCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => TemplateCategory_, { nullable: true })
    async TemplateCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TemplateCategory_ | null> {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Template Categories', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Template_])
    async Templates_CategoryIDArray(@Root() templatecategory_: TemplateCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [CategoryID]='${templatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Templates', rows);
        return result;
    }
        
    @FieldResolver(() => [TemplateCategory_])
    async TemplateCategories_ParentIDArray(@Root() templatecategory_: TemplateCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [ParentID]='${templatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Categories', rows);
        return result;
    }
        
    @Mutation(() => TemplateCategory_)
    async CreateTemplateCategory(
        @Arg('input', () => CreateTemplateCategoryInput) input: CreateTemplateCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => TemplateCategory_)
    async UpdateTemplateCategory(
        @Arg('input', () => UpdateTemplateCategoryInput) input: UpdateTemplateCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => TemplateCategory_)
    async DeleteTemplateCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Contents
//****************************************************************************
@ObjectType({ description: `Template content for different versions of a template for purposes like HTML/Text/etc` })
export class TemplateContent_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field({nullable: true, description: `The actual text content for the template`}) 
    TemplateText?: string;
        
    @Field(() => Int, {description: `Priority of the content version, higher priority versions will be used ahead of lower priority versions for a given Type`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `Indicates whether the content is active or not. Use this to disable a particular Template Content item without having to remove it`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
    @Field(() => [TemplateParam_])
    TemplateParams_TemplateContentIDArray: TemplateParam_[]; // Link to TemplateParams
    
}

//****************************************************************************
// INPUT TYPE for Template Contents
//****************************************************************************
@InputType()
export class CreateTemplateContentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Template Contents
//****************************************************************************
@InputType()
export class UpdateTemplateContentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Contents
//****************************************************************************
@ObjectType()
export class RunTemplateContentViewResult {
    @Field(() => [TemplateContent_])
    Results: TemplateContent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TemplateContent_)
export class TemplateContentResolver extends ResolverBase {
    @Query(() => RunTemplateContentViewResult)
    async RunTemplateContentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateContentViewResult)
    async RunTemplateContentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateContentViewResult)
    async RunTemplateContentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Contents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => TemplateContent_, { nullable: true })
    async TemplateContent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TemplateContent_ | null> {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Template Contents', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [TemplateParam_])
    async TemplateParams_TemplateContentIDArray(@Root() templatecontent_: TemplateContent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [TemplateContentID]='${templatecontent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Params', rows);
        return result;
    }
        
    @Mutation(() => TemplateContent_)
    async CreateTemplateContent(
        @Arg('input', () => CreateTemplateContentInput) input: CreateTemplateContentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Contents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => TemplateContent_)
    async UpdateTemplateContent(
        @Arg('input', () => UpdateTemplateContentInput) input: UpdateTemplateContentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Contents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => TemplateContent_)
    async DeleteTemplateContent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Contents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Params
//****************************************************************************
@ObjectType({ description: `Parameters allowed for use inside the template` })
export class TemplateParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field({description: `Name of the parameter`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the parameter`}) 
    Description?: string;
        
    @Field({description: `Type of the parameter - Record is an individual record within the entity specified by EntityID. Entity means an entire Entity or an entity filtered by the LinkedParameterName/Field attributes and/or ExtraFilter. Object is any valid JSON object. Array and Scalar have their common meanings.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Default value of the parameter`}) 
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `Whether this parameter must be provided when using the template.`}) 
    IsRequired: boolean;
        
    @Field({nullable: true, description: `Only used when Type=Entity, this is used to link an Entity parameter with another parameter so that the rows in the Entity parameter can be filtered automatically based on the FKEY relationship between the Record and this Entity parameter. For example, if the Entity-based parameter is for an entity like Activities and there is another parameter of type Record for an entity like Contacts, in that situation the Activities Parameter would point to the Contacts parameter as the LinkedParameterName because we would filter down the Activities in each template render to only those linked to the Contact.`}) 
    @MaxLength(510)
    LinkedParameterName?: string;
        
    @Field({nullable: true, description: `If the LinkedParameterName is specified, this is an optional setting to specify the field within the LinkedParameter that will be used for filtering. This is only needed if there is more than one foreign key relationship between the Entity parameter and the Linked parameter, or if there is no defined foreign key in the database between the two entities.`}) 
    @MaxLength(1000)
    LinkedParameterField?: string;
        
    @Field({nullable: true, description: `Only used when Type = Entity, used to specify an optional filter to reduce the set of rows that are returned for each of the templates being rendered.`}) 
    ExtraFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `Record ID, used only when Type is Record and a specific hardcoded record ID is desired, this is an uncommon use case, helpful for pulling in static types and metadata in some cases.`}) 
    @MaxLength(4000)
    RecordID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `This field is used only when the Type of the TemplateParam table is "Entity". It is an optional field used to specify the sorting order for the related entity data that is used in the template for the Entity specified.`}) 
    OrderBy?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific template content. When NULL, this parameter applies to all content items within the template. When set, this parameter applies only to the specified template content.`}) 
    @MaxLength(16)
    TemplateContentID?: string;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Template Params
//****************************************************************************
@InputType()
export class CreateTemplateParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName: string | null;

    @Field({ nullable: true })
    LinkedParameterField: string | null;

    @Field({ nullable: true })
    ExtraFilter: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    OrderBy: string | null;

    @Field({ nullable: true })
    TemplateContentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Template Params
//****************************************************************************
@InputType()
export class UpdateTemplateParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName?: string | null;

    @Field({ nullable: true })
    LinkedParameterField?: string | null;

    @Field({ nullable: true })
    ExtraFilter?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    OrderBy?: string | null;

    @Field({ nullable: true })
    TemplateContentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Params
//****************************************************************************
@ObjectType()
export class RunTemplateParamViewResult {
    @Field(() => [TemplateParam_])
    Results: TemplateParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TemplateParam_)
export class TemplateParamResolver extends ResolverBase {
    @Query(() => RunTemplateParamViewResult)
    async RunTemplateParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateParamViewResult)
    async RunTemplateParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateParamViewResult)
    async RunTemplateParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => TemplateParam_, { nullable: true })
    async TemplateParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TemplateParam_ | null> {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Template Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => TemplateParam_)
    async CreateTemplateParam(
        @Arg('input', () => CreateTemplateParamInput) input: CreateTemplateParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => TemplateParam_)
    async UpdateTemplateParam(
        @Arg('input', () => UpdateTemplateParamInput) input: UpdateTemplateParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => TemplateParam_)
    async DeleteTemplateParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Content Types
//****************************************************************************
@ObjectType({ description: `Template content types for categorizing content within templates` })
export class TemplateContentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template content type`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template content type`}) 
    Description?: string;
        
    @Field({description: `Refers to the primary language or codetype of the templates of this type, HTML, JSON, JavaScript, etc`}) 
    @MaxLength(50)
    CodeType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [TemplateContent_])
    TemplateContents_TypeIDArray: TemplateContent_[]; // Link to TemplateContents
    
}

//****************************************************************************
// INPUT TYPE for Template Content Types
//****************************************************************************
@InputType()
export class CreateTemplateContentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CodeType?: string;
}
    

//****************************************************************************
// INPUT TYPE for Template Content Types
//****************************************************************************
@InputType()
export class UpdateTemplateContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CodeType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Content Types
//****************************************************************************
@ObjectType()
export class RunTemplateContentTypeViewResult {
    @Field(() => [TemplateContentType_])
    Results: TemplateContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TemplateContentType_)
export class TemplateContentTypeResolver extends ResolverBase {
    @Query(() => RunTemplateContentTypeViewResult)
    async RunTemplateContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateContentTypeViewResult)
    async RunTemplateContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunTemplateContentTypeViewResult)
    async RunTemplateContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Content Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => TemplateContentType_, { nullable: true })
    async TemplateContentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TemplateContentType_ | null> {
        this.CheckUserReadPermissions('Template Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Template Content Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [TemplateContent_])
    async TemplateContents_TypeIDArray(@Root() templatecontenttype_: TemplateContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [TypeID]='${templatecontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Template Contents', rows);
        return result;
    }
        
    @Mutation(() => TemplateContentType_)
    async CreateTemplateContentType(
        @Arg('input', () => CreateTemplateContentTypeInput) input: CreateTemplateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Content Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => TemplateContentType_)
    async UpdateTemplateContentType(
        @Arg('input', () => UpdateTemplateContentTypeInput) input: UpdateTemplateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Content Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => TemplateContentType_)
    async DeleteTemplateContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Content Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendations
//****************************************************************************
@ObjectType({ description: `Recommendation headers that store the left side of the recommendation which we track in the SourceEntityID/SourceEntityRecordID` })
export class Recommendation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationRunID: string;
        
    @Field() 
    @MaxLength(16)
    SourceEntityID: string;
        
    @Field({description: `The record ID of the source entity`}) 
    SourceEntityRecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    SourceEntity: string;
        
    @Field(() => [RecommendationItem_])
    RecommendationItems_RecommendationIDArray: RecommendationItem_[]; // Link to RecommendationItems
    
}

//****************************************************************************
// INPUT TYPE for Recommendations
//****************************************************************************
@InputType()
export class CreateRecommendationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Recommendations
//****************************************************************************
@InputType()
export class UpdateRecommendationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendations
//****************************************************************************
@ObjectType()
export class RunRecommendationViewResult {
    @Field(() => [Recommendation_])
    Results: Recommendation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Recommendation_)
export class RecommendationResolver extends ResolverBase {
    @Query(() => RunRecommendationViewResult)
    async RunRecommendationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecommendationViewResult)
    async RunRecommendationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecommendationViewResult)
    async RunRecommendationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Recommendation_, { nullable: true })
    async Recommendation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Recommendation_ | null> {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Recommendations', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [RecommendationItem_])
    async RecommendationItems_RecommendationIDArray(@Root() recommendation_: Recommendation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [RecommendationID]='${recommendation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Items', rows);
        return result;
    }
        
    @Mutation(() => Recommendation_)
    async CreateRecommendation(
        @Arg('input', () => CreateRecommendationInput) input: CreateRecommendationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Recommendation_)
    async UpdateRecommendation(
        @Arg('input', () => UpdateRecommendationInput) input: UpdateRecommendationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Recommendation_)
    async DeleteRecommendation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Providers
//****************************************************************************
@ObjectType({ description: `Recommendation providers details` })
export class RecommendationProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [RecommendationRun_])
    RecommendationRuns_RecommendationProviderIDArray: RecommendationRun_[]; // Link to RecommendationRuns
    
}

//****************************************************************************
// INPUT TYPE for Recommendation Providers
//****************************************************************************
@InputType()
export class CreateRecommendationProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Providers
//****************************************************************************
@InputType()
export class UpdateRecommendationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Providers
//****************************************************************************
@ObjectType()
export class RunRecommendationProviderViewResult {
    @Field(() => [RecommendationProvider_])
    Results: RecommendationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecommendationProvider_)
export class RecommendationProviderResolver extends ResolverBase {
    @Query(() => RunRecommendationProviderViewResult)
    async RunRecommendationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecommendationProviderViewResult)
    async RunRecommendationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecommendationProviderViewResult)
    async RunRecommendationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => RecommendationProvider_, { nullable: true })
    async RecommendationProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecommendationProvider_ | null> {
        this.CheckUserReadPermissions('Recommendation Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Recommendation Providers', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [RecommendationRun_])
    async RecommendationRuns_RecommendationProviderIDArray(@Root() recommendationprovider_: RecommendationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [RecommendationProviderID]='${recommendationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Runs', rows);
        return result;
    }
        
    @Mutation(() => RecommendationProvider_)
    async CreateRecommendationProvider(
        @Arg('input', () => CreateRecommendationProviderInput) input: CreateRecommendationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => RecommendationProvider_)
    async UpdateRecommendationProvider(
        @Arg('input', () => UpdateRecommendationProviderInput) input: UpdateRecommendationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => RecommendationProvider_)
    async DeleteRecommendationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendation Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Runs
//****************************************************************************
@ObjectType({ description: `Recommendation runs log each time a provider is requested to provide recommendations` })
export class RecommendationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationProviderID: string;
        
    @Field({description: `The start date of the recommendation run`}) 
    @MaxLength(8)
    StartDate: Date;
        
    @Field({nullable: true, description: `The end date of the recommendation run`}) 
    @MaxLength(8)
    EndDate?: Date;
        
    @Field({description: `The status of the recommendation run`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    RecommendationProvider: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [Recommendation_])
    Recommendations_RecommendationRunIDArray: Recommendation_[]; // Link to Recommendations
    
}

//****************************************************************************
// INPUT TYPE for Recommendation Runs
//****************************************************************************
@InputType()
export class CreateRecommendationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Runs
//****************************************************************************
@InputType()
export class UpdateRecommendationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Runs
//****************************************************************************
@ObjectType()
export class RunRecommendationRunViewResult {
    @Field(() => [RecommendationRun_])
    Results: RecommendationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecommendationRun_)
export class RecommendationRunResolver extends ResolverBase {
    @Query(() => RunRecommendationRunViewResult)
    async RunRecommendationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecommendationRunViewResult)
    async RunRecommendationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecommendationRunViewResult)
    async RunRecommendationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => RecommendationRun_, { nullable: true })
    async RecommendationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecommendationRun_ | null> {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Recommendation Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [Recommendation_])
    async Recommendations_RecommendationRunIDArray(@Root() recommendationrun_: RecommendationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [RecommendationRunID]='${recommendationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendations', rows);
        return result;
    }
        
    @Mutation(() => RecommendationRun_)
    async CreateRecommendationRun(
        @Arg('input', () => CreateRecommendationRunInput) input: CreateRecommendationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => RecommendationRun_)
    async UpdateRecommendationRun(
        @Arg('input', () => UpdateRecommendationRunInput) input: UpdateRecommendationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => RecommendationRun_)
    async DeleteRecommendationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendation Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Items
//****************************************************************************
@ObjectType({ description: `Table to store individual recommendation items that are the right side of the recommendation which we track in the DestinationEntityID/DestinationEntityRecordID` })
export class RecommendationItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationID: string;
        
    @Field() 
    @MaxLength(16)
    DestinationEntityID: string;
        
    @Field({description: `The record ID of the destination entity`}) 
    @MaxLength(900)
    DestinationEntityRecordID: string;
        
    @Field(() => Float, {nullable: true, description: `A value between 0 and 1 indicating the probability of the match, higher numbers indicating a more certain match/recommendation.`}) 
    MatchProbability?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    DestinationEntity: string;
        
}

//****************************************************************************
// INPUT TYPE for Recommendation Items
//****************************************************************************
@InputType()
export class CreateRecommendationItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Items
//****************************************************************************
@InputType()
export class UpdateRecommendationItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Items
//****************************************************************************
@ObjectType()
export class RunRecommendationItemViewResult {
    @Field(() => [RecommendationItem_])
    Results: RecommendationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecommendationItem_)
export class RecommendationItemResolver extends ResolverBase {
    @Query(() => RunRecommendationItemViewResult)
    async RunRecommendationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecommendationItemViewResult)
    async RunRecommendationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecommendationItemViewResult)
    async RunRecommendationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => RecommendationItem_, { nullable: true })
    async RecommendationItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecommendationItem_ | null> {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Recommendation Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => RecommendationItem_)
    async CreateRecommendationItem(
        @Arg('input', () => CreateRecommendationItemInput) input: CreateRecommendationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => RecommendationItem_)
    async UpdateRecommendationItem(
        @Arg('input', () => UpdateRecommendationItemInput) input: UpdateRecommendationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => RecommendationItem_)
    async DeleteRecommendationItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendation Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Communication Message Types
//****************************************************************************
@ObjectType({ description: `Mapping between entities and communication base message types` })
export class EntityCommunicationMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    BaseMessageTypeID: string;
        
    @Field(() => Boolean, {description: `Indicates whether the message type is active`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    BaseMessageType: string;
        
    @Field(() => [EntityCommunicationField_])
    EntityCommunicationFields_EntityCommunicationMessageTypeIDArray: EntityCommunicationField_[]; // Link to EntityCommunicationFields
    
}

//****************************************************************************
// INPUT TYPE for Entity Communication Message Types
//****************************************************************************
@InputType()
export class CreateEntityCommunicationMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Entity Communication Message Types
//****************************************************************************
@InputType()
export class UpdateEntityCommunicationMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Communication Message Types
//****************************************************************************
@ObjectType()
export class RunEntityCommunicationMessageTypeViewResult {
    @Field(() => [EntityCommunicationMessageType_])
    Results: EntityCommunicationMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityCommunicationMessageType_)
export class EntityCommunicationMessageTypeResolver extends ResolverBase {
    @Query(() => RunEntityCommunicationMessageTypeViewResult)
    async RunEntityCommunicationMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityCommunicationMessageTypeViewResult)
    async RunEntityCommunicationMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityCommunicationMessageTypeViewResult)
    async RunEntityCommunicationMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Communication Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityCommunicationMessageType_, { nullable: true })
    async EntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityCommunicationMessageType_ | null> {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Communication Message Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityCommunicationField_])
    async EntityCommunicationFields_EntityCommunicationMessageTypeIDArray(@Root() entitycommunicationmessagetype_: EntityCommunicationMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationFields] WHERE [EntityCommunicationMessageTypeID]='${entitycommunicationmessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Fields', rows);
        return result;
    }
        
    @Mutation(() => EntityCommunicationMessageType_)
    async CreateEntityCommunicationMessageType(
        @Arg('input', () => CreateEntityCommunicationMessageTypeInput) input: CreateEntityCommunicationMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Communication Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityCommunicationMessageType_)
    async UpdateEntityCommunicationMessageType(
        @Arg('input', () => UpdateEntityCommunicationMessageTypeInput) input: UpdateEntityCommunicationMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Communication Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityCommunicationMessageType_)
    async DeleteEntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Communication Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Communication Fields
//****************************************************************************
@ObjectType({ description: `Mapping between entity fields and communication base message types with priority` })
export class EntityCommunicationField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityCommunicationMessageTypeID: string;
        
    @Field({description: `Name of the field in the entity that maps to the communication base message type`}) 
    @MaxLength(1000)
    FieldName: string;
        
    @Field(() => Int, {description: `Priority of the field for the communication base message type`}) 
    Priority: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Entity Communication Fields
//****************************************************************************
@InputType()
export class CreateEntityCommunicationFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Communication Fields
//****************************************************************************
@InputType()
export class UpdateEntityCommunicationFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Communication Fields
//****************************************************************************
@ObjectType()
export class RunEntityCommunicationFieldViewResult {
    @Field(() => [EntityCommunicationField_])
    Results: EntityCommunicationField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityCommunicationField_)
export class EntityCommunicationFieldResolver extends ResolverBase {
    @Query(() => RunEntityCommunicationFieldViewResult)
    async RunEntityCommunicationFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityCommunicationFieldViewResult)
    async RunEntityCommunicationFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityCommunicationFieldViewResult)
    async RunEntityCommunicationFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Communication Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityCommunicationField_, { nullable: true })
    async EntityCommunicationField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityCommunicationField_ | null> {
        this.CheckUserReadPermissions('Entity Communication Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Communication Fields', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EntityCommunicationField_)
    async CreateEntityCommunicationField(
        @Arg('input', () => CreateEntityCommunicationFieldInput) input: CreateEntityCommunicationFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Communication Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityCommunicationField_)
    async UpdateEntityCommunicationField(
        @Arg('input', () => UpdateEntityCommunicationFieldInput) input: UpdateEntityCommunicationFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Communication Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityCommunicationField_)
    async DeleteEntityCommunicationField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Communication Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Change Replay Runs
//****************************************************************************
@ObjectType({ description: `Table to track the runs of replaying external record changes` })
export class RecordChangeReplayRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Timestamp when the replay run started`}) 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the replay run ended`}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({description: `Status of the replay run (Pending, In Progress, Complete, Error)`}) 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [RecordChange_])
    RecordChanges_ReplayRunIDArray: RecordChange_[]; // Link to RecordChanges
    
}

//****************************************************************************
// INPUT TYPE for Record Change Replay Runs
//****************************************************************************
@InputType()
export class CreateRecordChangeReplayRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Record Change Replay Runs
//****************************************************************************
@InputType()
export class UpdateRecordChangeReplayRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Change Replay Runs
//****************************************************************************
@ObjectType()
export class RunRecordChangeReplayRunViewResult {
    @Field(() => [RecordChangeReplayRun_])
    Results: RecordChangeReplayRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecordChangeReplayRun_)
export class RecordChangeReplayRunResolver extends ResolverBase {
    @Query(() => RunRecordChangeReplayRunViewResult)
    async RunRecordChangeReplayRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecordChangeReplayRunViewResult)
    async RunRecordChangeReplayRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunRecordChangeReplayRunViewResult)
    async RunRecordChangeReplayRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Change Replay Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => RecordChangeReplayRun_, { nullable: true })
    async RecordChangeReplayRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecordChangeReplayRun_ | null> {
        this.CheckUserReadPermissions('Record Change Replay Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChangeReplayRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Record Change Replay Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [RecordChange_])
    async RecordChanges_ReplayRunIDArray(@Root() recordchangereplayrun_: RecordChangeReplayRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [ReplayRunID]='${recordchangereplayrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', rows);
        return result;
    }
        
    @Mutation(() => RecordChangeReplayRun_)
    async CreateRecordChangeReplayRun(
        @Arg('input', () => CreateRecordChangeReplayRunInput) input: CreateRecordChangeReplayRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Change Replay Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => RecordChangeReplayRun_)
    async UpdateRecordChangeReplayRun(
        @Arg('input', () => UpdateRecordChangeReplayRunInput) input: UpdateRecordChangeReplayRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Change Replay Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => RecordChangeReplayRun_)
    async DeleteRecordChangeReplayRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Record Change Replay Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Library Items
//****************************************************************************
@ObjectType({ description: `Table to store individual library items` })
export class LibraryItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field() 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({description: `Type of the library item for example Class, Interface, etc.`}) 
    @MaxLength(100)
    Type: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for Library Items
//****************************************************************************
@InputType()
export class CreateLibraryItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;
}
    

//****************************************************************************
// INPUT TYPE for Library Items
//****************************************************************************
@InputType()
export class UpdateLibraryItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Library Items
//****************************************************************************
@ObjectType()
export class RunLibraryItemViewResult {
    @Field(() => [LibraryItem_])
    Results: LibraryItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(LibraryItem_)
export class LibraryItemResolver extends ResolverBase {
    @Query(() => RunLibraryItemViewResult)
    async RunLibraryItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunLibraryItemViewResult)
    async RunLibraryItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunLibraryItemViewResult)
    async RunLibraryItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Library Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => LibraryItem_, { nullable: true })
    async LibraryItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<LibraryItem_ | null> {
        this.CheckUserReadPermissions('Library Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraryItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Library Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => LibraryItem_)
    async CreateLibraryItem(
        @Arg('input', () => CreateLibraryItemInput) input: CreateLibraryItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Library Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => LibraryItem_)
    async UpdateLibraryItem(
        @Arg('input', () => UpdateLibraryItemInput) input: UpdateLibraryItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Library Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => LibraryItem_)
    async DeleteLibraryItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Library Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Relationship Display Components
//****************************************************************************
@ObjectType({ description: `This table stores a list of components that are available for displaying relationships in the MJ Explorer UI` })
export class EntityRelationshipDisplayComponent_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The type of relationship the component displays. Valid values are "One to Many", "Many to Many", or "Both".`}) 
    @MaxLength(40)
    RelationshipType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityRelationship_])
    EntityRelationships_DisplayComponentIDArray: EntityRelationship_[]; // Link to EntityRelationships
    
}

//****************************************************************************
// INPUT TYPE for Entity Relationship Display Components
//****************************************************************************
@InputType()
export class CreateEntityRelationshipDisplayComponentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Relationship Display Components
//****************************************************************************
@InputType()
export class UpdateEntityRelationshipDisplayComponentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Relationship Display Components
//****************************************************************************
@ObjectType()
export class RunEntityRelationshipDisplayComponentViewResult {
    @Field(() => [EntityRelationshipDisplayComponent_])
    Results: EntityRelationshipDisplayComponent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityRelationshipDisplayComponent_)
export class EntityRelationshipDisplayComponentResolver extends ResolverBase {
    @Query(() => RunEntityRelationshipDisplayComponentViewResult)
    async RunEntityRelationshipDisplayComponentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityRelationshipDisplayComponentViewResult)
    async RunEntityRelationshipDisplayComponentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityRelationshipDisplayComponentViewResult)
    async RunEntityRelationshipDisplayComponentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Relationship Display Components';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityRelationshipDisplayComponent_, { nullable: true })
    async EntityRelationshipDisplayComponent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityRelationshipDisplayComponent_ | null> {
        this.CheckUserReadPermissions('Entity Relationship Display Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationshipDisplayComponents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationship Display Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Relationship Display Components', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [EntityRelationship_])
    async EntityRelationships_DisplayComponentIDArray(@Root() entityrelationshipdisplaycomponent_: EntityRelationshipDisplayComponent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [DisplayComponentID]='${entityrelationshipdisplaycomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows);
        return result;
    }
        
    @Mutation(() => EntityRelationshipDisplayComponent_)
    async CreateEntityRelationshipDisplayComponent(
        @Arg('input', () => CreateEntityRelationshipDisplayComponentInput) input: CreateEntityRelationshipDisplayComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Relationship Display Components', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityRelationshipDisplayComponent_)
    async UpdateEntityRelationshipDisplayComponent(
        @Arg('input', () => UpdateEntityRelationshipDisplayComponentInput) input: UpdateEntityRelationshipDisplayComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Relationship Display Components', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityRelationshipDisplayComponent_)
    async DeleteEntityRelationshipDisplayComponent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Relationship Display Components', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Params
//****************************************************************************
@ObjectType({ description: `Stores paramater mappings to enable Entity Actions to automatically invoke Actions` })
export class EntityActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionParamID: string;
        
    @Field({description: `Type of the value, which can be Static, Entity Object, or Script.`}) 
    @MaxLength(40)
    ValueType: string;
        
    @Field({nullable: true, description: `Value of the parameter, used only when ValueType is Static or Script. When value is Script, any valid JavaScript code can be provided. The script will have access to an object called EntityActionContext. This object will have a property called EntityObject on it that will contain the BaseEntity derived sub-class with the current data for the entity object this action is operating against. The script must provide the parameter value to the EntityActionContext.result property. This scripting capabilty is designed for very small and simple code, for anything of meaningful complexity, create a sub-class instead.`}) 
    Value?: string;
        
    @Field({nullable: true, description: `Additional comments regarding the parameter.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Params
//****************************************************************************
@InputType()
export class CreateEntityActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Params
//****************************************************************************
@InputType()
export class UpdateEntityActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Params
//****************************************************************************
@ObjectType()
export class RunEntityActionParamViewResult {
    @Field(() => [EntityActionParam_])
    Results: EntityActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityActionParam_)
export class EntityActionParamResolver extends ResolverBase {
    @Query(() => RunEntityActionParamViewResult)
    async RunEntityActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionParamViewResult)
    async RunEntityActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunEntityActionParamViewResult)
    async RunEntityActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => EntityActionParam_, { nullable: true })
    async EntityActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityActionParam_ | null> {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Entity Action Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => EntityActionParam_)
    async CreateEntityActionParam(
        @Arg('input', () => CreateEntityActionParamInput) input: CreateEntityActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => EntityActionParam_)
    async UpdateEntityActionParam(
        @Arg('input', () => UpdateEntityActionParamInput) input: UpdateEntityActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => EntityActionParam_)
    async DeleteEntityActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Permissions
//****************************************************************************
@ObjectType({ description: `Table for managing sharing of resources to users or roles with time constraints and permission levels` })
export class ResourcePermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the type of resource being shared (View, Dashboard, Report, etc.)`}) 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being shared`}) 
    @MaxLength(510)
    ResourceRecordID: string;
        
    @Field({description: `The level of sharing either Role or User`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `Optional: Date when sharing starts`}) 
    @MaxLength(10)
    StartSharingAt?: Date;
        
    @Field({nullable: true, description: `Optional: Date when sharing ends`}) 
    @MaxLength(10)
    EndSharingAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RoleID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Permission level defining the type of access (View, Edit, Owner)`}) 
    @MaxLength(40)
    PermissionLevel?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the resource permission request. Possible values are Requested, Approved, Rejected, or Revoked.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Role?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for Resource Permissions
//****************************************************************************
@InputType()
export class CreateResourcePermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt: Date | null;

    @Field({ nullable: true })
    EndSharingAt: Date | null;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    PermissionLevel: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Resource Permissions
//****************************************************************************
@InputType()
export class UpdateResourcePermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt?: Date | null;

    @Field({ nullable: true })
    EndSharingAt?: Date | null;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    PermissionLevel?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Permissions
//****************************************************************************
@ObjectType()
export class RunResourcePermissionViewResult {
    @Field(() => [ResourcePermission_])
    Results: ResourcePermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ResourcePermission_)
export class ResourcePermissionResolver extends ResolverBase {
    @Query(() => RunResourcePermissionViewResult)
    async RunResourcePermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunResourcePermissionViewResult)
    async RunResourcePermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunResourcePermissionViewResult)
    async RunResourcePermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ResourcePermission_, { nullable: true })
    async ResourcePermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ResourcePermission_ | null> {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Resource Permissions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ResourcePermission_)
    async CreateResourcePermission(
        @Arg('input', () => CreateResourcePermissionInput) input: CreateResourcePermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Resource Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ResourcePermission_)
    async UpdateResourcePermission(
        @Arg('input', () => UpdateResourcePermissionInput) input: UpdateResourcePermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Resource Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ResourcePermission_)
    async DeleteResourcePermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Links
//****************************************************************************
@ObjectType({ description: `Table to track user links to shared resources such as views, dashboards, etc.` })
export class ResourceLink_ {
    @Field({description: `Unique identifier for each resource link`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to the user linking the resource`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Foreign key to the resource type (view, dashboard, etc.)`}) 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being linked`}) 
    @MaxLength(510)
    ResourceRecordID: string;
        
    @Field({nullable: true, description: `Optional folder where the user organizes the linked resource`}) 
    @MaxLength(510)
    FolderID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for Resource Links
//****************************************************************************
@InputType()
export class CreateResourceLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Resource Links
//****************************************************************************
@InputType()
export class UpdateResourceLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Links
//****************************************************************************
@ObjectType()
export class RunResourceLinkViewResult {
    @Field(() => [ResourceLink_])
    Results: ResourceLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ResourceLink_)
export class ResourceLinkResolver extends ResolverBase {
    @Query(() => RunResourceLinkViewResult)
    async RunResourceLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunResourceLinkViewResult)
    async RunResourceLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunResourceLinkViewResult)
    async RunResourceLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ResourceLink_, { nullable: true })
    async ResourceLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ResourceLink_ | null> {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Resource Links', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ResourceLink_)
    async CreateResourceLink(
        @Arg('input', () => CreateResourceLinkInput) input: CreateResourceLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Resource Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ResourceLink_)
    async UpdateResourceLink(
        @Arg('input', () => UpdateResourceLinkInput) input: UpdateResourceLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Resource Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ResourceLink_)
    async DeleteResourceLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType({ description: `Stores versions of conversation artifacts` })
export class ConversationArtifactVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the parent artifact`}) 
    @MaxLength(16)
    ConversationArtifactID: string;
        
    @Field(() => Int, {description: `Sequential version number (starting from 1) for this artifact`}) 
    Version: number;
        
    @Field({description: `JSON configuration and metadata for this artifact version`}) 
    Configuration: string;
        
    @Field({nullable: true, description: `Actual content of the artifact, if stored separately from configuration`}) 
    Content?: string;
        
    @Field({nullable: true, description: `User comments specific to this version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ConversationArtifact: string;
        
    @Field(() => [ConversationDetail_])
    ConversationDetails_ArtifactVersionIDArray: ConversationDetail_[]; // Link to ConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class CreateConversationArtifactVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class UpdateConversationArtifactVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType()
export class RunConversationArtifactVersionViewResult {
    @Field(() => [ConversationArtifactVersion_])
    Results: ConversationArtifactVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ConversationArtifactVersion_)
export class ConversationArtifactVersionResolver extends ResolverBase {
    @Query(() => RunConversationArtifactVersionViewResult)
    async RunConversationArtifactVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactVersionViewResult)
    async RunConversationArtifactVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactVersionViewResult)
    async RunConversationArtifactVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ConversationArtifactVersion_, { nullable: true })
    async ConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ConversationArtifactVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ConversationDetail_])
    async ConversationDetails_ArtifactVersionIDArray(@Root() conversationartifactversion_: ConversationArtifactVersion_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ArtifactVersionID]='${conversationartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows);
        return result;
    }
        
    @Mutation(() => ConversationArtifactVersion_)
    async CreateConversationArtifactVersion(
        @Arg('input', () => CreateConversationArtifactVersionInput) input: CreateConversationArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifact Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ConversationArtifactVersion_)
    async UpdateConversationArtifactVersion(
        @Arg('input', () => UpdateConversationArtifactVersionInput) input: UpdateConversationArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifact Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ConversationArtifactVersion_)
    async DeleteConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Requests
//****************************************************************************
@ObjectType({ description: `Table to log AI Agent requests, responses, and their statuses.` })
export class AIAgentRequest_ {
    @Field({description: `Primary key for the AIAgentRequest table, uniquely identifies each record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key referencing the ID column in the AIAgent table.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Timestamp when the request was made by the agent.`}) 
    @MaxLength(8)
    RequestedAt: Date;
        
    @Field({nullable: true, description: `Optional, a user that the AI specifically is directing the request to, if null intended for general system owner.`}) 
    @MaxLength(16)
    RequestForUserID?: string;
        
    @Field({description: `Current status of the request (Requested, Approved, Rejected, Canceled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Details of what the AI Agent is requesting.`}) 
    Request: string;
        
    @Field({nullable: true, description: `Response provided by the human to the agent request.`}) 
    Response?: string;
        
    @Field({nullable: true, description: `Populated when a user responds indicating which user responded to the request.`}) 
    @MaxLength(16)
    ResponseByUserID?: string;
        
    @Field({nullable: true, description: `Timestamp when the response was provided by the human.`}) 
    @MaxLength(8)
    RespondedAt?: Date;
        
    @Field({nullable: true, description: `Additional comments about the request. Not shared with the agent, purely record keeping.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    RequestForUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ResponseByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Requests
//****************************************************************************
@InputType()
export class CreateAIAgentRequestInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response: string | null;

    @Field({ nullable: true })
    ResponseByUserID: string | null;

    @Field({ nullable: true })
    RespondedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Requests
//****************************************************************************
@InputType()
export class UpdateAIAgentRequestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response?: string | null;

    @Field({ nullable: true })
    ResponseByUserID?: string | null;

    @Field({ nullable: true })
    RespondedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Requests
//****************************************************************************
@ObjectType()
export class RunAIAgentRequestViewResult {
    @Field(() => [AIAgentRequest_])
    Results: AIAgentRequest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentRequest_)
export class AIAgentRequestResolver extends ResolverBase {
    @Query(() => RunAIAgentRequestViewResult)
    async RunAIAgentRequestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRequestViewResult)
    async RunAIAgentRequestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRequestViewResult)
    async RunAIAgentRequestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Requests';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentRequest_, { nullable: true })
    async AIAgentRequest(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentRequest_ | null> {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Requests', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIAgentRequest_)
    async CreateAIAgentRequest(
        @Arg('input', () => CreateAIAgentRequestInput) input: CreateAIAgentRequestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Requests', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentRequest_)
    async UpdateAIAgentRequest(
        @Arg('input', () => UpdateAIAgentRequestInput) input: UpdateAIAgentRequestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Requests', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentRequest_)
    async DeleteAIAgentRequest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Requests', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Vendors
//****************************************************************************
@ObjectType({ description: `Associates AI models with vendors providing them, including vendor-specific implementation details.` })
export class AIModelVendor_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ModelID: string;
        
    @Field() 
    @MaxLength(16)
    VendorID: string;
        
    @Field(() => Int, {description: `Determines the priority rank of this vendor for the model. Higher values indicate higher priority.`}) 
    Priority: number;
        
    @Field({description: `The current status of this model-vendor combination. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `The name of the driver class implementing this model-vendor combination.`}) 
    @MaxLength(200)
    DriverClass?: string;
        
    @Field({nullable: true, description: `The import path for the driver class.`}) 
    @MaxLength(510)
    DriverImportPath?: string;
        
    @Field({nullable: true, description: `The name of the model to use with API calls, which might differ from the model name. If not provided, the model name will be used.`}) 
    @MaxLength(200)
    APIName?: string;
        
    @Field(() => Int, {nullable: true, description: `The maximum number of input tokens supported by this model-vendor implementation.`}) 
    MaxInputTokens?: number;
        
    @Field(() => Int, {nullable: true, description: `The maximum number of output tokens supported by this model-vendor implementation.`}) 
    MaxOutputTokens?: number;
        
    @Field({description: `A comma-delimited string indicating the supported response formats for this model-vendor implementation. Options include Any, Text, Markdown, JSON, and ModelSpecific.`}) 
    @MaxLength(200)
    SupportedResponseFormats: string;
        
    @Field(() => Boolean, {description: `Specifies if this model-vendor implementation supports the concept of an effort level.`}) 
    SupportsEffortLevel: boolean;
        
    @Field(() => Boolean, {description: `Specifies if this model-vendor implementation supports streaming responses.`}) 
    SupportsStreaming: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `References the type/role of the vendor for this model (e.g., model developer, inference provider)`}) 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field() 
    @MaxLength(100)
    Vendor: string;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Vendors
//****************************************************************************
@InputType()
export class CreateAIModelVendorInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    APIName: string | null;

    @Field(() => Int, { nullable: true })
    MaxInputTokens: number | null;

    @Field(() => Int, { nullable: true })
    MaxOutputTokens: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsStreaming?: boolean;

    @Field({ nullable: true })
    TypeID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Vendors
//****************************************************************************
@InputType()
export class UpdateAIModelVendorInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    APIName?: string | null;

    @Field(() => Int, { nullable: true })
    MaxInputTokens?: number | null;

    @Field(() => Int, { nullable: true })
    MaxOutputTokens?: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsStreaming?: boolean;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Vendors
//****************************************************************************
@ObjectType()
export class RunAIModelVendorViewResult {
    @Field(() => [AIModelVendor_])
    Results: AIModelVendor_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModelVendor_)
export class AIModelVendorResolver extends ResolverBase {
    @Query(() => RunAIModelVendorViewResult)
    async RunAIModelVendorViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelVendorViewResult)
    async RunAIModelVendorViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelVendorViewResult)
    async RunAIModelVendorDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Vendors';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIModelVendor_, { nullable: true })
    async AIModelVendor(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModelVendor_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelVendors] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Model Vendors', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIModelVendor_)
    async CreateAIModelVendor(
        @Arg('input', () => CreateAIModelVendorInput) input: CreateAIModelVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Vendors', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIModelVendor_)
    async UpdateAIModelVendor(
        @Arg('input', () => UpdateAIModelVendorInput) input: UpdateAIModelVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Vendors', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIModelVendor_)
    async DeleteAIModelVendor(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Vendors', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendor Type Definitions
//****************************************************************************
@ObjectType({ description: `Defines the possible types of AI vendors, such as Model Developer or Inference Provider.` })
export class AIVendorTypeDefinition_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The name of the vendor type.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the vendor type.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIModelVendor_])
    MJ_AIModelVendors_TypeIDArray: AIModelVendor_[]; // Link to MJ_AIModelVendors
    
    @Field(() => [AIVendorType_])
    MJ_AIVendorTypes_TypeIDArray: AIVendorType_[]; // Link to MJ_AIVendorTypes
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Type Definitions
//****************************************************************************
@InputType()
export class CreateAIVendorTypeDefinitionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Type Definitions
//****************************************************************************
@InputType()
export class UpdateAIVendorTypeDefinitionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendor Type Definitions
//****************************************************************************
@ObjectType()
export class RunAIVendorTypeDefinitionViewResult {
    @Field(() => [AIVendorTypeDefinition_])
    Results: AIVendorTypeDefinition_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIVendorTypeDefinition_)
export class AIVendorTypeDefinitionResolver extends ResolverBase {
    @Query(() => RunAIVendorTypeDefinitionViewResult)
    async RunAIVendorTypeDefinitionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIVendorTypeDefinitionViewResult)
    async RunAIVendorTypeDefinitionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIVendorTypeDefinitionViewResult)
    async RunAIVendorTypeDefinitionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendor Type Definitions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIVendorTypeDefinition_, { nullable: true })
    async AIVendorTypeDefinition(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIVendorTypeDefinition_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendor Type Definitions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendorTypeDefinitions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Type Definitions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Vendor Type Definitions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIModelVendor_])
    async MJ_AIModelVendors_TypeIDArray(@Root() aivendortypedefinition_: AIVendorTypeDefinition_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelVendors] WHERE [TypeID]='${aivendortypedefinition_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows);
        return result;
    }
        
    @FieldResolver(() => [AIVendorType_])
    async MJ_AIVendorTypes_TypeIDArray(@Root() aivendortypedefinition_: AIVendorTypeDefinition_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendorTypes] WHERE [TypeID]='${aivendortypedefinition_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Vendor Types', rows);
        return result;
    }
        
    @Mutation(() => AIVendorTypeDefinition_)
    async CreateAIVendorTypeDefinition(
        @Arg('input', () => CreateAIVendorTypeDefinitionInput) input: CreateAIVendorTypeDefinitionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendor Type Definitions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIVendorTypeDefinition_)
    async UpdateAIVendorTypeDefinition(
        @Arg('input', () => UpdateAIVendorTypeDefinitionInput) input: UpdateAIVendorTypeDefinitionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendor Type Definitions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIVendorTypeDefinition_)
    async DeleteAIVendorTypeDefinition(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendor Type Definitions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report User States
//****************************************************************************
@ObjectType({ description: `Tracks individual user state within interactive reports` })
export class ReportUserState_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `JSON serialized state of user interaction with the report`}) 
    ReportState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class CreateReportUserStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class UpdateReportUserStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report User States
//****************************************************************************
@ObjectType()
export class RunReportUserStateViewResult {
    @Field(() => [ReportUserState_])
    Results: ReportUserState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ReportUserState_)
export class ReportUserStateResolver extends ResolverBase {
    @Query(() => RunReportUserStateViewResult)
    async RunReportUserStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportUserStateViewResult)
    async RunReportUserStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportUserStateViewResult)
    async RunReportUserStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report User States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ReportUserState_, { nullable: true })
    async ReportUserState(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ReportUserState_ | null> {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Report User States', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ReportUserState_)
    async CreateReportUserState(
        @Arg('input', () => CreateReportUserStateInput) input: CreateReportUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report User States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ReportUserState_)
    async UpdateReportUserState(
        @Arg('input', () => UpdateReportUserStateInput) input: UpdateReportUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report User States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ReportUserState_)
    async DeleteReportUserState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report User States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Entities
//****************************************************************************
@ObjectType({ description: `Tracks which entities are involved in a given query. The Queries table stores SQL and descriptions for stored queries that can be executed and serve as examples for AI.` })
export class QueryEntity_ {
    @Field({description: `Unique identifier for the QueryEntity record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `References the ID of the query in the Queries table.`}) 
    @MaxLength(16)
    QueryID: string;
        
    @Field({description: `References the ID of the entity in the Entities table.`}) 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates how this entity-query relationship was identified. "AI" means the QueryEntityServer used LLM analysis to parse the SQL/template and identify which MemberJunction entities are referenced (by analyzing table names, joins, and query structure). "Manual" means a user explicitly marked this entity as being used by the query. AI detection helps maintain accurate metadata automatically as queries evolve.`}) 
    @MaxLength(100)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was that this entity is actually used in the query. Only populated when DetectionMethod="AI". Considers factors like: direct table references vs indirect joins, clear entity names vs ambiguous aliases, and context from the query purpose. Lower scores might indicate the entity is only peripherally involved or the detection was uncertain.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Entities
//****************************************************************************
@InputType()
export class CreateQueryEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Query Entities
//****************************************************************************
@InputType()
export class UpdateQueryEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Entities
//****************************************************************************
@ObjectType()
export class RunQueryEntityViewResult {
    @Field(() => [QueryEntity_])
    Results: QueryEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryEntity_)
export class QueryEntityResolver extends ResolverBase {
    @Query(() => RunQueryEntityViewResult)
    async RunQueryEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryEntityViewResult)
    async RunQueryEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryEntityViewResult)
    async RunQueryEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => QueryEntity_, { nullable: true })
    async QueryEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryEntity_ | null> {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Query Entities', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => QueryEntity_)
    async CreateQueryEntity(
        @Arg('input', () => CreateQueryEntityInput) input: CreateQueryEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => QueryEntity_)
    async UpdateQueryEntity(
        @Arg('input', () => UpdateQueryEntityInput) input: UpdateQueryEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => QueryEntity_)
    async DeleteQueryEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard User States
//****************************************************************************
@ObjectType({ description: `Stores user-specific dashboard state information` })
export class DashboardUserState_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Dashboard that this state applies to`}) 
    @MaxLength(16)
    DashboardID: string;
        
    @Field({description: `User that this state belongs to`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `JSON object containing user-specific dashboard state`}) 
    UserState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Dashboard: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User States
//****************************************************************************
@InputType()
export class CreateDashboardUserStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UserState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User States
//****************************************************************************
@InputType()
export class UpdateDashboardUserStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UserState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard User States
//****************************************************************************
@ObjectType()
export class RunDashboardUserStateViewResult {
    @Field(() => [DashboardUserState_])
    Results: DashboardUserState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DashboardUserState_)
export class DashboardUserStateResolver extends ResolverBase {
    @Query(() => RunDashboardUserStateViewResult)
    async RunDashboardUserStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDashboardUserStateViewResult)
    async RunDashboardUserStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDashboardUserStateViewResult)
    async RunDashboardUserStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard User States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DashboardUserState_, { nullable: true })
    async DashboardUserState(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DashboardUserState_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserStates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Dashboard User States', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => DashboardUserState_)
    async CreateDashboardUserState(
        @Arg('input', () => CreateDashboardUserStateInput) input: CreateDashboardUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard User States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DashboardUserState_)
    async UpdateDashboardUserState(
        @Arg('input', () => UpdateDashboardUserStateInput) input: UpdateDashboardUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard User States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DashboardUserState_)
    async DeleteDashboardUserState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard User States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Components
//****************************************************************************
@ObjectType({ description: `Main catalog of reusable components with versioning and registry support` })
export class Component_ {
    @Field({description: `Immutable UUID that remains the same across all systems`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `Hierarchical namespace path (e.g., dashboards/sales for local, @memberjunction/dashboards/financial for external)`}) 
    Namespace?: string;
        
    @Field({description: `Component name within the namespace (e.g., revenue-tracker)`}) 
    @MaxLength(1000)
    Name: string;
        
    @Field({description: `Semantic version number (e.g., 1.0.0, 1.2.3-beta)`}) 
    @MaxLength(100)
    Version: string;
        
    @Field(() => Int, {description: `Numeric sequence for sorting versions`}) 
    VersionSequence: number;
        
    @Field({nullable: true, description: `User-friendly display title for the component`}) 
    @MaxLength(2000)
    Title?: string;
        
    @Field({nullable: true, description: `Detailed description of the component functionality`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Component type: report, dashboard, form, table, chart, navigation, search, widget, utility, or other`}) 
    @MaxLength(510)
    Type?: string;
        
    @Field({nullable: true, description: `Publication status: draft, published, or deprecated`}) 
    @MaxLength(100)
    Status?: string;
        
    @Field({nullable: true, description: `Name of the component developer or author`}) 
    @MaxLength(510)
    DeveloperName?: string;
        
    @Field({nullable: true, description: `Contact email for the component developer`}) 
    @MaxLength(510)
    DeveloperEmail?: string;
        
    @Field({nullable: true, description: `Organization name of the component developer`}) 
    @MaxLength(510)
    DeveloperOrganization?: string;
        
    @Field({nullable: true, description: `Foreign key to ComponentRegistry - NULL for local components, populated for replicated ones`}) 
    @MaxLength(16)
    SourceRegistryID?: string;
        
    @Field({nullable: true, description: `Timestamp when the component was replicated from external registry (NULL for local components)`}) 
    @MaxLength(10)
    ReplicatedAt?: Date;
        
    @Field({nullable: true, description: `Last synchronization timestamp with the source registry`}) 
    @MaxLength(10)
    LastSyncedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Complete JSON specification object for the component`}) 
    Specification: string;
        
    @Field({nullable: true, description: `Functional requirements describing what the component should accomplish`}) 
    FunctionalRequirements?: string;
        
    @Field({nullable: true, description: `Technical design describing how the component is implemented`}) 
    TechnicalDesign?: string;
        
    @Field({nullable: true, description: `Vector embedding of the functional requirements for similarity search`}) 
    FunctionalRequirementsVector?: string;
        
    @Field({nullable: true, description: `Vector embedding of the technical design for similarity search`}) 
    TechnicalDesignVector?: string;
        
    @Field(() => Boolean, {description: `Indicates if the component has custom properties defined in its specification. Components with custom props cannot be used directly by deterministic containers.`}) 
    HasCustomProps: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the component has custom events defined in its specification. Components with custom events may have limited functionality in generic containers.`}) 
    HasCustomEvents: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the component requires data access (utilities object with md, rv, rq). Used to determine if component needs data context.`}) 
    RequiresData: boolean;
        
    @Field(() => Int, {description: `Number of component dependencies defined in the specification. Used to assess component complexity.`}) 
    DependencyCount: number;
        
    @Field({nullable: true, description: `The ID of the AI model used to generate the vector embedding for the technical design`}) 
    TechnicalDesignVectorEmbeddingModelID?: string;
        
    @Field({nullable: true, description: `The ID of the AI model used to generate the vector embedding for the functional requirements`}) 
    FunctionalRequirementsVectorEmbeddingModelID?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the component has any custom properties that are marked as required. This is auto-calculated based on the component's properties array to identify components with mandatory custom configuration.`}) 
    HasRequiredCustomProps: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceRegistry?: string;
        
    @Field(() => [ComponentDependency_])
    MJ_ComponentDependencies_DependencyComponentIDArray: ComponentDependency_[]; // Link to MJ_ComponentDependencies
    
    @Field(() => [ComponentLibraryLink_])
    MJ_ComponentLibraryLinks_ComponentIDArray: ComponentLibraryLink_[]; // Link to MJ_ComponentLibraryLinks
    
    @Field(() => [ComponentDependency_])
    MJ_ComponentDependencies_ComponentIDArray: ComponentDependency_[]; // Link to MJ_ComponentDependencies
    
}

//****************************************************************************
// INPUT TYPE for MJ: Components
//****************************************************************************
@InputType()
export class CreateComponentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Namespace: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Version?: string;

    @Field(() => Int, { nullable: true })
    VersionSequence?: number;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    DeveloperName: string | null;

    @Field({ nullable: true })
    DeveloperEmail: string | null;

    @Field({ nullable: true })
    DeveloperOrganization: string | null;

    @Field({ nullable: true })
    SourceRegistryID: string | null;

    @Field({ nullable: true })
    ReplicatedAt: Date | null;

    @Field({ nullable: true })
    LastSyncedAt: Date | null;

    @Field({ nullable: true })
    Specification?: string;

    @Field({ nullable: true })
    FunctionalRequirements: string | null;

    @Field({ nullable: true })
    TechnicalDesign: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVector: string | null;

    @Field({ nullable: true })
    TechnicalDesignVector: string | null;

    @Field(() => Boolean, { nullable: true })
    HasCustomProps?: boolean;

    @Field(() => Boolean, { nullable: true })
    HasCustomEvents?: boolean;

    @Field(() => Boolean, { nullable: true })
    RequiresData?: boolean;

    @Field(() => Int, { nullable: true })
    DependencyCount?: number;

    @Field({ nullable: true })
    TechnicalDesignVectorEmbeddingModelID: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVectorEmbeddingModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    HasRequiredCustomProps?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Components
//****************************************************************************
@InputType()
export class UpdateComponentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Namespace?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Version?: string;

    @Field(() => Int, { nullable: true })
    VersionSequence?: number;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    DeveloperName?: string | null;

    @Field({ nullable: true })
    DeveloperEmail?: string | null;

    @Field({ nullable: true })
    DeveloperOrganization?: string | null;

    @Field({ nullable: true })
    SourceRegistryID?: string | null;

    @Field({ nullable: true })
    ReplicatedAt?: Date | null;

    @Field({ nullable: true })
    LastSyncedAt?: Date | null;

    @Field({ nullable: true })
    Specification?: string;

    @Field({ nullable: true })
    FunctionalRequirements?: string | null;

    @Field({ nullable: true })
    TechnicalDesign?: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVector?: string | null;

    @Field({ nullable: true })
    TechnicalDesignVector?: string | null;

    @Field(() => Boolean, { nullable: true })
    HasCustomProps?: boolean;

    @Field(() => Boolean, { nullable: true })
    HasCustomEvents?: boolean;

    @Field(() => Boolean, { nullable: true })
    RequiresData?: boolean;

    @Field(() => Int, { nullable: true })
    DependencyCount?: number;

    @Field({ nullable: true })
    TechnicalDesignVectorEmbeddingModelID?: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVectorEmbeddingModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    HasRequiredCustomProps?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Components
//****************************************************************************
@ObjectType()
export class RunComponentViewResult {
    @Field(() => [Component_])
    Results: Component_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Component_)
export class ComponentResolver extends ResolverBase {
    @Query(() => RunComponentViewResult)
    async RunComponentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentViewResult)
    async RunComponentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentViewResult)
    async RunComponentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Components';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => Component_, { nullable: true })
    async Component(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Component_ | null> {
        this.CheckUserReadPermissions('MJ: Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Components', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ComponentDependency_])
    async MJ_ComponentDependencies_DependencyComponentIDArray(@Root() component_: Component_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentDependencies] WHERE [DependencyComponentID]='${component_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Component Dependencies', rows);
        return result;
    }
        
    @FieldResolver(() => [ComponentLibraryLink_])
    async MJ_ComponentLibraryLinks_ComponentIDArray(@Root() component_: Component_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentLibraryLinks] WHERE [ComponentID]='${component_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Component Library Links', rows);
        return result;
    }
        
    @FieldResolver(() => [ComponentDependency_])
    async MJ_ComponentDependencies_ComponentIDArray(@Root() component_: Component_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentDependencies] WHERE [ComponentID]='${component_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Component Dependencies', rows);
        return result;
    }
        
    @Mutation(() => Component_)
    async CreateComponent(
        @Arg('input', () => CreateComponentInput) input: CreateComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Components', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => Component_)
    async UpdateComponent(
        @Arg('input', () => UpdateComponentInput) input: UpdateComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Components', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => Component_)
    async DeleteComponent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Components', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Types
//****************************************************************************
@ObjectType({ description: `Defines the types of artifacts that can be created within conversations` })
export class ArtifactType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the artifact type`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the artifact type`}) 
    Description?: string;
        
    @Field({description: `MIME type or content identifier for this artifact type`}) 
    @MaxLength(200)
    ContentType: string;
        
    @Field(() => Boolean, {description: `Indicates if this artifact type is currently available for use`}) 
    IsEnabled: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ConversationArtifact_])
    MJ_ConversationArtifacts_ArtifactTypeIDArray: ConversationArtifact_[]; // Link to MJ_ConversationArtifacts
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class CreateArtifactTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class UpdateArtifactTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Types
//****************************************************************************
@ObjectType()
export class RunArtifactTypeViewResult {
    @Field(() => [ArtifactType_])
    Results: ArtifactType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ArtifactType_)
export class ArtifactTypeResolver extends ResolverBase {
    @Query(() => RunArtifactTypeViewResult)
    async RunArtifactTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunArtifactTypeViewResult)
    async RunArtifactTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunArtifactTypeViewResult)
    async RunArtifactTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ArtifactType_, { nullable: true })
    async ArtifactType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ArtifactType_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Artifact Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ConversationArtifact_])
    async MJ_ConversationArtifacts_ArtifactTypeIDArray(@Root() artifacttype_: ArtifactType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ArtifactTypeID]='${artifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows);
        return result;
    }
        
    @Mutation(() => ArtifactType_)
    async CreateArtifactType(
        @Arg('input', () => CreateArtifactTypeInput) input: CreateArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ArtifactType_)
    async UpdateArtifactType(
        @Arg('input', () => UpdateArtifactTypeInput) input: UpdateArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ArtifactType_)
    async DeleteArtifactType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendor Types
//****************************************************************************
@ObjectType({ description: `Associates vendors with their types (Model Developer, Inference Provider) and tracks the status of each role.` })
export class AIVendorType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    VendorID: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field(() => Int, {description: `Determines the priority rank of this type for the vendor. Higher values indicate higher priority.`}) 
    Rank: number;
        
    @Field({description: `The current status of this vendor type. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Vendor: string;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Types
//****************************************************************************
@InputType()
export class CreateAIVendorTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Types
//****************************************************************************
@InputType()
export class UpdateAIVendorTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendor Types
//****************************************************************************
@ObjectType()
export class RunAIVendorTypeViewResult {
    @Field(() => [AIVendorType_])
    Results: AIVendorType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIVendorType_)
export class AIVendorTypeResolver extends ResolverBase {
    @Query(() => RunAIVendorTypeViewResult)
    async RunAIVendorTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIVendorTypeViewResult)
    async RunAIVendorTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIVendorTypeViewResult)
    async RunAIVendorTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendor Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIVendorType_, { nullable: true })
    async AIVendorType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIVendorType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendorTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Vendor Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIVendorType_)
    async CreateAIVendorType(
        @Arg('input', () => CreateAIVendorTypeInput) input: CreateAIVendorTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendor Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIVendorType_)
    async UpdateAIVendorType(
        @Arg('input', () => UpdateAIVendorTypeInput) input: UpdateAIVendorTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendor Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIVendorType_)
    async DeleteAIVendorType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendor Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType({ description: `Stores metadata for artifacts created within conversations` })
export class ConversationArtifact_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the artifact`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Extended description of the artifact`}) 
    Description?: string;
        
    @Field({description: `Reference to the conversation this artifact belongs to`}) 
    @MaxLength(16)
    ConversationID: string;
        
    @Field({description: `Reference to the type of artifact`}) 
    @MaxLength(16)
    ArtifactTypeID: string;
        
    @Field({description: `Controls who can view this artifact (None, SpecificUsers, Everyone, Public)`}) 
    @MaxLength(100)
    SharingScope: string;
        
    @Field({nullable: true, description: `User comments about the artifact`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field() 
    @MaxLength(200)
    ArtifactType: string;
        
    @Field(() => [ConversationArtifactPermission_])
    MJ_ConversationArtifactPermissions_ConversationArtifactIDArray: ConversationArtifactPermission_[]; // Link to MJ_ConversationArtifactPermissions
    
    @Field(() => [ConversationArtifactVersion_])
    MJ_ConversationArtifactVersions_ConversationArtifactIDArray: ConversationArtifactVersion_[]; // Link to MJ_ConversationArtifactVersions
    
    @Field(() => [ConversationDetail_])
    ConversationDetails_ArtifactIDArray: ConversationDetail_[]; // Link to ConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class CreateConversationArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class UpdateConversationArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType()
export class RunConversationArtifactViewResult {
    @Field(() => [ConversationArtifact_])
    Results: ConversationArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ConversationArtifact_)
export class ConversationArtifactResolver extends ResolverBase {
    @Query(() => RunConversationArtifactViewResult)
    async RunConversationArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactViewResult)
    async RunConversationArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactViewResult)
    async RunConversationArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ConversationArtifact_, { nullable: true })
    async ConversationArtifact(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ConversationArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ConversationArtifactPermission_])
    async MJ_ConversationArtifactPermissions_ConversationArtifactIDArray(@Root() conversationartifact_: ConversationArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactPermissions] WHERE [ConversationArtifactID]='${conversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', rows);
        return result;
    }
        
    @FieldResolver(() => [ConversationArtifactVersion_])
    async MJ_ConversationArtifactVersions_ConversationArtifactIDArray(@Root() conversationartifact_: ConversationArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactVersions] WHERE [ConversationArtifactID]='${conversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', rows);
        return result;
    }
        
    @FieldResolver(() => [ConversationDetail_])
    async ConversationDetails_ArtifactIDArray(@Root() conversationartifact_: ConversationArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ArtifactID]='${conversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows);
        return result;
    }
        
    @Mutation(() => ConversationArtifact_)
    async CreateConversationArtifact(
        @Arg('input', () => CreateConversationArtifactInput) input: CreateConversationArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ConversationArtifact_)
    async UpdateConversationArtifact(
        @Arg('input', () => UpdateConversationArtifactInput) input: UpdateConversationArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ConversationArtifact_)
    async DeleteConversationArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Prompts
//****************************************************************************
@ObjectType({ description: `Links AI agents with the prompts they use, including execution order and context handling.` })
export class AIAgentPrompt_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `References the agent this prompt is associated with.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `References the prompt to be used by the agent.`}) 
    @MaxLength(16)
    PromptID: string;
        
    @Field({nullable: true, description: `The functional purpose of this prompt within the agent, such as "Initialize", "ProcessData", or "Summarize".`}) 
    Purpose?: string;
        
    @Field(() => Int, {description: `The sequence order in which this prompt should be executed within the agent's workflow.`}) 
    ExecutionOrder: number;
        
    @Field({nullable: true, description: `Optional reference to a specific configuration to use for this prompt. If NULL, uses the default configuration.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field({description: `The current status of this agent-prompt mapping. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Determines how conversation context is filtered for this prompt: Complete, Smart, None, RecentMessages, InitialMessages, or Custom.`}) 
    @MaxLength(100)
    ContextBehavior: string;
        
    @Field(() => Int, {nullable: true, description: `The number of messages to include when ContextBehavior is set to RecentMessages or InitialMessages.`}) 
    ContextMessageCount?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field() 
    @MaxLength(510)
    Prompt: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Prompts
//****************************************************************************
@InputType()
export class CreateAIAgentPromptInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    Purpose: string | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ContextBehavior?: string;

    @Field(() => Int, { nullable: true })
    ContextMessageCount: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Prompts
//****************************************************************************
@InputType()
export class UpdateAIAgentPromptInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    Purpose?: string | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ContextBehavior?: string;

    @Field(() => Int, { nullable: true })
    ContextMessageCount?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Prompts
//****************************************************************************
@ObjectType()
export class RunAIAgentPromptViewResult {
    @Field(() => [AIAgentPrompt_])
    Results: AIAgentPrompt_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentPrompt_)
export class AIAgentPromptResolver extends ResolverBase {
    @Query(() => RunAIAgentPromptViewResult)
    async RunAIAgentPromptViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentPromptViewResult)
    async RunAIAgentPromptViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentPromptViewResult)
    async RunAIAgentPromptDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Prompts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentPrompt_, { nullable: true })
    async AIAgentPrompt(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentPrompt_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPrompts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIAgentPrompt_)
    async CreateAIAgentPrompt(
        @Arg('input', () => CreateAIAgentPromptInput) input: CreateAIAgentPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Prompts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentPrompt_)
    async UpdateAIAgentPrompt(
        @Arg('input', () => UpdateAIAgentPromptInput) input: UpdateAIAgentPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Prompts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentPrompt_)
    async DeleteAIAgentPrompt(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Prompts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Libraries
//****************************************************************************
@ObjectType({ description: `Catalog of third-party JavaScript libraries that components can depend on` })
export class ComponentLibrary_ {
    @Field({description: `Primary key for the component library`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `NPM-style package name (e.g., recharts, lodash, @memberjunction/lib-name)`}) 
    @MaxLength(1000)
    Name: string;
        
    @Field({nullable: true, description: `User-friendly display name for the library`}) 
    @MaxLength(1000)
    DisplayName?: string;
        
    @Field({nullable: true, description: `Library version number`}) 
    @MaxLength(200)
    Version?: string;
        
    @Field({nullable: true, description: `Global variable name when loaded (e.g., _ for lodash, React for react)`}) 
    @MaxLength(510)
    GlobalVariable?: string;
        
    @Field({nullable: true, description: `Library category: Core, Runtime, UI, Charting, Utility, or Other`}) 
    @MaxLength(200)
    Category?: string;
        
    @Field({nullable: true, description: `CDN URL for loading the library JavaScript`}) 
    @MaxLength(2000)
    CDNUrl?: string;
        
    @Field({nullable: true, description: `Optional CDN URL for loading library CSS`}) 
    @MaxLength(2000)
    CDNCssUrl?: string;
        
    @Field({nullable: true, description: `Description of the library and its capabilities`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the component library. Active: fully supported; Deprecated: works but shows console warning; Disabled: throws error if used`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `JSON configuration for library-specific lint rules that are applied during component validation. This field contains structured rules that define how components using this library should be validated, including DOM element requirements, initialization patterns, lifecycle methods, and common error patterns. Example structure: {"initialization": {"constructorName": "Chart", "elementType": "canvas"}, "lifecycle": {"requiredMethods": ["render"], "cleanupMethods": ["destroy"]}}. The linter dynamically applies these rules based on the libraries referenced in a component spec, enabling extensible validation without hardcoding library-specific logic.`}) 
    LintRules?: string;
        
    @Field({nullable: true, description: `JSON object defining dependencies for this component library. Format: { "libraryName": "versionSpec", ... }. Version specifications follow NPM-style syntax (e.g., "~1.0.0", "^1.2.3", "2.3.4"). Dependencies are loaded before this library to ensure proper execution context.`}) 
    Dependencies?: string;
        
    @Field(() => [ComponentLibraryLink_])
    MJ_ComponentLibraryLinks_LibraryIDArray: ComponentLibraryLink_[]; // Link to MJ_ComponentLibraryLinks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Component Libraries
//****************************************************************************
@InputType()
export class CreateComponentLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    Version: string | null;

    @Field({ nullable: true })
    GlobalVariable: string | null;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    CDNUrl: string | null;

    @Field({ nullable: true })
    CDNCssUrl: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LintRules: string | null;

    @Field({ nullable: true })
    Dependencies: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Libraries
//****************************************************************************
@InputType()
export class UpdateComponentLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    Version?: string | null;

    @Field({ nullable: true })
    GlobalVariable?: string | null;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    CDNUrl?: string | null;

    @Field({ nullable: true })
    CDNCssUrl?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LintRules?: string | null;

    @Field({ nullable: true })
    Dependencies?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Libraries
//****************************************************************************
@ObjectType()
export class RunComponentLibraryViewResult {
    @Field(() => [ComponentLibrary_])
    Results: ComponentLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ComponentLibrary_)
export class ComponentLibraryResolver extends ResolverBase {
    @Query(() => RunComponentLibraryViewResult)
    async RunComponentLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentLibraryViewResult)
    async RunComponentLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentLibraryViewResult)
    async RunComponentLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ComponentLibrary_, { nullable: true })
    async ComponentLibrary(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ComponentLibrary_ | null> {
        this.CheckUserReadPermissions('MJ: Component Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Component Libraries', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ComponentLibraryLink_])
    async MJ_ComponentLibraryLinks_LibraryIDArray(@Root() componentlibrary_: ComponentLibrary_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentLibraryLinks] WHERE [LibraryID]='${componentlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Component Library Links', rows);
        return result;
    }
        
    @Mutation(() => ComponentLibrary_)
    async CreateComponentLibrary(
        @Arg('input', () => CreateComponentLibraryInput) input: CreateComponentLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ComponentLibrary_)
    async UpdateComponentLibrary(
        @Arg('input', () => UpdateComponentLibraryInput) input: UpdateComponentLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ComponentLibrary_)
    async DeleteComponentLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard User Preferences
//****************************************************************************
@ObjectType({ description: `Stores dashboard preferences for users and system defaults. The absence of a record for a dashboard means it is not shown.` })
export class DashboardUserPreference_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `User that these preferences belong to, NULL for system defaults`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({description: `Dashboard that this preference refers to`}) 
    @MaxLength(16)
    DashboardID: string;
        
    @Field({description: `Scope of the preference (Global or App)`}) 
    @MaxLength(40)
    Scope: string;
        
    @Field({nullable: true, description: `Application that this preference applies to (only for App scope)`}) 
    @MaxLength(16)
    ApplicationID?: string;
        
    @Field(() => Int, {description: `Order in which to display the dashboard`}) 
    DisplayOrder: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field() 
    @MaxLength(510)
    Dashboard: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Application?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User Preferences
//****************************************************************************
@InputType()
export class CreateDashboardUserPreferenceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User Preferences
//****************************************************************************
@InputType()
export class UpdateDashboardUserPreferenceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard User Preferences
//****************************************************************************
@ObjectType()
export class RunDashboardUserPreferenceViewResult {
    @Field(() => [DashboardUserPreference_])
    Results: DashboardUserPreference_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DashboardUserPreference_)
export class DashboardUserPreferenceResolver extends ResolverBase {
    @Query(() => RunDashboardUserPreferenceViewResult)
    async RunDashboardUserPreferenceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDashboardUserPreferenceViewResult)
    async RunDashboardUserPreferenceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunDashboardUserPreferenceViewResult)
    async RunDashboardUserPreferenceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard User Preferences';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => DashboardUserPreference_, { nullable: true })
    async DashboardUserPreference(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DashboardUserPreference_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserPreferences] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => DashboardUserPreference_)
    async CreateDashboardUserPreference(
        @Arg('input', () => CreateDashboardUserPreferenceInput) input: CreateDashboardUserPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard User Preferences', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => DashboardUserPreference_)
    async UpdateDashboardUserPreference(
        @Arg('input', () => UpdateDashboardUserPreferenceInput) input: UpdateDashboardUserPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard User Preferences', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => DashboardUserPreference_)
    async DeleteDashboardUserPreference(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard User Preferences', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Query Parameters
//****************************************************************************
@ObjectType({ description: `Stores parameter definitions for parameterized queries that use Nunjucks templates. Each parameter represents a dynamic value that can be passed when executing the query. Parameters are automatically extracted from the query template by the QueryEntityServer using LLM analysis, or can be manually defined. The combination of parameter metadata and validation filters creates a self-documenting, type-safe query execution system.` })
export class QueryParameter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field({description: `The name of the parameter as it appears in the Nunjucks template. This must match exactly with the parameter reference in the SQL template. For example, if the template contains {{ userEmail | required | email }}, the Name would be "userEmail". Parameter names should follow JavaScript identifier rules: start with a letter, and contain only letters, numbers, and underscores.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `The data type of the parameter used for validation and type conversion. Valid values are: "string" for text values, "number" for integers or decimals, "date" for date/datetime values (ISO 8601 format expected), "boolean" for true/false values, and "array" for multiple values (typically used with IN clauses). The type determines which validation filters can be applied and how the parameter is processed.`}) 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether this parameter must be provided when executing the query. When true, the query execution will fail if the parameter is not supplied and no DefaultValue is set. This is automatically determined by the presence of the "required" filter in the template, but can be manually overridden. Required parameters ensure data integrity and prevent unintended query behavior.`}) 
    IsRequired?: boolean;
        
    @Field({nullable: true, description: `The default value to use when the parameter is not provided during query execution. This value must be compatible with the parameter Type. For arrays, use JSON format like ["value1","value2"]. Default values allow queries to have sensible fallbacks while still accepting custom inputs. If a parameter is required (IsRequired=true), the default value is ignored.`}) 
    DefaultValue?: string;
        
    @Field({nullable: true, description: `Human-readable description explaining the purpose and usage of this parameter. This is typically generated by LLM analysis of the query context but can be manually edited. Good descriptions include: what the parameter filters or controls, valid value ranges or formats, business meaning, and any special considerations. This text is shown in UI to help users understand what value to provide.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `A concrete example value demonstrating the proper format for this parameter. Generated by LLM based on the query context and validation filters. For example: "john@example.com" for an email parameter, "2024-01-15" for a date, or "["active","pending"]" for a status array. Sample values help users understand the expected format and can be used in API documentation.`}) 
    SampleValue?: string;
        
    @Field({nullable: true, description: `JSON array of Nunjucks filter definitions that validate and transform the parameter value. Each filter is an object with "name" and optional "args" properties. Filters are applied in order and can include: validation (required, email, min, max), transformation (trim, upper, lower), SQL safety (sqlsafe, sqljoin), and type conversion (number, date). Example: [{"name":"required"},{"name":"email"},{"name":"sqlsafe"}]. The filter chain ensures type safety and prevents SQL injection.`}) 
    ValidationFilters?: string;
        
    @Field({description: `Indicates how this parameter was identified and added to the system. "AI" means it was automatically detected by LLM analysis of the query template, including extraction of parameter name, type inference from filters, and generation of description. "Manual" means it was explicitly defined by a user. This helps track which parameters might need human review and provides transparency about the source of metadata.`}) 
    @MaxLength(100)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was about this parameter detection. Only populated when DetectionMethod="AI". Higher scores indicate the LLM was more confident about the parameter name, type, and usage. Scores above 0.80 are generally reliable, 0.60-0.80 may benefit from human review, and below 0.60 should be manually verified. This helps prioritize which auto-detected parameters need human attention.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Query Parameters
//****************************************************************************
@InputType()
export class CreateQueryParameterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean | null;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SampleValue: string | null;

    @Field({ nullable: true })
    ValidationFilters: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Query Parameters
//****************************************************************************
@InputType()
export class UpdateQueryParameterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean | null;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SampleValue?: string | null;

    @Field({ nullable: true })
    ValidationFilters?: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Query Parameters
//****************************************************************************
@ObjectType()
export class RunQueryParameterViewResult {
    @Field(() => [QueryParameter_])
    Results: QueryParameter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryParameter_)
export class QueryParameterResolver extends ResolverBase {
    @Query(() => RunQueryParameterViewResult)
    async RunQueryParameterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryParameterViewResult)
    async RunQueryParameterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunQueryParameterViewResult)
    async RunQueryParameterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Query Parameters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => QueryParameter_, { nullable: true })
    async QueryParameter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryParameter_ | null> {
        this.CheckUserReadPermissions('MJ: Query Parameters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryParameters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Parameters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Query Parameters', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => QueryParameter_)
    async CreateQueryParameter(
        @Arg('input', () => CreateQueryParameterInput) input: CreateQueryParameterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Query Parameters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => QueryParameter_)
    async UpdateQueryParameter(
        @Arg('input', () => UpdateQueryParameterInput) input: UpdateQueryParameterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Query Parameters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => QueryParameter_)
    async DeleteQueryParameter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Query Parameters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Relationships
//****************************************************************************
@ObjectType({ description: `Tracks relationships between AI agents for sub-agent orchestration` })
export class AIAgentRelationship_ {
    @Field({description: `Primary key for AI agent relationships`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to parent AIAgent that can invoke the sub-agent`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Foreign key to sub-agent AIAgent that can be invoked`}) 
    @MaxLength(16)
    SubAgentID: string;
        
    @Field({description: `Status of the relationship: Pending (awaiting approval), Active (can invoke), or Revoked (no longer allowed)`}) 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SubAgent?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Relationships
//****************************************************************************
@InputType()
export class CreateAIAgentRelationshipInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    SubAgentID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Relationships
//****************************************************************************
@InputType()
export class UpdateAIAgentRelationshipInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    SubAgentID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Relationships
//****************************************************************************
@ObjectType()
export class RunAIAgentRelationshipViewResult {
    @Field(() => [AIAgentRelationship_])
    Results: AIAgentRelationship_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentRelationship_)
export class AIAgentRelationshipResolver extends ResolverBase {
    @Query(() => RunAIAgentRelationshipViewResult)
    async RunAIAgentRelationshipViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRelationshipViewResult)
    async RunAIAgentRelationshipViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRelationshipViewResult)
    async RunAIAgentRelationshipDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Relationships';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentRelationship_, { nullable: true })
    async AIAgentRelationship(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentRelationship_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRelationships] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIAgentRelationship_)
    async CreateAIAgentRelationship(
        @Arg('input', () => CreateAIAgentRelationshipInput) input: CreateAIAgentRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Relationships', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentRelationship_)
    async UpdateAIAgentRelationship(
        @Arg('input', () => UpdateAIAgentRelationshipInput) input: UpdateAIAgentRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Relationships', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentRelationship_)
    async DeleteAIAgentRelationship(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Relationships', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Library Links
//****************************************************************************
@ObjectType({ description: `Links components to their third-party library dependencies` })
export class ComponentLibraryLink_ {
    @Field({description: `Primary key for component-library relationship`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to Component that depends on the library`}) 
    @MaxLength(16)
    ComponentID: string;
        
    @Field({description: `Foreign key to ComponentLibrary that the component depends on`}) 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({nullable: true, description: `Minimum version requirement using semantic versioning (e.g., ^1.0.0, ~2.5.0)`}) 
    @MaxLength(200)
    MinVersion?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    Component: string;
        
    @Field() 
    @MaxLength(1000)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Component Library Links
//****************************************************************************
@InputType()
export class CreateComponentLibraryLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    MinVersion: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Library Links
//****************************************************************************
@InputType()
export class UpdateComponentLibraryLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    MinVersion?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Library Links
//****************************************************************************
@ObjectType()
export class RunComponentLibraryLinkViewResult {
    @Field(() => [ComponentLibraryLink_])
    Results: ComponentLibraryLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ComponentLibraryLink_)
export class ComponentLibraryLinkResolver extends ResolverBase {
    @Query(() => RunComponentLibraryLinkViewResult)
    async RunComponentLibraryLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentLibraryLinkViewResult)
    async RunComponentLibraryLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunComponentLibraryLinkViewResult)
    async RunComponentLibraryLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Library Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ComponentLibraryLink_, { nullable: true })
    async ComponentLibraryLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ComponentLibraryLink_ | null> {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentLibraryLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Component Library Links', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ComponentLibraryLink_)
    async CreateComponentLibraryLink(
        @Arg('input', () => CreateComponentLibraryLinkInput) input: CreateComponentLibraryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Library Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ComponentLibraryLink_)
    async UpdateComponentLibraryLink(
        @Arg('input', () => UpdateComponentLibraryLinkInput) input: UpdateComponentLibraryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Library Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ComponentLibraryLink_)
    async DeleteComponentLibraryLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Library Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Process Runs
//****************************************************************************
@ObjectType({ description: `Tracks execution of content tagging workflows, logging the status and details of each execution and ensuring efficient processing of content.` })
export class ContentProcessRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    SourceID: string;
        
    @Field({nullable: true, description: `Timestamp when the content processing workflow began execution.`}) 
    @MaxLength(8)
    StartTime?: Date;
        
    @Field({nullable: true, description: `Timestamp when the content processing workflow completed or failed.`}) 
    @MaxLength(8)
    EndTime?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Status?: string;
        
    @Field(() => Int, {nullable: true, description: `Count of content items successfully processed during this run.`}) 
    ProcessedItems?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Source?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Process Runs
//****************************************************************************
@InputType()
export class CreateContentProcessRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime: Date | null;

    @Field({ nullable: true })
    EndTime: Date | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Process Runs
//****************************************************************************
@InputType()
export class UpdateContentProcessRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime?: Date | null;

    @Field({ nullable: true })
    EndTime?: Date | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Process Runs
//****************************************************************************
@ObjectType()
export class RunContentProcessRunViewResult {
    @Field(() => [ContentProcessRun_])
    Results: ContentProcessRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentProcessRun_)
export class ContentProcessRunResolver extends ResolverBase {
    @Query(() => RunContentProcessRunViewResult)
    async RunContentProcessRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentProcessRunViewResult)
    async RunContentProcessRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentProcessRunViewResult)
    async RunContentProcessRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Process Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentProcessRun_, { nullable: true })
    async ContentProcessRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentProcessRun_ | null> {
        this.CheckUserReadPermissions('Content Process Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentProcessRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Process Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ContentProcessRun_)
    async CreateContentProcessRun(
        @Arg('input', () => CreateContentProcessRunInput) input: CreateContentProcessRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Process Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentProcessRun_)
    async UpdateContentProcessRun(
        @Arg('input', () => UpdateContentProcessRunInput) input: UpdateContentProcessRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Process Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentProcessRun_)
    async DeleteContentProcessRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Process Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Sources
//****************************************************************************
@ObjectType({ description: `Configures connections to external content repositories and systems from which content is imported, synchronized, and tagged.` })
export class ContentSource_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentFileTypeID: string;
        
    @Field({description: `Base URL or connection string for accessing this content source.`}) 
    @MaxLength(4000)
    URL: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ContentType: string;
        
    @Field() 
    @MaxLength(510)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(510)
    ContentFileType: string;
        
    @Field(() => [ContentProcessRun_])
    ContentProcessRuns_SourceIDArray: ContentProcessRun_[]; // Link to ContentProcessRuns
    
    @Field(() => [ContentSourceParam_])
    ContentSourceParams_ContentSourceIDArray: ContentSourceParam_[]; // Link to ContentSourceParams
    
    @Field(() => [ContentItem_])
    ContentItems_ContentSourceIDArray: ContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Sources
//****************************************************************************
@InputType()
export class CreateContentSourceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Sources
//****************************************************************************
@InputType()
export class UpdateContentSourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Sources
//****************************************************************************
@ObjectType()
export class RunContentSourceViewResult {
    @Field(() => [ContentSource_])
    Results: ContentSource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentSource_)
export class ContentSourceResolver extends ResolverBase {
    @Query(() => RunContentSourceViewResult)
    async RunContentSourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentSourceViewResult)
    async RunContentSourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentSourceViewResult)
    async RunContentSourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Sources';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentSource_, { nullable: true })
    async ContentSource(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentSource_ | null> {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Sources', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ContentProcessRun_])
    async ContentProcessRuns_SourceIDArray(@Root() contentsource_: ContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Process Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentProcessRuns] WHERE [SourceID]='${contentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Process Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [ContentSourceParam_])
    async ContentSourceParams_ContentSourceIDArray(@Root() contentsource_: ContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Source Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceParams] WHERE [ContentSourceID]='${contentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Source Params', rows);
        return result;
    }
        
    @FieldResolver(() => [ContentItem_])
    async ContentItems_ContentSourceIDArray(@Root() contentsource_: ContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentSourceID]='${contentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', rows);
        return result;
    }
        
    @Mutation(() => ContentSource_)
    async CreateContentSource(
        @Arg('input', () => CreateContentSourceInput) input: CreateContentSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Sources', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentSource_)
    async UpdateContentSource(
        @Arg('input', () => UpdateContentSourceInput) input: UpdateContentSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Sources', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentSource_)
    async DeleteContentSource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Sources', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Params
//****************************************************************************
@ObjectType({ description: `Stores configuration parameters for specific content source instances, customizing how content is retrieved and processed from each source.` })
export class ContentSourceParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceID: string;
        
    @Field({description: `Reference to the parameter definition in Content Source Type Params.`}) 
    @MaxLength(16)
    ContentSourceTypeParamID: string;
        
    @Field({description: `The configured value for this parameter on this specific content source.`}) 
    Value: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContentSource?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Source Params
//****************************************************************************
@InputType()
export class CreateContentSourceParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Params
//****************************************************************************
@InputType()
export class UpdateContentSourceParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Params
//****************************************************************************
@ObjectType()
export class RunContentSourceParamViewResult {
    @Field(() => [ContentSourceParam_])
    Results: ContentSourceParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentSourceParam_)
export class ContentSourceParamResolver extends ResolverBase {
    @Query(() => RunContentSourceParamViewResult)
    async RunContentSourceParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentSourceParamViewResult)
    async RunContentSourceParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentSourceParamViewResult)
    async RunContentSourceParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentSourceParam_, { nullable: true })
    async ContentSourceParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentSourceParam_ | null> {
        this.CheckUserReadPermissions('Content Source Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Source Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ContentSourceParam_)
    async CreateContentSourceParam(
        @Arg('input', () => CreateContentSourceParamInput) input: CreateContentSourceParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentSourceParam_)
    async UpdateContentSourceParam(
        @Arg('input', () => UpdateContentSourceParamInput) input: UpdateContentSourceParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentSourceParam_)
    async DeleteContentSourceParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Types
//****************************************************************************
@ObjectType({ description: `Catalogs available content source types such as file systems, APIs, websites, databases, and cloud storage platforms with their capabilities.` })
export class ContentSourceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ContentSource_])
    ContentSources_ContentSourceTypeIDArray: ContentSource_[]; // Link to ContentSources
    
    @Field(() => [ContentItem_])
    ContentItems_ContentSourceTypeIDArray: ContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Source Types
//****************************************************************************
@InputType()
export class CreateContentSourceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Types
//****************************************************************************
@InputType()
export class UpdateContentSourceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Types
//****************************************************************************
@ObjectType()
export class RunContentSourceTypeViewResult {
    @Field(() => [ContentSourceType_])
    Results: ContentSourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentSourceType_)
export class ContentSourceTypeResolver extends ResolverBase {
    @Query(() => RunContentSourceTypeViewResult)
    async RunContentSourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentSourceTypeViewResult)
    async RunContentSourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentSourceTypeViewResult)
    async RunContentSourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentSourceType_, { nullable: true })
    async ContentSourceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentSourceType_ | null> {
        this.CheckUserReadPermissions('Content Source Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Source Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ContentSource_])
    async ContentSources_ContentSourceTypeIDArray(@Root() contentsourcetype_: ContentSourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentSourceTypeID]='${contentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', rows);
        return result;
    }
        
    @FieldResolver(() => [ContentItem_])
    async ContentItems_ContentSourceTypeIDArray(@Root() contentsourcetype_: ContentSourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentSourceTypeID]='${contentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', rows);
        return result;
    }
        
    @Mutation(() => ContentSourceType_)
    async CreateContentSourceType(
        @Arg('input', () => CreateContentSourceTypeInput) input: CreateContentSourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentSourceType_)
    async UpdateContentSourceType(
        @Arg('input', () => UpdateContentSourceTypeInput) input: UpdateContentSourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentSourceType_)
    async DeleteContentSourceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Type Params
//****************************************************************************
@ObjectType({ description: `Defines required and optional parameters for content source types, establishing the configuration for each source type.` })
export class ContentSourceTypeParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Data type of the parameter (string, number, boolean, date, etc.).`}) 
    @MaxLength(100)
    Type?: string;
        
    @Field({nullable: true, description: `Default value to use if not specified when configuring a content source.`}) 
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this parameter must be provided when setting up a content source.`}) 
    IsRequired: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Content Source Type Params
//****************************************************************************
@InputType()
export class CreateContentSourceTypeParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Type Params
//****************************************************************************
@InputType()
export class UpdateContentSourceTypeParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Type Params
//****************************************************************************
@ObjectType()
export class RunContentSourceTypeParamViewResult {
    @Field(() => [ContentSourceTypeParam_])
    Results: ContentSourceTypeParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentSourceTypeParam_)
export class ContentSourceTypeParamResolver extends ResolverBase {
    @Query(() => RunContentSourceTypeParamViewResult)
    async RunContentSourceTypeParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentSourceTypeParamViewResult)
    async RunContentSourceTypeParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentSourceTypeParamViewResult)
    async RunContentSourceTypeParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Type Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentSourceTypeParam_, { nullable: true })
    async ContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentSourceTypeParam_ | null> {
        this.CheckUserReadPermissions('Content Source Type Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceTypeParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Type Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Source Type Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ContentSourceTypeParam_)
    async CreateContentSourceTypeParam(
        @Arg('input', () => CreateContentSourceTypeParamInput) input: CreateContentSourceTypeParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Type Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentSourceTypeParam_)
    async UpdateContentSourceTypeParam(
        @Arg('input', () => UpdateContentSourceTypeParamInput) input: UpdateContentSourceTypeParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Type Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentSourceTypeParam_)
    async DeleteContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Type Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Types
//****************************************************************************
@ObjectType({ description: `Defines categories of content with specific schemas, behaviors, and processing rules for structured content management.` })
export class ContentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field(() => Int, {description: `Minimum number of tags that must be applied to content of this type.`}) 
    MinTags: number;
        
    @Field(() => Int, {description: `Maximum number of tags allowed on content of this type.`}) 
    MaxTags: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field(() => [ContentSource_])
    ContentSources_ContentTypeIDArray: ContentSource_[]; // Link to ContentSources
    
    @Field(() => [ContentItem_])
    ContentItems_ContentTypeIDArray: ContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Types
//****************************************************************************
@InputType()
export class CreateContentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;
}
    

//****************************************************************************
// INPUT TYPE for Content Types
//****************************************************************************
@InputType()
export class UpdateContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Types
//****************************************************************************
@ObjectType()
export class RunContentTypeViewResult {
    @Field(() => [ContentType_])
    Results: ContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentType_)
export class ContentTypeResolver extends ResolverBase {
    @Query(() => RunContentTypeViewResult)
    async RunContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentTypeViewResult)
    async RunContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentTypeViewResult)
    async RunContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentType_, { nullable: true })
    async ContentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentType_ | null> {
        this.CheckUserReadPermissions('Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ContentSource_])
    async ContentSources_ContentTypeIDArray(@Root() contenttype_: ContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentTypeID]='${contenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', rows);
        return result;
    }
        
    @FieldResolver(() => [ContentItem_])
    async ContentItems_ContentTypeIDArray(@Root() contenttype_: ContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentTypeID]='${contenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', rows);
        return result;
    }
        
    @Mutation(() => ContentType_)
    async CreateContentType(
        @Arg('input', () => CreateContentTypeInput) input: CreateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentType_)
    async UpdateContentType(
        @Arg('input', () => UpdateContentTypeInput) input: UpdateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentType_)
    async DeleteContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Type Attributes
//****************************************************************************
@ObjectType({ description: `Defines the attributes available for extraction via prompt for each content type.` })
export class ContentTypeAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the Content Type this attribute belongs to.`}) 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The AI prompt template used to extract this attribute from content.`}) 
    Prompt: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Content Type Attributes
//****************************************************************************
@InputType()
export class CreateContentTypeAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Type Attributes
//****************************************************************************
@InputType()
export class UpdateContentTypeAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Type Attributes
//****************************************************************************
@ObjectType()
export class RunContentTypeAttributeViewResult {
    @Field(() => [ContentTypeAttribute_])
    Results: ContentTypeAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentTypeAttribute_)
export class ContentTypeAttributeResolver extends ResolverBase {
    @Query(() => RunContentTypeAttributeViewResult)
    async RunContentTypeAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentTypeAttributeViewResult)
    async RunContentTypeAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentTypeAttributeViewResult)
    async RunContentTypeAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Type Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentTypeAttribute_, { nullable: true })
    async ContentTypeAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentTypeAttribute_ | null> {
        this.CheckUserReadPermissions('Content Type Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypeAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Type Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Type Attributes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ContentTypeAttribute_)
    async CreateContentTypeAttribute(
        @Arg('input', () => CreateContentTypeAttributeInput) input: CreateContentTypeAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Type Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentTypeAttribute_)
    async UpdateContentTypeAttribute(
        @Arg('input', () => UpdateContentTypeAttributeInput) input: UpdateContentTypeAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Type Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentTypeAttribute_)
    async DeleteContentTypeAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Type Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content File Types
//****************************************************************************
@ObjectType({ description: `Defines supported file types for content management, including extensions and processing rules for different content formats.` })
export class ContentFileType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `The file extension (e.g., .pdf, .docx, .jpg) used to identify this content type.`}) 
    @MaxLength(510)
    FileExtension?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ContentSource_])
    ContentSources_ContentFileTypeIDArray: ContentSource_[]; // Link to ContentSources
    
    @Field(() => [ContentItem_])
    ContentItems_ContentFileTypeIDArray: ContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content File Types
//****************************************************************************
@InputType()
export class CreateContentFileTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content File Types
//****************************************************************************
@InputType()
export class UpdateContentFileTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content File Types
//****************************************************************************
@ObjectType()
export class RunContentFileTypeViewResult {
    @Field(() => [ContentFileType_])
    Results: ContentFileType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentFileType_)
export class ContentFileTypeResolver extends ResolverBase {
    @Query(() => RunContentFileTypeViewResult)
    async RunContentFileTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentFileTypeViewResult)
    async RunContentFileTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentFileTypeViewResult)
    async RunContentFileTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content File Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentFileType_, { nullable: true })
    async ContentFileType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentFileType_ | null> {
        this.CheckUserReadPermissions('Content File Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentFileTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content File Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content File Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ContentSource_])
    async ContentSources_ContentFileTypeIDArray(@Root() contentfiletype_: ContentFileType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentFileTypeID]='${contentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', rows);
        return result;
    }
        
    @FieldResolver(() => [ContentItem_])
    async ContentItems_ContentFileTypeIDArray(@Root() contentfiletype_: ContentFileType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentFileTypeID]='${contentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', rows);
        return result;
    }
        
    @Mutation(() => ContentFileType_)
    async CreateContentFileType(
        @Arg('input', () => CreateContentFileTypeInput) input: CreateContentFileTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content File Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentFileType_)
    async UpdateContentFileType(
        @Arg('input', () => UpdateContentFileTypeInput) input: UpdateContentFileTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content File Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentFileType_)
    async DeleteContentFileType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content File Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Items
//****************************************************************************
@ObjectType({ description: `Stores extracted text from content assets, as well as the source location, versioning, and links to extracted tags and attributes.` })
export class ContentItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceID: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentFileTypeID: string;
        
    @Field({nullable: true, description: `Hash value of the content used to detect changes and prevent duplicate processing.`}) 
    @MaxLength(200)
    Checksum?: string;
        
    @Field({description: `The source location URL where this content was retrieved from.`}) 
    @MaxLength(4000)
    URL: string;
        
    @Field({nullable: true, description: `The extracted text content from the source document or file.`}) 
    Text?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContentSource?: string;
        
    @Field() 
    @MaxLength(510)
    ContentType: string;
        
    @Field() 
    @MaxLength(510)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(510)
    ContentFileType: string;
        
    @Field(() => [ContentItemAttribute_])
    ContentItemAttributes_ContentItemIDArray: ContentItemAttribute_[]; // Link to ContentItemAttributes
    
    @Field(() => [ContentItemTag_])
    ContentItemTags_ItemIDArray: ContentItemTag_[]; // Link to ContentItemTags
    
}

//****************************************************************************
// INPUT TYPE for Content Items
//****************************************************************************
@InputType()
export class CreateContentItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Items
//****************************************************************************
@InputType()
export class UpdateContentItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum?: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Items
//****************************************************************************
@ObjectType()
export class RunContentItemViewResult {
    @Field(() => [ContentItem_])
    Results: ContentItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentItem_)
export class ContentItemResolver extends ResolverBase {
    @Query(() => RunContentItemViewResult)
    async RunContentItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentItemViewResult)
    async RunContentItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentItemViewResult)
    async RunContentItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentItem_, { nullable: true })
    async ContentItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentItem_ | null> {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Items', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [ContentItemAttribute_])
    async ContentItemAttributes_ContentItemIDArray(@Root() contentitem_: ContentItem_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Item Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemAttributes] WHERE [ContentItemID]='${contentitem_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Item Attributes', rows);
        return result;
    }
        
    @FieldResolver(() => [ContentItemTag_])
    async ContentItemTags_ItemIDArray(@Root() contentitem_: ContentItem_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Item Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemTags] WHERE [ItemID]='${contentitem_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('Content Item Tags', rows);
        return result;
    }
        
    @Mutation(() => ContentItem_)
    async CreateContentItem(
        @Arg('input', () => CreateContentItemInput) input: CreateContentItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentItem_)
    async UpdateContentItem(
        @Arg('input', () => UpdateContentItemInput) input: UpdateContentItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentItem_)
    async DeleteContentItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Item Attributes
//****************************************************************************
@ObjectType({ description: `Stores metadata attributes extracted with prompting for content items, enabling flexible key-value properties and custom fields for content classification.` })
export class ContentItemAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentItemID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The extracted or assigned value for this attribute on the content item.`}) 
    Value: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    ContentItem?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Item Attributes
//****************************************************************************
@InputType()
export class CreateContentItemAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Item Attributes
//****************************************************************************
@InputType()
export class UpdateContentItemAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Item Attributes
//****************************************************************************
@ObjectType()
export class RunContentItemAttributeViewResult {
    @Field(() => [ContentItemAttribute_])
    Results: ContentItemAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentItemAttribute_)
export class ContentItemAttributeResolver extends ResolverBase {
    @Query(() => RunContentItemAttributeViewResult)
    async RunContentItemAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentItemAttributeViewResult)
    async RunContentItemAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentItemAttributeViewResult)
    async RunContentItemAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Item Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentItemAttribute_, { nullable: true })
    async ContentItemAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentItemAttribute_ | null> {
        this.CheckUserReadPermissions('Content Item Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Item Attributes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ContentItemAttribute_)
    async CreateContentItemAttribute(
        @Arg('input', () => CreateContentItemAttributeInput) input: CreateContentItemAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Item Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentItemAttribute_)
    async UpdateContentItemAttribute(
        @Arg('input', () => UpdateContentItemAttributeInput) input: UpdateContentItemAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Item Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentItemAttribute_)
    async DeleteContentItemAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Item Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Item Tags
//****************************************************************************
@ObjectType({ description: `Links tags to content items for categorization, searchability, and content discovery across the system.` })
export class ContentItemTag_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ItemID: string;
        
    @Field({description: `The tag text applied to the content item for categorization and search.`}) 
    @MaxLength(400)
    Tag: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Item?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Item Tags
//****************************************************************************
@InputType()
export class CreateContentItemTagInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Item Tags
//****************************************************************************
@InputType()
export class UpdateContentItemTagInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Item Tags
//****************************************************************************
@ObjectType()
export class RunContentItemTagViewResult {
    @Field(() => [ContentItemTag_])
    Results: ContentItemTag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentItemTag_)
export class ContentItemTagResolver extends ResolverBase {
    @Query(() => RunContentItemTagViewResult)
    async RunContentItemTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentItemTagViewResult)
    async RunContentItemTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunContentItemTagViewResult)
    async RunContentItemTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Item Tags';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ContentItemTag_, { nullable: true })
    async ContentItemTag(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentItemTag_ | null> {
        this.CheckUserReadPermissions('Content Item Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemTags] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Content Item Tags', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ContentItemTag_)
    async CreateContentItemTag(
        @Arg('input', () => CreateContentItemTagInput) input: CreateContentItemTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Item Tags', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ContentItemTag_)
    async UpdateContentItemTag(
        @Arg('input', () => UpdateContentItemTagInput) input: UpdateContentItemTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Item Tags', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ContentItemTag_)
    async DeleteContentItemTag(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Item Tags', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Generated Codes
//****************************************************************************
@ObjectType({ description: `Stores LLM-generated code snippets, tracking their source, category, and validation status.` })
export class GeneratedCode_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `When the code was generated.`}) 
    @MaxLength(10)
    GeneratedAt: Date;
        
    @Field({description: `Reference to the category of generated code.`}) 
    @MaxLength(16)
    CategoryID: string;
        
    @Field({description: `AI model responsible for generating this code.`}) 
    @MaxLength(16)
    GeneratedByModelID: string;
        
    @Field({description: `Descriptive name of the generated code.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the generated code.`}) 
    Description?: string;
        
    @Field({description: `The actual generated code.`}) 
    Code: string;
        
    @Field({description: `Source material used to generate the code, e.g., a SQL CHECK constraint.`}) 
    Source: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `JSON containing the primary key(s) of the record this generated code is associated with.`}) 
    LinkedRecordPrimaryKey?: string;
        
    @Field({description: `Status of the generated code, e.g., Pending, Approved, or Rejected.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Programming language of the generated code (TypeScript, SQL, HTML, CSS, JavaScript, Python, or Other).`}) 
    @MaxLength(100)
    Language: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Category: string;
        
    @Field() 
    @MaxLength(100)
    GeneratedByModel: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LinkedEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Generated Codes
//****************************************************************************
@InputType()
export class CreateGeneratedCodeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;
}
    

//****************************************************************************
// INPUT TYPE for Generated Codes
//****************************************************************************
@InputType()
export class UpdateGeneratedCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Generated Codes
//****************************************************************************
@ObjectType()
export class RunGeneratedCodeViewResult {
    @Field(() => [GeneratedCode_])
    Results: GeneratedCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(GeneratedCode_)
export class GeneratedCodeResolver extends ResolverBase {
    @Query(() => RunGeneratedCodeViewResult)
    async RunGeneratedCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunGeneratedCodeViewResult)
    async RunGeneratedCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunGeneratedCodeViewResult)
    async RunGeneratedCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Generated Codes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => GeneratedCode_, { nullable: true })
    async GeneratedCode(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<GeneratedCode_ | null> {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('Generated Codes', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => GeneratedCode_)
    async CreateGeneratedCode(
        @Arg('input', () => CreateGeneratedCodeInput) input: CreateGeneratedCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Generated Codes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => GeneratedCode_)
    async UpdateGeneratedCode(
        @Arg('input', () => UpdateGeneratedCodeInput) input: UpdateGeneratedCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Generated Codes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => GeneratedCode_)
    async DeleteGeneratedCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Generated Codes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Runs
//****************************************************************************
@ObjectType({ description: `Tracks AI prompt executions including timings, inputs, outputs, and performance metrics.` })
export class AIPromptRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The prompt that was executed.`}) 
    @MaxLength(16)
    PromptID: string;
        
    @Field({description: `The AI model used for execution.`}) 
    @MaxLength(16)
    ModelID: string;
        
    @Field({description: `The vendor providing the model/inference.`}) 
    @MaxLength(16)
    VendorID: string;
        
    @Field({nullable: true, description: `If this prompt was run as part of an agent, references the agent.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `Optional configuration used for this execution.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field({description: `When the prompt run started, with timezone offset information.`}) 
    @MaxLength(10)
    RunAt: Date;
        
    @Field({nullable: true, description: `When the prompt run completed, with timezone offset information.`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total execution time in milliseconds.`}) 
    ExecutionTimeMS?: number;
        
    @Field({nullable: true, description: `The input messages sent to the model, typically in JSON format.`}) 
    Messages?: string;
        
    @Field({nullable: true, description: `The output result from the model.`}) 
    Result?: string;
        
    @Field(() => Int, {nullable: true, description: `Total number of tokens used (prompt + completion).`}) 
    TokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tokens in the prompt.`}) 
    TokensPrompt?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tokens in the completion/result.`}) 
    TokensCompletion?: number;
        
    @Field(() => Float, {nullable: true, description: `Total cost of this prompt run including its own cost plus all descendant costs. Calculated as Cost + DescendantCost. This value is stored (not computed) for query performance. Currency is specified in CostCurrency field.`}) 
    TotalCost?: number;
        
    @Field(() => Boolean, {description: `Whether the execution was successful.`}) 
    Success: boolean;
        
    @Field({nullable: true, description: `Error message if the execution failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `References the parent AIPromptRun.ID for hierarchical execution tracking. NULL for top-level runs, populated for parallel children and result selector runs.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Type of prompt run execution: Single (standard single prompt), ParallelParent (coordinator for parallel execution), ParallelChild (individual parallel execution), ResultSelector (result selection prompt that chooses best result)`}) 
    @MaxLength(40)
    RunType: string;
        
    @Field(() => Int, {nullable: true, description: `Execution order for parallel child runs and result selector runs. Used to track the sequence of execution within a parallel run group. NULL for single runs and parallel parent runs.`}) 
    ExecutionOrder?: number;
        
    @Field({nullable: true, description: `Optional reference to the AIAgentRun that initiated this prompt execution. Links prompt runs to their parent agent runs for comprehensive execution tracking.`}) 
    @MaxLength(16)
    AgentRunID?: string;
        
    @Field(() => Float, {nullable: true, description: `The cost of this specific prompt execution as reported by the AI provider. This does not include costs from child executions. The currency is specified in CostCurrency field.`}) 
    Cost?: number;
        
    @Field({nullable: true, description: `ISO 4217 currency code for the Cost field (e.g., USD, EUR, GBP). Different AI providers may use different currencies.`}) 
    @MaxLength(20)
    CostCurrency?: string;
        
    @Field(() => Int, {nullable: true, description: `Total tokens used including this execution and all child/grandchild executions. This provides a complete view of token usage for hierarchical prompt trees. Calculated as TokensPromptRollup + TokensCompletionRollup.`}) 
    TokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total prompt/input tokens including this execution and all child/grandchild executions. For leaf nodes (no children), this equals TokensPrompt. For parent nodes, this includes the sum of all descendant prompt tokens.`}) 
    TokensPromptRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total completion/output tokens including this execution and all child/grandchild executions. For leaf nodes (no children), this equals TokensCompletion. For parent nodes, this includes the sum of all descendant completion tokens.`}) 
    TokensCompletionRollup?: number;
        
    @Field(() => Float, {nullable: true, description: `The temperature parameter used for this prompt run, controlling randomness in the output (0.0 = deterministic, 2.0 = very random)`}) 
    Temperature?: number;
        
    @Field(() => Float, {nullable: true, description: `Top-p (nucleus) sampling parameter used for this run. Considers tokens with cumulative probability up to this value (0-1)`}) 
    TopP?: number;
        
    @Field(() => Int, {nullable: true, description: `Top-k sampling parameter used for this run. Limits sampling to the top K most likely tokens`}) 
    TopK?: number;
        
    @Field(() => Float, {nullable: true, description: `Minimum probability threshold used for token sampling (0-1). Tokens below this probability are filtered out`}) 
    MinP?: number;
        
    @Field(() => Float, {nullable: true, description: `Frequency penalty parameter used (-2.0 to 2.0). Positive values reduce repetition of tokens based on their frequency in the output`}) 
    FrequencyPenalty?: number;
        
    @Field(() => Float, {nullable: true, description: `Presence penalty parameter used (-2.0 to 2.0). Positive values encourage the model to talk about new topics`}) 
    PresencePenalty?: number;
        
    @Field(() => Int, {nullable: true, description: `Random seed used for reproducible outputs. When set, the same seed with identical inputs should produce the same output`}) 
    Seed?: number;
        
    @Field({nullable: true, description: `JSON array of stop sequences used. The model stops generating when any of these sequences are encountered`}) 
    StopSequences?: string;
        
    @Field({nullable: true, description: `The response format requested for this run (e.g., 'JSON', 'Text', 'Markdown')`}) 
    @MaxLength(100)
    ResponseFormat?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Whether log probabilities were requested for this run`}) 
    LogProbs?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of top log probabilities requested per token (if LogProbs is true)`}) 
    TopLogProbs?: number;
        
    @Field(() => Float, {nullable: true, description: `The total cost of all descendant (child and grandchild) prompt runs, excluding this run's own cost. For leaf nodes (no children), this is 0. Updated when child costs change.`}) 
    DescendantCost?: number;
        
    @Field(() => Int, {nullable: true, description: `Total number of validation attempts made (including the initial attempt)`}) 
    ValidationAttemptCount?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of validation attempts that passed validation`}) 
    SuccessfulValidationCount?: number;
        
    @Field(() => Boolean, {nullable: true, description: `Whether validation ultimately passed (1) or failed (0)`}) 
    FinalValidationPassed?: boolean;
        
    @Field({nullable: true, description: `Validation behavior used: Strict, Warn, or None`}) 
    @MaxLength(100)
    ValidationBehavior?: string;
        
    @Field({nullable: true, description: `Retry strategy used: Fixed, Linear, or Exponential`}) 
    @MaxLength(100)
    RetryStrategy?: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of retries configured on the prompt`}) 
    MaxRetriesConfigured?: number;
        
    @Field({nullable: true, description: `The final validation error message if validation failed`}) 
    @MaxLength(1000)
    FinalValidationError?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of validation errors on the final attempt`}) 
    ValidationErrorCount?: number;
        
    @Field({nullable: true, description: `Most frequent validation error across all attempts`}) 
    @MaxLength(510)
    CommonValidationError?: string;
        
    @Field({nullable: true, description: `Timestamp of the first validation attempt`}) 
    @MaxLength(8)
    FirstAttemptAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the last validation attempt`}) 
    @MaxLength(8)
    LastAttemptAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total time spent on retries in milliseconds (excluding first attempt)`}) 
    TotalRetryDurationMS?: number;
        
    @Field({nullable: true, description: `JSON array containing detailed information about each validation attempt`}) 
    ValidationAttempts?: string;
        
    @Field({nullable: true, description: `JSON object containing summary information about the validation process`}) 
    ValidationSummary?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of failover attempts made during this prompt run`}) 
    FailoverAttempts?: number;
        
    @Field({nullable: true, description: `JSON array of error details from each failover attempt`}) 
    FailoverErrors?: string;
        
    @Field({nullable: true, description: `JSON array of duration in milliseconds for each failover attempt`}) 
    FailoverDurations?: string;
        
    @Field({nullable: true, description: `The AI Model ID that was originally attempted before any failovers`}) 
    @MaxLength(16)
    OriginalModelID?: string;
        
    @Field({nullable: true, description: `Timestamp when the original request started, before any failovers`}) 
    @MaxLength(8)
    OriginalRequestStartTime?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total time spent in failover attempts in milliseconds`}) 
    TotalFailoverDuration?: number;
        
    @Field({nullable: true, description: `If this run was initiated as a re-run of another prompt run, this field links back to the original run ID`}) 
    @MaxLength(16)
    RerunFromPromptRunID?: string;
        
    @Field({nullable: true, description: `JSON object containing detailed model selection information including all models considered, their scores, and the selection rationale`}) 
    ModelSelection?: string;
        
    @Field({description: `Current execution status of the prompt run. Valid values: Pending, Running, Completed, Failed, Cancelled`}) 
    @MaxLength(100)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates whether this prompt run was cancelled before completion`}) 
    Cancelled: boolean;
        
    @Field({nullable: true, description: `Detailed reason for cancellation if the prompt run was cancelled. Could be user_requested, timeout, error, or resource_limit`}) 
    CancellationReason?: string;
        
    @Field(() => Int, {nullable: true, description: `Power rank of the model that was selected for this run. Lower numbers indicate more powerful models`}) 
    ModelPowerRank?: number;
        
    @Field({nullable: true, description: `Strategy used for model selection. Valid values: Default (system default), Specific (specific models configured), ByPower (based on power ranking)`}) 
    @MaxLength(100)
    SelectionStrategy?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this result was served from cache rather than executing a new model call`}) 
    CacheHit: boolean;
        
    @Field({nullable: true, description: `Unique key used for caching this prompt result, typically a hash of the prompt and parameters`}) 
    @MaxLength(1000)
    CacheKey?: string;
        
    @Field({nullable: true, description: `ID of the AIPrompt used as a judge to evaluate and rank multiple parallel execution results`}) 
    @MaxLength(16)
    JudgeID?: string;
        
    @Field(() => Float, {nullable: true, description: `Score assigned by the judge prompt when evaluating multiple results. Higher scores indicate better results`}) 
    JudgeScore?: number;
        
    @Field(() => Boolean, {description: `Indicates whether this result was selected as the best result when multiple models were run in parallel`}) 
    WasSelectedResult: boolean;
        
    @Field(() => Boolean, {description: `Indicates whether streaming was enabled for this prompt execution`}) 
    StreamingEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds from request initiation to receiving the first token from the model`}) 
    FirstTokenTime?: number;
        
    @Field({nullable: true, description: `Detailed error information in JSON format if the prompt execution failed, including stack traces and error codes`}) 
    ErrorDetails?: string;
        
    @Field({nullable: true, description: `References the specific child prompt that was executed as part of hierarchical prompt composition. NULL for regular prompts or parent prompts that don't directly execute a child.`}) 
    @MaxLength(16)
    ChildPromptID?: string;
        
    @Field(() => Int, {nullable: true, description: `Queue time in milliseconds before the model started processing the request. Provider-specific timing metric.`}) 
    QueueTime?: number;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds for the model to ingest and process the prompt. Provider-specific timing metric.`}) 
    PromptTime?: number;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds for the model to generate the completion/response tokens. Provider-specific timing metric.`}) 
    CompletionTime?: number;
        
    @Field({nullable: true, description: `JSON field containing provider-specific response metadata and details not captured in standard fields. Structure varies by AI provider.`}) 
    ModelSpecificResponseDetails?: string;
        
    @Field(() => Int, {nullable: true, description: `Effort level that was actually used during this prompt run execution (1-100, where 1=minimal effort, 100=maximum effort). This is the resolved effort level after applying the precedence hierarchy: runtime override > agent default > prompt default > provider default.`}) 
    EffortLevel?: number;
        
    @Field({nullable: true, description: `Optional name for the prompt run to help identify and tag runs for easier reference`}) 
    @MaxLength(510)
    RunName?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this prompt run`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(510)
    Prompt: string;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field() 
    @MaxLength(100)
    Vendor: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OriginalModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Judge?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ChildPrompt?: string;
        
    @Field(() => [AIPromptRun_])
    MJ_AIPromptRuns_ParentIDArray: AIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [AIResultCache_])
    AIResultCache_PromptRunIDArray: AIResultCache_[]; // Link to AIResultCache
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Runs
//****************************************************************************
@InputType()
export class CreateAIPromptRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Int, { nullable: true })
    ExecutionTimeMS: number | null;

    @Field({ nullable: true })
    Messages: string | null;

    @Field({ nullable: true })
    Result: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TokensPrompt: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletion: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    RunType?: string;

    @Field(() => Int, { nullable: true })
    ExecutionOrder: number | null;

    @Field({ nullable: true })
    AgentRunID: string | null;

    @Field(() => Float, { nullable: true })
    Cost: number | null;

    @Field({ nullable: true })
    CostCurrency: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TokensPromptRollup: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletionRollup: number | null;

    @Field(() => Float, { nullable: true })
    Temperature: number | null;

    @Field(() => Float, { nullable: true })
    TopP: number | null;

    @Field(() => Int, { nullable: true })
    TopK: number | null;

    @Field(() => Float, { nullable: true })
    MinP: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty: number | null;

    @Field(() => Int, { nullable: true })
    Seed: number | null;

    @Field({ nullable: true })
    StopSequences: string | null;

    @Field({ nullable: true })
    ResponseFormat: string | null;

    @Field(() => Boolean, { nullable: true })
    LogProbs: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs: number | null;

    @Field(() => Float, { nullable: true })
    DescendantCost: number | null;

    @Field(() => Int, { nullable: true })
    ValidationAttemptCount: number | null;

    @Field(() => Int, { nullable: true })
    SuccessfulValidationCount: number | null;

    @Field(() => Boolean, { nullable: true })
    FinalValidationPassed: boolean | null;

    @Field({ nullable: true })
    ValidationBehavior: string | null;

    @Field({ nullable: true })
    RetryStrategy: string | null;

    @Field(() => Int, { nullable: true })
    MaxRetriesConfigured: number | null;

    @Field({ nullable: true })
    FinalValidationError: string | null;

    @Field(() => Int, { nullable: true })
    ValidationErrorCount: number | null;

    @Field({ nullable: true })
    CommonValidationError: string | null;

    @Field({ nullable: true })
    FirstAttemptAt: Date | null;

    @Field({ nullable: true })
    LastAttemptAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRetryDurationMS: number | null;

    @Field({ nullable: true })
    ValidationAttempts: string | null;

    @Field({ nullable: true })
    ValidationSummary: string | null;

    @Field(() => Int, { nullable: true })
    FailoverAttempts?: number | null;

    @Field({ nullable: true })
    FailoverErrors: string | null;

    @Field({ nullable: true })
    FailoverDurations: string | null;

    @Field({ nullable: true })
    OriginalModelID: string | null;

    @Field({ nullable: true })
    OriginalRequestStartTime: Date | null;

    @Field(() => Int, { nullable: true })
    TotalFailoverDuration: number | null;

    @Field({ nullable: true })
    RerunFromPromptRunID: string | null;

    @Field({ nullable: true })
    ModelSelection: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Cancelled?: boolean;

    @Field({ nullable: true })
    CancellationReason: string | null;

    @Field(() => Int, { nullable: true })
    ModelPowerRank: number | null;

    @Field({ nullable: true })
    SelectionStrategy: string | null;

    @Field(() => Boolean, { nullable: true })
    CacheHit?: boolean;

    @Field({ nullable: true })
    CacheKey: string | null;

    @Field({ nullable: true })
    JudgeID: string | null;

    @Field(() => Float, { nullable: true })
    JudgeScore: number | null;

    @Field(() => Boolean, { nullable: true })
    WasSelectedResult?: boolean;

    @Field(() => Boolean, { nullable: true })
    StreamingEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    FirstTokenTime: number | null;

    @Field({ nullable: true })
    ErrorDetails: string | null;

    @Field({ nullable: true })
    ChildPromptID: string | null;

    @Field(() => Int, { nullable: true })
    QueueTime: number | null;

    @Field(() => Int, { nullable: true })
    PromptTime: number | null;

    @Field(() => Int, { nullable: true })
    CompletionTime: number | null;

    @Field({ nullable: true })
    ModelSpecificResponseDetails: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;

    @Field({ nullable: true })
    RunName: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Runs
//****************************************************************************
@InputType()
export class UpdateAIPromptRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    ExecutionTimeMS?: number | null;

    @Field({ nullable: true })
    Messages?: string | null;

    @Field({ nullable: true })
    Result?: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TokensPrompt?: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletion?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    RunType?: string;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number | null;

    @Field({ nullable: true })
    AgentRunID?: string | null;

    @Field(() => Float, { nullable: true })
    Cost?: number | null;

    @Field({ nullable: true })
    CostCurrency?: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TokensPromptRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletionRollup?: number | null;

    @Field(() => Float, { nullable: true })
    Temperature?: number | null;

    @Field(() => Float, { nullable: true })
    TopP?: number | null;

    @Field(() => Int, { nullable: true })
    TopK?: number | null;

    @Field(() => Float, { nullable: true })
    MinP?: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty?: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty?: number | null;

    @Field(() => Int, { nullable: true })
    Seed?: number | null;

    @Field({ nullable: true })
    StopSequences?: string | null;

    @Field({ nullable: true })
    ResponseFormat?: string | null;

    @Field(() => Boolean, { nullable: true })
    LogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs?: number | null;

    @Field(() => Float, { nullable: true })
    DescendantCost?: number | null;

    @Field(() => Int, { nullable: true })
    ValidationAttemptCount?: number | null;

    @Field(() => Int, { nullable: true })
    SuccessfulValidationCount?: number | null;

    @Field(() => Boolean, { nullable: true })
    FinalValidationPassed?: boolean | null;

    @Field({ nullable: true })
    ValidationBehavior?: string | null;

    @Field({ nullable: true })
    RetryStrategy?: string | null;

    @Field(() => Int, { nullable: true })
    MaxRetriesConfigured?: number | null;

    @Field({ nullable: true })
    FinalValidationError?: string | null;

    @Field(() => Int, { nullable: true })
    ValidationErrorCount?: number | null;

    @Field({ nullable: true })
    CommonValidationError?: string | null;

    @Field({ nullable: true })
    FirstAttemptAt?: Date | null;

    @Field({ nullable: true })
    LastAttemptAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRetryDurationMS?: number | null;

    @Field({ nullable: true })
    ValidationAttempts?: string | null;

    @Field({ nullable: true })
    ValidationSummary?: string | null;

    @Field(() => Int, { nullable: true })
    FailoverAttempts?: number | null;

    @Field({ nullable: true })
    FailoverErrors?: string | null;

    @Field({ nullable: true })
    FailoverDurations?: string | null;

    @Field({ nullable: true })
    OriginalModelID?: string | null;

    @Field({ nullable: true })
    OriginalRequestStartTime?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalFailoverDuration?: number | null;

    @Field({ nullable: true })
    RerunFromPromptRunID?: string | null;

    @Field({ nullable: true })
    ModelSelection?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Cancelled?: boolean;

    @Field({ nullable: true })
    CancellationReason?: string | null;

    @Field(() => Int, { nullable: true })
    ModelPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string | null;

    @Field(() => Boolean, { nullable: true })
    CacheHit?: boolean;

    @Field({ nullable: true })
    CacheKey?: string | null;

    @Field({ nullable: true })
    JudgeID?: string | null;

    @Field(() => Float, { nullable: true })
    JudgeScore?: number | null;

    @Field(() => Boolean, { nullable: true })
    WasSelectedResult?: boolean;

    @Field(() => Boolean, { nullable: true })
    StreamingEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    FirstTokenTime?: number | null;

    @Field({ nullable: true })
    ErrorDetails?: string | null;

    @Field({ nullable: true })
    ChildPromptID?: string | null;

    @Field(() => Int, { nullable: true })
    QueueTime?: number | null;

    @Field(() => Int, { nullable: true })
    PromptTime?: number | null;

    @Field(() => Int, { nullable: true })
    CompletionTime?: number | null;

    @Field({ nullable: true })
    ModelSpecificResponseDetails?: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field({ nullable: true })
    RunName?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Runs
//****************************************************************************
@ObjectType()
export class RunAIPromptRunViewResult {
    @Field(() => [AIPromptRun_])
    Results: AIPromptRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIPromptRun_)
export class AIPromptRunResolver extends ResolverBase {
    @Query(() => RunAIPromptRunViewResult)
    async RunAIPromptRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptRunViewResult)
    async RunAIPromptRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIPromptRunViewResult)
    async RunAIPromptRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIPromptRun_, { nullable: true })
    async AIPromptRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIPromptRun_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIPromptRun_])
    async MJ_AIPromptRuns_ParentIDArray(@Root() aipromptrun_: AIPromptRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [ParentID]='${aipromptrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows);
        return result;
    }
        
    @FieldResolver(() => [AIResultCache_])
    async AIResultCache_PromptRunIDArray(@Root() aipromptrun_: AIPromptRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [PromptRunID]='${aipromptrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows);
        return result;
    }
        
    @Mutation(() => AIPromptRun_)
    async CreateAIPromptRun(
        @Arg('input', () => CreateAIPromptRunInput) input: CreateAIPromptRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIPromptRun_)
    async UpdateAIPromptRun(
        @Arg('input', () => UpdateAIPromptRunInput) input: UpdateAIPromptRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIPromptRun_)
    async DeleteAIPromptRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Run Steps
//****************************************************************************
@ObjectType({ description: `Provides basic, step-by-step tracking of agent execution. Each step represents a discrete action within an agent run, such as prompt execution, tool usage, decision making, or sub-agent coordination.` })
export class AIAgentRunStep_ {
    @Field({description: `Unique identifier for this execution step`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the parent AIAgentRun that contains this step`}) 
    @MaxLength(16)
    AgentRunID: string;
        
    @Field(() => Int, {description: `Sequential number of this step within the agent run, starting from 1`}) 
    StepNumber: number;
        
    @Field({description: `Type of execution step: Prompt, Actions, Sub-Agent, Decision, Chat, Validation`}) 
    @MaxLength(100)
    StepType: string;
        
    @Field({description: `Human-readable name of what this step accomplishes`}) 
    @MaxLength(510)
    StepName: string;
        
    @Field({nullable: true, description: `ID of the specific target being executed (AIPrompt.ID, AIAction.ID, AIAgent.ID, etc.). NULL for steps that don't target a specific entity.`}) 
    @MaxLength(16)
    TargetID?: string;
        
    @Field({description: `Current execution status of this step: Running, Completed, Failed, Cancelled`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({description: `Timestamp when this step began execution`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when this step completed. NULL while still running.`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Whether this step completed successfully. NULL while running, TRUE/FALSE when completed.`}) 
    Success?: boolean;
        
    @Field({nullable: true, description: `Error message if this step failed. NULL for successful steps.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON serialization of input data passed to this step for execution`}) 
    InputData?: string;
        
    @Field({nullable: true, description: `JSON serialization of the output data produced by this step`}) 
    OutputData?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `ID of the execution log/run record created for this step (ActionExecutionLog.ID for action steps, AIAgentRun.ID for subagent steps, AIPromptRun.ID for prompt steps)`}) 
    @MaxLength(16)
    TargetLogID?: string;
        
    @Field({nullable: true, description: `JSON serialization of the Payload state at the start of this step`}) 
    PayloadAtStart?: string;
        
    @Field({nullable: true, description: `JSON serialization of the Payload state at the end of this step`}) 
    PayloadAtEnd?: string;
        
    @Field({nullable: true, description: `Result of the final payload validation for this step. Pass indicates successful
validation, Retry means validation failed but will retry, Fail means validation failed
permanently, Warn means validation failed but execution continues.`}) 
    @MaxLength(50)
    FinalPayloadValidationResult?: string;
        
    @Field({nullable: true, description: `Validation error messages or warnings from final payload validation. Contains
detailed information about what validation rules failed.`}) 
    FinalPayloadValidationMessages?: string;
        
    @Field({nullable: true, description: `Optional reference to parent step for tracking hierarchical relationships like code->test->fix->code cycles`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this agent run step`}) 
    Comments?: string;
        
    @Field(() => [AIAgentRunStep_])
    MJ_AIAgentRunSteps_ParentIDArray: AIAgentRunStep_[]; // Link to MJ_AIAgentRunSteps
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Steps
//****************************************************************************
@InputType()
export class CreateAIAgentRunStepInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field(() => Int, { nullable: true })
    StepNumber?: number;

    @Field({ nullable: true })
    StepType?: string;

    @Field({ nullable: true })
    StepName?: string;

    @Field({ nullable: true })
    TargetID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success: boolean | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    InputData: string | null;

    @Field({ nullable: true })
    OutputData: string | null;

    @Field({ nullable: true })
    TargetLogID: string | null;

    @Field({ nullable: true })
    PayloadAtStart: string | null;

    @Field({ nullable: true })
    PayloadAtEnd: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationResult: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMessages: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Steps
//****************************************************************************
@InputType()
export class UpdateAIAgentRunStepInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field(() => Int, { nullable: true })
    StepNumber?: number;

    @Field({ nullable: true })
    StepType?: string;

    @Field({ nullable: true })
    StepName?: string;

    @Field({ nullable: true })
    TargetID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    InputData?: string | null;

    @Field({ nullable: true })
    OutputData?: string | null;

    @Field({ nullable: true })
    TargetLogID?: string | null;

    @Field({ nullable: true })
    PayloadAtStart?: string | null;

    @Field({ nullable: true })
    PayloadAtEnd?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationResult?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMessages?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Run Steps
//****************************************************************************
@ObjectType()
export class RunAIAgentRunStepViewResult {
    @Field(() => [AIAgentRunStep_])
    Results: AIAgentRunStep_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentRunStep_)
export class AIAgentRunStepResolver extends ResolverBase {
    @Query(() => RunAIAgentRunStepViewResult)
    async RunAIAgentRunStepViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRunStepViewResult)
    async RunAIAgentRunStepViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRunStepViewResult)
    async RunAIAgentRunStepDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Run Steps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentRunStep_, { nullable: true })
    async AIAgentRunStep(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentRunStep_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunSteps] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIAgentRunStep_])
    async MJ_AIAgentRunSteps_ParentIDArray(@Root() aiagentrunstep_: AIAgentRunStep_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunSteps] WHERE [ParentID]='${aiagentrunstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows);
        return result;
    }
        
    @Mutation(() => AIAgentRunStep_)
    async CreateAIAgentRunStep(
        @Arg('input', () => CreateAIAgentRunStepInput) input: CreateAIAgentRunStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Run Steps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentRunStep_)
    async UpdateAIAgentRunStep(
        @Arg('input', () => UpdateAIAgentRunStepInput) input: UpdateAIAgentRunStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Run Steps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentRunStep_)
    async DeleteAIAgentRunStep(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Run Steps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for conversation artifacts` })
export class ConversationArtifactPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the artifact this permission applies to`}) 
    @MaxLength(16)
    ConversationArtifactID: string;
        
    @Field({description: `User this permission applies to`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Level of access granted (Read, Edit, Owner)`}) 
    @MaxLength(40)
    AccessLevel: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ConversationArtifact: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class CreateConversationArtifactPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class UpdateConversationArtifactPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType()
export class RunConversationArtifactPermissionViewResult {
    @Field(() => [ConversationArtifactPermission_])
    Results: ConversationArtifactPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ConversationArtifactPermission_)
export class ConversationArtifactPermissionResolver extends ResolverBase {
    @Query(() => RunConversationArtifactPermissionViewResult)
    async RunConversationArtifactPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactPermissionViewResult)
    async RunConversationArtifactPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactPermissionViewResult)
    async RunConversationArtifactPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ConversationArtifactPermission_, { nullable: true })
    async ConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ConversationArtifactPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ConversationArtifactPermission_)
    async CreateConversationArtifactPermission(
        @Arg('input', () => CreateConversationArtifactPermissionInput) input: CreateConversationArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifact Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ConversationArtifactPermission_)
    async UpdateConversationArtifactPermission(
        @Arg('input', () => UpdateConversationArtifactPermissionInput) input: UpdateConversationArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifact Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ConversationArtifactPermission_)
    async DeleteConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Price Unit Types
//****************************************************************************
@ObjectType({ description: `Defines the unit scales used for pricing (e.g., Per 1M Tokens, Per 1K Tokens, Per Minute). Includes driver class for normalization calculations` })
export class AIModelPriceUnitType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name for the pricing unit (e.g., "Per 1M Tokens", "Per 1K Tokens", "Per Minute")`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed explanation of the unit scale and any special considerations for this pricing unit`}) 
    Description?: string;
        
    @Field({description: `Fully qualified class name that handles cost calculations and unit normalization for this pricing unit (e.g., "TokenPer1M", "TokenPer1K")`}) 
    @MaxLength(510)
    DriverClass: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIModelCost_])
    MJ_AIModelCosts_UnitTypeIDArray: AIModelCost_[]; // Link to MJ_AIModelCosts
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Unit Types
//****************************************************************************
@InputType()
export class CreateAIModelPriceUnitTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Unit Types
//****************************************************************************
@InputType()
export class UpdateAIModelPriceUnitTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Price Unit Types
//****************************************************************************
@ObjectType()
export class RunAIModelPriceUnitTypeViewResult {
    @Field(() => [AIModelPriceUnitType_])
    Results: AIModelPriceUnitType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModelPriceUnitType_)
export class AIModelPriceUnitTypeResolver extends ResolverBase {
    @Query(() => RunAIModelPriceUnitTypeViewResult)
    async RunAIModelPriceUnitTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelPriceUnitTypeViewResult)
    async RunAIModelPriceUnitTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIModelPriceUnitTypeViewResult)
    async RunAIModelPriceUnitTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Price Unit Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIModelPriceUnitType_, { nullable: true })
    async AIModelPriceUnitType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModelPriceUnitType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Price Unit Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelPriceUnitTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Price Unit Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Model Price Unit Types', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @FieldResolver(() => [AIModelCost_])
    async MJ_AIModelCosts_UnitTypeIDArray(@Root() aimodelpriceunittype_: AIModelPriceUnitType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [UnitTypeID]='${aimodelpriceunittype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows);
        return result;
    }
        
    @Mutation(() => AIModelPriceUnitType_)
    async CreateAIModelPriceUnitType(
        @Arg('input', () => CreateAIModelPriceUnitTypeInput) input: CreateAIModelPriceUnitTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Price Unit Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIModelPriceUnitType_)
    async UpdateAIModelPriceUnitType(
        @Arg('input', () => UpdateAIModelPriceUnitTypeInput) input: UpdateAIModelPriceUnitTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Price Unit Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIModelPriceUnitType_)
    async DeleteAIModelPriceUnitType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Price Unit Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Step Paths
//****************************************************************************
@ObjectType({ description: `Defines paths (edges) between steps in a flow-based AI agent execution graph` })
export class AIAgentStepPath_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    OriginStepID: string;
        
    @Field() 
    @MaxLength(16)
    DestinationStepID: string;
        
    @Field({nullable: true, description: `Boolean expression to evaluate. If null, path is always taken. Evaluated against payload and step results.`}) 
    Condition?: string;
        
    @Field(() => Int, {description: `Path evaluation priority. Higher values are evaluated first. Use 0 or negative values for default/fallback paths that execute when no other conditions match.`}) 
    Priority: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Description?: string;
        
    @Field({nullable: true}) 
    PathPoints?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    OriginStep: string;
        
    @Field() 
    @MaxLength(510)
    DestinationStep: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Step Paths
//****************************************************************************
@InputType()
export class CreateAIAgentStepPathInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    OriginStepID?: string;

    @Field({ nullable: true })
    DestinationStepID?: string;

    @Field({ nullable: true })
    Condition: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    PathPoints: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Step Paths
//****************************************************************************
@InputType()
export class UpdateAIAgentStepPathInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    OriginStepID?: string;

    @Field({ nullable: true })
    DestinationStepID?: string;

    @Field({ nullable: true })
    Condition?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    PathPoints?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Step Paths
//****************************************************************************
@ObjectType()
export class RunAIAgentStepPathViewResult {
    @Field(() => [AIAgentStepPath_])
    Results: AIAgentStepPath_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentStepPath_)
export class AIAgentStepPathResolver extends ResolverBase {
    @Query(() => RunAIAgentStepPathViewResult)
    async RunAIAgentStepPathViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentStepPathViewResult)
    async RunAIAgentStepPathViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentStepPathViewResult)
    async RunAIAgentStepPathDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Step Paths';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentStepPath_, { nullable: true })
    async AIAgentStepPath(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentStepPath_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentStepPaths] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIAgentStepPath_)
    async CreateAIAgentStepPath(
        @Arg('input', () => CreateAIAgentStepPathInput) input: CreateAIAgentStepPathInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Step Paths', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentStepPath_)
    async UpdateAIAgentStepPath(
        @Arg('input', () => UpdateAIAgentStepPathInput) input: UpdateAIAgentStepPathInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Step Paths', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentStepPath_)
    async DeleteAIAgentStepPath(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Step Paths', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Learning Cycles
//****************************************************************************
@ObjectType({ description: `Tracks the learning cycles for AI Agents where the Agent does offline reasoning, reflection, learning, and updates metadata.` })
export class AIAgentLearningCycle_ {
    @Field({description: `Unique identifier for the learning cycle.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Identifier for the AI Agent associated with this learning cycle.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Timestamp indicating when the learning cycle started.`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp indicating when the learning cycle ended.`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Status of the learning cycle (In-Progress, Complete, or Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Text summary provided by the agent about what it learned and any changes it requested for stored metadata.`}) 
    AgentSummary?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class CreateAIAgentLearningCycleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class UpdateAIAgentLearningCycleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Learning Cycles
//****************************************************************************
@ObjectType()
export class RunAIAgentLearningCycleViewResult {
    @Field(() => [AIAgentLearningCycle_])
    Results: AIAgentLearningCycle_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentLearningCycle_)
export class AIAgentLearningCycleResolver extends ResolverBase {
    @Query(() => RunAIAgentLearningCycleViewResult)
    async RunAIAgentLearningCycleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentLearningCycleViewResult)
    async RunAIAgentLearningCycleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIAgentLearningCycleViewResult)
    async RunAIAgentLearningCycleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Learning Cycles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIAgentLearningCycle_, { nullable: true })
    async AIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentLearningCycle_ | null> {
        this.CheckUserReadPermissions('AI Agent Learning Cycles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentLearningCycles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('AI Agent Learning Cycles', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIAgentLearningCycle_)
    async CreateAIAgentLearningCycle(
        @Arg('input', () => CreateAIAgentLearningCycleInput) input: CreateAIAgentLearningCycleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Learning Cycles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentLearningCycle_)
    async UpdateAIAgentLearningCycle(
        @Arg('input', () => UpdateAIAgentLearningCycleInput) input: UpdateAIAgentLearningCycleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Learning Cycles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentLearningCycle_)
    async DeleteAIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Learning Cycles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report Versions
//****************************************************************************
@ObjectType({ description: `Stores iterations of report logic, structure, and layout changes` })
export class ReportVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field(() => Int, {description: `Report version number, sequential per report starting at 1`}) 
    VersionNumber: number;
        
    @Field({description: `Name of this report version`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of this report version`}) 
    Description?: string;
        
    @Field({nullable: true, description: `JSON configuration of report structure, layout and logic`}) 
    Configuration?: string;
        
    @Field(() => Boolean, {description: `Indicates if the data context was updated in this version`}) 
    DataContextUpdated: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class CreateReportVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class UpdateReportVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report Versions
//****************************************************************************
@ObjectType()
export class RunReportVersionViewResult {
    @Field(() => [ReportVersion_])
    Results: ReportVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ReportVersion_)
export class ReportVersionResolver extends ResolverBase {
    @Query(() => RunReportVersionViewResult)
    async RunReportVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportVersionViewResult)
    async RunReportVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunReportVersionViewResult)
    async RunReportVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => ReportVersion_, { nullable: true })
    async ReportVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ReportVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: Report Versions', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => ReportVersion_)
    async CreateReportVersion(
        @Arg('input', () => CreateReportVersionInput) input: CreateReportVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => ReportVersion_)
    async UpdateReportVersion(
        @Arg('input', () => UpdateReportVersionInput) input: UpdateReportVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => ReportVersion_)
    async DeleteReportVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Configuration Params
//****************************************************************************
@ObjectType({ description: `Stores configuration parameters that can be referenced by prompts and used to control execution behavior.` })
export class AIConfigurationParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ConfigurationID: string;
        
    @Field({description: `The name of the configuration parameter.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The data type of the parameter (string, number, boolean, date, object).`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({description: `The value of the parameter, stored as a string but interpreted according to the Type.`}) 
    Value: string;
        
    @Field({nullable: true, description: `Detailed description of the parameter and its usage.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Configuration: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Configuration Params
//****************************************************************************
@InputType()
export class CreateAIConfigurationParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConfigurationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Configuration Params
//****************************************************************************
@InputType()
export class UpdateAIConfigurationParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConfigurationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Configuration Params
//****************************************************************************
@ObjectType()
export class RunAIConfigurationParamViewResult {
    @Field(() => [AIConfigurationParam_])
    Results: AIConfigurationParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIConfigurationParam_)
export class AIConfigurationParamResolver extends ResolverBase {
    @Query(() => RunAIConfigurationParamViewResult)
    async RunAIConfigurationParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIConfigurationParamViewResult)
    async RunAIConfigurationParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunAIConfigurationParamViewResult)
    async RunAIConfigurationParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Configuration Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => AIConfigurationParam_, { nullable: true })
    async AIConfigurationParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIConfigurationParam_ | null> {
        this.CheckUserReadPermissions('MJ: AI Configuration Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurationParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configuration Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = this.MapFieldNamesToCodeNames('MJ: AI Configuration Params', rows && rows.length > 0 ? rows[0] : {})
        return result;
    }
    
    @Mutation(() => AIConfigurationParam_)
    async CreateAIConfigurationParam(
        @Arg('input', () => CreateAIConfigurationParamInput) input: CreateAIConfigurationParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Configuration Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => AIConfigurationParam_)
    async UpdateAIConfigurationParam(
        @Arg('input', () => UpdateAIConfigurationParamInput) input: UpdateAIConfigurationParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Configuration Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => AIConfigurationParam_)
    async DeleteAIConfigurationParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Configuration Params', key, options, provider, userPayload, pubSub);
    }
    
}