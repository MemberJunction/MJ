/********************************************************************************
* ALL ENTITIES - TypeGraphQL Type Class Definition - AUTO GENERATED FILE
* Generated Entities and Resolvers for Server
*
*   >>> DO NOT MODIFY THIS FILE!!!!!!!!!!!!
*   >>> YOUR CHANGES WILL BE OVERWRITTEN
*   >>> THE NEXT TIME THIS FILE IS GENERATED
*
**********************************************************************************/
import { Arg, Ctx, Int, Query, Resolver, Field, Float, ObjectType, FieldResolver, Root, InputType, Mutation,
            PubSub, PubSubEngine, ResolverBase, RunViewByIDInput, RunViewByNameInput, RunDynamicViewInput,
            AppContext, KeyValuePairInput, DeleteOptionsInput, GraphQLTimestamp as Timestamp,
            GetReadOnlyProvider, GetReadWriteProvider } from '@memberjunction/server';
import { Metadata, EntityPermissionType, CompositeKey, UserInfo } from '@memberjunction/core'

import { MaxLength } from 'class-validator';
import { mj_core_schema } from '../config.js';



import { MJAccessControlRuleEntity, MJActionAuthorizationEntity, MJActionCategoryEntity, MJActionContextTypeEntity, MJActionContextEntity, MJActionExecutionLogEntity, MJActionFilterEntity, MJActionLibraryEntity, MJActionParamEntity, MJActionResultCodeEntity, MJActionEntity, MJAIActionEntity, MJAIAgentActionEntity, MJAIAgentArtifactTypeEntity, MJAIAgentConfigurationEntity, MJAIAgentDataSourceEntity, MJAIAgentExampleEntity, MJAIAgentLearningCycleEntity, MJAIAgentModalityEntity, MJAIAgentModelEntity, MJAIAgentNoteTypeEntity, MJAIAgentNoteEntity, MJAIAgentPermissionEntity, MJAIAgentPromptEntity, MJAIAgentRelationshipEntity, MJAIAgentRequestEntity, MJAIAgentRunMediaEntity, MJAIAgentRunStepEntity, MJAIAgentRunEntity, MJAIAgentStepPathEntity, MJAIAgentStepEntity, MJAIAgentTypeEntity, MJAIAgentEntity, MJAIArchitectureEntity, MJAIConfigurationParamEntity, MJAIConfigurationEntity, MJAICredentialBindingEntity, MJAIModalityEntity, MJAIModelActionEntity, MJAIModelArchitectureEntity, MJAIModelCostEntity, MJAIModelModalityEntity, MJAIModelPriceTypeEntity, MJAIModelPriceUnitTypeEntity, MJAIModelTypeEntity, MJAIModelVendorEntity, MJAIModelEntity, MJAIPromptCategoryEntity, MJAIPromptModelEntity, MJAIPromptRunMediaEntity, MJAIPromptRunEntity, MJAIPromptTypeEntity, MJAIPromptEntity, MJAIResultCacheEntity, MJAIVendorTypeDefinitionEntity, MJAIVendorTypeEntity, MJAIVendorEntity, MJAPIApplicationScopeEntity, MJAPIApplicationEntity, MJAPIKeyApplicationEntity, MJAPIKeyScopeEntity, MJAPIKeyUsageLogEntity, MJAPIKeyEntity, MJAPIScopeEntity, MJApplicationEntityEntity, MJApplicationSettingEntity, MJApplicationEntity, MJArtifactPermissionEntity, MJArtifactTypeEntity, MJArtifactUseEntity, MJArtifactVersionAttributeEntity, MJArtifactVersionEntity, MJArtifactEntity, MJAuditLogTypeEntity, MJAuditLogEntity, MJAuthorizationRoleEntity, MJAuthorizationEntity, MJCollectionArtifactEntity, MJCollectionPermissionEntity, MJCollectionEntity, MJCommunicationBaseMessageTypeEntity, MJCommunicationLogEntity, MJCommunicationProviderMessageTypeEntity, MJCommunicationProviderEntity, MJCommunicationRunEntity, MJCompanyEntity, MJCompanyIntegrationRecordMapEntity, MJCompanyIntegrationRunAPILogEntity, MJCompanyIntegrationRunDetailEntity, MJCompanyIntegrationRunEntity, MJCompanyIntegrationEntity, MJComponentDependencyEntity, MJComponentLibraryEntity, MJComponentLibraryLinkEntity, MJComponentRegistryEntity, MJComponentEntity, MJContentFileTypeEntity, MJContentItemAttributeEntity, MJContentItemTagEntity, MJContentItemEntity, MJContentProcessRunEntity, MJContentSourceParamEntity, MJContentSourceTypeParamEntity, MJContentSourceTypeEntity, MJContentSourceEntity, MJContentTypeAttributeEntity, MJContentTypeEntity, MJConversationArtifactPermissionEntity, MJConversationArtifactVersionEntity, MJConversationArtifactEntity, MJConversationDetailArtifactEntity, MJConversationDetailAttachmentEntity, MJConversationDetailRatingEntity, MJConversationDetailEntity, MJConversationEntity, MJCredentialCategoryEntity, MJCredentialTypeEntity, MJCredentialEntity, MJDashboardCategoryEntity, MJDashboardCategoryLinkEntity, MJDashboardCategoryPermissionEntity, MJDashboardPartTypeEntity, MJDashboardPermissionEntity, MJDashboardUserPreferenceEntity, MJDashboardUserStateEntity, MJDashboardEntity, MJDataContextItemEntity, MJDataContextEntity, MJDatasetItemEntity, MJDatasetEntity, MJDuplicateRunDetailMatchEntity, MJDuplicateRunDetailEntity, MJDuplicateRunEntity, MJEmployeeCompanyIntegrationEntity, MJEmployeeRoleEntity, MJEmployeeSkillEntity, MJEmployeeEntity, MJEncryptionAlgorithmEntity, MJEncryptionKeySourceEntity, MJEncryptionKeyEntity, MJEntityEntity, MJEntityActionFilterEntity, MJEntityActionInvocationTypeEntity, MJEntityActionInvocationEntity, MJEntityActionParamEntity, MJEntityActionEntity, MJEntityAIActionEntity, MJEntityCommunicationFieldEntity, MJEntityCommunicationMessageTypeEntity, MJEntityDocumentRunEntity, MJEntityDocumentSettingEntity, MJEntityDocumentTypeEntity, MJEntityDocumentEntity, MJEntityFieldValueEntity, MJEntityFieldEntity, MJEntityPermissionEntity, MJEntityRecordDocumentEntity, MJEntityRelationshipDisplayComponentEntity, MJEntityRelationshipEntity, MJEntitySettingEntity, MJEnvironmentEntity, MJErrorLogEntity, MJExplorerNavigationItemEntity, MJFileCategoryEntity, MJFileEntityRecordLinkEntity, MJFileStorageAccountEntity, MJFileStorageProviderEntity, MJFileEntity, MJGeneratedCodeCategoryEntity, MJGeneratedCodeEntity, MJIntegrationURLFormatEntity, MJIntegrationEntity, MJLibraryEntity, MJLibraryItemEntity, MJListCategoryEntity, MJListDetailEntity, MJListInvitationEntity, MJListShareEntity, MJListEntity, MJMCPServerConnectionPermissionEntity, MJMCPServerConnectionToolEntity, MJMCPServerConnectionEntity, MJMCPServerToolEntity, MJMCPServerEntity, MJMCPToolExecutionLogEntity, MJOAuthAuthServerMetadataCacheEntity, MJOAuthAuthorizationStateEntity, MJOAuthClientRegistrationEntity, MJOAuthTokenEntity, MJOpenAppDependencyEntity, MJOpenAppInstallHistoryEntity, MJOpenAppEntity, MJOutputDeliveryTypeEntity, MJOutputFormatTypeEntity, MJOutputTriggerTypeEntity, MJProjectEntity, MJPublicLinkEntity, MJQueryEntity, MJQueryCategoryEntity, MJQueryEntityEntity, MJQueryFieldEntity, MJQueryParameterEntity, MJQueryPermissionEntity, MJQuerySQLEntity, MJQueueTaskEntity, MJQueueTypeEntity, MJQueueEntity, MJRecommendationItemEntity, MJRecommendationProviderEntity, MJRecommendationRunEntity, MJRecommendationEntity, MJRecordChangeReplayRunEntity, MJRecordChangeEntity, MJRecordLinkEntity, MJRecordMergeDeletionLogEntity, MJRecordMergeLogEntity, MJReportCategoryEntity, MJReportSnapshotEntity, MJReportUserStateEntity, MJReportVersionEntity, MJReportEntity, MJResourceLinkEntity, MJResourcePermissionEntity, MJResourceTypeEntity, MJRoleEntity, MJRowLevelSecurityFilterEntity, MJScheduledActionParamEntity, MJScheduledActionEntity, MJScheduledJobRunEntity, MJScheduledJobTypeEntity, MJScheduledJobEntity, MJSchemaInfoEntity, MJSkillEntity, MJSQLDialectEntity, MJTaggedItemEntity, MJTagEntity, MJTaskDependencyEntity, MJTaskTypeEntity, MJTaskEntity, MJTemplateCategoryEntity, MJTemplateContentTypeEntity, MJTemplateContentEntity, MJTemplateParamEntity, MJTemplateEntity, MJTestRubricEntity, MJTestRunFeedbackEntity, MJTestRunOutputTypeEntity, MJTestRunOutputEntity, MJTestRunEntity, MJTestSuiteRunEntity, MJTestSuiteTestEntity, MJTestSuiteEntity, MJTestTypeEntity, MJTestEntity, MJUserApplicationEntityEntity, MJUserApplicationEntity, MJUserFavoriteEntity, MJUserNotificationPreferenceEntity, MJUserNotificationTypeEntity, MJUserNotificationEntity, MJUserRecordLogEntity, MJUserRoleEntity, MJUserSettingEntity, MJUserViewCategoryEntity, MJUserViewRunDetailEntity, MJUserViewRunEntity, MJUserViewEntity, MJUserEntity, MJVectorDatabaseEntity, MJVectorIndexEntity, MJVersionInstallationEntity, MJVersionLabelItemEntity, MJVersionLabelRestoreEntity, MJVersionLabelEntity, MJWorkflowEngineEntity, MJWorkflowRunEntity, MJWorkflowEntity, MJWorkspaceItemEntity, MJWorkspaceEntity } from '@memberjunction/core-entities';
    

//****************************************************************************
// ENTITY CLASS for MJ: Access Control Rules
//****************************************************************************
@ObjectType({ description: `Generic ACL-style permission system that can control access to any entity record in the system with granular CRUD permissions.` })
export class MJAccessControlRule_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `Primary key value(s) of the record being protected - scalar for simple PKs or JSON for composite PKs`}) 
    @MaxLength(500)
    RecordID: string;
        
    @Field({description: `Type of grantee receiving permission (User, Role, Everyone, Public). "Everyone" means all authenticated users whereas "Public" means any authenticated OR anonymous user.`}) 
    @MaxLength(50)
    GranteeType: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    GranteeID?: string;
        
    @Field(() => Boolean, {description: `Permission to read/view the record`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Permission to create new related records`}) 
    CanCreate: boolean;
        
    @Field(() => Boolean, {description: `Permission to update/modify the record`}) 
    CanUpdate: boolean;
        
    @Field(() => Boolean, {description: `Permission to delete the record`}) 
    CanDelete: boolean;
        
    @Field(() => Boolean, {description: `Permission to share/grant permissions to other users`}) 
    CanShare: boolean;
        
    @Field({nullable: true, description: `Optional expiration date/time for this access rule`}) 
    ExpiresAt?: Date;
        
    @Field() 
    @MaxLength(36)
    GrantedByUserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    GrantedByUser: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Access Control Rules
//****************************************************************************
@InputType()
export class CreateMJAccessControlRuleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    GranteeType?: string;

    @Field({ nullable: true })
    GranteeID: string | null;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    ExpiresAt: Date | null;

    @Field({ nullable: true })
    GrantedByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Access Control Rules
//****************************************************************************
@InputType()
export class UpdateMJAccessControlRuleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    GranteeType?: string;

    @Field({ nullable: true })
    GranteeID?: string | null;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field({ nullable: true })
    GrantedByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Access Control Rules
//****************************************************************************
@ObjectType()
export class RunMJAccessControlRuleViewResult {
    @Field(() => [MJAccessControlRule_])
    Results: MJAccessControlRule_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAccessControlRule_)
export class MJAccessControlRuleResolver extends ResolverBase {
    @Query(() => RunMJAccessControlRuleViewResult)
    async RunMJAccessControlRuleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAccessControlRuleViewResult)
    async RunMJAccessControlRuleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAccessControlRuleViewResult)
    async RunMJAccessControlRuleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Access Control Rules';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAccessControlRule_, { nullable: true })
    async MJAccessControlRule(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAccessControlRule_ | null> {
        this.CheckUserReadPermissions('MJ: Access Control Rules', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAccessControlRules')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Access Control Rules', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Access Control Rules', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAccessControlRule_)
    async CreateMJAccessControlRule(
        @Arg('input', () => CreateMJAccessControlRuleInput) input: CreateMJAccessControlRuleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Access Control Rules', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAccessControlRule_)
    async UpdateMJAccessControlRule(
        @Arg('input', () => UpdateMJAccessControlRuleInput) input: UpdateMJAccessControlRuleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Access Control Rules', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAccessControlRule_)
    async DeleteMJAccessControlRule(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Access Control Rules', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Authorizations
//****************************************************************************
@ObjectType({ description: `Links actions to authorizations, one or more of these must be possessed by a user in order to execute the action.` })
export class MJActionAuthorization_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ActionID: string;
        
    @Field() 
    @MaxLength(36)
    AuthorizationID: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(425)
    Action: string;
        
    @Field() 
    @MaxLength(100)
    Authorization: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Action Authorizations
//****************************************************************************
@InputType()
export class CreateMJActionAuthorizationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Authorizations
//****************************************************************************
@InputType()
export class UpdateMJActionAuthorizationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Authorizations
//****************************************************************************
@ObjectType()
export class RunMJActionAuthorizationViewResult {
    @Field(() => [MJActionAuthorization_])
    Results: MJActionAuthorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionAuthorization_)
export class MJActionAuthorizationResolver extends ResolverBase {
    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Authorizations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionAuthorization_, { nullable: true })
    async MJActionAuthorization(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionAuthorization_ | null> {
        this.CheckUserReadPermissions('MJ: Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionAuthorizations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Authorizations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionAuthorization_)
    async CreateMJActionAuthorization(
        @Arg('input', () => CreateMJActionAuthorizationInput) input: CreateMJActionAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Authorizations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionAuthorization_)
    async UpdateMJActionAuthorization(
        @Arg('input', () => UpdateMJActionAuthorizationInput) input: UpdateMJActionAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Authorizations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionAuthorization_)
    async DeleteMJActionAuthorization(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Authorizations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Categories
//****************************************************************************
@ObjectType({ description: `Organizes actions into categories, including name, description, and optional parent category for hierarchy.` })
export class MJActionCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Name of the action category.`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of the action category.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Status of the action category (Pending, Active, Disabled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJActionCategory_])
    MJActionCategories_ParentIDArray: MJActionCategory_[]; // Link to MJActionCategories
    
    @Field(() => [MJAction_])
    MJActions_CategoryIDArray: MJAction_[]; // Link to MJActions
    
    @Field(() => [MJMCPServerTool_])
    MJMCPServerTools_GeneratedActionCategoryIDArray: MJMCPServerTool_[]; // Link to MJMCPServerTools
    
}

//****************************************************************************
// INPUT TYPE for MJ: Action Categories
//****************************************************************************
@InputType()
export class CreateMJActionCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Categories
//****************************************************************************
@InputType()
export class UpdateMJActionCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Categories
//****************************************************************************
@ObjectType()
export class RunMJActionCategoryViewResult {
    @Field(() => [MJActionCategory_])
    Results: MJActionCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionCategory_)
export class MJActionCategoryResolver extends ResolverBase {
    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionCategory_, { nullable: true })
    async MJActionCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionCategory_ | null> {
        this.CheckUserReadPermissions('MJ: Action Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJActionCategory_])
    async MJActionCategories_ParentIDArray(@Root() mjactioncategory_: MJActionCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjactioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async MJActions_CategoryIDArray(@Root() mjactioncategory_: MJActionCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActions')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjactioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerTool_])
    async MJMCPServerTools_GeneratedActionCategoryIDArray(@Root() mjactioncategory_: MJActionCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerTools')} WHERE ${provider.QuoteIdentifier('GeneratedActionCategoryID')}='${mjactioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJActionCategory_)
    async CreateMJActionCategory(
        @Arg('input', () => CreateMJActionCategoryInput) input: CreateMJActionCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionCategory_)
    async UpdateMJActionCategory(
        @Arg('input', () => UpdateMJActionCategoryInput) input: UpdateMJActionCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionCategory_)
    async DeleteMJActionCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Context Types
//****************************************************************************
@ObjectType({ description: `Lists possible contexts for action execution with optional descriptions.` })
export class MJActionContextType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Name of the context type.`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of the context type.`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJActionContext_])
    MJActionContexts_ContextTypeIDArray: MJActionContext_[]; // Link to MJActionContexts
    
}

//****************************************************************************
// INPUT TYPE for MJ: Action Context Types
//****************************************************************************
@InputType()
export class CreateMJActionContextTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Context Types
//****************************************************************************
@InputType()
export class UpdateMJActionContextTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Context Types
//****************************************************************************
@ObjectType()
export class RunMJActionContextTypeViewResult {
    @Field(() => [MJActionContextType_])
    Results: MJActionContextType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionContextType_)
export class MJActionContextTypeResolver extends ResolverBase {
    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Context Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionContextType_, { nullable: true })
    async MJActionContextType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionContextType_ | null> {
        this.CheckUserReadPermissions('MJ: Action Context Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionContextTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Context Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Context Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJActionContext_])
    async MJActionContexts_ContextTypeIDArray(@Root() mjactioncontexttype_: MJActionContextType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionContexts')} WHERE ${provider.QuoteIdentifier('ContextTypeID')}='${mjactioncontexttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Contexts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJActionContextType_)
    async CreateMJActionContextType(
        @Arg('input', () => CreateMJActionContextTypeInput) input: CreateMJActionContextTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Context Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionContextType_)
    async UpdateMJActionContextType(
        @Arg('input', () => UpdateMJActionContextTypeInput) input: UpdateMJActionContextTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Context Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionContextType_)
    async DeleteMJActionContextType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Context Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Contexts
//****************************************************************************
@ObjectType({ description: `Links actions to their supported context types enabling a given action to be executable in more than one context.` })
export class MJActionContext_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ActionID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ContextTypeID?: string;
        
    @Field({description: `Status of the action context (Pending, Active, Disabled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(425)
    Action: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ContextType?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Action Contexts
//****************************************************************************
@InputType()
export class CreateMJActionContextInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Contexts
//****************************************************************************
@InputType()
export class UpdateMJActionContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Contexts
//****************************************************************************
@ObjectType()
export class RunMJActionContextViewResult {
    @Field(() => [MJActionContext_])
    Results: MJActionContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionContext_)
export class MJActionContextResolver extends ResolverBase {
    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Contexts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionContext_, { nullable: true })
    async MJActionContext(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionContext_ | null> {
        this.CheckUserReadPermissions('MJ: Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionContexts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Contexts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionContext_)
    async CreateMJActionContext(
        @Arg('input', () => CreateMJActionContextInput) input: CreateMJActionContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Contexts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionContext_)
    async UpdateMJActionContext(
        @Arg('input', () => UpdateMJActionContextInput) input: UpdateMJActionContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Contexts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionContext_)
    async DeleteMJActionContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Contexts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Execution Logs
//****************************************************************************
@ObjectType({ description: `Tracks every execution of an action, including start and end times, inputs, outputs, and result codes.` })
export class MJActionExecutionLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ActionID: string;
        
    @Field({description: `Timestamp when the action execution started (timezone-aware)`}) 
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the action execution ended (timezone-aware)`}) 
    EndedAt?: Date;
        
    @Field({nullable: true, description: `JSON-formatted input parameters passed to the action during execution, storing the exact values used for this specific run.`}) 
    Params?: string;
        
    @Field({nullable: true, description: `The outcome code returned by the action execution, indicating success, failure, or specific error conditions as defined in Action Result Codes.`}) 
    @MaxLength(255)
    ResultCode?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain the log; NULL for indefinite retention.`}) 
    RetentionPeriod?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON-formatted output data or response from the action execution`}) 
    Message?: string;
        
    @Field() 
    @MaxLength(425)
    Action: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Action Execution Logs
//****************************************************************************
@InputType()
export class CreateMJActionExecutionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Params: string | null;

    @Field({ nullable: true })
    ResultCode: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;

    @Field({ nullable: true })
    Message: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Execution Logs
//****************************************************************************
@InputType()
export class UpdateMJActionExecutionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Params?: string | null;

    @Field({ nullable: true })
    ResultCode?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Execution Logs
//****************************************************************************
@ObjectType()
export class RunMJActionExecutionLogViewResult {
    @Field(() => [MJActionExecutionLog_])
    Results: MJActionExecutionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionExecutionLog_)
export class MJActionExecutionLogResolver extends ResolverBase {
    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Execution Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionExecutionLog_, { nullable: true })
    async MJActionExecutionLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionExecutionLog_ | null> {
        this.CheckUserReadPermissions('MJ: Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionExecutionLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Execution Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionExecutionLog_)
    async CreateMJActionExecutionLog(
        @Arg('input', () => CreateMJActionExecutionLogInput) input: CreateMJActionExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Execution Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionExecutionLog_)
    async UpdateMJActionExecutionLog(
        @Arg('input', () => UpdateMJActionExecutionLogInput) input: UpdateMJActionExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Execution Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionExecutionLog_)
    async DeleteMJActionExecutionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Execution Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Filters
//****************************************************************************
@ObjectType({ description: `Defines filters that can be evaluated ahead of executing an action. Action Filters are usable in any code pipeline you can execute them with the same context as the action itself and use the outcome to determine if the action should execute or not.` })
export class MJActionFilter_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Human-readable explanation of what this filter checks and when it should prevent action execution, written for non-technical users.`}) 
    UserDescription: string;
        
    @Field({nullable: true, description: `Additional notes or implementation details about the filter logic, including examples or edge cases to consider.`}) 
    UserComments?: string;
        
    @Field({description: `JavaScript code that evaluates to true (allow action) or false (prevent action), executed in the same context as the action.`}) 
    Code: string;
        
    @Field({nullable: true, description: `Technical documentation of the filter code logic, including expected inputs, outputs, and any dependencies or assumptions.`}) 
    CodeExplanation?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityActionFilter_])
    MJEntityActionFilters_ActionFilterIDArray: MJEntityActionFilter_[]; // Link to MJEntityActionFilters
    
}

//****************************************************************************
// INPUT TYPE for MJ: Action Filters
//****************************************************************************
@InputType()
export class CreateMJActionFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Filters
//****************************************************************************
@InputType()
export class UpdateMJActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Filters
//****************************************************************************
@ObjectType()
export class RunMJActionFilterViewResult {
    @Field(() => [MJActionFilter_])
    Results: MJActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionFilter_)
export class MJActionFilterResolver extends ResolverBase {
    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionFilter_, { nullable: true })
    async MJActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionFilter_ | null> {
        this.CheckUserReadPermissions('MJ: Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionFilters')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Filters', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionFilter_])
    async MJEntityActionFilters_ActionFilterIDArray(@Root() mjactionfilter_: MJActionFilter_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionFilters')} WHERE ${provider.QuoteIdentifier('ActionFilterID')}='${mjactionfilter_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Action Filters', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJActionFilter_)
    async CreateMJActionFilter(
        @Arg('input', () => CreateMJActionFilterInput) input: CreateMJActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionFilter_)
    async UpdateMJActionFilter(
        @Arg('input', () => UpdateMJActionFilterInput) input: UpdateMJActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionFilter_)
    async DeleteMJActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Libraries
//****************************************************************************
@ObjectType({ description: `Tracks the list of libraries that a given Action uses, including a list of classes/functions for each library.` })
export class MJActionLibrary_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ActionID: string;
        
    @Field() 
    @MaxLength(36)
    LibraryID: string;
        
    @Field({nullable: true, description: `List of classes and functions used by the action from the library.`}) 
    ItemsUsed?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(425)
    Action: string;
        
    @Field() 
    @MaxLength(255)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Action Libraries
//****************************************************************************
@InputType()
export class CreateMJActionLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Libraries
//****************************************************************************
@InputType()
export class UpdateMJActionLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Libraries
//****************************************************************************
@ObjectType()
export class RunMJActionLibraryViewResult {
    @Field(() => [MJActionLibrary_])
    Results: MJActionLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionLibrary_)
export class MJActionLibraryResolver extends ResolverBase {
    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionLibrary_, { nullable: true })
    async MJActionLibrary(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionLibrary_ | null> {
        this.CheckUserReadPermissions('MJ: Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionLibraries')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Libraries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionLibrary_)
    async CreateMJActionLibrary(
        @Arg('input', () => CreateMJActionLibraryInput) input: CreateMJActionLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionLibrary_)
    async UpdateMJActionLibrary(
        @Arg('input', () => UpdateMJActionLibraryInput) input: UpdateMJActionLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionLibrary_)
    async DeleteMJActionLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Params
//****************************************************************************
@ObjectType({ description: `Tracks the input and output parameters for Actions.` })
export class MJActionParam_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ActionID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `The default value for this parameter if not provided during action execution, can be a literal value or JSON for complex types.`}) 
    DefaultValue?: string;
        
    @Field({description: `Specifies whether this parameter is used for Input, Output, or Both directions in the action execution flow.`}) 
    @MaxLength(10)
    Type: string;
        
    @Field({description: `Tracks the basic value type of the parameter, additional information can be provided in the Description field`}) 
    @MaxLength(30)
    ValueType: string;
        
    @Field(() => Boolean, {description: `Indicates whether this parameter accepts or returns an array of values rather than a single value.`}) 
    IsArray: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `Determines if this parameter must be provided for input parameters or will always be populated for output parameters.`}) 
    IsRequired: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Specifies the type of media this parameter outputs when ValueType is MediaOutput. Used for action discovery and validation.`}) 
    @MaxLength(20)
    MediaModality?: string;
        
    @Field() 
    @MaxLength(425)
    Action: string;
        
    @Field(() => [MJEntityActionParam_])
    MJEntityActionParams_ActionParamIDArray: MJEntityActionParam_[]; // Link to MJEntityActionParams
    
    @Field(() => [MJScheduledActionParam_])
    MJScheduledActionParams_ActionParamIDArray: MJScheduledActionParam_[]; // Link to MJScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for MJ: Action Params
//****************************************************************************
@InputType()
export class CreateMJActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    MediaModality: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Params
//****************************************************************************
@InputType()
export class UpdateMJActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    MediaModality?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Params
//****************************************************************************
@ObjectType()
export class RunMJActionParamViewResult {
    @Field(() => [MJActionParam_])
    Results: MJActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionParam_)
export class MJActionParamResolver extends ResolverBase {
    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionParam_, { nullable: true })
    async MJActionParam(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionParam_ | null> {
        this.CheckUserReadPermissions('MJ: Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionParams')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionParam_])
    async MJEntityActionParams_ActionParamIDArray(@Root() mjactionparam_: MJActionParam_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionParams')} WHERE ${provider.QuoteIdentifier('ActionParamID')}='${mjactionparam_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledActionParam_])
    async MJScheduledActionParams_ActionParamIDArray(@Root() mjactionparam_: MJActionParam_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledActionParams')} WHERE ${provider.QuoteIdentifier('ActionParamID')}='${mjactionparam_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJActionParam_)
    async CreateMJActionParam(
        @Arg('input', () => CreateMJActionParamInput) input: CreateMJActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionParam_)
    async UpdateMJActionParam(
        @Arg('input', () => UpdateMJActionParamInput) input: UpdateMJActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionParam_)
    async DeleteMJActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Action Result Codes
//****************************************************************************
@ObjectType({ description: `Defines the possible result codes for each action.` })
export class MJActionResultCode_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ActionID: string;
        
    @Field({description: `The unique code string returned by the action to indicate specific outcomes, used for programmatic handling of results.`}) 
    @MaxLength(255)
    ResultCode: string;
        
    @Field(() => Boolean, {description: `Indicates if the result code is a success or not. It is possible an action might have more than one failure condition/result code and same for success conditions.`}) 
    IsSuccess: boolean;
        
    @Field({nullable: true, description: `Description of the result code.`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(425)
    Action: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Action Result Codes
//****************************************************************************
@InputType()
export class CreateMJActionResultCodeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Action Result Codes
//****************************************************************************
@InputType()
export class UpdateMJActionResultCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Action Result Codes
//****************************************************************************
@ObjectType()
export class RunMJActionResultCodeViewResult {
    @Field(() => [MJActionResultCode_])
    Results: MJActionResultCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionResultCode_)
export class MJActionResultCodeResolver extends ResolverBase {
    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Action Result Codes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionResultCode_, { nullable: true })
    async MJActionResultCode(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionResultCode_ | null> {
        this.CheckUserReadPermissions('MJ: Action Result Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionResultCodes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Action Result Codes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionResultCode_)
    async CreateMJActionResultCode(
        @Arg('input', () => CreateMJActionResultCodeInput) input: CreateMJActionResultCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Action Result Codes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionResultCode_)
    async UpdateMJActionResultCode(
        @Arg('input', () => UpdateMJActionResultCodeInput) input: UpdateMJActionResultCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Action Result Codes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionResultCode_)
    async DeleteMJActionResultCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Action Result Codes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Actions
//****************************************************************************
@ObjectType({ description: `Stores action definitions, including prompts, generated code, user comments, and status.` })
export class MJAction_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field({description: `The name of the action. Must be unique within the combination of CategoryID and ParentID. Actions with the same name can exist in different categories or under different parents.`}) 
    @MaxLength(425)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Generated or Custom. Generated means the UserPrompt is used to prompt an AI model to automatically create the code for the Action. Custom means that a custom class has been implemented that subclasses the BaseAction class. The custom class needs to use the @RegisterClass decorator and be included in the MJAPI (or other runtime environment) to be available for execution.`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `The natural language prompt provided by the user describing what the action should accomplish, used for AI code generation.`}) 
    UserPrompt?: string;
        
    @Field({nullable: true, description: `User's comments not shared with the LLM.`}) 
    UserComments?: string;
        
    @Field({nullable: true, description: `The generated or manually written code that implements the action logic, typically TypeScript/JavaScript that will be executed.`}) 
    Code?: string;
        
    @Field({nullable: true, description: `AI's explanation of the code.`}) 
    CodeComments?: string;
        
    @Field({description: `An action won't be usable until the code is approved.`}) 
    @MaxLength(20)
    CodeApprovalStatus: string;
        
    @Field({nullable: true, description: `Optional comments when an individual (or an AI) reviews and approves the code.`}) 
    CodeApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CodeApprovedByUserID?: string;
        
    @Field({nullable: true, description: `When the code was approved.`}) 
    CodeApprovedAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 1, Code will never be generated by the AI system. This overrides all other settings including the ForceCodeGeneration bit`}) 
    CodeLocked: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, the Action will generate code for the provided UserPrompt on the next Save even if the UserPrompt hasn't changed. This is useful to force regeneration when other candidates (such as a change in Action Inputs/Outputs) occurs or on demand by a user.`}) 
    ForceCodeGeneration: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain execution logs; NULL for indefinite.`}) 
    RetentionPeriod?: number;
        
    @Field({description: `Status of the action (Pending, Active, Disabled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `For actions where Type='Custom', this specifies the fully qualified class name of the BaseAction sub-class that should be instantiated to handle the action execution. This provides a more reliable mechanism than relying on the Name field for class instantiation.`}) 
    @MaxLength(255)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Optional ID of the parent action this action inherits from. Used for hierarchical action composition where child actions can specialize parent actions.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class (e.g., fa-cog, fa-play, fa-search) for visual representation of the action.`}) 
    @MaxLength(100)
    IconClass?: string;
        
    @Field({nullable: true, description: `Default prompt for compacting/summarizing this action's results when used by agents with CompactMode=AISummary. Action designers define how their specific results should be summarized. Can be overridden per agent in AIAgentAction.CompactPromptID.`}) 
    @MaxLength(36)
    DefaultCompactPromptID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    CodeApprovedByUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(425)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    DefaultCompactPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJActionParam_])
    MJActionParams_ActionIDArray: MJActionParam_[]; // Link to MJActionParams
    
    @Field(() => [MJActionLibrary_])
    MJActionLibraries_ActionIDArray: MJActionLibrary_[]; // Link to MJActionLibraries
    
    @Field(() => [MJActionResultCode_])
    MJActionResultCodes_ActionIDArray: MJActionResultCode_[]; // Link to MJActionResultCodes
    
    @Field(() => [MJScheduledAction_])
    MJScheduledActions_ActionIDArray: MJScheduledAction_[]; // Link to MJScheduledActions
    
    @Field(() => [MJAIAgentAction_])
    MJAIAgentActions_ActionIDArray: MJAIAgentAction_[]; // Link to MJAIAgentActions
    
    @Field(() => [MJMCPServerTool_])
    MJMCPServerTools_GeneratedActionIDArray: MJMCPServerTool_[]; // Link to MJMCPServerTools
    
    @Field(() => [MJActionContext_])
    MJActionContexts_ActionIDArray: MJActionContext_[]; // Link to MJActionContexts
    
    @Field(() => [MJEntityAction_])
    MJEntityActions_ActionIDArray: MJEntityAction_[]; // Link to MJEntityActions
    
    @Field(() => [MJAIAgentStep_])
    MJAIAgentSteps_ActionIDArray: MJAIAgentStep_[]; // Link to MJAIAgentSteps
    
    @Field(() => [MJActionExecutionLog_])
    MJActionExecutionLogs_ActionIDArray: MJActionExecutionLog_[]; // Link to MJActionExecutionLogs
    
    @Field(() => [MJActionAuthorization_])
    MJActionAuthorizations_ActionIDArray: MJActionAuthorization_[]; // Link to MJActionAuthorizations
    
    @Field(() => [MJAction_])
    MJActions_ParentIDArray: MJAction_[]; // Link to MJActions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Actions
//****************************************************************************
@InputType()
export class CreateMJActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    CodeComments: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID: string | null;

    @Field({ nullable: true })
    CodeApprovedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    DefaultCompactPromptID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Actions
//****************************************************************************
@InputType()
export class UpdateMJActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    CodeComments?: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments?: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID?: string | null;

    @Field({ nullable: true })
    CodeApprovedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    DefaultCompactPromptID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Actions
//****************************************************************************
@ObjectType()
export class RunMJActionViewResult {
    @Field(() => [MJAction_])
    Results: MJAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAction_)
export class MJActionResolver extends ResolverBase {
    @Query(() => RunMJActionViewResult)
    async RunMJActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionViewResult)
    async RunMJActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionViewResult)
    async RunMJActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAction_, { nullable: true })
    async MJAction(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAction_ | null> {
        this.CheckUserReadPermissions('MJ: Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJActionParam_])
    async MJActionParams_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionParams')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionLibrary_])
    async MJActionLibraries_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionLibraries')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Libraries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionResultCode_])
    async MJActionResultCodes_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Result Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionResultCodes')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Result Codes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledAction_])
    async MJScheduledActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledActions')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentAction_])
    async MJAIAgentActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentActions')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerTool_])
    async MJMCPServerTools_GeneratedActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerTools')} WHERE ${provider.QuoteIdentifier('GeneratedActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionContext_])
    async MJActionContexts_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionContexts')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Contexts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAction_])
    async MJEntityActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActions')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStep_])
    async MJAIAgentSteps_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentSteps')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionExecutionLog_])
    async MJActionExecutionLogs_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionExecutionLogs')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionAuthorization_])
    async MJActionAuthorizations_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionAuthorizations')} WHERE ${provider.QuoteIdentifier('ActionID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Authorizations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async MJActions_ParentIDArray(@Root() mjaction_: MJAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActions')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAction_)
    async CreateMJAction(
        @Arg('input', () => CreateMJActionInput) input: CreateMJActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAction_)
    async UpdateMJAction(
        @Arg('input', () => UpdateMJActionInput) input: UpdateMJActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAction_)
    async DeleteMJAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Actions
//****************************************************************************
@ObjectType({ description: `List of all actions that are possible across all AI Models` })
export class MJAIAction_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `The standard prompt template used when invoking this AI action, can include placeholders for dynamic values.`}) 
    DefaultPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    DefaultModelID?: string;
        
    @Field(() => Boolean, {description: `Controls whether this AI action is currently available for use across the system.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    DefaultModel?: string;
        
    @Field(() => [MJAIModelAction_])
    MJAIModelActions_AIActionIDArray: MJAIModelAction_[]; // Link to MJAIModelActions
    
    @Field(() => [MJEntityAIAction_])
    MJEntityAIActions_AIActionIDArray: MJEntityAIAction_[]; // Link to MJEntityAIActions
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Actions
//****************************************************************************
@InputType()
export class CreateMJAIActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultPrompt: string | null;

    @Field({ nullable: true })
    DefaultModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Actions
//****************************************************************************
@InputType()
export class UpdateMJAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultPrompt?: string | null;

    @Field({ nullable: true })
    DefaultModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Actions
//****************************************************************************
@ObjectType()
export class RunMJAIActionViewResult {
    @Field(() => [MJAIAction_])
    Results: MJAIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAction_)
export class MJAIActionResolver extends ResolverBase {
    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAction_, { nullable: true })
    async MJAIAction(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAction_ | null> {
        this.CheckUserReadPermissions('MJ: AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIActions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAIAction_])
    async AllMJAIActions(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIActions')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModelAction_])
    async MJAIModelActions_AIActionIDArray(@Root() mjaiaction_: MJAIAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelActions')} WHERE ${provider.QuoteIdentifier('AIActionID')}='${mjaiaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async MJEntityAIActions_AIActionIDArray(@Root() mjaiaction_: MJAIAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityAIActions')} WHERE ${provider.QuoteIdentifier('AIActionID')}='${mjaiaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAction_)
    async CreateMJAIAction(
        @Arg('input', () => CreateMJAIActionInput) input: CreateMJAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAction_)
    async UpdateMJAIAction(
        @Arg('input', () => UpdateMJAIActionInput) input: UpdateMJAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAction_)
    async DeleteMJAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Actions
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and actions.` })
export class MJAIAgentAction_ {
    @Field({description: `The unique identifier for each AI agent-action mapping. Serves as the primary key.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from the AIAgent table.`}) 
    @MaxLength(36)
    AgentID?: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated action from the Action table.`}) 
    @MaxLength(36)
    ActionID?: string;
        
    @Field() 
    @MaxLength(15)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Minimum number of times this action must be executed per agent run`}) 
    MinExecutionsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of times this action can be executed per agent run`}) 
    MaxExecutionsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of conversation turns before action results expire from conversation context. NULL = never expire (default). 0 = expire immediately after next turn.`}) 
    ResultExpirationTurns?: number;
        
    @Field({description: `How to handle expired action results: None (no expiration, default), Remove (delete message entirely), Compact (reduce size via CompactMode while preserving key information).`}) 
    @MaxLength(20)
    ResultExpirationMode: string;
        
    @Field({nullable: true, description: `How to compact results when ResultExpirationMode=Compact: FirstNChars (truncate to CompactLength characters, fast and free), AISummary (use LLM to intelligently summarize with CompactPromptID or Action.DefaultCompactPromptID).`}) 
    @MaxLength(20)
    CompactMode?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of characters to keep when CompactMode=FirstNChars. Required when CompactMode is FirstNChars, ignored otherwise.`}) 
    CompactLength?: number;
        
    @Field({nullable: true, description: `Optional override for AI summarization prompt when CompactMode=AISummary. Lookup hierarchy: this field -> Action.DefaultCompactPromptID -> system default. Allows agent-specific summarization focus (e.g., technical vs. marketing perspective).`}) 
    @MaxLength(36)
    CompactPromptID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(425)
    Action?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    CompactPrompt?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Actions
//****************************************************************************
@InputType()
export class CreateMJAIAgentActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ActionID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    ResultExpirationTurns: number | null;

    @Field({ nullable: true })
    ResultExpirationMode?: string;

    @Field({ nullable: true })
    CompactMode: string | null;

    @Field(() => Int, { nullable: true })
    CompactLength: number | null;

    @Field({ nullable: true })
    CompactPromptID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Actions
//****************************************************************************
@InputType()
export class UpdateMJAIAgentActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ActionID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    ResultExpirationTurns?: number | null;

    @Field({ nullable: true })
    ResultExpirationMode?: string;

    @Field({ nullable: true })
    CompactMode?: string | null;

    @Field(() => Int, { nullable: true })
    CompactLength?: number | null;

    @Field({ nullable: true })
    CompactPromptID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Actions
//****************************************************************************
@ObjectType()
export class RunMJAIAgentActionViewResult {
    @Field(() => [MJAIAgentAction_])
    Results: MJAIAgentAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentAction_)
export class MJAIAgentActionResolver extends ResolverBase {
    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentAction_, { nullable: true })
    async MJAIAgentAction(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentAction_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentActions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentAction_)
    async CreateMJAIAgentAction(
        @Arg('input', () => CreateMJAIAgentActionInput) input: CreateMJAIAgentActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentAction_)
    async UpdateMJAIAgentAction(
        @Arg('input', () => UpdateMJAIAgentActionInput) input: UpdateMJAIAgentActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentAction_)
    async DeleteMJAIAgentAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Artifact Types
//****************************************************************************
@ObjectType({ description: `Junction table linking AI Agents to the artifact types they can produce. An agent can produce zero to many artifact types.` })
export class MJAIAgentArtifactType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `AI Agent that can produce this artifact type`}) 
    @MaxLength(36)
    AgentID: string;
        
    @Field({description: `Artifact type that this agent can produce`}) 
    @MaxLength(36)
    ArtifactTypeID: string;
        
    @Field(() => Int, {nullable: true, description: `Optional sequence for ordering multiple artifact types for an agent`}) 
    Sequence?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field() 
    @MaxLength(100)
    ArtifactType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Artifact Types
//****************************************************************************
@InputType()
export class CreateMJAIAgentArtifactTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field(() => Int, { nullable: true })
    Sequence: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Artifact Types
//****************************************************************************
@InputType()
export class UpdateMJAIAgentArtifactTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Artifact Types
//****************************************************************************
@ObjectType()
export class RunMJAIAgentArtifactTypeViewResult {
    @Field(() => [MJAIAgentArtifactType_])
    Results: MJAIAgentArtifactType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentArtifactType_)
export class MJAIAgentArtifactTypeResolver extends ResolverBase {
    @Query(() => RunMJAIAgentArtifactTypeViewResult)
    async RunMJAIAgentArtifactTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentArtifactTypeViewResult)
    async RunMJAIAgentArtifactTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentArtifactTypeViewResult)
    async RunMJAIAgentArtifactTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Artifact Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentArtifactType_, { nullable: true })
    async MJAIAgentArtifactType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentArtifactType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentArtifactTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Artifact Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentArtifactType_)
    async CreateMJAIAgentArtifactType(
        @Arg('input', () => CreateMJAIAgentArtifactTypeInput) input: CreateMJAIAgentArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Artifact Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentArtifactType_)
    async UpdateMJAIAgentArtifactType(
        @Arg('input', () => UpdateMJAIAgentArtifactTypeInput) input: UpdateMJAIAgentArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Artifact Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentArtifactType_)
    async DeleteMJAIAgentArtifactType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Artifact Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Configurations
//****************************************************************************
@ObjectType({ description: `Defines semantic configuration presets for agents, allowing users to select between different AI model configurations (e.g., Fast, Balanced, High Quality) when executing an agent. Each preset maps to an AI Configuration which controls model selection across all prompts.` })
export class MJAIAgentConfiguration_ {
    @Field({description: `Primary Key - Unique identifier for the agent configuration preset`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign Key - The agent this configuration preset belongs to`}) 
    @MaxLength(36)
    AgentID: string;
        
    @Field({description: `Code-friendly name for the preset (e.g., HighPower, Fast, Balanced). Used in API calls and metadata references.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `User-friendly display name shown in UI (e.g., "High Quality", "Quick Draft", "Maximum Detail")`}) 
    @MaxLength(200)
    DisplayName: string;
        
    @Field({nullable: true, description: `Description shown to users explaining what this configuration does (e.g., "Uses Claude Opus for highest quality results")`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Foreign Key - Optional AI Configuration to use for this preset. If NULL, uses default configuration (prompts with ConfigurationID IS NULL)`}) 
    @MaxLength(36)
    AIConfigurationID?: string;
        
    @Field(() => Boolean, {description: `Whether this is the default preset for the agent. Should have exactly one default per agent.`}) 
    IsDefault: boolean;
        
    @Field(() => Int, {description: `Display order for UI. Lower numbers appear first. Typical values: 100 (Default), 200 (Fast), 300 (Balanced), 400 (High Quality)`}) 
    Priority: number;
        
    @Field({description: `Status of the preset: Pending (being configured), Active (available for use), Revoked (no longer available)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    AIConfiguration?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Configurations
//****************************************************************************
@InputType()
export class CreateMJAIAgentConfigurationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIConfigurationID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Configurations
//****************************************************************************
@InputType()
export class UpdateMJAIAgentConfigurationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIConfigurationID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Configurations
//****************************************************************************
@ObjectType()
export class RunMJAIAgentConfigurationViewResult {
    @Field(() => [MJAIAgentConfiguration_])
    Results: MJAIAgentConfiguration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentConfiguration_)
export class MJAIAgentConfigurationResolver extends ResolverBase {
    @Query(() => RunMJAIAgentConfigurationViewResult)
    async RunMJAIAgentConfigurationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentConfigurationViewResult)
    async RunMJAIAgentConfigurationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentConfigurationViewResult)
    async RunMJAIAgentConfigurationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Configurations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentConfiguration_, { nullable: true })
    async MJAIAgentConfiguration(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentConfiguration_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentConfigurations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Configurations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentConfiguration_)
    async CreateMJAIAgentConfiguration(
        @Arg('input', () => CreateMJAIAgentConfigurationInput) input: CreateMJAIAgentConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Configurations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentConfiguration_)
    async UpdateMJAIAgentConfiguration(
        @Arg('input', () => UpdateMJAIAgentConfigurationInput) input: UpdateMJAIAgentConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Configurations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentConfiguration_)
    async DeleteMJAIAgentConfiguration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Configurations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Data Sources
//****************************************************************************
@ObjectType({ description: `Defines data sources that should be preloaded into the data parameter before agent execution. Supports both RunView and RunQuery sources with configurable caching.` })
export class MJAIAgentDataSource_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    AgentID: string;
        
    @Field({description: `Variable name for the data in the data parameter (e.g., "ALL_ENTITIES"). Must be unique within an agent.`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of what this data source provides`}) 
    Description?: string;
        
    @Field({description: `Type of data source: RunView or RunQuery. Determines which parameters are used.`}) 
    @MaxLength(20)
    SourceType: string;
        
    @Field({nullable: true, description: `Entity name for RunView data sources (e.g., "Entities", "AI Models")`}) 
    @MaxLength(255)
    EntityName?: string;
        
    @Field({nullable: true, description: `SQL WHERE clause filter for RunView data sources`}) 
    ExtraFilter?: string;
        
    @Field({nullable: true, description: `SQL ORDER BY clause for RunView data sources`}) 
    @MaxLength(500)
    OrderBy?: string;
        
    @Field({nullable: true, description: `JSON array of field names to return for RunView data sources (e.g., ["ID", "Name", "Description"])`}) 
    FieldsToRetrieve?: string;
        
    @Field({nullable: true, description: `Result type for RunView: simple (default) or entity_object`}) 
    @MaxLength(20)
    ResultType?: string;
        
    @Field({nullable: true, description: `Query name for RunQuery data sources`}) 
    @MaxLength(255)
    QueryName?: string;
        
    @Field({nullable: true, description: `Category path for RunQuery data sources (e.g., "/MJ/AI/Agents/")`}) 
    @MaxLength(500)
    CategoryPath?: string;
        
    @Field({nullable: true, description: `JSON object of parameters for RunQuery data sources (e.g., {"organizationId": "123"})`}) 
    Parameters?: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of rows to return. Applies to both RunView and RunQuery.`}) 
    MaxRows?: number;
        
    @Field(() => Int, {description: `Execution order when multiple data sources are defined for an agent (lower numbers execute first)`}) 
    ExecutionOrder: number;
        
    @Field({description: `Status of the data source: Active or Disabled`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({description: `Cache policy: None (no caching), PerRun (cache for duration of agent run), PerAgent (cache across runs with timeout)`}) 
    @MaxLength(20)
    CachePolicy: string;
        
    @Field(() => Int, {nullable: true, description: `Time-to-live in seconds for PerAgent cache policy. Ignored for other cache policies.`}) 
    CacheTimeoutSeconds?: number;
        
    @Field({description: `Destination for the preloaded data: Data (for Nunjucks templates in prompts), Context (for actions only), or Payload (for agent state)`}) 
    @MaxLength(20)
    DestinationType: string;
        
    @Field({nullable: true, description: `Path within the destination where data should be injected. Supports nested paths using dot notation (e.g., "config.api.endpoints", "analysis.orders.recent"). If null, uses Name as root-level key.`}) 
    @MaxLength(500)
    DestinationPath?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Data Sources
//****************************************************************************
@InputType()
export class CreateMJAIAgentDataSourceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SourceType?: string;

    @Field({ nullable: true })
    EntityName: string | null;

    @Field({ nullable: true })
    ExtraFilter: string | null;

    @Field({ nullable: true })
    OrderBy: string | null;

    @Field({ nullable: true })
    FieldsToRetrieve: string | null;

    @Field({ nullable: true })
    ResultType?: string | null;

    @Field({ nullable: true })
    QueryName: string | null;

    @Field({ nullable: true })
    CategoryPath: string | null;

    @Field({ nullable: true })
    Parameters: string | null;

    @Field(() => Int, { nullable: true })
    MaxRows: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    CachePolicy?: string;

    @Field(() => Int, { nullable: true })
    CacheTimeoutSeconds: number | null;

    @Field({ nullable: true })
    DestinationType?: string;

    @Field({ nullable: true })
    DestinationPath: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Data Sources
//****************************************************************************
@InputType()
export class UpdateMJAIAgentDataSourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SourceType?: string;

    @Field({ nullable: true })
    EntityName?: string | null;

    @Field({ nullable: true })
    ExtraFilter?: string | null;

    @Field({ nullable: true })
    OrderBy?: string | null;

    @Field({ nullable: true })
    FieldsToRetrieve?: string | null;

    @Field({ nullable: true })
    ResultType?: string | null;

    @Field({ nullable: true })
    QueryName?: string | null;

    @Field({ nullable: true })
    CategoryPath?: string | null;

    @Field({ nullable: true })
    Parameters?: string | null;

    @Field(() => Int, { nullable: true })
    MaxRows?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    CachePolicy?: string;

    @Field(() => Int, { nullable: true })
    CacheTimeoutSeconds?: number | null;

    @Field({ nullable: true })
    DestinationType?: string;

    @Field({ nullable: true })
    DestinationPath?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Data Sources
//****************************************************************************
@ObjectType()
export class RunMJAIAgentDataSourceViewResult {
    @Field(() => [MJAIAgentDataSource_])
    Results: MJAIAgentDataSource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentDataSource_)
export class MJAIAgentDataSourceResolver extends ResolverBase {
    @Query(() => RunMJAIAgentDataSourceViewResult)
    async RunMJAIAgentDataSourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentDataSourceViewResult)
    async RunMJAIAgentDataSourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentDataSourceViewResult)
    async RunMJAIAgentDataSourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Data Sources';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentDataSource_, { nullable: true })
    async MJAIAgentDataSource(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentDataSource_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Data Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentDataSources')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Data Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Data Sources', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentDataSource_)
    async CreateMJAIAgentDataSource(
        @Arg('input', () => CreateMJAIAgentDataSourceInput) input: CreateMJAIAgentDataSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Data Sources', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentDataSource_)
    async UpdateMJAIAgentDataSource(
        @Arg('input', () => UpdateMJAIAgentDataSourceInput) input: UpdateMJAIAgentDataSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Data Sources', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentDataSource_)
    async DeleteMJAIAgentDataSource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Data Sources', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Examples
//****************************************************************************
@ObjectType({ description: `Stores example input/output pairs for AI agents to learn from successful interactions. Examples are always agent-specific and support optional user/company scoping for personalized examples.` })
export class MJAIAgentExample_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The AI agent this example is associated with. Examples are always agent-specific.`}) 
    @MaxLength(36)
    AgentID: string;
        
    @Field({nullable: true, description: `Optional user scope. When populated, this example is specific to this user.`}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field({nullable: true, description: `Optional company scope. When populated, this example is specific to this company.`}) 
    @MaxLength(36)
    CompanyID?: string;
        
    @Field({description: `Quick categorization of the example: Preference (demonstrates user preference), Constraint (shows constraint compliance), Context (provides contextual example), Example (typical successful interaction - most common), or Issue (demonstrates handling of known issue).`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({description: `The input text or prompt that was provided in this example interaction.`}) 
    ExampleInput: string;
        
    @Field({description: `The successful output or response that the agent provided for this example.`}) 
    ExampleOutput: string;
        
    @Field(() => Boolean, {description: `Indicates whether this example was automatically captured (1) or manually created (0).`}) 
    IsAutoGenerated: boolean;
        
    @Field({nullable: true, description: `Optional reference to the conversation where this example originated.`}) 
    @MaxLength(36)
    SourceConversationID?: string;
        
    @Field({nullable: true, description: `Optional reference to the specific conversation message that represents this example.`}) 
    @MaxLength(36)
    SourceConversationDetailID?: string;
        
    @Field({nullable: true, description: `Optional reference to the AI agent run that generated this example.`}) 
    @MaxLength(36)
    SourceAIAgentRunID?: string;
        
    @Field(() => Float, {nullable: true, description: `Optional success score (0-100) indicating the quality or effectiveness of this example based on user feedback or metrics.`}) 
    SuccessScore?: number;
        
    @Field({nullable: true, description: `Internal comments about this example, not included in agent context injection.`}) 
    Comments?: string;
        
    @Field({description: `Status of the example: Pending (awaiting review), Active (in use), or Revoked (disabled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON array of embedding vector for semantic search on ExampleInput field. Auto-generated when ExampleInput changes.`}) 
    EmbeddingVector?: string;
        
    @Field({nullable: true, description: `Reference to the AI model used to generate the embedding vector.`}) 
    @MaxLength(36)
    EmbeddingModelID?: string;
        
    @Field({nullable: true, description: `Foreign key to Entity table identifying which entity type is used for primary scoping. NULL means this is a global example.`}) 
    @MaxLength(36)
    PrimaryScopeEntityID?: string;
        
    @Field({nullable: true, description: `The record ID within the primary scope entity. NULL means global example. When set with empty SecondaryScopes, indicates primary-scope-only example.`}) 
    @MaxLength(100)
    PrimaryScopeRecordID?: string;
        
    @Field({nullable: true, description: `JSON object containing additional scope dimensions. Empty/NULL with PrimaryScopeRecordID set = org-level example. Populated = fully-scoped example.`}) 
    SecondaryScopes?: string;
        
    @Field({nullable: true, description: `Timestamp of when this example was last accessed/used for agent context. Used for lifecycle management and cleanup.`}) 
    LastAccessedAt?: Date;
        
    @Field(() => Int, {description: `Number of times this example has been accessed/used. Used for analytics and determining example value.`}) 
    AccessCount: number;
        
    @Field({nullable: true, description: `Optional expiration timestamp. Examples past this date are candidates for archival. NULL means no expiration.`}) 
    ExpiresAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Company?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SourceConversation?: string;
        
    @Field({nullable: true}) 
    SourceConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SourceAIAgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    EmbeddingModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    PrimaryScopeEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Examples
//****************************************************************************
@InputType()
export class CreateMJAIAgentExampleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    CompanyID: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ExampleInput?: string;

    @Field({ nullable: true })
    ExampleOutput?: string;

    @Field(() => Boolean, { nullable: true })
    IsAutoGenerated?: boolean;

    @Field({ nullable: true })
    SourceConversationID: string | null;

    @Field({ nullable: true })
    SourceConversationDetailID: string | null;

    @Field({ nullable: true })
    SourceAIAgentRunID: string | null;

    @Field(() => Float, { nullable: true })
    SuccessScore: number | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    EmbeddingVector: string | null;

    @Field({ nullable: true })
    EmbeddingModelID: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID: string | null;

    @Field({ nullable: true })
    SecondaryScopes: string | null;

    @Field({ nullable: true })
    LastAccessedAt: Date | null;

    @Field(() => Int, { nullable: true })
    AccessCount?: number;

    @Field({ nullable: true })
    ExpiresAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Examples
//****************************************************************************
@InputType()
export class UpdateMJAIAgentExampleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    CompanyID?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ExampleInput?: string;

    @Field({ nullable: true })
    ExampleOutput?: string;

    @Field(() => Boolean, { nullable: true })
    IsAutoGenerated?: boolean;

    @Field({ nullable: true })
    SourceConversationID?: string | null;

    @Field({ nullable: true })
    SourceConversationDetailID?: string | null;

    @Field({ nullable: true })
    SourceAIAgentRunID?: string | null;

    @Field(() => Float, { nullable: true })
    SuccessScore?: number | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    EmbeddingVector?: string | null;

    @Field({ nullable: true })
    EmbeddingModelID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID?: string | null;

    @Field({ nullable: true })
    SecondaryScopes?: string | null;

    @Field({ nullable: true })
    LastAccessedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    AccessCount?: number;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Examples
//****************************************************************************
@ObjectType()
export class RunMJAIAgentExampleViewResult {
    @Field(() => [MJAIAgentExample_])
    Results: MJAIAgentExample_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentExample_)
export class MJAIAgentExampleResolver extends ResolverBase {
    @Query(() => RunMJAIAgentExampleViewResult)
    async RunMJAIAgentExampleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentExampleViewResult)
    async RunMJAIAgentExampleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentExampleViewResult)
    async RunMJAIAgentExampleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Examples';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentExample_, { nullable: true })
    async MJAIAgentExample(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentExample_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Examples', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentExample_)
    async CreateMJAIAgentExample(
        @Arg('input', () => CreateMJAIAgentExampleInput) input: CreateMJAIAgentExampleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Examples', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentExample_)
    async UpdateMJAIAgentExample(
        @Arg('input', () => UpdateMJAIAgentExampleInput) input: UpdateMJAIAgentExampleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Examples', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentExample_)
    async DeleteMJAIAgentExample(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Examples', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Learning Cycles
//****************************************************************************
@ObjectType({ description: `Tracks the learning cycles for AI Agents where the Agent does offline reasoning, reflection, learning, and updates metadata.` })
export class MJAIAgentLearningCycle_ {
    @Field({description: `Unique identifier for the learning cycle.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Identifier for the AI Agent associated with this learning cycle.`}) 
    @MaxLength(36)
    AgentID: string;
        
    @Field({description: `Timestamp indicating when the learning cycle started.`}) 
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp indicating when the learning cycle ended.`}) 
    EndedAt?: Date;
        
    @Field({description: `Status of the learning cycle (In-Progress, Complete, or Failed).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Text summary provided by the agent about what it learned and any changes it requested for stored metadata.`}) 
    AgentSummary?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class CreateMJAIAgentLearningCycleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class UpdateMJAIAgentLearningCycleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Learning Cycles
//****************************************************************************
@ObjectType()
export class RunMJAIAgentLearningCycleViewResult {
    @Field(() => [MJAIAgentLearningCycle_])
    Results: MJAIAgentLearningCycle_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentLearningCycle_)
export class MJAIAgentLearningCycleResolver extends ResolverBase {
    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Learning Cycles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentLearningCycle_, { nullable: true })
    async MJAIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentLearningCycle_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Learning Cycles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentLearningCycles')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Learning Cycles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentLearningCycle_)
    async CreateMJAIAgentLearningCycle(
        @Arg('input', () => CreateMJAIAgentLearningCycleInput) input: CreateMJAIAgentLearningCycleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Learning Cycles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentLearningCycle_)
    async UpdateMJAIAgentLearningCycle(
        @Arg('input', () => UpdateMJAIAgentLearningCycleInput) input: UpdateMJAIAgentLearningCycleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Learning Cycles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentLearningCycle_)
    async DeleteMJAIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Learning Cycles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Modalities
//****************************************************************************
@ObjectType({ description: `Agent-level modality configuration. Allows agents to restrict or customize modality settings beyond what the model supports. Absence of a record means the agent uses model defaults (Text in/out assumed if no records exist).` })
export class MJAIAgentModality_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    AgentID: string;
        
    @Field() 
    @MaxLength(36)
    ModalityID: string;
        
    @Field({description: `Whether this is an Input or Output modality for the agent.`}) 
    @MaxLength(10)
    Direction: string;
        
    @Field(() => Boolean, {description: `Whether this modality is allowed for this agent. Set to FALSE to disable a modality even if the underlying model supports it.`}) 
    IsAllowed: boolean;
        
    @Field(() => Int, {nullable: true, description: `Agent-specific maximum size in bytes. Overrides model and system defaults. Must be less than or equal to model limit.`}) 
    MaxSizeBytes?: number;
        
    @Field(() => Int, {nullable: true, description: `Agent-specific maximum count per message. Overrides model and system defaults. Must be less than or equal to model limit.`}) 
    MaxCountPerMessage?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field() 
    @MaxLength(50)
    Modality: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Modalities
//****************************************************************************
@InputType()
export class CreateMJAIAgentModalityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => Boolean, { nullable: true })
    IsAllowed?: boolean;

    @Field(() => Int, { nullable: true })
    MaxSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    MaxCountPerMessage: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Modalities
//****************************************************************************
@InputType()
export class UpdateMJAIAgentModalityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => Boolean, { nullable: true })
    IsAllowed?: boolean;

    @Field(() => Int, { nullable: true })
    MaxSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    MaxCountPerMessage?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Modalities
//****************************************************************************
@ObjectType()
export class RunMJAIAgentModalityViewResult {
    @Field(() => [MJAIAgentModality_])
    Results: MJAIAgentModality_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentModality_)
export class MJAIAgentModalityResolver extends ResolverBase {
    @Query(() => RunMJAIAgentModalityViewResult)
    async RunMJAIAgentModalityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModalityViewResult)
    async RunMJAIAgentModalityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModalityViewResult)
    async RunMJAIAgentModalityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Modalities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentModality_, { nullable: true })
    async MJAIAgentModality(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentModality_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentModalities')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Modalities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentModality_)
    async CreateMJAIAgentModality(
        @Arg('input', () => CreateMJAIAgentModalityInput) input: CreateMJAIAgentModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Modalities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentModality_)
    async UpdateMJAIAgentModality(
        @Arg('input', () => UpdateMJAIAgentModalityInput) input: UpdateMJAIAgentModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Modalities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentModality_)
    async DeleteMJAIAgentModality(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Modalities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Models
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and AI models.` })
export class MJAIAgentModel_ {
    @Field({description: `The unique identifier for each AI agent-model mapping. Serves as the primary key.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from AIAgent table.`}) 
    @MaxLength(36)
    AgentID?: string;
        
    @Field({nullable: true, description: `The unique identifier of the associated AI model.`}) 
    @MaxLength(36)
    ModelID?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether this specific agent-model combination is currently enabled for use in AI operations.`}) 
    Active?: boolean;
        
    @Field(() => Int, {nullable: true, description: `The priority level of the AI model for the agent, where higher values indicate higher priority.`}) 
    Priority?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Model?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Models
//****************************************************************************
@InputType()
export class CreateMJAIAgentModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    Active: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Models
//****************************************************************************
@InputType()
export class UpdateMJAIAgentModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Models
//****************************************************************************
@ObjectType()
export class RunMJAIAgentModelViewResult {
    @Field(() => [MJAIAgentModel_])
    Results: MJAIAgentModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentModel_)
export class MJAIAgentModelResolver extends ResolverBase {
    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentModel_, { nullable: true })
    async MJAIAgentModel(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentModel_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentModels')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Models', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentModel_)
    async CreateMJAIAgentModel(
        @Arg('input', () => CreateMJAIAgentModelInput) input: CreateMJAIAgentModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentModel_)
    async UpdateMJAIAgentModel(
        @Arg('input', () => UpdateMJAIAgentModelInput) input: UpdateMJAIAgentModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentModel_)
    async DeleteMJAIAgentModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Note Types
//****************************************************************************
@ObjectType({ description: `Defines categories and types for AI agent notes, enabling classification and organization of agent-generated observations, recommendations, and learnings.` })
export class MJAIAgentNoteType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {description: `Priority for injection ordering. Lower numbers are injected first (0 is highest priority).`}) 
    Priority: number;
        
    @Field({description: `Status of the note type: Pending (awaiting approval), Active (available for use), or Revoked (deprecated).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_AgentNoteTypeIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Note Types
//****************************************************************************
@InputType()
export class CreateMJAIAgentNoteTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Note Types
//****************************************************************************
@InputType()
export class UpdateMJAIAgentNoteTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Note Types
//****************************************************************************
@ObjectType()
export class RunMJAIAgentNoteTypeViewResult {
    @Field(() => [MJAIAgentNoteType_])
    Results: MJAIAgentNoteType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentNoteType_)
export class MJAIAgentNoteTypeResolver extends ResolverBase {
    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Note Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentNoteType_, { nullable: true })
    async MJAIAgentNoteType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentNoteType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Note Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNoteTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Note Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Note Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_AgentNoteTypeIDArray(@Root() mjaiagentnotetype_: MJAIAgentNoteType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('AgentNoteTypeID')}='${mjaiagentnotetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentNoteType_)
    async CreateMJAIAgentNoteType(
        @Arg('input', () => CreateMJAIAgentNoteTypeInput) input: CreateMJAIAgentNoteTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Note Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentNoteType_)
    async UpdateMJAIAgentNoteType(
        @Arg('input', () => UpdateMJAIAgentNoteTypeInput) input: UpdateMJAIAgentNoteTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Note Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentNoteType_)
    async DeleteMJAIAgentNoteType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Note Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Notes
//****************************************************************************
@ObjectType({ description: `Stores notes, observations, and learnings for AI agents with multi-dimensional scoping (Agent, User, company). Scoping is determined by which FK fields are populated: all NULL = global, AgentID only = agent-specific, UserID only = user-specific across all agents, etc.` })
export class MJAIAgentNote_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    AgentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    AgentNoteTypeID?: string;
        
    @Field({nullable: true, description: `The content of the note, observation, or learning captured by the AI agent during its execution.`}) 
    Note?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Foreign key referencing the ID column in the User table, indicating the user associated with the note. Used when Type=User`}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field({description: `Quick categorization of the note content: Preference (user preferences), Constraint (hard rules/requirements), Context (background information), Example (sample interactions), or Issue (known problems/limitations). Complements the more detailed AIAgentNoteType categorization.`}) 
    @MaxLength(20)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates whether this note was automatically generated by an AI agent (1) or manually created (0).`}) 
    IsAutoGenerated: boolean;
        
    @Field({nullable: true, description: `Internal comments about this note, not included in agent context injection.`}) 
    Comments?: string;
        
    @Field({description: `Status of the note: Pending (awaiting review), Active (in use), or Revoked (disabled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Optional reference to the conversation that inspired or generated this note.`}) 
    @MaxLength(36)
    SourceConversationID?: string;
        
    @Field({nullable: true, description: `Optional reference to the specific conversation message that inspired this note.`}) 
    @MaxLength(36)
    SourceConversationDetailID?: string;
        
    @Field({nullable: true, description: `Optional reference to the AI agent run that generated this note.`}) 
    @MaxLength(36)
    SourceAIAgentRunID?: string;
        
    @Field({nullable: true, description: `Optional company scope for this note. When populated with UserID, creates org+user specific notes.`}) 
    @MaxLength(36)
    CompanyID?: string;
        
    @Field({nullable: true, description: `JSON array of embedding vector for semantic search on Note field. Auto-generated when Note changes.`}) 
    EmbeddingVector?: string;
        
    @Field({nullable: true, description: `Reference to the AI model used to generate the embedding vector.`}) 
    @MaxLength(36)
    EmbeddingModelID?: string;
        
    @Field({nullable: true, description: `Foreign key to Entity table identifying which entity type is used for primary scoping. NULL means this is a global note.`}) 
    @MaxLength(36)
    PrimaryScopeEntityID?: string;
        
    @Field({nullable: true, description: `The record ID within the primary scope entity. NULL means global note. When set with empty SecondaryScopes, indicates primary-scope-only note.`}) 
    @MaxLength(100)
    PrimaryScopeRecordID?: string;
        
    @Field({nullable: true, description: `JSON object containing additional scope dimensions. Empty/NULL with PrimaryScopeRecordID set = org-level note. Populated = fully-scoped note.`}) 
    SecondaryScopes?: string;
        
    @Field({nullable: true, description: `Timestamp of when this note was last accessed/injected into agent context. Used for lifecycle management and cleanup.`}) 
    LastAccessedAt?: Date;
        
    @Field(() => Int, {description: `Number of times this note has been accessed/injected into agent context. Used for analytics and determining note value.`}) 
    AccessCount: number;
        
    @Field({nullable: true, description: `Optional expiration timestamp. Notes past this date are candidates for archival. NULL means no expiration.`}) 
    ExpiresAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    AgentNoteType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SourceConversation?: string;
        
    @Field({nullable: true}) 
    SourceConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SourceAIAgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Company?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    EmbeddingModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    PrimaryScopeEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Notes
//****************************************************************************
@InputType()
export class CreateMJAIAgentNoteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID: string | null;

    @Field({ nullable: true })
    Note: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsAutoGenerated?: boolean;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SourceConversationID: string | null;

    @Field({ nullable: true })
    SourceConversationDetailID: string | null;

    @Field({ nullable: true })
    SourceAIAgentRunID: string | null;

    @Field({ nullable: true })
    CompanyID: string | null;

    @Field({ nullable: true })
    EmbeddingVector: string | null;

    @Field({ nullable: true })
    EmbeddingModelID: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID: string | null;

    @Field({ nullable: true })
    SecondaryScopes: string | null;

    @Field({ nullable: true })
    LastAccessedAt: Date | null;

    @Field(() => Int, { nullable: true })
    AccessCount?: number;

    @Field({ nullable: true })
    ExpiresAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Notes
//****************************************************************************
@InputType()
export class UpdateMJAIAgentNoteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID?: string | null;

    @Field({ nullable: true })
    Note?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsAutoGenerated?: boolean;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SourceConversationID?: string | null;

    @Field({ nullable: true })
    SourceConversationDetailID?: string | null;

    @Field({ nullable: true })
    SourceAIAgentRunID?: string | null;

    @Field({ nullable: true })
    CompanyID?: string | null;

    @Field({ nullable: true })
    EmbeddingVector?: string | null;

    @Field({ nullable: true })
    EmbeddingModelID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID?: string | null;

    @Field({ nullable: true })
    SecondaryScopes?: string | null;

    @Field({ nullable: true })
    LastAccessedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    AccessCount?: number;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Notes
//****************************************************************************
@ObjectType()
export class RunMJAIAgentNoteViewResult {
    @Field(() => [MJAIAgentNote_])
    Results: MJAIAgentNote_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentNote_)
export class MJAIAgentNoteResolver extends ResolverBase {
    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Notes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentNote_, { nullable: true })
    async MJAIAgentNote(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentNote_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Notes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentNote_)
    async CreateMJAIAgentNote(
        @Arg('input', () => CreateMJAIAgentNoteInput) input: CreateMJAIAgentNoteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Notes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentNote_)
    async UpdateMJAIAgentNote(
        @Arg('input', () => UpdateMJAIAgentNoteInput) input: UpdateMJAIAgentNoteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Notes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentNote_)
    async DeleteMJAIAgentNote(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Notes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Permissions
//****************************************************************************
@ObjectType({ description: `Defines access control permissions for AI agents using an ACL (Access Control List) model. Permissions can be granted to individual users or roles.` })
export class MJAIAgentPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    AgentID: string;
        
    @Field({nullable: true, description: `The role this permission is granted to. Either RoleID or UserID must be specified, but not both.`}) 
    @MaxLength(36)
    RoleID?: string;
        
    @Field({nullable: true, description: `The user this permission is granted to. Either RoleID or UserID must be specified, but not both.`}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field(() => Boolean, {description: `Grants permission to view the agent configuration and details.`}) 
    CanView: boolean;
        
    @Field(() => Boolean, {description: `Grants permission to execute/run the agent. Typically implies CanView as well.`}) 
    CanRun: boolean;
        
    @Field(() => Boolean, {description: `Grants permission to modify the agent configuration, prompts, and settings. Typically implies CanView and CanRun as well.`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Grants permission to delete the agent. Typically implies all other permissions as well.`}) 
    CanDelete: boolean;
        
    @Field({nullable: true, description: `Optional comments explaining why this permission was granted or any special notes.`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Role?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Permissions
//****************************************************************************
@InputType()
export class CreateMJAIAgentPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field(() => Boolean, { nullable: true })
    CanView?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRun?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Permissions
//****************************************************************************
@InputType()
export class UpdateMJAIAgentPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field(() => Boolean, { nullable: true })
    CanView?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRun?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Permissions
//****************************************************************************
@ObjectType()
export class RunMJAIAgentPermissionViewResult {
    @Field(() => [MJAIAgentPermission_])
    Results: MJAIAgentPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentPermission_)
export class MJAIAgentPermissionResolver extends ResolverBase {
    @Query(() => RunMJAIAgentPermissionViewResult)
    async RunMJAIAgentPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentPermissionViewResult)
    async RunMJAIAgentPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentPermissionViewResult)
    async RunMJAIAgentPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentPermission_, { nullable: true })
    async MJAIAgentPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentPermission_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentPermission_)
    async CreateMJAIAgentPermission(
        @Arg('input', () => CreateMJAIAgentPermissionInput) input: CreateMJAIAgentPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentPermission_)
    async UpdateMJAIAgentPermission(
        @Arg('input', () => UpdateMJAIAgentPermissionInput) input: UpdateMJAIAgentPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentPermission_)
    async DeleteMJAIAgentPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Prompts
//****************************************************************************
@ObjectType({ description: `Links AI agents with the prompts they use, including execution order and context handling.` })
export class MJAIAgentPrompt_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `References the agent this prompt is associated with.`}) 
    @MaxLength(36)
    AgentID: string;
        
    @Field({description: `References the prompt to be used by the agent.`}) 
    @MaxLength(36)
    PromptID: string;
        
    @Field({nullable: true, description: `The functional purpose of this prompt within the agent, such as "Initialize", "ProcessData", or "Summarize".`}) 
    Purpose?: string;
        
    @Field(() => Int, {description: `The sequence order in which this prompt should be executed within the agent's workflow.`}) 
    ExecutionOrder: number;
        
    @Field({nullable: true, description: `Optional reference to a specific configuration to use for this prompt. If NULL, uses the default configuration.`}) 
    @MaxLength(36)
    ConfigurationID?: string;
        
    @Field({description: `The current status of this agent-prompt mapping. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({description: `Determines how conversation context is filtered for this prompt: Complete, Smart, None, RecentMessages, InitialMessages, or Custom.`}) 
    @MaxLength(50)
    ContextBehavior: string;
        
    @Field(() => Int, {nullable: true, description: `The number of messages to include when ContextBehavior is set to RecentMessages or InitialMessages.`}) 
    ContextMessageCount?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field() 
    @MaxLength(255)
    Prompt: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Configuration?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Prompts
//****************************************************************************
@InputType()
export class CreateMJAIAgentPromptInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    Purpose: string | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ContextBehavior?: string;

    @Field(() => Int, { nullable: true })
    ContextMessageCount: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Prompts
//****************************************************************************
@InputType()
export class UpdateMJAIAgentPromptInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    Purpose?: string | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ContextBehavior?: string;

    @Field(() => Int, { nullable: true })
    ContextMessageCount?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Prompts
//****************************************************************************
@ObjectType()
export class RunMJAIAgentPromptViewResult {
    @Field(() => [MJAIAgentPrompt_])
    Results: MJAIAgentPrompt_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentPrompt_)
export class MJAIAgentPromptResolver extends ResolverBase {
    @Query(() => RunMJAIAgentPromptViewResult)
    async RunMJAIAgentPromptViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentPromptViewResult)
    async RunMJAIAgentPromptViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentPromptViewResult)
    async RunMJAIAgentPromptDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Prompts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentPrompt_, { nullable: true })
    async MJAIAgentPrompt(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentPrompt_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentPrompts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentPrompt_)
    async CreateMJAIAgentPrompt(
        @Arg('input', () => CreateMJAIAgentPromptInput) input: CreateMJAIAgentPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Prompts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentPrompt_)
    async UpdateMJAIAgentPrompt(
        @Arg('input', () => UpdateMJAIAgentPromptInput) input: UpdateMJAIAgentPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Prompts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentPrompt_)
    async DeleteMJAIAgentPrompt(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Prompts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Relationships
//****************************************************************************
@ObjectType({ description: `Tracks relationships between AI agents for sub-agent orchestration` })
export class MJAIAgentRelationship_ {
    @Field({description: `Primary key for AI agent relationships`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign key to parent AIAgent that can invoke the sub-agent`}) 
    @MaxLength(36)
    AgentID: string;
        
    @Field({description: `Foreign key to sub-agent AIAgent that can be invoked`}) 
    @MaxLength(36)
    SubAgentID: string;
        
    @Field({description: `Status of the relationship: Pending (awaiting approval), Active (can invoke), or Revoked (no longer allowed)`}) 
    @MaxLength(50)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON configuration mapping sub-agent result payload paths to parent agent payload paths. Enables controlled merging of sub-agent results. Format: {"subAgentPath": "parentPath", "*": "captureAllPath"}. If null, sub-agent results are not automatically merged into parent payload.`}) 
    SubAgentOutputMapping?: string;
        
    @Field({nullable: true, description: `JSON mapping of parent payload paths to sub-agent initial payload paths. Enables structural data transfer from parent to related sub-agent. Format: {"parentPath": "subAgentPath", "parent.nested": "subAgent.field"}. Example: {"searchQuery": "query", "maxResults": "limit"}. If null, sub-agent starts with empty payload (default behavior).`}) 
    SubAgentInputMapping?: string;
        
    @Field({nullable: true, description: `JSON array of parent payload paths to send as LLM context to related sub-agent. Sub-agent receives this data in a formatted context message before its task message. Format: ["path1", "path2.nested", "path3.*", "*"]. Use "*" to send entire parent payload. Example: ["userPreferences", "priorFindings.summary", "sources[*]"]. If null, no parent context is sent (default behavior).`}) 
    SubAgentContextPaths?: string;
        
    @Field({description: `Specifies how conversation messages are passed from parent agent to related sub-agent. Valid values: 'None' (fresh start - only context and task message, default), 'All' (all parent conversation history), 'Latest' (most recent MaxMessages messages), 'Bookend' (first 2 messages + most recent MaxMessages-2 messages with indicator between). Stored on relationship because related sub-agents can have multiple parents with different message passing needs.`}) 
    @MaxLength(50)
    MessageMode: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of conversation messages to include when MessageMode is 'Latest' or 'Bookend'. NULL means no limit (ignored for 'None' and 'All' modes). Must be greater than 0 if specified. For 'Latest': keeps most recent N messages. For 'Bookend': keeps first 2 + most recent (N-2) messages.`}) 
    MaxMessages?: number;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SubAgent?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Relationships
//****************************************************************************
@InputType()
export class CreateMJAIAgentRelationshipInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    SubAgentID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SubAgentOutputMapping: string | null;

    @Field({ nullable: true })
    SubAgentInputMapping: string | null;

    @Field({ nullable: true })
    SubAgentContextPaths: string | null;

    @Field({ nullable: true })
    MessageMode?: string;

    @Field(() => Int, { nullable: true })
    MaxMessages: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Relationships
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRelationshipInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    SubAgentID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SubAgentOutputMapping?: string | null;

    @Field({ nullable: true })
    SubAgentInputMapping?: string | null;

    @Field({ nullable: true })
    SubAgentContextPaths?: string | null;

    @Field({ nullable: true })
    MessageMode?: string;

    @Field(() => Int, { nullable: true })
    MaxMessages?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Relationships
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRelationshipViewResult {
    @Field(() => [MJAIAgentRelationship_])
    Results: MJAIAgentRelationship_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRelationship_)
export class MJAIAgentRelationshipResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRelationshipViewResult)
    async RunMJAIAgentRelationshipViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRelationshipViewResult)
    async RunMJAIAgentRelationshipViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRelationshipViewResult)
    async RunMJAIAgentRelationshipDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Relationships';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRelationship_, { nullable: true })
    async MJAIAgentRelationship(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRelationship_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRelationships')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentRelationship_)
    async CreateMJAIAgentRelationship(
        @Arg('input', () => CreateMJAIAgentRelationshipInput) input: CreateMJAIAgentRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Relationships', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRelationship_)
    async UpdateMJAIAgentRelationship(
        @Arg('input', () => UpdateMJAIAgentRelationshipInput) input: UpdateMJAIAgentRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Relationships', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRelationship_)
    async DeleteMJAIAgentRelationship(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Relationships', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Requests
//****************************************************************************
@ObjectType({ description: `Table to log AI Agent requests, responses, and their statuses.` })
export class MJAIAgentRequest_ {
    @Field({description: `Primary key for the AIAgentRequest table, uniquely identifies each record.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign key referencing the ID column in the AIAgent table.`}) 
    @MaxLength(36)
    AgentID: string;
        
    @Field({description: `Timestamp when the request was made by the agent.`}) 
    RequestedAt: Date;
        
    @Field({nullable: true, description: `Optional, a user that the AI specifically is directing the request to, if null intended for general system owner.`}) 
    @MaxLength(36)
    RequestForUserID?: string;
        
    @Field({description: `Current status of the request (Requested, Approved, Rejected, Canceled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({description: `Details of what the AI Agent is requesting.`}) 
    Request: string;
        
    @Field({nullable: true, description: `Response provided by the human to the agent request.`}) 
    Response?: string;
        
    @Field({nullable: true, description: `Populated when a user responds indicating which user responded to the request.`}) 
    @MaxLength(36)
    ResponseByUserID?: string;
        
    @Field({nullable: true, description: `Timestamp when the response was provided by the human.`}) 
    RespondedAt?: Date;
        
    @Field({nullable: true, description: `Additional comments about the request. Not shared with the agent, purely record keeping.`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    RequestForUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ResponseByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Requests
//****************************************************************************
@InputType()
export class CreateMJAIAgentRequestInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response: string | null;

    @Field({ nullable: true })
    ResponseByUserID: string | null;

    @Field({ nullable: true })
    RespondedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Requests
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRequestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response?: string | null;

    @Field({ nullable: true })
    ResponseByUserID?: string | null;

    @Field({ nullable: true })
    RespondedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Requests
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRequestViewResult {
    @Field(() => [MJAIAgentRequest_])
    Results: MJAIAgentRequest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRequest_)
export class MJAIAgentRequestResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Requests';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRequest_, { nullable: true })
    async MJAIAgentRequest(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRequest_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRequests')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Requests', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentRequest_)
    async CreateMJAIAgentRequest(
        @Arg('input', () => CreateMJAIAgentRequestInput) input: CreateMJAIAgentRequestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Requests', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRequest_)
    async UpdateMJAIAgentRequest(
        @Arg('input', () => UpdateMJAIAgentRequestInput) input: UpdateMJAIAgentRequestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Requests', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRequest_)
    async DeleteMJAIAgentRequest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Requests', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Run Medias
//****************************************************************************
@ObjectType()
export class MJAIAgentRunMedia_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    AgentRunID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    SourcePromptRunMediaID?: string;
        
    @Field() 
    @MaxLength(36)
    ModalityID: string;
        
    @Field() 
    @MaxLength(100)
    MimeType: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    FileName?: string;
        
    @Field(() => Int, {nullable: true}) 
    FileSizeBytes?: number;
        
    @Field(() => Int, {nullable: true}) 
    Width?: number;
        
    @Field(() => Int, {nullable: true}) 
    Height?: number;
        
    @Field(() => Float, {nullable: true}) 
    DurationSeconds?: number;
        
    @Field({nullable: true}) 
    InlineData?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    FileID?: string;
        
    @Field({nullable: true}) 
    ThumbnailBase64?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Label?: string;
        
    @Field({nullable: true}) 
    Metadata?: string;
        
    @Field(() => Int) 
    DisplayOrder: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Agent notes describing what this media represents. Used for internal tracking and can be displayed in UI.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    AgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SourcePromptRunMedia?: string;
        
    @Field() 
    @MaxLength(50)
    Modality: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    File?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Medias
//****************************************************************************
@InputType()
export class CreateMJAIAgentRunMediaInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field({ nullable: true })
    SourcePromptRunMediaID: string | null;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    Width: number | null;

    @Field(() => Int, { nullable: true })
    Height: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    InlineData: string | null;

    @Field({ nullable: true })
    FileID: string | null;

    @Field({ nullable: true })
    ThumbnailBase64: string | null;

    @Field({ nullable: true })
    Label: string | null;

    @Field({ nullable: true })
    Metadata: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Medias
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRunMediaInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field({ nullable: true })
    SourcePromptRunMediaID?: string | null;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName?: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    Width?: number | null;

    @Field(() => Int, { nullable: true })
    Height?: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    InlineData?: string | null;

    @Field({ nullable: true })
    FileID?: string | null;

    @Field({ nullable: true })
    ThumbnailBase64?: string | null;

    @Field({ nullable: true })
    Label?: string | null;

    @Field({ nullable: true })
    Metadata?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Run Medias
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRunMediaViewResult {
    @Field(() => [MJAIAgentRunMedia_])
    Results: MJAIAgentRunMedia_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRunMedia_)
export class MJAIAgentRunMediaResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRunMediaViewResult)
    async RunMJAIAgentRunMediaViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunMediaViewResult)
    async RunMJAIAgentRunMediaViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunMediaViewResult)
    async RunMJAIAgentRunMediaDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Run Medias';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRunMedia_, { nullable: true })
    async MJAIAgentRunMedia(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRunMedia_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRunMedias')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentRunMedia_)
    async CreateMJAIAgentRunMedia(
        @Arg('input', () => CreateMJAIAgentRunMediaInput) input: CreateMJAIAgentRunMediaInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Run Medias', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRunMedia_)
    async UpdateMJAIAgentRunMedia(
        @Arg('input', () => UpdateMJAIAgentRunMediaInput) input: UpdateMJAIAgentRunMediaInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Run Medias', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRunMedia_)
    async DeleteMJAIAgentRunMedia(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Run Medias', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Run Steps
//****************************************************************************
@ObjectType({ description: `Provides basic, step-by-step tracking of agent execution. Each step represents a discrete action within an agent run, such as prompt execution, tool usage, decision making, or sub-agent coordination.` })
export class MJAIAgentRunStep_ {
    @Field({description: `Unique identifier for this execution step`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the parent AIAgentRun that contains this step`}) 
    @MaxLength(36)
    AgentRunID: string;
        
    @Field(() => Int, {description: `Sequential number of this step within the agent run, starting from 1`}) 
    StepNumber: number;
        
    @Field({description: `Type of execution step: Prompt, Actions, Sub-Agent, Decision, Chat, Validation`}) 
    @MaxLength(50)
    StepType: string;
        
    @Field({description: `Human-readable name of what this step accomplishes`}) 
    @MaxLength(255)
    StepName: string;
        
    @Field({nullable: true, description: `ID of the specific target being executed (AIPrompt.ID, AIAction.ID, AIAgent.ID, etc.). NULL for steps that don't target a specific entity.`}) 
    @MaxLength(36)
    TargetID?: string;
        
    @Field({description: `Current execution status of this step: Running, Completed, Failed, Cancelled`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({description: `Timestamp when this step began execution`}) 
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when this step completed. NULL while still running.`}) 
    CompletedAt?: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Whether this step completed successfully. NULL while running, TRUE/FALSE when completed.`}) 
    Success?: boolean;
        
    @Field({nullable: true, description: `Error message if this step failed. NULL for successful steps.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON serialization of input data passed to this step for execution`}) 
    InputData?: string;
        
    @Field({nullable: true, description: `JSON serialization of the output data produced by this step`}) 
    OutputData?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `ID of the execution log/run record created for this step (ActionExecutionLog.ID for action steps, AIAgentRun.ID for subagent steps, AIPromptRun.ID for prompt steps)`}) 
    @MaxLength(36)
    TargetLogID?: string;
        
    @Field({nullable: true, description: `JSON serialization of the Payload state at the start of this step`}) 
    PayloadAtStart?: string;
        
    @Field({nullable: true, description: `JSON serialization of the Payload state at the end of this step`}) 
    PayloadAtEnd?: string;
        
    @Field({nullable: true, description: `Result of the final payload validation for this step. Pass indicates successful
validation, Retry means validation failed but will retry, Fail means validation failed
permanently, Warn means validation failed but execution continues.`}) 
    @MaxLength(25)
    FinalPayloadValidationResult?: string;
        
    @Field({nullable: true, description: `Validation error messages or warnings from final payload validation. Contains
detailed information about what validation rules failed.`}) 
    FinalPayloadValidationMessages?: string;
        
    @Field({nullable: true, description: `Optional reference to parent step for tracking hierarchical relationships like code->test->fix->code cycles`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this agent run step`}) 
    Comments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    AgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJAIAgentRunStep_])
    MJAIAgentRunSteps_ParentIDArray: MJAIAgentRunStep_[]; // Link to MJAIAgentRunSteps
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Steps
//****************************************************************************
@InputType()
export class CreateMJAIAgentRunStepInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field(() => Int, { nullable: true })
    StepNumber?: number;

    @Field({ nullable: true })
    StepType?: string;

    @Field({ nullable: true })
    StepName?: string;

    @Field({ nullable: true })
    TargetID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success: boolean | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    InputData: string | null;

    @Field({ nullable: true })
    OutputData: string | null;

    @Field({ nullable: true })
    TargetLogID: string | null;

    @Field({ nullable: true })
    PayloadAtStart: string | null;

    @Field({ nullable: true })
    PayloadAtEnd: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationResult: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMessages: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Steps
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRunStepInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field(() => Int, { nullable: true })
    StepNumber?: number;

    @Field({ nullable: true })
    StepType?: string;

    @Field({ nullable: true })
    StepName?: string;

    @Field({ nullable: true })
    TargetID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    InputData?: string | null;

    @Field({ nullable: true })
    OutputData?: string | null;

    @Field({ nullable: true })
    TargetLogID?: string | null;

    @Field({ nullable: true })
    PayloadAtStart?: string | null;

    @Field({ nullable: true })
    PayloadAtEnd?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationResult?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMessages?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Run Steps
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRunStepViewResult {
    @Field(() => [MJAIAgentRunStep_])
    Results: MJAIAgentRunStep_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRunStep_)
export class MJAIAgentRunStepResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRunStepViewResult)
    async RunMJAIAgentRunStepViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunStepViewResult)
    async RunMJAIAgentRunStepViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunStepViewResult)
    async RunMJAIAgentRunStepDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Run Steps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRunStep_, { nullable: true })
    async MJAIAgentRunStep(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRunStep_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRunSteps')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentRunStep_])
    async MJAIAgentRunSteps_ParentIDArray(@Root() mjaiagentrunstep_: MJAIAgentRunStep_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRunSteps')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjaiagentrunstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentRunStep_)
    async CreateMJAIAgentRunStep(
        @Arg('input', () => CreateMJAIAgentRunStepInput) input: CreateMJAIAgentRunStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Run Steps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRunStep_)
    async UpdateMJAIAgentRunStep(
        @Arg('input', () => UpdateMJAIAgentRunStepInput) input: UpdateMJAIAgentRunStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Run Steps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRunStep_)
    async DeleteMJAIAgentRunStep(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Run Steps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Runs
//****************************************************************************
@ObjectType({ description: `Tracks individual execution runs of AI agents, including hierarchical sub-agent runs. Provides basic logging, state persistence, and resource tracking for agent executions. Supports pause/resume functionality through state serialization.` })
export class MJAIAgentRun_ {
    @Field({description: `Unique identifier for this agent run`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the AIAgent that is being executed in this run`}) 
    @MaxLength(36)
    AgentID: string;
        
    @Field({nullable: true, description: `Reference to the parent agent run if this is a sub-agent execution. NULL for root-level agent runs. Enables hierarchical execution tracking.`}) 
    @MaxLength(36)
    ParentRunID?: string;
        
    @Field({description: `Current status of the agent run. Running -> Completed/Failed/Cancelled`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({description: `Timestamp when the agent run began execution`}) 
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the agent run completed (successfully or with failure). NULL while running.`}) 
    CompletedAt?: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether the agent run completed successfully. NULL while running, TRUE/FALSE when completed.`}) 
    Success?: boolean;
        
    @Field({nullable: true, description: `Error message if the agent run failed. NULL for successful runs.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `Identifier linking multiple agent runs that are part of the same conversation or user session`}) 
    @MaxLength(36)
    ConversationID?: string;
        
    @Field({nullable: true, description: `User context identifier for authentication and permissions during the agent run`}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field({nullable: true, description: `Final result or output from the agent execution, stored as JSON or text`}) 
    Result?: string;
        
    @Field({nullable: true, description: `JSON serialization of the complete agent state, including conversation context, variables, and execution state. Enables pause/resume functionality.`}) 
    AgentState?: string;
        
    @Field(() => Int, {nullable: true, description: `Total number of tokens consumed by all LLM calls during this agent run`}) 
    TotalTokensUsed?: number;
        
    @Field(() => Float, {nullable: true, description: `Total estimated cost for all AI model usage during this agent run`}) 
    TotalCost?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Total number of prompt/input tokens used across all AIPromptRun executions during this agent run. This provides a breakdown of the TotalTokensUsed field to help analyze the ratio of input vs output tokens consumed by the agent.`}) 
    TotalPromptTokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Total number of completion/output tokens generated across all AIPromptRun executions during this agent run. This provides a breakdown of the TotalTokensUsed field to help analyze the ratio of input vs output tokens consumed by the agent.`}) 
    TotalCompletionTokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Total tokens used including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalTokensUsed. For parent agents, this includes the sum of all descendant agent tokens. Calculated as TotalPromptTokensUsedRollup + TotalCompletionTokensUsedRollup.`}) 
    TotalTokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total prompt/input tokens including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalPromptTokensUsed. For parent agents, this includes the sum of all descendant agent prompt tokens.`}) 
    TotalPromptTokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total completion/output tokens including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalCompletionTokensUsed. For parent agents, this includes the sum of all descendant agent completion tokens.`}) 
    TotalCompletionTokensUsedRollup?: number;
        
    @Field(() => Float, {nullable: true, description: `Total cost including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalCost. For parent agents, this includes the sum of all descendant agent costs. Note: This assumes all costs are in the same currency for accurate rollup.`}) 
    TotalCostRollup?: number;
        
    @Field({nullable: true, description: `Optional tracking of a specific conversation detail (e.g. a specific message) that spawned this agent run`}) 
    @MaxLength(36)
    ConversationDetailID?: string;
        
    @Field(() => Int, {nullable: true, description: `If a conversation detail spawned multiple agent runs, tracks the order of their spawn/execution`}) 
    ConversationDetailSequence?: number;
        
    @Field({nullable: true, description: `Reason for cancellation if the agent run was cancelled`}) 
    @MaxLength(30)
    CancellationReason?: string;
        
    @Field({nullable: true, description: `The final step type that concluded the agent run`}) 
    @MaxLength(30)
    FinalStep?: string;
        
    @Field({nullable: true, description: `JSON serialization of the final Payload state at the end of the agent run`}) 
    FinalPayload?: string;
        
    @Field({nullable: true, description: `Final message from the agent to the end user at the end of a run`}) 
    Message?: string;
        
    @Field({nullable: true, description: `Links to the previous run in a chain. Different from ParentRunID which is for sub-agent hierarchy.`}) 
    @MaxLength(36)
    LastRunID?: string;
        
    @Field({nullable: true, description: `The initial payload provided at the start of this run. Can be populated from the FinalPayload of the LastRun.`}) 
    StartingPayload?: string;
        
    @Field(() => Int, {description: `Total number of prompt iterations executed during this agent run. Incremented
each time the agent processes a prompt step.`}) 
    TotalPromptIterations: number;
        
    @Field({nullable: true, description: `The AI Configuration used for this agent execution. When set, this configuration was used for all prompts executed by this agent and its sub-agents.`}) 
    @MaxLength(36)
    ConfigurationID?: string;
        
    @Field({nullable: true, description: `Runtime model override that was used for this execution. When set, this model took precedence over all other model selection methods.`}) 
    @MaxLength(36)
    OverrideModelID?: string;
        
    @Field({nullable: true, description: `Runtime vendor override that was used for this execution. When set along with OverrideModelID, this vendor was used to provide the model.`}) 
    @MaxLength(36)
    OverrideVendorID?: string;
        
    @Field({nullable: true, description: `JSON serialized data that was passed for template rendering and prompt execution. This data was passed to the agent's prompt as well as all sub-agents.`}) 
    Data?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether verbose logging was enabled during this agent execution. When true, detailed decision-making and execution flow was logged.`}) 
    Verbose?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Effort level that was actually used during this agent run execution (1-100, where 1=minimal effort, 100=maximum effort). This is the resolved effort level after applying the precedence hierarchy: runtime override > agent default > prompt defaults.`}) 
    EffortLevel?: number;
        
    @Field({nullable: true, description: `Optional name for the agent run to help identify and tag runs for easier reference`}) 
    @MaxLength(255)
    RunName?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this agent run`}) 
    Comments?: string;
        
    @Field({nullable: true, description: `Links to the scheduled job run that triggered this agent execution. NULL for manually-triggered agent runs. Enables tracking which scheduled jobs spawned which agent executions.`}) 
    @MaxLength(36)
    ScheduledJobRunID?: string;
        
    @Field({nullable: true, description: `Optional Foreign Key - Links this agent run to a test run if this execution was part of a test. Allows navigation from agent execution to test context.`}) 
    @MaxLength(36)
    TestRunID?: string;
        
    @Field({nullable: true, description: `Foreign key to Entity table identifying which entity type is used for primary scoping (e.g., Organizations, Tenants)`}) 
    @MaxLength(36)
    PrimaryScopeEntityID?: string;
        
    @Field({nullable: true, description: `The record ID within the primary scope entity (e.g., the specific OrganizationID). Indexed for fast multi-tenant filtering.`}) 
    @MaxLength(100)
    PrimaryScopeRecordID?: string;
        
    @Field({nullable: true, description: `JSON object containing additional scope dimensions beyond the primary scope. Example: {"ContactID":"abc-123","TeamID":"team-456"}`}) 
    SecondaryScopes?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ParentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
    @Field({nullable: true}) 
    ConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    LastRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    OverrideModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    OverrideVendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ScheduledJobRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    TestRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    PrimaryScopeEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootLastRunID?: string;
        
    @Field(() => [MJAIAgentRunStep_])
    MJAIAgentRunSteps_AgentRunIDArray: MJAIAgentRunStep_[]; // Link to MJAIAgentRunSteps
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_ParentRunIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
    @Field(() => [MJAIAgentExample_])
    MJAIAgentExamples_SourceAIAgentRunIDArray: MJAIAgentExample_[]; // Link to MJAIAgentExamples
    
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_SourceAIAgentRunIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
    @Field(() => [MJAIAgentRunMedia_])
    MJAIAgentRunMedias_AgentRunIDArray: MJAIAgentRunMedia_[]; // Link to MJAIAgentRunMedias
    
    @Field(() => [MJAIPromptRun_])
    MJAIPromptRuns_AgentRunIDArray: MJAIPromptRun_[]; // Link to MJAIPromptRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Runs
//****************************************************************************
@InputType()
export class CreateMJAIAgentRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ParentRunID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success: boolean | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ConversationID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    Result: string | null;

    @Field({ nullable: true })
    AgentState: string | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsed?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsedRollup: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostRollup: number | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field(() => Int, { nullable: true })
    ConversationDetailSequence: number | null;

    @Field({ nullable: true })
    CancellationReason: string | null;

    @Field({ nullable: true })
    FinalStep: string | null;

    @Field({ nullable: true })
    FinalPayload: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    LastRunID: string | null;

    @Field({ nullable: true })
    StartingPayload: string | null;

    @Field(() => Int, { nullable: true })
    TotalPromptIterations?: number;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    OverrideModelID: string | null;

    @Field({ nullable: true })
    OverrideVendorID: string | null;

    @Field({ nullable: true })
    Data: string | null;

    @Field(() => Boolean, { nullable: true })
    Verbose?: boolean | null;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;

    @Field({ nullable: true })
    RunName: string | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ScheduledJobRunID: string | null;

    @Field({ nullable: true })
    TestRunID: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID: string | null;

    @Field({ nullable: true })
    SecondaryScopes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Runs
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ParentRunID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ConversationID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    Result?: string | null;

    @Field({ nullable: true })
    AgentState?: string | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsed?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsedRollup?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostRollup?: number | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field(() => Int, { nullable: true })
    ConversationDetailSequence?: number | null;

    @Field({ nullable: true })
    CancellationReason?: string | null;

    @Field({ nullable: true })
    FinalStep?: string | null;

    @Field({ nullable: true })
    FinalPayload?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    LastRunID?: string | null;

    @Field({ nullable: true })
    StartingPayload?: string | null;

    @Field(() => Int, { nullable: true })
    TotalPromptIterations?: number;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    OverrideModelID?: string | null;

    @Field({ nullable: true })
    OverrideVendorID?: string | null;

    @Field({ nullable: true })
    Data?: string | null;

    @Field(() => Boolean, { nullable: true })
    Verbose?: boolean | null;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field({ nullable: true })
    RunName?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ScheduledJobRunID?: string | null;

    @Field({ nullable: true })
    TestRunID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID?: string | null;

    @Field({ nullable: true })
    SecondaryScopes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Runs
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRunViewResult {
    @Field(() => [MJAIAgentRun_])
    Results: MJAIAgentRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRun_)
export class MJAIAgentRunResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRunViewResult)
    async RunMJAIAgentRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunViewResult)
    async RunMJAIAgentRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunViewResult)
    async RunMJAIAgentRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRun_, { nullable: true })
    async MJAIAgentRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRun_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentRunStep_])
    async MJAIAgentRunSteps_AgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRunSteps')} WHERE ${provider.QuoteIdentifier('AgentRunID')}='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_ParentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('ParentRunID')}='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJAIAgentExamples_SourceAIAgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('SourceAIAgentRunID')}='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_SourceAIAgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('SourceAIAgentRunID')}='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRunMedia_])
    async MJAIAgentRunMedias_AgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRunMedias')} WHERE ${provider.QuoteIdentifier('AgentRunID')}='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJAIPromptRuns_AgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('AgentRunID')}='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentRun_)
    async CreateMJAIAgentRun(
        @Arg('input', () => CreateMJAIAgentRunInput) input: CreateMJAIAgentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRun_)
    async UpdateMJAIAgentRun(
        @Arg('input', () => UpdateMJAIAgentRunInput) input: UpdateMJAIAgentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRun_)
    async DeleteMJAIAgentRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Step Paths
//****************************************************************************
@ObjectType({ description: `Defines paths (edges) between steps in a flow-based AI agent execution graph` })
export class MJAIAgentStepPath_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    OriginStepID: string;
        
    @Field() 
    @MaxLength(36)
    DestinationStepID: string;
        
    @Field({nullable: true, description: `Boolean expression to evaluate. If null, path is always taken. Evaluated against payload and step results.`}) 
    Condition?: string;
        
    @Field(() => Int, {description: `Path evaluation priority. Higher values are evaluated first. Use 0 or negative values for default/fallback paths that execute when no other conditions match.`}) 
    Priority: number;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Description?: string;
        
    @Field({nullable: true}) 
    PathPoints?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    OriginStep: string;
        
    @Field() 
    @MaxLength(255)
    DestinationStep: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Step Paths
//****************************************************************************
@InputType()
export class CreateMJAIAgentStepPathInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    OriginStepID?: string;

    @Field({ nullable: true })
    DestinationStepID?: string;

    @Field({ nullable: true })
    Condition: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    PathPoints: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Step Paths
//****************************************************************************
@InputType()
export class UpdateMJAIAgentStepPathInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    OriginStepID?: string;

    @Field({ nullable: true })
    DestinationStepID?: string;

    @Field({ nullable: true })
    Condition?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    PathPoints?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Step Paths
//****************************************************************************
@ObjectType()
export class RunMJAIAgentStepPathViewResult {
    @Field(() => [MJAIAgentStepPath_])
    Results: MJAIAgentStepPath_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentStepPath_)
export class MJAIAgentStepPathResolver extends ResolverBase {
    @Query(() => RunMJAIAgentStepPathViewResult)
    async RunMJAIAgentStepPathViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentStepPathViewResult)
    async RunMJAIAgentStepPathViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentStepPathViewResult)
    async RunMJAIAgentStepPathDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Step Paths';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentStepPath_, { nullable: true })
    async MJAIAgentStepPath(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentStepPath_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentStepPaths')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentStepPath_)
    async CreateMJAIAgentStepPath(
        @Arg('input', () => CreateMJAIAgentStepPathInput) input: CreateMJAIAgentStepPathInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Step Paths', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentStepPath_)
    async UpdateMJAIAgentStepPath(
        @Arg('input', () => UpdateMJAIAgentStepPathInput) input: UpdateMJAIAgentStepPathInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Step Paths', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentStepPath_)
    async DeleteMJAIAgentStepPath(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Step Paths', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Steps
//****************************************************************************
@ObjectType({ description: `Defines individual steps (nodes) in a flow-based AI agent execution graph` })
export class MJAIAgentStep_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    AgentID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Type of step: Action (execute an action), Sub-Agent (delegate to another agent), or Prompt (run an AI prompt)`}) 
    @MaxLength(20)
    StepType: string;
        
    @Field(() => Boolean, {description: `If true, this step is executed when the agent starts`}) 
    StartingStep: boolean;
        
    @Field(() => Int, {nullable: true}) 
    TimeoutSeconds?: number;
        
    @Field(() => Int) 
    RetryCount: number;
        
    @Field() 
    @MaxLength(20)
    OnErrorBehavior: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ActionID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    SubAgentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    PromptID?: string;
        
    @Field({nullable: true, description: `JSON configuration for mapping action output parameters to payload paths. Example: {"outputParam1": "payload.customer.status", "*": "payload.lastResult"}`}) 
    ActionOutputMapping?: string;
        
    @Field(() => Int) 
    PositionX: number;
        
    @Field(() => Int) 
    PositionY: number;
        
    @Field(() => Int) 
    Width: number;
        
    @Field(() => Int) 
    Height: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Controls whether this step is executed. Active=normal execution, Pending=skip but may activate later, Disabled=never execute`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `JSON configuration for mapping static values or payload paths to action input parameters. Example: {"param1": "staticValue", "param2": "payload.dynamicValue"}`}) 
    ActionInputMapping?: string;
        
    @Field({nullable: true, description: `Specifies what type of operation executes in the loop body. Values: Action, Sub-Agent, Prompt. Only used when StepType is ForEach or While.`}) 
    @MaxLength(50)
    LoopBodyType?: string;
        
    @Field({nullable: true, description: `JSON configuration object for step-specific settings. For loop steps: { type: "ForEach"|"While", collectionPath?, itemVariable?, indexVariable?, maxIterations?, continueOnError?, condition? }. For other step types: reserved for future use.`}) 
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(425)
    Action?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SubAgent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Prompt?: string;
        
    @Field(() => [MJAIAgentStepPath_])
    MJAIAgentStepPaths_DestinationStepIDArray: MJAIAgentStepPath_[]; // Link to MJAIAgentStepPaths
    
    @Field(() => [MJAIAgentStepPath_])
    MJAIAgentStepPaths_OriginStepIDArray: MJAIAgentStepPath_[]; // Link to MJAIAgentStepPaths
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Steps
//****************************************************************************
@InputType()
export class CreateMJAIAgentStepInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    StepType?: string;

    @Field(() => Boolean, { nullable: true })
    StartingStep?: boolean;

    @Field(() => Int, { nullable: true })
    TimeoutSeconds?: number | null;

    @Field(() => Int, { nullable: true })
    RetryCount?: number;

    @Field({ nullable: true })
    OnErrorBehavior?: string;

    @Field({ nullable: true })
    ActionID: string | null;

    @Field({ nullable: true })
    SubAgentID: string | null;

    @Field({ nullable: true })
    PromptID: string | null;

    @Field({ nullable: true })
    ActionOutputMapping: string | null;

    @Field(() => Int, { nullable: true })
    PositionX?: number;

    @Field(() => Int, { nullable: true })
    PositionY?: number;

    @Field(() => Int, { nullable: true })
    Width?: number;

    @Field(() => Int, { nullable: true })
    Height?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActionInputMapping: string | null;

    @Field({ nullable: true })
    LoopBodyType: string | null;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Steps
//****************************************************************************
@InputType()
export class UpdateMJAIAgentStepInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    StepType?: string;

    @Field(() => Boolean, { nullable: true })
    StartingStep?: boolean;

    @Field(() => Int, { nullable: true })
    TimeoutSeconds?: number | null;

    @Field(() => Int, { nullable: true })
    RetryCount?: number;

    @Field({ nullable: true })
    OnErrorBehavior?: string;

    @Field({ nullable: true })
    ActionID?: string | null;

    @Field({ nullable: true })
    SubAgentID?: string | null;

    @Field({ nullable: true })
    PromptID?: string | null;

    @Field({ nullable: true })
    ActionOutputMapping?: string | null;

    @Field(() => Int, { nullable: true })
    PositionX?: number;

    @Field(() => Int, { nullable: true })
    PositionY?: number;

    @Field(() => Int, { nullable: true })
    Width?: number;

    @Field(() => Int, { nullable: true })
    Height?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActionInputMapping?: string | null;

    @Field({ nullable: true })
    LoopBodyType?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Steps
//****************************************************************************
@ObjectType()
export class RunMJAIAgentStepViewResult {
    @Field(() => [MJAIAgentStep_])
    Results: MJAIAgentStep_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentStep_)
export class MJAIAgentStepResolver extends ResolverBase {
    @Query(() => RunMJAIAgentStepViewResult)
    async RunMJAIAgentStepViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentStepViewResult)
    async RunMJAIAgentStepViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentStepViewResult)
    async RunMJAIAgentStepDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Steps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentStep_, { nullable: true })
    async MJAIAgentStep(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentStep_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentSteps')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Steps', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentStepPath_])
    async MJAIAgentStepPaths_DestinationStepIDArray(@Root() mjaiagentstep_: MJAIAgentStep_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentStepPaths')} WHERE ${provider.QuoteIdentifier('DestinationStepID')}='${mjaiagentstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStepPath_])
    async MJAIAgentStepPaths_OriginStepIDArray(@Root() mjaiagentstep_: MJAIAgentStep_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentStepPaths')} WHERE ${provider.QuoteIdentifier('OriginStepID')}='${mjaiagentstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentStep_)
    async CreateMJAIAgentStep(
        @Arg('input', () => CreateMJAIAgentStepInput) input: CreateMJAIAgentStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Steps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentStep_)
    async UpdateMJAIAgentStep(
        @Arg('input', () => UpdateMJAIAgentStepInput) input: UpdateMJAIAgentStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Steps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentStep_)
    async DeleteMJAIAgentStep(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Steps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Types
//****************************************************************************
@ObjectType({ description: `Defines types of AI agents with their system prompts and behavioral characteristics. Each agent type represents a category of agents that share common system-level instructions and capabilities.` })
export class MJAIAgentType_ {
    @Field({description: `Unique identifier for the agent type`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name of the agent type (e.g., "Base", "CustomerSupport", "DataAnalysis"). Used for programmatic identification and factory instantiation.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the agent type, its purpose, and typical use cases`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Reference to the AI Prompt that contains the system-level instructions for all agents of this type. This prompt will be blended with individual agent prompts.`}) 
    @MaxLength(36)
    SystemPromptID?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this agent type is available for use. Inactive types cannot be assigned to new agents.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The placeholder name used in the system prompt template where the agent prompt result should be injected. For example, if the system prompt contains "{{ agentPrompt }}", this field should contain "agentPrompt". This enables proper hierarchical prompt execution where the agent type's system prompt acts as the parent and the agent's specific prompt acts as the child.`}) 
    @MaxLength(255)
    AgentPromptPlaceholder?: string;
        
    @Field({nullable: true, description: `The class name used by the MemberJunction class factory to instantiate the specific agent type implementation. For example, "LoopAgentType" for a looping agent pattern. If not specified, defaults to using the agent type Name for the DriverClass lookup key.`}) 
    @MaxLength(255)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Optional Angular component key name for a subclass of BaseFormSectionComponent that provides a custom form section for this agent type. When specified, this component will be dynamically loaded and displayed as the first expandable section in the AI Agent form. This allows agent types to have specialized UI elements. The class must be registered with the MemberJunction class factory via @RegisterClass`}) 
    @MaxLength(500)
    UIFormSectionKey?: string;
        
    @Field({nullable: true, description: `Optional Angular component key name for a subclass of BaseFormComponent that will completely overrides the default AI Agent form for this agent type. When specified, this component will be used instead of the standard AI Agent form, allowing for completely custom form implementations. The class must be registered with the MemberJunction class factory via @RegisterClass. If both UIFormClass and UIFormSectionClass are specified, UIFormClass takes precedence.`}) 
    @MaxLength(500)
    UIFormKey?: string;
        
    @Field(() => Boolean, {description: `Determines whether the custom form section (specified by UIFormSectionClass) should be expanded by default when the AI Agent form loads. True means the section starts expanded, False means it starts collapsed. Only applies when UIFormSectionClass is specified. Defaults to 1 (expanded).`}) 
    UIFormSectionExpandedByDefault: boolean;
        
    @Field({nullable: true, description: `JSON Schema defining the available prompt parameters for this agent type. Includes property definitions with types, defaults, and descriptions. Used by agents of this type to customize which prompt sections are included in the system prompt. The schema follows JSON Schema draft-07 format.`}) 
    PromptParamsSchema?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SystemPrompt?: string;
        
    @Field(() => [MJAIAgent_])
    MJAIAgents_TypeIDArray: MJAIAgent_[]; // Link to MJAIAgents
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Types
//****************************************************************************
@InputType()
export class CreateMJAIAgentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SystemPromptID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    AgentPromptPlaceholder: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    UIFormSectionKey: string | null;

    @Field({ nullable: true })
    UIFormKey: string | null;

    @Field(() => Boolean, { nullable: true })
    UIFormSectionExpandedByDefault?: boolean;

    @Field({ nullable: true })
    PromptParamsSchema: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Types
//****************************************************************************
@InputType()
export class UpdateMJAIAgentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SystemPromptID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    AgentPromptPlaceholder?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    UIFormSectionKey?: string | null;

    @Field({ nullable: true })
    UIFormKey?: string | null;

    @Field(() => Boolean, { nullable: true })
    UIFormSectionExpandedByDefault?: boolean;

    @Field({ nullable: true })
    PromptParamsSchema?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Types
//****************************************************************************
@ObjectType()
export class RunMJAIAgentTypeViewResult {
    @Field(() => [MJAIAgentType_])
    Results: MJAIAgentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentType_)
export class MJAIAgentTypeResolver extends ResolverBase {
    @Query(() => RunMJAIAgentTypeViewResult)
    async RunMJAIAgentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentTypeViewResult)
    async RunMJAIAgentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentTypeViewResult)
    async RunMJAIAgentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentType_, { nullable: true })
    async MJAIAgentType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgent_])
    async MJAIAgents_TypeIDArray(@Root() mjaiagenttype_: MJAIAgentType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgents')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjaiagenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentType_)
    async CreateMJAIAgentType(
        @Arg('input', () => CreateMJAIAgentTypeInput) input: CreateMJAIAgentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentType_)
    async UpdateMJAIAgentType(
        @Arg('input', () => UpdateMJAIAgentTypeInput) input: UpdateMJAIAgentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentType_)
    async DeleteMJAIAgentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agents
//****************************************************************************
@ObjectType({ description: `Table to store information about AI agents.` })
export class MJAIAgent_ {
    @Field({description: `The unique identifier for each AI agent. Serves as the primary key.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true, description: `The name of the AI agent.`}) 
    @MaxLength(255)
    Name?: string;
        
    @Field({nullable: true, description: `A detailed description of the AI agent.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `URL to an image file or base64 data URI (e.g., data:image/png;base64,...) for the agent logo. Takes precedence over IconClass in UI display.`}) 
    @MaxLength(255)
    LogoURL?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `References the parent agent in the hierarchical structure. If NULL, this is a root (top-level) agent.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field(() => Boolean, {description: `When true, this agent can be exposed as an action for use by other agents. Only valid for root agents.`}) 
    ExposeAsAction: boolean;
        
    @Field(() => Int, {description: `The order in which this agent should be executed among its siblings under the same parent.`}) 
    ExecutionOrder: number;
        
    @Field({description: `Controls how this agent's child agents are executed. Sequential runs children in order, Parallel runs them simultaneously.`}) 
    @MaxLength(20)
    ExecutionMode: string;
        
    @Field(() => Boolean, {description: `When true, enables automatic compression of conversation context when the message threshold is reached.`}) 
    EnableContextCompression: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of messages that triggers context compression when EnableContextCompression is true.`}) 
    ContextCompressionMessageThreshold?: number;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ContextCompressionPromptID?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of recent messages to keep uncompressed when context compression is applied.`}) 
    ContextCompressionMessageRetentionCount?: number;
        
    @Field({nullable: true, description: `Reference to the AIAgentType that defines the category and system-level behavior for this agent. Cannot be null.`}) 
    @MaxLength(36)
    TypeID?: string;
        
    @Field({description: `Current status of the AI agent. Active agents can be executed, Disabled agents are inactive, and Pending agents are awaiting configuration or approval. Allowed values: Active, Disabled, Pending.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Optional override for the class name used by the MemberJunction class factory to instantiate this specific agent. If specified, this overrides the agent type's DriverClass. Useful for specialized agent implementations.`}) 
    @MaxLength(255)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class (e.g., fa-robot, fa-brain) for the agent. Used as fallback when LogoURL is not set or fails to load.`}) 
    @MaxLength(100)
    IconClass?: string;
        
    @Field({description: `Controls whether model selection is driven by the Agent Type's system prompt or the Agent's specific prompt. Default is Agent Type for backward compatibility.`}) 
    @MaxLength(50)
    ModelSelectionMode: string;
        
    @Field({description: `JSON array of paths that define which parts of the payload should be sent downstream to sub-agents. Use ["*"] to send entire payload, or specify paths like ["customer.id", "campaign.*", "analysis.sentiment"]`}) 
    PayloadDownstreamPaths: string;
        
    @Field({description: `JSON array of paths that define which parts of the payload sub-agents are allowed to write back upstream. Use ["*"] to allow all writes, or specify paths like ["analysis.results", "recommendations.*"]`}) 
    PayloadUpstreamPaths: string;
        
    @Field({nullable: true, description: `JSON array of paths that specify what parts of the payload the agent's own prompt can read. Controls downstream data 
flow when the agent executes its own prompt step.`}) 
    PayloadSelfReadPaths?: string;
        
    @Field({nullable: true, description: `JSON array of paths that specify what parts of the payload the agent's own prompt can write back. Controls upstream 
data flow when the agent executes its own prompt step.`}) 
    PayloadSelfWritePaths?: string;
        
    @Field({nullable: true, description: `Defines the scope/path within the parent payload that this sub-agent operates on. When set, the sub-agent receives only this portion of the payload and all change requests are relative to this scope. Format: /path/to/scope (e.g. /PropA/SubProp1)`}) 
    PayloadScope?: string;
        
    @Field({nullable: true, description: `Optional JSON schema or requirements that define the expected structure and content of the agent's final payload. Used to validate the output when the agent declares success. Similar to OutputExample in AI Prompts.`}) 
    FinalPayloadValidation?: string;
        
    @Field({description: `Determines how to handle validation failures when FinalPayloadValidation is specified. Options: Retry (default) - retry the agent with validation feedback, Fail - fail the agent run immediately, Warn - log a warning but allow success.`}) 
    @MaxLength(25)
    FinalPayloadValidationMode: string;
        
    @Field(() => Int, {description: `Maximum number of retry attempts allowed when FinalPayloadValidation fails with
Retry mode. After reaching this limit, the validation will fail permanently.`}) 
    FinalPayloadValidationMaxRetries: number;
        
    @Field(() => Float, {nullable: true, description: `Maximum cost in dollars allowed for a single agent run. Run will be terminated
if this limit is exceeded.`}) 
    MaxCostPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum total tokens (input + output) allowed for a single agent run. Run will
be terminated if this limit is exceeded.`}) 
    MaxTokensPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of prompt iterations allowed for a single agent run. Run will be
terminated if this limit is exceeded.`}) 
    MaxIterationsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum time in seconds allowed for a single agent run. Run will be terminated
if this limit is exceeded.`}) 
    MaxTimePerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `When acting as a sub-agent, minimum number of times this agent must be executed per parent agent run`}) 
    MinExecutionsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `When acting as a sub-agent, maximum number of times this agent can be executed per parent agent run`}) 
    MaxExecutionsPerRun?: number;
        
    @Field({nullable: true, description: `Optional JSON schema validation to apply to the input payload before agent execution begins. Uses the same JSONValidator format as FinalPayloadValidation.`}) 
    StartingPayloadValidation?: string;
        
    @Field({description: `Determines how to handle StartingPayloadValidation failures. Fail = reject invalid input, Warn = log warning but proceed.`}) 
    @MaxLength(25)
    StartingPayloadValidationMode: string;
        
    @Field(() => Int, {nullable: true, description: `Default effort level for all prompts executed by this agent (1-100, where 1=minimal effort, 100=maximum effort). Takes precedence over individual prompt EffortLevel settings but can be overridden by runtime parameters. Inherited by sub-agents unless explicitly overridden.`}) 
    DefaultPromptEffortLevel?: number;
        
    @Field({nullable: true, description: `Controls how Chat next steps are handled. When null (default), Chat propagates to caller. When set to Success, Failed, or Retry, Chat steps are remapped to that value and re-validated.`}) 
    @MaxLength(30)
    ChatHandlingOption?: string;
        
    @Field({nullable: true, description: `Default artifact type produced by this agent. This is the primary artifact type; additional artifact types can be linked via AIAgentArtifactType junction table. Can be NULL if agent does not produce artifacts by default.`}) 
    @MaxLength(36)
    DefaultArtifactTypeID?: string;
        
    @Field({description: `The user who owns and created this AI agent. Automatically set to the current user if not specified. Owner has full permissions (view, run, edit, delete) regardless of ACL entries.`}) 
    @MaxLength(36)
    OwnerUserID: string;
        
    @Field({description: `Controls how the agent can be invoked: Any (default - can be top-level or sub-agent), Top-Level (only callable as primary agent), Sub-Agent (only callable as sub-agent). Used to filter available agents in tools like Sage.`}) 
    @MaxLength(20)
    InvocationMode: string;
        
    @Field({description: `Controls how artifacts are created from this agent's payloads. "Always" creates visible artifacts, "Never" skips artifact creation, "System Only" creates hidden system artifacts.`}) 
    @MaxLength(20)
    ArtifactCreationMode: string;
        
    @Field({nullable: true, description: `Detailed markdown formatted requirements that explain the business goals of the agent without specific technical implementation details.`}) 
    FunctionalRequirements?: string;
        
    @Field({nullable: true, description: `Detailed markdown that explains the structure of the agent including agent architecture, actions, sub-agents, prompts, and payload structure.`}) 
    TechnicalDesign?: string;
        
    @Field(() => Boolean, {description: `When enabled, agent notes will be automatically injected into the agent context based on scoping rules.`}) 
    InjectNotes: boolean;
        
    @Field(() => Int, {description: `Maximum number of notes to inject into agent context per request.`}) 
    MaxNotesToInject: number;
        
    @Field({description: `Strategy for selecting which notes to inject: Relevant (semantic search), Recent (most recent first), or All (up to max limit).`}) 
    @MaxLength(20)
    NoteInjectionStrategy: string;
        
    @Field(() => Boolean, {description: `When enabled, agent examples will be automatically injected into the agent context based on scoping rules.`}) 
    InjectExamples: boolean;
        
    @Field(() => Int, {description: `Maximum number of examples to inject into agent context per request.`}) 
    MaxExamplesToInject: number;
        
    @Field({description: `Strategy for selecting which examples to inject: Semantic (vector similarity), Recent (most recent first), or Rated (highest success score first).`}) 
    @MaxLength(20)
    ExampleInjectionStrategy: string;
        
    @Field(() => Boolean, {description: `When true, agent is restricted to system/scheduled use only and hidden from user selection, Agent Manager, and MCP/A2A discovery.`}) 
    IsRestricted: boolean;
        
    @Field({description: `Specifies how conversation messages are passed from parent agent to this child sub-agent (when this agent is a child via ParentID). Valid values: 'None' (fresh start - only context and task message, default), 'All' (all parent conversation history), 'Latest' (most recent MaxMessages messages), 'Bookend' (first 2 messages + most recent MaxMessages-2 messages with indicator between). Stored on child agent because each child has only one parent relationship.`}) 
    @MaxLength(50)
    MessageMode: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of conversation messages to include when MessageMode is 'Latest' or 'Bookend'. NULL means no limit (ignored for 'None' and 'All' modes). Must be greater than 0 if specified. For 'Latest': keeps most recent N messages. For 'Bookend': keeps first 2 + most recent (N-2) messages.`}) 
    MaxMessages?: number;
        
    @Field({nullable: true, description: `File storage provider for large attachments. Overrides the default from AIConfiguration. NULL uses system default.`}) 
    @MaxLength(36)
    AttachmentStorageProviderID?: string;
        
    @Field({nullable: true, description: `Base path within the storage provider for this agent's attachments. Agent run ID and sequence number are appended to create unique paths. Format: /folder/subfolder`}) 
    @MaxLength(500)
    AttachmentRootPath?: string;
        
    @Field(() => Int, {nullable: true, description: `File size threshold for inline storage. Files <= this size are stored as base64 inline, larger files use MJStorage. NULL uses system default (1MB). Set to 0 to always use MJStorage.`}) 
    InlineStorageThresholdBytes?: number;
        
    @Field({nullable: true, description: `JSON object containing parameter values that customize how this agent's type-level system prompt is rendered. The schema is defined by the agent type's PromptParamsSchema field. Allows per-agent control over which prompt sections are included, enabling token savings by excluding unused documentation.`}) 
    AgentTypePromptParams?: string;
        
    @Field({nullable: true, description: `JSON configuration defining scope dimensions for multi-tenant deployments. Example: {"dimensions":[{"name":"OrganizationID","entityId":"...","isPrimary":true,"required":true},{"name":"ContactID","entityId":"...","isPrimary":false,"required":false}],"inheritanceMode":"cascading"}`}) 
    ScopeConfig?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain notes before archiving due to inactivity. Default 90. NULL means use system default.`}) 
    NoteRetentionDays?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain examples before archiving due to inactivity. Default 180. NULL means use system default.`}) 
    ExampleRetentionDays?: number;
        
    @Field(() => Boolean, {description: `Whether automatic archival of stale notes/examples is enabled for this agent. Default true.`}) 
    AutoArchiveEnabled: boolean;
        
    @Field({nullable: true, description: `JSON configuration for optional reranking of retrieved memory items. Schema: { enabled: boolean, rerankerModelId: string, retrievalMultiplier: number (default 3), minRelevanceThreshold: number (default 0.5), rerankPromptId?: string, contextFields?: string[], fallbackOnError: boolean (default true) }. When null or disabled, vector search results are used directly without reranking.`}) 
    RerankerConfiguration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ContextCompressionPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Type?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DefaultArtifactType?: string;
        
    @Field() 
    @MaxLength(100)
    OwnerUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    AttachmentStorageProvider?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJAIAgentModel_])
    MJAIAgentModels_AgentIDArray: MJAIAgentModel_[]; // Link to MJAIAgentModels
    
    @Field(() => [MJAIAgentAction_])
    MJAIAgentActions_AgentIDArray: MJAIAgentAction_[]; // Link to MJAIAgentActions
    
    @Field(() => [MJAIAgentLearningCycle_])
    MJAIAgentLearningCycles_AgentIDArray: MJAIAgentLearningCycle_[]; // Link to MJAIAgentLearningCycles
    
    @Field(() => [MJAIAgentRequest_])
    MJAIAgentRequests_AgentIDArray: MJAIAgentRequest_[]; // Link to MJAIAgentRequests
    
    @Field(() => [MJAIAgentStep_])
    MJAIAgentSteps_AgentIDArray: MJAIAgentStep_[]; // Link to MJAIAgentSteps
    
    @Field(() => [MJAIAgentRelationship_])
    MJAIAgentRelationships_AgentIDArray: MJAIAgentRelationship_[]; // Link to MJAIAgentRelationships
    
    @Field(() => [MJAIAgentArtifactType_])
    MJAIAgentArtifactTypes_AgentIDArray: MJAIAgentArtifactType_[]; // Link to MJAIAgentArtifactTypes
    
    @Field(() => [MJAIAgentPermission_])
    MJAIAgentPermissions_AgentIDArray: MJAIAgentPermission_[]; // Link to MJAIAgentPermissions
    
    @Field(() => [MJAIAgentDataSource_])
    MJAIAgentDataSources_AgentIDArray: MJAIAgentDataSource_[]; // Link to MJAIAgentDataSources
    
    @Field(() => [MJAIAgentModality_])
    MJAIAgentModalities_AgentIDArray: MJAIAgentModality_[]; // Link to MJAIAgentModalities
    
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_AgentIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
    @Field(() => [MJAIAgentPrompt_])
    MJAIAgentPrompts_AgentIDArray: MJAIAgentPrompt_[]; // Link to MJAIAgentPrompts
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_AgentIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
    @Field(() => [MJAIAgentStep_])
    MJAIAgentSteps_SubAgentIDArray: MJAIAgentStep_[]; // Link to MJAIAgentSteps
    
    @Field(() => [MJAIAgentRelationship_])
    MJAIAgentRelationships_SubAgentIDArray: MJAIAgentRelationship_[]; // Link to MJAIAgentRelationships
    
    @Field(() => [MJTask_])
    MJTasks_AgentIDArray: MJTask_[]; // Link to MJTasks
    
    @Field(() => [MJAIAgentExample_])
    MJAIAgentExamples_AgentIDArray: MJAIAgentExample_[]; // Link to MJAIAgentExamples
    
    @Field(() => [MJAIAgentConfiguration_])
    MJAIAgentConfigurations_AgentIDArray: MJAIAgentConfiguration_[]; // Link to MJAIAgentConfigurations
    
    @Field(() => [MJAIResultCache_])
    MJAIResultCache_AgentIDArray: MJAIResultCache_[]; // Link to MJAIResultCache
    
    @Field(() => [MJAIPromptRun_])
    MJAIPromptRuns_AgentIDArray: MJAIPromptRun_[]; // Link to MJAIPromptRuns
    
    @Field(() => [MJConversationDetail_])
    MJConversationDetails_AgentIDArray: MJConversationDetail_[]; // Link to MJConversationDetails
    
    @Field(() => [MJAIAgent_])
    MJAIAgents_ParentIDArray: MJAIAgent_[]; // Link to MJAIAgents
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agents
//****************************************************************************
@InputType()
export class CreateMJAIAgentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field(() => Boolean, { nullable: true })
    ExposeAsAction?: boolean;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ExecutionMode?: string;

    @Field(() => Boolean, { nullable: true })
    EnableContextCompression?: boolean;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageThreshold: number | null;

    @Field({ nullable: true })
    ContextCompressionPromptID: string | null;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageRetentionCount: number | null;

    @Field({ nullable: true })
    TypeID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    ModelSelectionMode?: string;

    @Field({ nullable: true })
    PayloadDownstreamPaths?: string;

    @Field({ nullable: true })
    PayloadUpstreamPaths?: string;

    @Field({ nullable: true })
    PayloadSelfReadPaths: string | null;

    @Field({ nullable: true })
    PayloadSelfWritePaths: string | null;

    @Field({ nullable: true })
    PayloadScope: string | null;

    @Field({ nullable: true })
    FinalPayloadValidation: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    FinalPayloadValidationMaxRetries?: number;

    @Field(() => Float, { nullable: true })
    MaxCostPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxTokensPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxIterationsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxTimePerRun: number | null;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun: number | null;

    @Field({ nullable: true })
    StartingPayloadValidation: string | null;

    @Field({ nullable: true })
    StartingPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    DefaultPromptEffortLevel: number | null;

    @Field({ nullable: true })
    ChatHandlingOption: string | null;

    @Field({ nullable: true })
    DefaultArtifactTypeID: string | null;

    @Field({ nullable: true })
    OwnerUserID?: string;

    @Field({ nullable: true })
    InvocationMode?: string;

    @Field({ nullable: true })
    ArtifactCreationMode?: string;

    @Field({ nullable: true })
    FunctionalRequirements: string | null;

    @Field({ nullable: true })
    TechnicalDesign: string | null;

    @Field(() => Boolean, { nullable: true })
    InjectNotes?: boolean;

    @Field(() => Int, { nullable: true })
    MaxNotesToInject?: number;

    @Field({ nullable: true })
    NoteInjectionStrategy?: string;

    @Field(() => Boolean, { nullable: true })
    InjectExamples?: boolean;

    @Field(() => Int, { nullable: true })
    MaxExamplesToInject?: number;

    @Field({ nullable: true })
    ExampleInjectionStrategy?: string;

    @Field(() => Boolean, { nullable: true })
    IsRestricted?: boolean;

    @Field({ nullable: true })
    MessageMode?: string;

    @Field(() => Int, { nullable: true })
    MaxMessages: number | null;

    @Field({ nullable: true })
    AttachmentStorageProviderID: string | null;

    @Field({ nullable: true })
    AttachmentRootPath: string | null;

    @Field(() => Int, { nullable: true })
    InlineStorageThresholdBytes: number | null;

    @Field({ nullable: true })
    AgentTypePromptParams: string | null;

    @Field({ nullable: true })
    ScopeConfig: string | null;

    @Field(() => Int, { nullable: true })
    NoteRetentionDays?: number | null;

    @Field(() => Int, { nullable: true })
    ExampleRetentionDays?: number | null;

    @Field(() => Boolean, { nullable: true })
    AutoArchiveEnabled?: boolean;

    @Field({ nullable: true })
    RerankerConfiguration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agents
//****************************************************************************
@InputType()
export class UpdateMJAIAgentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => Boolean, { nullable: true })
    ExposeAsAction?: boolean;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ExecutionMode?: string;

    @Field(() => Boolean, { nullable: true })
    EnableContextCompression?: boolean;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageThreshold?: number | null;

    @Field({ nullable: true })
    ContextCompressionPromptID?: string | null;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageRetentionCount?: number | null;

    @Field({ nullable: true })
    TypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    ModelSelectionMode?: string;

    @Field({ nullable: true })
    PayloadDownstreamPaths?: string;

    @Field({ nullable: true })
    PayloadUpstreamPaths?: string;

    @Field({ nullable: true })
    PayloadSelfReadPaths?: string | null;

    @Field({ nullable: true })
    PayloadSelfWritePaths?: string | null;

    @Field({ nullable: true })
    PayloadScope?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidation?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    FinalPayloadValidationMaxRetries?: number;

    @Field(() => Float, { nullable: true })
    MaxCostPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxTokensPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxIterationsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxTimePerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun?: number | null;

    @Field({ nullable: true })
    StartingPayloadValidation?: string | null;

    @Field({ nullable: true })
    StartingPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    DefaultPromptEffortLevel?: number | null;

    @Field({ nullable: true })
    ChatHandlingOption?: string | null;

    @Field({ nullable: true })
    DefaultArtifactTypeID?: string | null;

    @Field({ nullable: true })
    OwnerUserID?: string;

    @Field({ nullable: true })
    InvocationMode?: string;

    @Field({ nullable: true })
    ArtifactCreationMode?: string;

    @Field({ nullable: true })
    FunctionalRequirements?: string | null;

    @Field({ nullable: true })
    TechnicalDesign?: string | null;

    @Field(() => Boolean, { nullable: true })
    InjectNotes?: boolean;

    @Field(() => Int, { nullable: true })
    MaxNotesToInject?: number;

    @Field({ nullable: true })
    NoteInjectionStrategy?: string;

    @Field(() => Boolean, { nullable: true })
    InjectExamples?: boolean;

    @Field(() => Int, { nullable: true })
    MaxExamplesToInject?: number;

    @Field({ nullable: true })
    ExampleInjectionStrategy?: string;

    @Field(() => Boolean, { nullable: true })
    IsRestricted?: boolean;

    @Field({ nullable: true })
    MessageMode?: string;

    @Field(() => Int, { nullable: true })
    MaxMessages?: number | null;

    @Field({ nullable: true })
    AttachmentStorageProviderID?: string | null;

    @Field({ nullable: true })
    AttachmentRootPath?: string | null;

    @Field(() => Int, { nullable: true })
    InlineStorageThresholdBytes?: number | null;

    @Field({ nullable: true })
    AgentTypePromptParams?: string | null;

    @Field({ nullable: true })
    ScopeConfig?: string | null;

    @Field(() => Int, { nullable: true })
    NoteRetentionDays?: number | null;

    @Field(() => Int, { nullable: true })
    ExampleRetentionDays?: number | null;

    @Field(() => Boolean, { nullable: true })
    AutoArchiveEnabled?: boolean;

    @Field({ nullable: true })
    RerankerConfiguration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agents
//****************************************************************************
@ObjectType()
export class RunMJAIAgentViewResult {
    @Field(() => [MJAIAgent_])
    Results: MJAIAgent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgent_)
export class MJAIAgentResolver extends ResolverBase {
    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgent_, { nullable: true })
    async MJAIAgent(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgent_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgents')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agents', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentModel_])
    async MJAIAgentModels_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentModels')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentAction_])
    async MJAIAgentActions_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentActions')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentLearningCycle_])
    async MJAIAgentLearningCycles_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Learning Cycles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentLearningCycles')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Learning Cycles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async MJAIAgentRequests_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRequests')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Requests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStep_])
    async MJAIAgentSteps_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentSteps')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRelationship_])
    async MJAIAgentRelationships_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRelationships')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentArtifactType_])
    async MJAIAgentArtifactTypes_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentArtifactTypes')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Artifact Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPermission_])
    async MJAIAgentPermissions_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentPermissions')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentDataSource_])
    async MJAIAgentDataSources_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Data Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentDataSources')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Data Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Data Sources', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentModality_])
    async MJAIAgentModalities_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentModalities')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Modalities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPrompt_])
    async MJAIAgentPrompts_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentPrompts')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStep_])
    async MJAIAgentSteps_SubAgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentSteps')} WHERE ${provider.QuoteIdentifier('SubAgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRelationship_])
    async MJAIAgentRelationships_SubAgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRelationships')} WHERE ${provider.QuoteIdentifier('SubAgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJTasks_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTasks')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJAIAgentExamples_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentConfiguration_])
    async MJAIAgentConfigurations_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentConfigurations')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async MJAIResultCache_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIResultCaches')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJAIPromptRuns_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async MJConversationDetails_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetails')} WHERE ${provider.QuoteIdentifier('AgentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async MJAIAgents_ParentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgents')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgent_)
    async CreateMJAIAgent(
        @Arg('input', () => CreateMJAIAgentInput) input: CreateMJAIAgentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgent_)
    async UpdateMJAIAgent(
        @Arg('input', () => UpdateMJAIAgentInput) input: UpdateMJAIAgentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgent_)
    async DeleteMJAIAgent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Architectures
//****************************************************************************
@ObjectType({ description: `Master table of AI model architectures (Transformer, Diffusion, MoE, etc.) for model catalog enrichment and eval reporting.` })
export class MJAIArchitecture_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(50)
    Category: string;
        
    @Field({nullable: true, description: `Hierarchical relationship to parent architecture. Used for variants like Sparse Transformer being a child of Transformer.`}) 
    @MaxLength(36)
    ParentArchitectureID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    WikipediaURL?: string;
        
    @Field(() => Int, {nullable: true}) 
    YearIntroduced?: number;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    KeyPaper?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ParentArchitecture?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentArchitectureID?: string;
        
    @Field(() => [MJAIArchitecture_])
    MJAIArchitectures_ParentArchitectureIDArray: MJAIArchitecture_[]; // Link to MJAIArchitectures
    
    @Field(() => [MJAIModelArchitecture_])
    MJAIModelArchitectures_ArchitectureIDArray: MJAIModelArchitecture_[]; // Link to MJAIModelArchitectures
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Architectures
//****************************************************************************
@InputType()
export class CreateMJAIArchitectureInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    ParentArchitectureID: string | null;

    @Field({ nullable: true })
    WikipediaURL: string | null;

    @Field(() => Int, { nullable: true })
    YearIntroduced: number | null;

    @Field({ nullable: true })
    KeyPaper: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Architectures
//****************************************************************************
@InputType()
export class UpdateMJAIArchitectureInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    ParentArchitectureID?: string | null;

    @Field({ nullable: true })
    WikipediaURL?: string | null;

    @Field(() => Int, { nullable: true })
    YearIntroduced?: number | null;

    @Field({ nullable: true })
    KeyPaper?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Architectures
//****************************************************************************
@ObjectType()
export class RunMJAIArchitectureViewResult {
    @Field(() => [MJAIArchitecture_])
    Results: MJAIArchitecture_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIArchitecture_)
export class MJAIArchitectureResolver extends ResolverBase {
    @Query(() => RunMJAIArchitectureViewResult)
    async RunMJAIArchitectureViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIArchitectureViewResult)
    async RunMJAIArchitectureViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIArchitectureViewResult)
    async RunMJAIArchitectureDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Architectures';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIArchitecture_, { nullable: true })
    async MJAIArchitecture(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIArchitecture_ | null> {
        this.CheckUserReadPermissions('MJ: AI Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIArchitectures')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Architectures', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIArchitecture_])
    async MJAIArchitectures_ParentArchitectureIDArray(@Root() mjaiarchitecture_: MJAIArchitecture_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIArchitectures')} WHERE ${provider.QuoteIdentifier('ParentArchitectureID')}='${mjaiarchitecture_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Architectures', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelArchitecture_])
    async MJAIModelArchitectures_ArchitectureIDArray(@Root() mjaiarchitecture_: MJAIArchitecture_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelArchitectures')} WHERE ${provider.QuoteIdentifier('ArchitectureID')}='${mjaiarchitecture_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Architectures', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIArchitecture_)
    async CreateMJAIArchitecture(
        @Arg('input', () => CreateMJAIArchitectureInput) input: CreateMJAIArchitectureInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Architectures', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIArchitecture_)
    async UpdateMJAIArchitecture(
        @Arg('input', () => UpdateMJAIArchitectureInput) input: UpdateMJAIArchitectureInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Architectures', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIArchitecture_)
    async DeleteMJAIArchitecture(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Architectures', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Configuration Params
//****************************************************************************
@ObjectType({ description: `Stores configuration parameters that can be referenced by prompts and used to control execution behavior.` })
export class MJAIConfigurationParam_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ConfigurationID: string;
        
    @Field({description: `The name of the configuration parameter.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `The data type of the parameter (string, number, boolean, date, object).`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({description: `The value of the parameter, stored as a string but interpreted according to the Type.`}) 
    Value: string;
        
    @Field({nullable: true, description: `Detailed description of the parameter and its usage.`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Configuration: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Configuration Params
//****************************************************************************
@InputType()
export class CreateMJAIConfigurationParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConfigurationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Configuration Params
//****************************************************************************
@InputType()
export class UpdateMJAIConfigurationParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConfigurationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Configuration Params
//****************************************************************************
@ObjectType()
export class RunMJAIConfigurationParamViewResult {
    @Field(() => [MJAIConfigurationParam_])
    Results: MJAIConfigurationParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIConfigurationParam_)
export class MJAIConfigurationParamResolver extends ResolverBase {
    @Query(() => RunMJAIConfigurationParamViewResult)
    async RunMJAIConfigurationParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIConfigurationParamViewResult)
    async RunMJAIConfigurationParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIConfigurationParamViewResult)
    async RunMJAIConfigurationParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Configuration Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIConfigurationParam_, { nullable: true })
    async MJAIConfigurationParam(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIConfigurationParam_ | null> {
        this.CheckUserReadPermissions('MJ: AI Configuration Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIConfigurationParams')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configuration Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Configuration Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIConfigurationParam_)
    async CreateMJAIConfigurationParam(
        @Arg('input', () => CreateMJAIConfigurationParamInput) input: CreateMJAIConfigurationParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Configuration Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIConfigurationParam_)
    async UpdateMJAIConfigurationParam(
        @Arg('input', () => UpdateMJAIConfigurationParamInput) input: UpdateMJAIConfigurationParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Configuration Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIConfigurationParam_)
    async DeleteMJAIConfigurationParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Configuration Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Configurations
//****************************************************************************
@ObjectType({ description: `Stores configurations for AI prompt execution environments and settings.` })
export class MJAIConfiguration_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The name of the configuration.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the configuration.`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this is the default configuration to use when none is specified.`}) 
    IsDefault: boolean;
        
    @Field({description: `The current status of the configuration. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Default prompt to use for context compression when not specified at the agent level.`}) 
    @MaxLength(36)
    DefaultPromptForContextCompressionID?: string;
        
    @Field({nullable: true, description: `Default prompt to use for context summarization when not specified at the agent level.`}) 
    @MaxLength(36)
    DefaultPromptForContextSummarizationID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Default file storage provider for agent attachments. Used when an agent does not specify its own AttachmentStorageProviderID.`}) 
    @MaxLength(36)
    DefaultStorageProviderID?: string;
        
    @Field({nullable: true, description: `Default root path within the storage provider for agent attachments. Used when an agent does not specify its own AttachmentRootPath.`}) 
    @MaxLength(500)
    DefaultStorageRootPath?: string;
        
    @Field({nullable: true, description: `Optional reference to a parent configuration. When set, this configuration inherits prompt-model mappings and parameters from its parent. Child configurations can override specific settings while inheriting defaults from the parent chain. Supports N-level deep inheritance.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    DefaultPromptForContextCompression?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    DefaultPromptForContextSummarization?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    DefaultStorageProvider?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJAIConfigurationParam_])
    MJAIConfigurationParams_ConfigurationIDArray: MJAIConfigurationParam_[]; // Link to MJAIConfigurationParams
    
    @Field(() => [MJAIAgentPrompt_])
    MJAIAgentPrompts_ConfigurationIDArray: MJAIAgentPrompt_[]; // Link to MJAIAgentPrompts
    
    @Field(() => [MJAIAgentConfiguration_])
    MJAIAgentConfigurations_AIConfigurationIDArray: MJAIAgentConfiguration_[]; // Link to MJAIAgentConfigurations
    
    @Field(() => [MJAIPromptModel_])
    MJAIPromptModels_ConfigurationIDArray: MJAIPromptModel_[]; // Link to MJAIPromptModels
    
    @Field(() => [MJAIResultCache_])
    MJAIResultCache_ConfigurationIDArray: MJAIResultCache_[]; // Link to MJAIResultCache
    
    @Field(() => [MJAIPromptRun_])
    MJAIPromptRuns_ConfigurationIDArray: MJAIPromptRun_[]; // Link to MJAIPromptRuns
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_ConfigurationIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
    @Field(() => [MJAIConfiguration_])
    MJAIConfigurations_ParentIDArray: MJAIConfiguration_[]; // Link to MJAIConfigurations
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Configurations
//****************************************************************************
@InputType()
export class CreateMJAIConfigurationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DefaultPromptForContextCompressionID: string | null;

    @Field({ nullable: true })
    DefaultPromptForContextSummarizationID: string | null;

    @Field({ nullable: true })
    DefaultStorageProviderID: string | null;

    @Field({ nullable: true })
    DefaultStorageRootPath: string | null;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Configurations
//****************************************************************************
@InputType()
export class UpdateMJAIConfigurationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DefaultPromptForContextCompressionID?: string | null;

    @Field({ nullable: true })
    DefaultPromptForContextSummarizationID?: string | null;

    @Field({ nullable: true })
    DefaultStorageProviderID?: string | null;

    @Field({ nullable: true })
    DefaultStorageRootPath?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Configurations
//****************************************************************************
@ObjectType()
export class RunMJAIConfigurationViewResult {
    @Field(() => [MJAIConfiguration_])
    Results: MJAIConfiguration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIConfiguration_)
export class MJAIConfigurationResolver extends ResolverBase {
    @Query(() => RunMJAIConfigurationViewResult)
    async RunMJAIConfigurationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIConfigurationViewResult)
    async RunMJAIConfigurationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIConfigurationViewResult)
    async RunMJAIConfigurationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Configurations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIConfiguration_, { nullable: true })
    async MJAIConfiguration(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIConfiguration_ | null> {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIConfigurations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Configurations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIConfigurationParam_])
    async MJAIConfigurationParams_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configuration Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIConfigurationParams')} WHERE ${provider.QuoteIdentifier('ConfigurationID')}='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configuration Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configuration Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPrompt_])
    async MJAIAgentPrompts_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentPrompts')} WHERE ${provider.QuoteIdentifier('ConfigurationID')}='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentConfiguration_])
    async MJAIAgentConfigurations_AIConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentConfigurations')} WHERE ${provider.QuoteIdentifier('AIConfigurationID')}='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptModel_])
    async MJAIPromptModels_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptModels')} WHERE ${provider.QuoteIdentifier('ConfigurationID')}='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async MJAIResultCache_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIResultCaches')} WHERE ${provider.QuoteIdentifier('ConfigurationID')}='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJAIPromptRuns_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('ConfigurationID')}='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('ConfigurationID')}='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIConfiguration_])
    async MJAIConfigurations_ParentIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIConfigurations')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIConfiguration_)
    async CreateMJAIConfiguration(
        @Arg('input', () => CreateMJAIConfigurationInput) input: CreateMJAIConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Configurations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIConfiguration_)
    async UpdateMJAIConfiguration(
        @Arg('input', () => UpdateMJAIConfigurationInput) input: UpdateMJAIConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Configurations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIConfiguration_)
    async DeleteMJAIConfiguration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Configurations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Credential Bindings
//****************************************************************************
@ObjectType({ description: `Junction table that binds credentials to AI entities (Vendors, ModelVendors, PromptModels). Decouples credential assignments from core AI entities to prevent MJ updates from overwriting customer configurations. Supports priority-based failover with multiple credentials per binding level.` })
export class MJAICredentialBinding_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the credential being bound.`}) 
    @MaxLength(36)
    CredentialID: string;
        
    @Field({description: `The type of AI entity this credential is bound to: Vendor (broadest), ModelVendor (model+vendor specific), or PromptModel (most specific). Resolution follows prompt  model  vendor hierarchy.`}) 
    @MaxLength(20)
    BindingType: string;
        
    @Field({nullable: true, description: `Reference to AIVendor when BindingType is Vendor. NULL otherwise.`}) 
    @MaxLength(36)
    AIVendorID?: string;
        
    @Field({nullable: true, description: `Reference to AIModelVendor when BindingType is ModelVendor. NULL otherwise.`}) 
    @MaxLength(36)
    AIModelVendorID?: string;
        
    @Field({nullable: true, description: `Reference to AIPromptModel when BindingType is PromptModel. NULL otherwise.`}) 
    @MaxLength(36)
    AIPromptModelID?: string;
        
    @Field(() => Int, {description: `Priority for credential selection when multiple bindings exist at the same level. Lower values have higher priority (0 is highest). Enables failover when primary credentials are unavailable.`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `When false, this binding is ignored during credential resolution. Allows temporary disabling without deletion.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Credential: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    AIVendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    AIModelVendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    AIPromptModel?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Credential Bindings
//****************************************************************************
@InputType()
export class CreateMJAICredentialBindingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CredentialID?: string;

    @Field({ nullable: true })
    BindingType?: string;

    @Field({ nullable: true })
    AIVendorID: string | null;

    @Field({ nullable: true })
    AIModelVendorID: string | null;

    @Field({ nullable: true })
    AIPromptModelID: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Credential Bindings
//****************************************************************************
@InputType()
export class UpdateMJAICredentialBindingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CredentialID?: string;

    @Field({ nullable: true })
    BindingType?: string;

    @Field({ nullable: true })
    AIVendorID?: string | null;

    @Field({ nullable: true })
    AIModelVendorID?: string | null;

    @Field({ nullable: true })
    AIPromptModelID?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Credential Bindings
//****************************************************************************
@ObjectType()
export class RunMJAICredentialBindingViewResult {
    @Field(() => [MJAICredentialBinding_])
    Results: MJAICredentialBinding_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAICredentialBinding_)
export class MJAICredentialBindingResolver extends ResolverBase {
    @Query(() => RunMJAICredentialBindingViewResult)
    async RunMJAICredentialBindingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAICredentialBindingViewResult)
    async RunMJAICredentialBindingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAICredentialBindingViewResult)
    async RunMJAICredentialBindingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Credential Bindings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAICredentialBinding_, { nullable: true })
    async MJAICredentialBinding(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAICredentialBinding_ | null> {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAICredentialBindings')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAICredentialBinding_)
    async CreateMJAICredentialBinding(
        @Arg('input', () => CreateMJAICredentialBindingInput) input: CreateMJAICredentialBindingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Credential Bindings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAICredentialBinding_)
    async UpdateMJAICredentialBinding(
        @Arg('input', () => UpdateMJAICredentialBindingInput) input: UpdateMJAICredentialBindingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Credential Bindings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAICredentialBinding_)
    async DeleteMJAICredentialBinding(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Credential Bindings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Modalities
//****************************************************************************
@ObjectType({ description: `Master list of AI content modalities (Text, Image, Audio, Video, etc.) that models can accept as input or produce as output. New modalities can be added via INSERT without schema changes.` })
export class MJAIModality_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Display name of the modality (e.g., Text, Image, Audio, Video, File, Embedding).`}) 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of this modality and its use cases.`}) 
    @MaxLength(500)
    Description?: string;
        
    @Field({description: `Maps to ChatMessageContentBlock.type values: text, image_url, video_url, audio_url, file_url, embedding. Must match the TypeScript type definition.`}) 
    @MaxLength(50)
    ContentBlockType: string;
        
    @Field({nullable: true, description: `MIME type pattern for this modality (e.g., image/*, audio/*, video/*, text/*, application/*). Used for file type validation.`}) 
    @MaxLength(100)
    MIMETypePattern?: string;
        
    @Field({description: `Classification type: Content (human-readable text), Structured (JSON/embeddings), Binary (media files like images, audio, video).`}) 
    @MaxLength(50)
    Type: string;
        
    @Field(() => Int, {nullable: true, description: `System-wide default maximum size in bytes for this modality. Can be overridden at model or agent level. NULL means no size limit.`}) 
    DefaultMaxSizeBytes?: number;
        
    @Field(() => Int, {nullable: true, description: `System-wide default maximum count per message for this modality. Can be overridden at model or agent level. NULL means no count limit.`}) 
    DefaultMaxCountPerMessage?: number;
        
    @Field(() => Int, {description: `Display order for UI presentation. Lower numbers appear first.`}) 
    DisplayOrder: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIAgentModality_])
    MJAIAgentModalities_ModalityIDArray: MJAIAgentModality_[]; // Link to MJAIAgentModalities
    
    @Field(() => [MJAIModelModality_])
    MJAIModelModalities_ModalityIDArray: MJAIModelModality_[]; // Link to MJAIModelModalities
    
    @Field(() => [MJConversationDetailAttachment_])
    MJConversationDetailAttachments_ModalityIDArray: MJConversationDetailAttachment_[]; // Link to MJConversationDetailAttachments
    
    @Field(() => [MJAIModelType_])
    MJAIModelTypes_DefaultOutputModalityIDArray: MJAIModelType_[]; // Link to MJAIModelTypes
    
    @Field(() => [MJAIPromptRunMedia_])
    MJAIPromptRunMedias_ModalityIDArray: MJAIPromptRunMedia_[]; // Link to MJAIPromptRunMedias
    
    @Field(() => [MJAIModelType_])
    MJAIModelTypes_DefaultInputModalityIDArray: MJAIModelType_[]; // Link to MJAIModelTypes
    
    @Field(() => [MJAIAgentRunMedia_])
    MJAIAgentRunMedias_ModalityIDArray: MJAIAgentRunMedia_[]; // Link to MJAIAgentRunMedias
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Modalities
//****************************************************************************
@InputType()
export class CreateMJAIModalityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentBlockType?: string;

    @Field({ nullable: true })
    MIMETypePattern: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Int, { nullable: true })
    DefaultMaxSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    DefaultMaxCountPerMessage: number | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Modalities
//****************************************************************************
@InputType()
export class UpdateMJAIModalityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentBlockType?: string;

    @Field({ nullable: true })
    MIMETypePattern?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Int, { nullable: true })
    DefaultMaxSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    DefaultMaxCountPerMessage?: number | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Modalities
//****************************************************************************
@ObjectType()
export class RunMJAIModalityViewResult {
    @Field(() => [MJAIModality_])
    Results: MJAIModality_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModality_)
export class MJAIModalityResolver extends ResolverBase {
    @Query(() => RunMJAIModalityViewResult)
    async RunMJAIModalityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModalityViewResult)
    async RunMJAIModalityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModalityViewResult)
    async RunMJAIModalityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Modalities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModality_, { nullable: true })
    async MJAIModality(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModality_ | null> {
        this.CheckUserReadPermissions('MJ: AI Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModalities')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Modalities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentModality_])
    async MJAIAgentModalities_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentModalities')} WHERE ${provider.QuoteIdentifier('ModalityID')}='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Modalities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelModality_])
    async MJAIModelModalities_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelModalities')} WHERE ${provider.QuoteIdentifier('ModalityID')}='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Modalities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailAttachment_])
    async MJConversationDetailAttachments_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Attachments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailAttachments')} WHERE ${provider.QuoteIdentifier('ModalityID')}='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Attachments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Attachments', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelType_])
    async MJAIModelTypes_DefaultOutputModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelTypes')} WHERE ${provider.QuoteIdentifier('DefaultOutputModalityID')}='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRunMedia_])
    async MJAIPromptRunMedias_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRunMedias')} WHERE ${provider.QuoteIdentifier('ModalityID')}='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelType_])
    async MJAIModelTypes_DefaultInputModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelTypes')} WHERE ${provider.QuoteIdentifier('DefaultInputModalityID')}='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRunMedia_])
    async MJAIAgentRunMedias_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRunMedias')} WHERE ${provider.QuoteIdentifier('ModalityID')}='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModality_)
    async CreateMJAIModality(
        @Arg('input', () => CreateMJAIModalityInput) input: CreateMJAIModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Modalities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModality_)
    async UpdateMJAIModality(
        @Arg('input', () => UpdateMJAIModalityInput) input: UpdateMJAIModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Modalities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModality_)
    async DeleteMJAIModality(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Modalities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Actions
//****************************************************************************
@ObjectType({ description: `Tracks the actions supported by each AI Model` })
export class MJAIModelAction_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    AIModelID: string;
        
    @Field() 
    @MaxLength(36)
    AIActionID: string;
        
    @Field(() => Boolean, {description: `Determines if this specific action is currently enabled for the associated AI model.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    AIModel: string;
        
    @Field() 
    @MaxLength(50)
    AIAction: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Actions
//****************************************************************************
@InputType()
export class CreateMJAIModelActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Actions
//****************************************************************************
@InputType()
export class UpdateMJAIModelActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Actions
//****************************************************************************
@ObjectType()
export class RunMJAIModelActionViewResult {
    @Field(() => [MJAIModelAction_])
    Results: MJAIModelAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelAction_)
export class MJAIModelActionResolver extends ResolverBase {
    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelAction_, { nullable: true })
    async MJAIModelAction(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelAction_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelActions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAIModelAction_])
    async AllMJAIModelActions(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelActions')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIModelAction_)
    async CreateMJAIModelAction(
        @Arg('input', () => CreateMJAIModelActionInput) input: CreateMJAIModelActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelAction_)
    async UpdateMJAIModelAction(
        @Arg('input', () => UpdateMJAIModelActionInput) input: UpdateMJAIModelActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelAction_)
    async DeleteMJAIModelAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Architectures
//****************************************************************************
@ObjectType({ description: `Junction table linking AI models to their underlying architectures. Supports multiple architectures per model with ranking.` })
export class MJAIModelArchitecture_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ModelID: string;
        
    @Field() 
    @MaxLength(36)
    ArchitectureID: string;
        
    @Field(() => Int, {description: `Ranking of this architecture for the model. 1=Primary architecture, 2=Secondary, etc. Lower numbers indicate more dominant role.`}) 
    Rank: number;
        
    @Field(() => Float, {nullable: true, description: `Optional weight (0.0-1.0) indicating the mix ratio for hybrid architectures. E.g., 0.7 for 70% contribution.`}) 
    Weight?: number;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Notes?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    Model: string;
        
    @Field() 
    @MaxLength(100)
    Architecture: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Architectures
//****************************************************************************
@InputType()
export class CreateMJAIModelArchitectureInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    ArchitectureID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field(() => Float, { nullable: true })
    Weight: number | null;

    @Field({ nullable: true })
    Notes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Architectures
//****************************************************************************
@InputType()
export class UpdateMJAIModelArchitectureInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    ArchitectureID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field(() => Float, { nullable: true })
    Weight?: number | null;

    @Field({ nullable: true })
    Notes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Architectures
//****************************************************************************
@ObjectType()
export class RunMJAIModelArchitectureViewResult {
    @Field(() => [MJAIModelArchitecture_])
    Results: MJAIModelArchitecture_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelArchitecture_)
export class MJAIModelArchitectureResolver extends ResolverBase {
    @Query(() => RunMJAIModelArchitectureViewResult)
    async RunMJAIModelArchitectureViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelArchitectureViewResult)
    async RunMJAIModelArchitectureViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelArchitectureViewResult)
    async RunMJAIModelArchitectureDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Architectures';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelArchitecture_, { nullable: true })
    async MJAIModelArchitecture(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelArchitecture_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelArchitectures')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Architectures', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIModelArchitecture_)
    async CreateMJAIModelArchitecture(
        @Arg('input', () => CreateMJAIModelArchitectureInput) input: CreateMJAIModelArchitectureInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Architectures', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelArchitecture_)
    async UpdateMJAIModelArchitecture(
        @Arg('input', () => UpdateMJAIModelArchitectureInput) input: UpdateMJAIModelArchitectureInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Architectures', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelArchitecture_)
    async DeleteMJAIModelArchitecture(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Architectures', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Costs
//****************************************************************************
@ObjectType({ description: `Stores historical and current pricing information for AI models across different vendors, with optional temporal tracking and support for different processing types` })
export class MJAIModelCost_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ModelID: string;
        
    @Field() 
    @MaxLength(36)
    VendorID: string;
        
    @Field({nullable: true, description: `Date and time with timezone when this pricing became effective. NULL disables temporal tracking. Defaults to current UTC time when record is created`}) 
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Date and time with timezone when this pricing expired or will expire. NULL indicates currently active pricing`}) 
    EndedAt?: Date;
        
    @Field({description: `Current status of this pricing record. Active=currently in use, Pending=scheduled for future, Expired=no longer valid, Invalid=data error`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({description: `ISO 4217 three-letter currency code (e.g., USD, EUR, GBP) in uppercase`}) 
    @MaxLength(3)
    Currency: string;
        
    @Field() 
    @MaxLength(36)
    PriceTypeID: string;
        
    @Field(() => Float, {description: `Price per unit for input tokens/requests. Must be non-negative. Precision allows for micro-pricing scenarios`}) 
    InputPricePerUnit: number;
        
    @Field(() => Float, {description: `Price per unit for output tokens/responses. Must be non-negative. Often higher than input pricing`}) 
    OutputPricePerUnit: number;
        
    @Field() 
    @MaxLength(36)
    UnitTypeID: string;
        
    @Field({description: `Processing method that affects pricing. Realtime=immediate response, Batch=delayed processing often with discounts`}) 
    @MaxLength(20)
    ProcessingType: string;
        
    @Field({nullable: true, description: `Optional notes about pricing context, source, special conditions, or vendor-specific details`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    Model: string;
        
    @Field() 
    @MaxLength(50)
    Vendor: string;
        
    @Field() 
    @MaxLength(100)
    PriceType: string;
        
    @Field() 
    @MaxLength(100)
    UnitType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Costs
//****************************************************************************
@InputType()
export class CreateMJAIModelCostInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Currency?: string;

    @Field({ nullable: true })
    PriceTypeID?: string;

    @Field(() => Float, { nullable: true })
    InputPricePerUnit?: number;

    @Field(() => Float, { nullable: true })
    OutputPricePerUnit?: number;

    @Field({ nullable: true })
    UnitTypeID?: string;

    @Field({ nullable: true })
    ProcessingType?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Costs
//****************************************************************************
@InputType()
export class UpdateMJAIModelCostInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Currency?: string;

    @Field({ nullable: true })
    PriceTypeID?: string;

    @Field(() => Float, { nullable: true })
    InputPricePerUnit?: number;

    @Field(() => Float, { nullable: true })
    OutputPricePerUnit?: number;

    @Field({ nullable: true })
    UnitTypeID?: string;

    @Field({ nullable: true })
    ProcessingType?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Costs
//****************************************************************************
@ObjectType()
export class RunMJAIModelCostViewResult {
    @Field(() => [MJAIModelCost_])
    Results: MJAIModelCost_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelCost_)
export class MJAIModelCostResolver extends ResolverBase {
    @Query(() => RunMJAIModelCostViewResult)
    async RunMJAIModelCostViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelCostViewResult)
    async RunMJAIModelCostViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelCostViewResult)
    async RunMJAIModelCostDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Costs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelCost_, { nullable: true })
    async MJAIModelCost(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelCost_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelCosts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Costs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIModelCost_)
    async CreateMJAIModelCost(
        @Arg('input', () => CreateMJAIModelCostInput) input: CreateMJAIModelCostInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Costs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelCost_)
    async UpdateMJAIModelCost(
        @Arg('input', () => UpdateMJAIModelCostInput) input: UpdateMJAIModelCostInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Costs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelCost_)
    async DeleteMJAIModelCost(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Costs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Modalities
//****************************************************************************
@ObjectType({ description: `Junction table linking AI models to their supported input and output modalities with model-specific configuration. Used to extend beyond the default modalities inherited from AIModelType.` })
export class MJAIModelModality_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ModelID: string;
        
    @Field() 
    @MaxLength(36)
    ModalityID: string;
        
    @Field({description: `Whether this is an Input or Output modality for the model.`}) 
    @MaxLength(10)
    Direction: string;
        
    @Field(() => Boolean, {description: `Whether this modality is supported. Can be set to FALSE to explicitly disable an inherited modality.`}) 
    IsSupported: boolean;
        
    @Field(() => Boolean, {description: `For input modalities: whether this modality is required (e.g., text is usually required for LLMs). For outputs: not typically applicable.`}) 
    IsRequired: boolean;
        
    @Field({nullable: true, description: `Comma-separated list of supported file formats/extensions (e.g., png,jpg,webp,gif for images or mp3,wav,m4a for audio).`}) 
    @MaxLength(500)
    SupportedFormats?: string;
        
    @Field(() => Int, {nullable: true, description: `Model-specific maximum size in bytes. Overrides AIModality.DefaultMaxSizeBytes. NULL means use system default.`}) 
    MaxSizeBytes?: number;
        
    @Field(() => Int, {nullable: true, description: `Model-specific maximum count per message. Overrides AIModality.DefaultMaxCountPerMessage. NULL means use system default.`}) 
    MaxCountPerMessage?: number;
        
    @Field(() => Int, {nullable: true, description: `For image/video modalities: maximum dimension (width or height) in pixels supported by this model.`}) 
    MaxDimension?: number;
        
    @Field({nullable: true, description: `Additional notes or documentation about this model-modality configuration.`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    Model: string;
        
    @Field() 
    @MaxLength(50)
    Modality: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Modalities
//****************************************************************************
@InputType()
export class CreateMJAIModelModalityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => Boolean, { nullable: true })
    IsSupported?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    SupportedFormats: string | null;

    @Field(() => Int, { nullable: true })
    MaxSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    MaxCountPerMessage: number | null;

    @Field(() => Int, { nullable: true })
    MaxDimension: number | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Modalities
//****************************************************************************
@InputType()
export class UpdateMJAIModelModalityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => Boolean, { nullable: true })
    IsSupported?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    SupportedFormats?: string | null;

    @Field(() => Int, { nullable: true })
    MaxSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    MaxCountPerMessage?: number | null;

    @Field(() => Int, { nullable: true })
    MaxDimension?: number | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Modalities
//****************************************************************************
@ObjectType()
export class RunMJAIModelModalityViewResult {
    @Field(() => [MJAIModelModality_])
    Results: MJAIModelModality_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelModality_)
export class MJAIModelModalityResolver extends ResolverBase {
    @Query(() => RunMJAIModelModalityViewResult)
    async RunMJAIModelModalityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelModalityViewResult)
    async RunMJAIModelModalityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelModalityViewResult)
    async RunMJAIModelModalityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Modalities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelModality_, { nullable: true })
    async MJAIModelModality(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelModality_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelModalities')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Modalities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIModelModality_)
    async CreateMJAIModelModality(
        @Arg('input', () => CreateMJAIModelModalityInput) input: CreateMJAIModelModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Modalities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelModality_)
    async UpdateMJAIModelModality(
        @Arg('input', () => UpdateMJAIModelModalityInput) input: UpdateMJAIModelModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Modalities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelModality_)
    async DeleteMJAIModelModality(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Modalities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Price Types
//****************************************************************************
@ObjectType({ description: `Defines the different types of pricing metrics used by AI model vendors (e.g., Tokens, Minutes, Characters, API Calls)` })
export class MJAIModelPriceType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Short, descriptive name for the price type (e.g., "Tokens", "Minutes", "Characters")`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this price type represents and how it is measured`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIModelCost_])
    MJAIModelCosts_PriceTypeIDArray: MJAIModelCost_[]; // Link to MJAIModelCosts
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Types
//****************************************************************************
@InputType()
export class CreateMJAIModelPriceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Types
//****************************************************************************
@InputType()
export class UpdateMJAIModelPriceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Price Types
//****************************************************************************
@ObjectType()
export class RunMJAIModelPriceTypeViewResult {
    @Field(() => [MJAIModelPriceType_])
    Results: MJAIModelPriceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelPriceType_)
export class MJAIModelPriceTypeResolver extends ResolverBase {
    @Query(() => RunMJAIModelPriceTypeViewResult)
    async RunMJAIModelPriceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelPriceTypeViewResult)
    async RunMJAIModelPriceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelPriceTypeViewResult)
    async RunMJAIModelPriceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Price Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelPriceType_, { nullable: true })
    async MJAIModelPriceType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelPriceType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Price Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelPriceTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Price Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Price Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModelCost_])
    async MJAIModelCosts_PriceTypeIDArray(@Root() mjaimodelpricetype_: MJAIModelPriceType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelCosts')} WHERE ${provider.QuoteIdentifier('PriceTypeID')}='${mjaimodelpricetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModelPriceType_)
    async CreateMJAIModelPriceType(
        @Arg('input', () => CreateMJAIModelPriceTypeInput) input: CreateMJAIModelPriceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Price Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelPriceType_)
    async UpdateMJAIModelPriceType(
        @Arg('input', () => UpdateMJAIModelPriceTypeInput) input: UpdateMJAIModelPriceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Price Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelPriceType_)
    async DeleteMJAIModelPriceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Price Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Price Unit Types
//****************************************************************************
@ObjectType({ description: `Defines the unit scales used for pricing (e.g., Per 1M Tokens, Per 1K Tokens, Per Minute). Includes driver class for normalization calculations` })
export class MJAIModelPriceUnitType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Display name for the pricing unit (e.g., "Per 1M Tokens", "Per 1K Tokens", "Per Minute")`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed explanation of the unit scale and any special considerations for this pricing unit`}) 
    Description?: string;
        
    @Field({description: `Fully qualified class name that handles cost calculations and unit normalization for this pricing unit (e.g., "TokenPer1M", "TokenPer1K")`}) 
    @MaxLength(255)
    DriverClass: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIModelCost_])
    MJAIModelCosts_UnitTypeIDArray: MJAIModelCost_[]; // Link to MJAIModelCosts
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Unit Types
//****************************************************************************
@InputType()
export class CreateMJAIModelPriceUnitTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Unit Types
//****************************************************************************
@InputType()
export class UpdateMJAIModelPriceUnitTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Price Unit Types
//****************************************************************************
@ObjectType()
export class RunMJAIModelPriceUnitTypeViewResult {
    @Field(() => [MJAIModelPriceUnitType_])
    Results: MJAIModelPriceUnitType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelPriceUnitType_)
export class MJAIModelPriceUnitTypeResolver extends ResolverBase {
    @Query(() => RunMJAIModelPriceUnitTypeViewResult)
    async RunMJAIModelPriceUnitTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelPriceUnitTypeViewResult)
    async RunMJAIModelPriceUnitTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelPriceUnitTypeViewResult)
    async RunMJAIModelPriceUnitTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Price Unit Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelPriceUnitType_, { nullable: true })
    async MJAIModelPriceUnitType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelPriceUnitType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Price Unit Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelPriceUnitTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Price Unit Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Price Unit Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModelCost_])
    async MJAIModelCosts_UnitTypeIDArray(@Root() mjaimodelpriceunittype_: MJAIModelPriceUnitType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelCosts')} WHERE ${provider.QuoteIdentifier('UnitTypeID')}='${mjaimodelpriceunittype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModelPriceUnitType_)
    async CreateMJAIModelPriceUnitType(
        @Arg('input', () => CreateMJAIModelPriceUnitTypeInput) input: CreateMJAIModelPriceUnitTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Price Unit Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelPriceUnitType_)
    async UpdateMJAIModelPriceUnitType(
        @Arg('input', () => UpdateMJAIModelPriceUnitTypeInput) input: UpdateMJAIModelPriceUnitTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Price Unit Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelPriceUnitType_)
    async DeleteMJAIModelPriceUnitType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Price Unit Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Types
//****************************************************************************
@ObjectType({ description: `Types of AI Models` })
export class MJAIModelType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Default input modality for this model type. Models of this type inherit this as their primary input modality unless overridden.`}) 
    @MaxLength(36)
    DefaultInputModalityID: string;
        
    @Field({description: `Default output modality for this model type. Models of this type inherit this as their primary output modality unless overridden.`}) 
    @MaxLength(36)
    DefaultOutputModalityID: string;
        
    @Field() 
    @MaxLength(50)
    DefaultInputModality: string;
        
    @Field() 
    @MaxLength(50)
    DefaultOutputModality: string;
        
    @Field(() => [MJAIModel_])
    MJAIModels_AIModelTypeIDArray: MJAIModel_[]; // Link to MJAIModels
    
    @Field(() => [MJAIPrompt_])
    MJAIPrompts_AIModelTypeIDArray: MJAIPrompt_[]; // Link to MJAIPrompts
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Types
//****************************************************************************
@InputType()
export class CreateMJAIModelTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultInputModalityID?: string;

    @Field({ nullable: true })
    DefaultOutputModalityID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Types
//****************************************************************************
@InputType()
export class UpdateMJAIModelTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultInputModalityID?: string;

    @Field({ nullable: true })
    DefaultOutputModalityID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Types
//****************************************************************************
@ObjectType()
export class RunMJAIModelTypeViewResult {
    @Field(() => [MJAIModelType_])
    Results: MJAIModelType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelType_)
export class MJAIModelTypeResolver extends ResolverBase {
    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelType_, { nullable: true })
    async MJAIModelType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAIModelType_])
    async AllMJAIModelTypes(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelTypes')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModel_])
    async MJAIModels_AIModelTypeIDArray(@Root() mjaimodeltype_: MJAIModelType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModels')} WHERE ${provider.QuoteIdentifier('AIModelTypeID')}='${mjaimodeltype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPrompt_])
    async MJAIPrompts_AIModelTypeIDArray(@Root() mjaimodeltype_: MJAIModelType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPrompts')} WHERE ${provider.QuoteIdentifier('AIModelTypeID')}='${mjaimodeltype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModelType_)
    async CreateMJAIModelType(
        @Arg('input', () => CreateMJAIModelTypeInput) input: CreateMJAIModelTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelType_)
    async UpdateMJAIModelType(
        @Arg('input', () => UpdateMJAIModelTypeInput) input: UpdateMJAIModelTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelType_)
    async DeleteMJAIModelType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Vendors
//****************************************************************************
@ObjectType({ description: `Associates AI models with vendors providing them, including vendor-specific implementation details.` })
export class MJAIModelVendor_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ModelID: string;
        
    @Field() 
    @MaxLength(36)
    VendorID: string;
        
    @Field(() => Int, {description: `Determines the priority rank of this vendor for the model. Higher values indicate higher priority.`}) 
    Priority: number;
        
    @Field({description: `The current status of this model-vendor combination. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `The name of the driver class implementing this model-vendor combination.`}) 
    @MaxLength(100)
    DriverClass?: string;
        
    @Field({nullable: true, description: `The import path for the driver class.`}) 
    @MaxLength(255)
    DriverImportPath?: string;
        
    @Field({nullable: true, description: `The name of the model to use with API calls, which might differ from the model name. If not provided, the model name will be used.`}) 
    @MaxLength(100)
    APIName?: string;
        
    @Field(() => Int, {nullable: true, description: `The maximum number of input tokens supported by this model-vendor implementation.`}) 
    MaxInputTokens?: number;
        
    @Field(() => Int, {nullable: true, description: `The maximum number of output tokens supported by this model-vendor implementation.`}) 
    MaxOutputTokens?: number;
        
    @Field({description: `A comma-delimited string indicating the supported response formats for this model-vendor implementation. Options include Any, Text, Markdown, JSON, and ModelSpecific.`}) 
    @MaxLength(100)
    SupportedResponseFormats: string;
        
    @Field(() => Boolean, {description: `Specifies if this model-vendor implementation supports the concept of an effort level.`}) 
    SupportsEffortLevel: boolean;
        
    @Field(() => Boolean, {description: `Specifies if this model-vendor implementation supports streaming responses.`}) 
    SupportsStreaming: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `References the type/role of the vendor for this model (e.g., model developer, inference provider)`}) 
    @MaxLength(36)
    TypeID: string;
        
    @Field() 
    @MaxLength(50)
    Model: string;
        
    @Field() 
    @MaxLength(50)
    Vendor: string;
        
    @Field() 
    @MaxLength(50)
    Type: string;
        
    @Field(() => [MJAICredentialBinding_])
    MJAICredentialBindings_AIModelVendorIDArray: MJAICredentialBinding_[]; // Link to MJAICredentialBindings
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Vendors
//****************************************************************************
@InputType()
export class CreateMJAIModelVendorInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    APIName: string | null;

    @Field(() => Int, { nullable: true })
    MaxInputTokens: number | null;

    @Field(() => Int, { nullable: true })
    MaxOutputTokens: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsStreaming?: boolean;

    @Field({ nullable: true })
    TypeID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Vendors
//****************************************************************************
@InputType()
export class UpdateMJAIModelVendorInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    APIName?: string | null;

    @Field(() => Int, { nullable: true })
    MaxInputTokens?: number | null;

    @Field(() => Int, { nullable: true })
    MaxOutputTokens?: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsStreaming?: boolean;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Vendors
//****************************************************************************
@ObjectType()
export class RunMJAIModelVendorViewResult {
    @Field(() => [MJAIModelVendor_])
    Results: MJAIModelVendor_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelVendor_)
export class MJAIModelVendorResolver extends ResolverBase {
    @Query(() => RunMJAIModelVendorViewResult)
    async RunMJAIModelVendorViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelVendorViewResult)
    async RunMJAIModelVendorViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelVendorViewResult)
    async RunMJAIModelVendorDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Vendors';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelVendor_, { nullable: true })
    async MJAIModelVendor(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelVendor_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelVendors')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Vendors', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAICredentialBinding_])
    async MJAICredentialBindings_AIModelVendorIDArray(@Root() mjaimodelvendor_: MJAIModelVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAICredentialBindings')} WHERE ${provider.QuoteIdentifier('AIModelVendorID')}='${mjaimodelvendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModelVendor_)
    async CreateMJAIModelVendor(
        @Arg('input', () => CreateMJAIModelVendorInput) input: CreateMJAIModelVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Vendors', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelVendor_)
    async UpdateMJAIModelVendor(
        @Arg('input', () => UpdateMJAIModelVendorInput) input: UpdateMJAIModelVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Vendors', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelVendor_)
    async DeleteMJAIModelVendor(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Vendors', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Models
//****************************************************************************
@ObjectType({ description: `Catalog of all AI Models configured in the system` })
export class MJAIModel_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    AIModelTypeID: string;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the power of the AI model. Default is 0 and should be non-negative.`}) 
    PowerRank?: number;
        
    @Field(() => Boolean, {description: `Controls whether this AI model is available for use in the system.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the speed of the AI model. Default is 0 and should be non-negative.`}) 
    SpeedRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the cost of the AI model. Default is 0 and should be non-negative.`}) 
    CostRank?: number;
        
    @Field({nullable: true, description: `This column stores unstructured text notes that provide insights into what the model is particularly good at and areas where it may not perform as well. These notes can be used by a human or an AI to determine if the model is a good fit for various purposes.`}) 
    ModelSelectionInsights?: string;
        
    @Field(() => Boolean, {description: `When TRUE (default), the model inherits default input/output modalities from its AIModelType AND can extend with additional modalities via AIModelModality records. When FALSE, only modalities explicitly defined in AIModelModality are used.`}) 
    InheritTypeModalities: boolean;
        
    @Field({nullable: true, description: `Reference to the previous version of this model, creating a version lineage chain. For example, GPT-4 Turbo might reference GPT-4 as its prior version.`}) 
    @MaxLength(36)
    PriorVersionID?: string;
        
    @Field() 
    @MaxLength(50)
    AIModelType: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DriverClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    DriverImportPath?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    APIName?: string;
        
    @Field(() => Int, {nullable: true}) 
    InputTokenLimit?: number;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SupportedResponseFormats?: string;
        
    @Field(() => Boolean, {nullable: true}) 
    SupportsEffortLevel?: boolean;
        
    @Field(() => [MJAIAction_])
    MJAIActions_DefaultModelIDArray: MJAIAction_[]; // Link to MJAIActions
    
    @Field(() => [MJAIModelAction_])
    MJAIModelActions_AIModelIDArray: MJAIModelAction_[]; // Link to MJAIModelActions
    
    @Field(() => [MJVectorIndex_])
    MJVectorIndexes_EmbeddingModelIDArray: MJVectorIndex_[]; // Link to MJVectorIndexes
    
    @Field(() => [MJEntityDocument_])
    MJEntityDocuments_AIModelIDArray: MJEntityDocument_[]; // Link to MJEntityDocuments
    
    @Field(() => [MJEntityAIAction_])
    MJEntityAIActions_AIModelIDArray: MJEntityAIAction_[]; // Link to MJEntityAIActions
    
    @Field(() => [MJContentType_])
    MJContentTypes_AIModelIDArray: MJContentType_[]; // Link to MJContentTypes
    
    @Field(() => [MJAIResultCache_])
    MJAIResultCache_AIModelIDArray: MJAIResultCache_[]; // Link to MJAIResultCache
    
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_EmbeddingModelIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
    @Field(() => [MJAIAgentExample_])
    MJAIAgentExamples_EmbeddingModelIDArray: MJAIAgentExample_[]; // Link to MJAIAgentExamples
    
    @Field(() => [MJAIModelModality_])
    MJAIModelModalities_ModelIDArray: MJAIModelModality_[]; // Link to MJAIModelModalities
    
    @Field(() => [MJAIModelArchitecture_])
    MJAIModelArchitectures_ModelIDArray: MJAIModelArchitecture_[]; // Link to MJAIModelArchitectures
    
    @Field(() => [MJAIAgentModel_])
    MJAIAgentModels_ModelIDArray: MJAIAgentModel_[]; // Link to MJAIAgentModels
    
    @Field(() => [MJAIModelVendor_])
    MJAIModelVendors_ModelIDArray: MJAIModelVendor_[]; // Link to MJAIModelVendors
    
    @Field(() => [MJGeneratedCode_])
    MJGeneratedCodes_GeneratedByModelIDArray: MJGeneratedCode_[]; // Link to MJGeneratedCodes
    
    @Field(() => [MJAIModelCost_])
    MJAIModelCosts_ModelIDArray: MJAIModelCost_[]; // Link to MJAIModelCosts
    
    @Field(() => [MJAIPromptModel_])
    MJAIPromptModels_ModelIDArray: MJAIPromptModel_[]; // Link to MJAIPromptModels
    
    @Field(() => [MJAIPromptRun_])
    MJAIPromptRuns_ModelIDArray: MJAIPromptRun_[]; // Link to MJAIPromptRuns
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_OverrideModelIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
    @Field(() => [MJQuery_])
    MJQueries_EmbeddingModelIDArray: MJQuery_[]; // Link to MJQueries
    
    @Field(() => [MJAIModel_])
    MJAIModels_PriorVersionIDArray: MJAIModel_[]; // Link to MJAIModels
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Models
//****************************************************************************
@InputType()
export class CreateMJAIModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights: string | null;

    @Field(() => Boolean, { nullable: true })
    InheritTypeModalities?: boolean;

    @Field({ nullable: true })
    PriorVersionID: string | null;

    @Field({ nullable: true })
    Vendor: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    APIName: string | null;

    @Field(() => Int, { nullable: true })
    InputTokenLimit: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats: string | null;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel: boolean | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Models
//****************************************************************************
@InputType()
export class UpdateMJAIModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights?: string | null;

    @Field(() => Boolean, { nullable: true })
    InheritTypeModalities?: boolean;

    @Field({ nullable: true })
    PriorVersionID?: string | null;

    @Field({ nullable: true })
    Vendor?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    APIName?: string | null;

    @Field(() => Int, { nullable: true })
    InputTokenLimit?: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string | null;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel?: boolean | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Models
//****************************************************************************
@ObjectType()
export class RunMJAIModelViewResult {
    @Field(() => [MJAIModel_])
    Results: MJAIModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModel_)
export class MJAIModelResolver extends ResolverBase {
    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModel_, { nullable: true })
    async MJAIModel(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModel_ | null> {
        this.CheckUserReadPermissions('MJ: AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModels')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Models', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAIModel_])
    async AllMJAIModels(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModels')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Models', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAction_])
    async MJAIActions_DefaultModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIActions')} WHERE ${provider.QuoteIdentifier('DefaultModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelAction_])
    async MJAIModelActions_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelActions')} WHERE ${provider.QuoteIdentifier('AIModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVectorIndex_])
    async MJVectorIndexes_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVectorIndexes')} WHERE ${provider.QuoteIdentifier('EmbeddingModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Vector Indexes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async MJEntityDocuments_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocuments')} WHERE ${provider.QuoteIdentifier('AIModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async MJEntityAIActions_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityAIActions')} WHERE ${provider.QuoteIdentifier('AIModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentType_])
    async MJContentTypes_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentTypes')} WHERE ${provider.QuoteIdentifier('AIModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async MJAIResultCache_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIResultCaches')} WHERE ${provider.QuoteIdentifier('AIModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('EmbeddingModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJAIAgentExamples_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('EmbeddingModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelModality_])
    async MJAIModelModalities_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelModalities')} WHERE ${provider.QuoteIdentifier('ModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Modalities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelArchitecture_])
    async MJAIModelArchitectures_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelArchitectures')} WHERE ${provider.QuoteIdentifier('ModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Architectures', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentModel_])
    async MJAIAgentModels_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentModels')} WHERE ${provider.QuoteIdentifier('ModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelVendor_])
    async MJAIModelVendors_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelVendors')} WHERE ${provider.QuoteIdentifier('ModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async MJGeneratedCodes_GeneratedByModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwGeneratedCodes')} WHERE ${provider.QuoteIdentifier('GeneratedByModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Generated Codes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelCost_])
    async MJAIModelCosts_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelCosts')} WHERE ${provider.QuoteIdentifier('ModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptModel_])
    async MJAIPromptModels_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptModels')} WHERE ${provider.QuoteIdentifier('ModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJAIPromptRuns_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('ModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_OverrideModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('OverrideModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQuery_])
    async MJQueries_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueries')} WHERE ${provider.QuoteIdentifier('EmbeddingModelID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Queries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModel_])
    async MJAIModels_PriorVersionIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModels')} WHERE ${provider.QuoteIdentifier('PriorVersionID')}='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModel_)
    async CreateMJAIModel(
        @Arg('input', () => CreateMJAIModelInput) input: CreateMJAIModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModel_)
    async UpdateMJAIModel(
        @Arg('input', () => UpdateMJAIModelInput) input: UpdateMJAIModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModel_)
    async DeleteMJAIModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Categories
//****************************************************************************
@ObjectType({ description: `Categories for organizing AI prompts in a hierarchical structure.` })
export class MJAIPromptCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Parent category ID for hierarchical organization.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJAIPrompt_])
    MJAIPrompts_CategoryIDArray: MJAIPrompt_[]; // Link to MJAIPrompts
    
    @Field(() => [MJAIPromptCategory_])
    MJAIPromptCategories_ParentIDArray: MJAIPromptCategory_[]; // Link to MJAIPromptCategories
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Categories
//****************************************************************************
@InputType()
export class CreateMJAIPromptCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Categories
//****************************************************************************
@InputType()
export class UpdateMJAIPromptCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Categories
//****************************************************************************
@ObjectType()
export class RunMJAIPromptCategoryViewResult {
    @Field(() => [MJAIPromptCategory_])
    Results: MJAIPromptCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptCategory_)
export class MJAIPromptCategoryResolver extends ResolverBase {
    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptCategory_, { nullable: true })
    async MJAIPromptCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptCategory_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompt Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIPrompt_])
    async MJAIPrompts_CategoryIDArray(@Root() mjaipromptcategory_: MJAIPromptCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPrompts')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjaipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptCategory_])
    async MJAIPromptCategories_ParentIDArray(@Root() mjaipromptcategory_: MJAIPromptCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjaipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptCategory_)
    async CreateMJAIPromptCategory(
        @Arg('input', () => CreateMJAIPromptCategoryInput) input: CreateMJAIPromptCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptCategory_)
    async UpdateMJAIPromptCategory(
        @Arg('input', () => UpdateMJAIPromptCategoryInput) input: UpdateMJAIPromptCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptCategory_)
    async DeleteMJAIPromptCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Models
//****************************************************************************
@ObjectType({ description: `Associates AI prompts with specific models and configurations, including execution details.` })
export class MJAIPromptModel_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `References the AI prompt this model association applies to.`}) 
    @MaxLength(36)
    PromptID: string;
        
    @Field({description: `References the AI model to use for this prompt.`}) 
    @MaxLength(36)
    ModelID: string;
        
    @Field({nullable: true, description: `Optional reference to a specific vendor for the model. If NULL, uses the highest priority vendor for the model.`}) 
    @MaxLength(36)
    VendorID?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific configuration. If NULL, this model is available in all configurations.`}) 
    @MaxLength(36)
    ConfigurationID?: string;
        
    @Field(() => Int, {description: `Priority of this model for the prompt. Higher values indicate higher priority.`}) 
    Priority: number;
        
    @Field(() => Int, {description: `Execution group for parallel processing. Models with the same group are executed in parallel.`}) 
    ExecutionGroup: number;
        
    @Field({nullable: true, description: `JSON-formatted parameters specific to this model (temperature, max tokens, etc.).`}) 
    ModelParameters?: string;
        
    @Field({description: `The current status of this model configuration. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({description: `Controls how this model participates in parallelization: None, StaticCount, or ConfigParam.`}) 
    @MaxLength(20)
    ParallelizationMode: string;
        
    @Field(() => Int, {description: `Number of parallel executions to perform with this model when ParallelizationMode is StaticCount.`}) 
    ParallelCount: number;
        
    @Field({nullable: true, description: `Name of a configuration parameter that contains the parallel count when ParallelizationMode is ConfigParam.`}) 
    @MaxLength(100)
    ParallelConfigParam?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Model-specific effort level override (1-100, where 1=minimal effort, 100=maximum effort). Allows customizing effort level per model - useful when a more capable model can use lower effort for tasks that require higher effort from lesser models. Takes precedence over agent and prompt effort levels but can be overridden by runtime parameters.`}) 
    EffortLevel?: number;
        
    @Field() 
    @MaxLength(255)
    Prompt: string;
        
    @Field() 
    @MaxLength(50)
    Model: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Configuration?: string;
        
    @Field(() => [MJAICredentialBinding_])
    MJAICredentialBindings_AIPromptModelIDArray: MJAICredentialBinding_[]; // Link to MJAICredentialBindings
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Models
//****************************************************************************
@InputType()
export class CreateMJAIPromptModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Int, { nullable: true })
    ExecutionGroup?: number;

    @Field({ nullable: true })
    ModelParameters: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number;

    @Field({ nullable: true })
    ParallelConfigParam: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Models
//****************************************************************************
@InputType()
export class UpdateMJAIPromptModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Int, { nullable: true })
    ExecutionGroup?: number;

    @Field({ nullable: true })
    ModelParameters?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number;

    @Field({ nullable: true })
    ParallelConfigParam?: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Models
//****************************************************************************
@ObjectType()
export class RunMJAIPromptModelViewResult {
    @Field(() => [MJAIPromptModel_])
    Results: MJAIPromptModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptModel_)
export class MJAIPromptModelResolver extends ResolverBase {
    @Query(() => RunMJAIPromptModelViewResult)
    async RunMJAIPromptModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptModelViewResult)
    async RunMJAIPromptModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptModelViewResult)
    async RunMJAIPromptModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptModel_, { nullable: true })
    async MJAIPromptModel(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptModel_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptModels')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompt Models', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAICredentialBinding_])
    async MJAICredentialBindings_AIPromptModelIDArray(@Root() mjaipromptmodel_: MJAIPromptModel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAICredentialBindings')} WHERE ${provider.QuoteIdentifier('AIPromptModelID')}='${mjaipromptmodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptModel_)
    async CreateMJAIPromptModel(
        @Arg('input', () => CreateMJAIPromptModelInput) input: CreateMJAIPromptModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptModel_)
    async UpdateMJAIPromptModel(
        @Arg('input', () => UpdateMJAIPromptModelInput) input: UpdateMJAIPromptModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptModel_)
    async DeleteMJAIPromptModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Run Medias
//****************************************************************************
@ObjectType()
export class MJAIPromptRunMedia_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    PromptRunID: string;
        
    @Field() 
    @MaxLength(36)
    ModalityID: string;
        
    @Field() 
    @MaxLength(100)
    MimeType: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    FileName?: string;
        
    @Field(() => Int, {nullable: true}) 
    FileSizeBytes?: number;
        
    @Field(() => Int, {nullable: true}) 
    Width?: number;
        
    @Field(() => Int, {nullable: true}) 
    Height?: number;
        
    @Field(() => Float, {nullable: true}) 
    DurationSeconds?: number;
        
    @Field({nullable: true}) 
    InlineData?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    FileID?: string;
        
    @Field({nullable: true}) 
    ThumbnailBase64?: string;
        
    @Field({nullable: true}) 
    Metadata?: string;
        
    @Field(() => Int) 
    DisplayOrder: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Description of the media generated during prompt execution. Provides context for audit trail.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    PromptRun?: string;
        
    @Field() 
    @MaxLength(50)
    Modality: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    File?: string;
        
    @Field(() => [MJAIAgentRunMedia_])
    MJAIAgentRunMedias_SourcePromptRunMediaIDArray: MJAIAgentRunMedia_[]; // Link to MJAIAgentRunMedias
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Run Medias
//****************************************************************************
@InputType()
export class CreateMJAIPromptRunMediaInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    PromptRunID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    Width: number | null;

    @Field(() => Int, { nullable: true })
    Height: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    InlineData: string | null;

    @Field({ nullable: true })
    FileID: string | null;

    @Field({ nullable: true })
    ThumbnailBase64: string | null;

    @Field({ nullable: true })
    Metadata: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Run Medias
//****************************************************************************
@InputType()
export class UpdateMJAIPromptRunMediaInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    PromptRunID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName?: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    Width?: number | null;

    @Field(() => Int, { nullable: true })
    Height?: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    InlineData?: string | null;

    @Field({ nullable: true })
    FileID?: string | null;

    @Field({ nullable: true })
    ThumbnailBase64?: string | null;

    @Field({ nullable: true })
    Metadata?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Run Medias
//****************************************************************************
@ObjectType()
export class RunMJAIPromptRunMediaViewResult {
    @Field(() => [MJAIPromptRunMedia_])
    Results: MJAIPromptRunMedia_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptRunMedia_)
export class MJAIPromptRunMediaResolver extends ResolverBase {
    @Query(() => RunMJAIPromptRunMediaViewResult)
    async RunMJAIPromptRunMediaViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptRunMediaViewResult)
    async RunMJAIPromptRunMediaViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptRunMediaViewResult)
    async RunMJAIPromptRunMediaDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Run Medias';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptRunMedia_, { nullable: true })
    async MJAIPromptRunMedia(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptRunMedia_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRunMedias')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompt Run Medias', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentRunMedia_])
    async MJAIAgentRunMedias_SourcePromptRunMediaIDArray(@Root() mjaipromptrunmedia_: MJAIPromptRunMedia_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRunMedias')} WHERE ${provider.QuoteIdentifier('SourcePromptRunMediaID')}='${mjaipromptrunmedia_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptRunMedia_)
    async CreateMJAIPromptRunMedia(
        @Arg('input', () => CreateMJAIPromptRunMediaInput) input: CreateMJAIPromptRunMediaInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Run Medias', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptRunMedia_)
    async UpdateMJAIPromptRunMedia(
        @Arg('input', () => UpdateMJAIPromptRunMediaInput) input: UpdateMJAIPromptRunMediaInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Run Medias', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptRunMedia_)
    async DeleteMJAIPromptRunMedia(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Run Medias', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Runs
//****************************************************************************
@ObjectType({ description: `Tracks AI prompt executions including timings, inputs, outputs, and performance metrics.` })
export class MJAIPromptRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The prompt that was executed.`}) 
    @MaxLength(36)
    PromptID: string;
        
    @Field({description: `The AI model used for execution.`}) 
    @MaxLength(36)
    ModelID: string;
        
    @Field({description: `The vendor providing the model/inference.`}) 
    @MaxLength(36)
    VendorID: string;
        
    @Field({nullable: true, description: `If this prompt was run as part of an agent, references the agent.`}) 
    @MaxLength(36)
    AgentID?: string;
        
    @Field({nullable: true, description: `Optional configuration used for this execution.`}) 
    @MaxLength(36)
    ConfigurationID?: string;
        
    @Field({description: `When the prompt run started, with timezone offset information.`}) 
    RunAt: Date;
        
    @Field({nullable: true, description: `When the prompt run completed, with timezone offset information.`}) 
    CompletedAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total execution time in milliseconds.`}) 
    ExecutionTimeMS?: number;
        
    @Field({nullable: true, description: `The input messages sent to the model, typically in JSON format.`}) 
    Messages?: string;
        
    @Field({nullable: true, description: `The output result from the model.`}) 
    Result?: string;
        
    @Field(() => Int, {nullable: true, description: `Total number of tokens used (prompt + completion).`}) 
    TokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tokens in the prompt.`}) 
    TokensPrompt?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tokens in the completion/result.`}) 
    TokensCompletion?: number;
        
    @Field(() => Float, {nullable: true, description: `Total cost of this prompt run including its own cost plus all descendant costs. Calculated as Cost + DescendantCost. This value is stored (not computed) for query performance. Currency is specified in CostCurrency field.`}) 
    TotalCost?: number;
        
    @Field(() => Boolean, {description: `Whether the execution was successful.`}) 
    Success: boolean;
        
    @Field({nullable: true, description: `Error message if the execution failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `References the parent AIPromptRun.ID for hierarchical execution tracking. NULL for top-level runs, populated for parallel children and result selector runs.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Type of prompt run execution: Single (standard single prompt), ParallelParent (coordinator for parallel execution), ParallelChild (individual parallel execution), ResultSelector (result selection prompt that chooses best result)`}) 
    @MaxLength(20)
    RunType: string;
        
    @Field(() => Int, {nullable: true, description: `Execution order for parallel child runs and result selector runs. Used to track the sequence of execution within a parallel run group. NULL for single runs and parallel parent runs.`}) 
    ExecutionOrder?: number;
        
    @Field({nullable: true, description: `Optional reference to the AIAgentRun that initiated this prompt execution. Links prompt runs to their parent agent runs for comprehensive execution tracking.`}) 
    @MaxLength(36)
    AgentRunID?: string;
        
    @Field(() => Float, {nullable: true, description: `The cost of this specific prompt execution as reported by the AI provider. This does not include costs from child executions. The currency is specified in CostCurrency field.`}) 
    Cost?: number;
        
    @Field({nullable: true, description: `ISO 4217 currency code for the Cost field (e.g., USD, EUR, GBP). Different AI providers may use different currencies.`}) 
    @MaxLength(10)
    CostCurrency?: string;
        
    @Field(() => Int, {nullable: true, description: `Total tokens used including this execution and all child/grandchild executions. This provides a complete view of token usage for hierarchical prompt trees. Calculated as TokensPromptRollup + TokensCompletionRollup.`}) 
    TokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total prompt/input tokens including this execution and all child/grandchild executions. For leaf nodes (no children), this equals TokensPrompt. For parent nodes, this includes the sum of all descendant prompt tokens.`}) 
    TokensPromptRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total completion/output tokens including this execution and all child/grandchild executions. For leaf nodes (no children), this equals TokensCompletion. For parent nodes, this includes the sum of all descendant completion tokens.`}) 
    TokensCompletionRollup?: number;
        
    @Field(() => Float, {nullable: true, description: `The temperature parameter used for this prompt run, controlling randomness in the output (0.0 = deterministic, 2.0 = very random)`}) 
    Temperature?: number;
        
    @Field(() => Float, {nullable: true, description: `Top-p (nucleus) sampling parameter used for this run. Considers tokens with cumulative probability up to this value (0-1)`}) 
    TopP?: number;
        
    @Field(() => Int, {nullable: true, description: `Top-k sampling parameter used for this run. Limits sampling to the top K most likely tokens`}) 
    TopK?: number;
        
    @Field(() => Float, {nullable: true, description: `Minimum probability threshold used for token sampling (0-1). Tokens below this probability are filtered out`}) 
    MinP?: number;
        
    @Field(() => Float, {nullable: true, description: `Frequency penalty parameter used (-2.0 to 2.0). Positive values reduce repetition of tokens based on their frequency in the output`}) 
    FrequencyPenalty?: number;
        
    @Field(() => Float, {nullable: true, description: `Presence penalty parameter used (-2.0 to 2.0). Positive values encourage the model to talk about new topics`}) 
    PresencePenalty?: number;
        
    @Field(() => Int, {nullable: true, description: `Random seed used for reproducible outputs. When set, the same seed with identical inputs should produce the same output`}) 
    Seed?: number;
        
    @Field({nullable: true, description: `JSON array of stop sequences used. The model stops generating when any of these sequences are encountered`}) 
    StopSequences?: string;
        
    @Field({nullable: true, description: `The response format requested for this run (e.g., 'JSON', 'Text', 'Markdown')`}) 
    @MaxLength(50)
    ResponseFormat?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Whether log probabilities were requested for this run`}) 
    LogProbs?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of top log probabilities requested per token (if LogProbs is true)`}) 
    TopLogProbs?: number;
        
    @Field(() => Float, {nullable: true, description: `The total cost of all descendant (child and grandchild) prompt runs, excluding this run's own cost. For leaf nodes (no children), this is 0. Updated when child costs change.`}) 
    DescendantCost?: number;
        
    @Field(() => Int, {nullable: true, description: `Total number of validation attempts made (including the initial attempt)`}) 
    ValidationAttemptCount?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of validation attempts that passed validation`}) 
    SuccessfulValidationCount?: number;
        
    @Field(() => Boolean, {nullable: true, description: `Whether validation ultimately passed (1) or failed (0)`}) 
    FinalValidationPassed?: boolean;
        
    @Field({nullable: true, description: `Validation behavior used: Strict, Warn, or None`}) 
    @MaxLength(50)
    ValidationBehavior?: string;
        
    @Field({nullable: true, description: `Retry strategy used: Fixed, Linear, or Exponential`}) 
    @MaxLength(50)
    RetryStrategy?: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of retries configured on the prompt`}) 
    MaxRetriesConfigured?: number;
        
    @Field({nullable: true, description: `The final validation error message if validation failed`}) 
    @MaxLength(500)
    FinalValidationError?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of validation errors on the final attempt`}) 
    ValidationErrorCount?: number;
        
    @Field({nullable: true, description: `Most frequent validation error across all attempts`}) 
    @MaxLength(255)
    CommonValidationError?: string;
        
    @Field({nullable: true, description: `Timestamp of the first validation attempt`}) 
    FirstAttemptAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the last validation attempt`}) 
    LastAttemptAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total time spent on retries in milliseconds (excluding first attempt)`}) 
    TotalRetryDurationMS?: number;
        
    @Field({nullable: true, description: `JSON array containing detailed information about each validation attempt`}) 
    ValidationAttempts?: string;
        
    @Field({nullable: true, description: `JSON object containing summary information about the validation process`}) 
    ValidationSummary?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of failover attempts made during this prompt run`}) 
    FailoverAttempts?: number;
        
    @Field({nullable: true, description: `JSON array of error details from each failover attempt`}) 
    FailoverErrors?: string;
        
    @Field({nullable: true, description: `JSON array of duration in milliseconds for each failover attempt`}) 
    FailoverDurations?: string;
        
    @Field({nullable: true, description: `The AI Model ID that was originally attempted before any failovers`}) 
    @MaxLength(36)
    OriginalModelID?: string;
        
    @Field({nullable: true, description: `Timestamp when the original request started, before any failovers`}) 
    OriginalRequestStartTime?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total time spent in failover attempts in milliseconds`}) 
    TotalFailoverDuration?: number;
        
    @Field({nullable: true, description: `If this run was initiated as a re-run of another prompt run, this field links back to the original run ID`}) 
    @MaxLength(36)
    RerunFromPromptRunID?: string;
        
    @Field({nullable: true, description: `JSON object containing detailed model selection information including all models considered, their scores, and the selection rationale`}) 
    ModelSelection?: string;
        
    @Field({description: `Current execution status of the prompt run. Valid values: Pending, Running, Completed, Failed, Cancelled`}) 
    @MaxLength(50)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates whether this prompt run was cancelled before completion`}) 
    Cancelled: boolean;
        
    @Field({nullable: true, description: `Detailed reason for cancellation if the prompt run was cancelled. Could be user_requested, timeout, error, or resource_limit`}) 
    CancellationReason?: string;
        
    @Field(() => Int, {nullable: true, description: `Power rank of the model that was selected for this run. Lower numbers indicate more powerful models`}) 
    ModelPowerRank?: number;
        
    @Field({nullable: true, description: `Strategy used for model selection. Valid values: Default (system default), Specific (specific models configured), ByPower (based on power ranking)`}) 
    @MaxLength(50)
    SelectionStrategy?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this result was served from cache rather than executing a new model call`}) 
    CacheHit: boolean;
        
    @Field({nullable: true, description: `Unique key used for caching this prompt result, typically a hash of the prompt and parameters`}) 
    @MaxLength(500)
    CacheKey?: string;
        
    @Field({nullable: true, description: `ID of the AIPrompt used as a judge to evaluate and rank multiple parallel execution results`}) 
    @MaxLength(36)
    JudgeID?: string;
        
    @Field(() => Float, {nullable: true, description: `Score assigned by the judge prompt when evaluating multiple results. Higher scores indicate better results`}) 
    JudgeScore?: number;
        
    @Field(() => Boolean, {description: `Indicates whether this result was selected as the best result when multiple models were run in parallel`}) 
    WasSelectedResult: boolean;
        
    @Field(() => Boolean, {description: `Indicates whether streaming was enabled for this prompt execution`}) 
    StreamingEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds from request initiation to receiving the first token from the model`}) 
    FirstTokenTime?: number;
        
    @Field({nullable: true, description: `Detailed error information in JSON format if the prompt execution failed, including stack traces and error codes`}) 
    ErrorDetails?: string;
        
    @Field({nullable: true, description: `References the specific child prompt that was executed as part of hierarchical prompt composition. NULL for regular prompts or parent prompts that don't directly execute a child.`}) 
    @MaxLength(36)
    ChildPromptID?: string;
        
    @Field(() => Int, {nullable: true, description: `Queue time in milliseconds before the model started processing the request. Provider-specific timing metric.`}) 
    QueueTime?: number;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds for the model to ingest and process the prompt. Provider-specific timing metric.`}) 
    PromptTime?: number;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds for the model to generate the completion/response tokens. Provider-specific timing metric.`}) 
    CompletionTime?: number;
        
    @Field({nullable: true, description: `JSON field containing provider-specific response metadata and details not captured in standard fields. Structure varies by AI provider.`}) 
    ModelSpecificResponseDetails?: string;
        
    @Field(() => Int, {nullable: true, description: `Effort level that was actually used during this prompt run execution (1-100, where 1=minimal effort, 100=maximum effort). This is the resolved effort level after applying the precedence hierarchy: runtime override > agent default > prompt default > provider default.`}) 
    EffortLevel?: number;
        
    @Field({nullable: true, description: `Optional name for the prompt run to help identify and tag runs for easier reference`}) 
    @MaxLength(255)
    RunName?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this prompt run`}) 
    Comments?: string;
        
    @Field({nullable: true, description: `Optional Foreign Key - Links this prompt run to a test run if this prompt execution was part of a test. Enables testing individual prompts for quality and consistency before agent integration.`}) 
    @MaxLength(36)
    TestRunID?: string;
        
    @Field() 
    @MaxLength(255)
    Prompt: string;
        
    @Field() 
    @MaxLength(50)
    Model: string;
        
    @Field() 
    @MaxLength(50)
    Vendor: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    AgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    OriginalModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    RerunFromPromptRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Judge?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ChildPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    TestRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootRerunFromPromptRunID?: string;
        
    @Field(() => [MJAIPromptRun_])
    MJAIPromptRuns_ParentIDArray: MJAIPromptRun_[]; // Link to MJAIPromptRuns
    
    @Field(() => [MJAIPromptRunMedia_])
    MJAIPromptRunMedias_PromptRunIDArray: MJAIPromptRunMedia_[]; // Link to MJAIPromptRunMedias
    
    @Field(() => [MJAIResultCache_])
    MJAIResultCache_PromptRunIDArray: MJAIResultCache_[]; // Link to MJAIResultCache
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Runs
//****************************************************************************
@InputType()
export class CreateMJAIPromptRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Int, { nullable: true })
    ExecutionTimeMS: number | null;

    @Field({ nullable: true })
    Messages: string | null;

    @Field({ nullable: true })
    Result: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TokensPrompt: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletion: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    RunType?: string;

    @Field(() => Int, { nullable: true })
    ExecutionOrder: number | null;

    @Field({ nullable: true })
    AgentRunID: string | null;

    @Field(() => Float, { nullable: true })
    Cost: number | null;

    @Field({ nullable: true })
    CostCurrency: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TokensPromptRollup: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletionRollup: number | null;

    @Field(() => Float, { nullable: true })
    Temperature: number | null;

    @Field(() => Float, { nullable: true })
    TopP: number | null;

    @Field(() => Int, { nullable: true })
    TopK: number | null;

    @Field(() => Float, { nullable: true })
    MinP: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty: number | null;

    @Field(() => Int, { nullable: true })
    Seed: number | null;

    @Field({ nullable: true })
    StopSequences: string | null;

    @Field({ nullable: true })
    ResponseFormat: string | null;

    @Field(() => Boolean, { nullable: true })
    LogProbs: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs: number | null;

    @Field(() => Float, { nullable: true })
    DescendantCost: number | null;

    @Field(() => Int, { nullable: true })
    ValidationAttemptCount: number | null;

    @Field(() => Int, { nullable: true })
    SuccessfulValidationCount: number | null;

    @Field(() => Boolean, { nullable: true })
    FinalValidationPassed: boolean | null;

    @Field({ nullable: true })
    ValidationBehavior: string | null;

    @Field({ nullable: true })
    RetryStrategy: string | null;

    @Field(() => Int, { nullable: true })
    MaxRetriesConfigured: number | null;

    @Field({ nullable: true })
    FinalValidationError: string | null;

    @Field(() => Int, { nullable: true })
    ValidationErrorCount: number | null;

    @Field({ nullable: true })
    CommonValidationError: string | null;

    @Field({ nullable: true })
    FirstAttemptAt: Date | null;

    @Field({ nullable: true })
    LastAttemptAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRetryDurationMS: number | null;

    @Field({ nullable: true })
    ValidationAttempts: string | null;

    @Field({ nullable: true })
    ValidationSummary: string | null;

    @Field(() => Int, { nullable: true })
    FailoverAttempts?: number | null;

    @Field({ nullable: true })
    FailoverErrors: string | null;

    @Field({ nullable: true })
    FailoverDurations: string | null;

    @Field({ nullable: true })
    OriginalModelID: string | null;

    @Field({ nullable: true })
    OriginalRequestStartTime: Date | null;

    @Field(() => Int, { nullable: true })
    TotalFailoverDuration: number | null;

    @Field({ nullable: true })
    RerunFromPromptRunID: string | null;

    @Field({ nullable: true })
    ModelSelection: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Cancelled?: boolean;

    @Field({ nullable: true })
    CancellationReason: string | null;

    @Field(() => Int, { nullable: true })
    ModelPowerRank: number | null;

    @Field({ nullable: true })
    SelectionStrategy: string | null;

    @Field(() => Boolean, { nullable: true })
    CacheHit?: boolean;

    @Field({ nullable: true })
    CacheKey: string | null;

    @Field({ nullable: true })
    JudgeID: string | null;

    @Field(() => Float, { nullable: true })
    JudgeScore: number | null;

    @Field(() => Boolean, { nullable: true })
    WasSelectedResult?: boolean;

    @Field(() => Boolean, { nullable: true })
    StreamingEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    FirstTokenTime: number | null;

    @Field({ nullable: true })
    ErrorDetails: string | null;

    @Field({ nullable: true })
    ChildPromptID: string | null;

    @Field(() => Int, { nullable: true })
    QueueTime: number | null;

    @Field(() => Int, { nullable: true })
    PromptTime: number | null;

    @Field(() => Int, { nullable: true })
    CompletionTime: number | null;

    @Field({ nullable: true })
    ModelSpecificResponseDetails: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;

    @Field({ nullable: true })
    RunName: string | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    TestRunID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Runs
//****************************************************************************
@InputType()
export class UpdateMJAIPromptRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    ExecutionTimeMS?: number | null;

    @Field({ nullable: true })
    Messages?: string | null;

    @Field({ nullable: true })
    Result?: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TokensPrompt?: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletion?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    RunType?: string;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number | null;

    @Field({ nullable: true })
    AgentRunID?: string | null;

    @Field(() => Float, { nullable: true })
    Cost?: number | null;

    @Field({ nullable: true })
    CostCurrency?: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TokensPromptRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletionRollup?: number | null;

    @Field(() => Float, { nullable: true })
    Temperature?: number | null;

    @Field(() => Float, { nullable: true })
    TopP?: number | null;

    @Field(() => Int, { nullable: true })
    TopK?: number | null;

    @Field(() => Float, { nullable: true })
    MinP?: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty?: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty?: number | null;

    @Field(() => Int, { nullable: true })
    Seed?: number | null;

    @Field({ nullable: true })
    StopSequences?: string | null;

    @Field({ nullable: true })
    ResponseFormat?: string | null;

    @Field(() => Boolean, { nullable: true })
    LogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs?: number | null;

    @Field(() => Float, { nullable: true })
    DescendantCost?: number | null;

    @Field(() => Int, { nullable: true })
    ValidationAttemptCount?: number | null;

    @Field(() => Int, { nullable: true })
    SuccessfulValidationCount?: number | null;

    @Field(() => Boolean, { nullable: true })
    FinalValidationPassed?: boolean | null;

    @Field({ nullable: true })
    ValidationBehavior?: string | null;

    @Field({ nullable: true })
    RetryStrategy?: string | null;

    @Field(() => Int, { nullable: true })
    MaxRetriesConfigured?: number | null;

    @Field({ nullable: true })
    FinalValidationError?: string | null;

    @Field(() => Int, { nullable: true })
    ValidationErrorCount?: number | null;

    @Field({ nullable: true })
    CommonValidationError?: string | null;

    @Field({ nullable: true })
    FirstAttemptAt?: Date | null;

    @Field({ nullable: true })
    LastAttemptAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRetryDurationMS?: number | null;

    @Field({ nullable: true })
    ValidationAttempts?: string | null;

    @Field({ nullable: true })
    ValidationSummary?: string | null;

    @Field(() => Int, { nullable: true })
    FailoverAttempts?: number | null;

    @Field({ nullable: true })
    FailoverErrors?: string | null;

    @Field({ nullable: true })
    FailoverDurations?: string | null;

    @Field({ nullable: true })
    OriginalModelID?: string | null;

    @Field({ nullable: true })
    OriginalRequestStartTime?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalFailoverDuration?: number | null;

    @Field({ nullable: true })
    RerunFromPromptRunID?: string | null;

    @Field({ nullable: true })
    ModelSelection?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Cancelled?: boolean;

    @Field({ nullable: true })
    CancellationReason?: string | null;

    @Field(() => Int, { nullable: true })
    ModelPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string | null;

    @Field(() => Boolean, { nullable: true })
    CacheHit?: boolean;

    @Field({ nullable: true })
    CacheKey?: string | null;

    @Field({ nullable: true })
    JudgeID?: string | null;

    @Field(() => Float, { nullable: true })
    JudgeScore?: number | null;

    @Field(() => Boolean, { nullable: true })
    WasSelectedResult?: boolean;

    @Field(() => Boolean, { nullable: true })
    StreamingEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    FirstTokenTime?: number | null;

    @Field({ nullable: true })
    ErrorDetails?: string | null;

    @Field({ nullable: true })
    ChildPromptID?: string | null;

    @Field(() => Int, { nullable: true })
    QueueTime?: number | null;

    @Field(() => Int, { nullable: true })
    PromptTime?: number | null;

    @Field(() => Int, { nullable: true })
    CompletionTime?: number | null;

    @Field({ nullable: true })
    ModelSpecificResponseDetails?: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field({ nullable: true })
    RunName?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    TestRunID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Runs
//****************************************************************************
@ObjectType()
export class RunMJAIPromptRunViewResult {
    @Field(() => [MJAIPromptRun_])
    Results: MJAIPromptRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptRun_)
export class MJAIPromptRunResolver extends ResolverBase {
    @Query(() => RunMJAIPromptRunViewResult)
    async RunMJAIPromptRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptRunViewResult)
    async RunMJAIPromptRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptRunViewResult)
    async RunMJAIPromptRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptRun_, { nullable: true })
    async MJAIPromptRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptRun_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIPromptRun_])
    async MJAIPromptRuns_ParentIDArray(@Root() mjaipromptrun_: MJAIPromptRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjaipromptrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRunMedia_])
    async MJAIPromptRunMedias_PromptRunIDArray(@Root() mjaipromptrun_: MJAIPromptRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRunMedias')} WHERE ${provider.QuoteIdentifier('PromptRunID')}='${mjaipromptrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async MJAIResultCache_PromptRunIDArray(@Root() mjaipromptrun_: MJAIPromptRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIResultCaches')} WHERE ${provider.QuoteIdentifier('PromptRunID')}='${mjaipromptrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptRun_)
    async CreateMJAIPromptRun(
        @Arg('input', () => CreateMJAIPromptRunInput) input: CreateMJAIPromptRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptRun_)
    async UpdateMJAIPromptRun(
        @Arg('input', () => UpdateMJAIPromptRunInput) input: UpdateMJAIPromptRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptRun_)
    async DeleteMJAIPromptRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Types
//****************************************************************************
@ObjectType({ description: `Types of AI prompts such as Chat, Text-to-Image, Text-to-Video, etc.` })
export class MJAIPromptType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIPrompt_])
    MJAIPrompts_TypeIDArray: MJAIPrompt_[]; // Link to MJAIPrompts
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Types
//****************************************************************************
@InputType()
export class CreateMJAIPromptTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Types
//****************************************************************************
@InputType()
export class UpdateMJAIPromptTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Types
//****************************************************************************
@ObjectType()
export class RunMJAIPromptTypeViewResult {
    @Field(() => [MJAIPromptType_])
    Results: MJAIPromptType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptType_)
export class MJAIPromptTypeResolver extends ResolverBase {
    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptType_, { nullable: true })
    async MJAIPromptType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompt Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIPrompt_])
    async MJAIPrompts_TypeIDArray(@Root() mjaiprompttype_: MJAIPromptType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPrompts')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjaiprompttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptType_)
    async CreateMJAIPromptType(
        @Arg('input', () => CreateMJAIPromptTypeInput) input: CreateMJAIPromptTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptType_)
    async UpdateMJAIPromptType(
        @Arg('input', () => UpdateMJAIPromptTypeInput) input: UpdateMJAIPromptTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptType_)
    async DeleteMJAIPromptType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompts
//****************************************************************************
@ObjectType({ description: `Stores AI prompts, including references to categories, types, and templates.` })
export class MJAIPrompt_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Reference to the template used for the prompt.`}) 
    @MaxLength(36)
    TemplateID: string;
        
    @Field({nullable: true, description: `Reference to the category the prompt belongs to.`}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field({description: `Reference to the type of the prompt.`}) 
    @MaxLength(36)
    TypeID: string;
        
    @Field() 
    @MaxLength(50)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Specifies the expected response format for the AI model. Options include Any, Text, Markdown, JSON, and ModelSpecific. Defaults to Any if not specified.`}) 
    @MaxLength(20)
    ResponseFormat: string;
        
    @Field({nullable: true, description: `A JSON-formatted string containing model-specific response format instructions. This will be parsed and provided as a JSON object to the model.`}) 
    ModelSpecificResponseFormat?: string;
        
    @Field({nullable: true, description: `References the type of AI model this prompt is designed for (LLM, Image, Audio, etc.).`}) 
    @MaxLength(36)
    AIModelTypeID?: string;
        
    @Field(() => Int, {nullable: true, description: `The minimum power rank required for models to be considered for this prompt.`}) 
    MinPowerRank?: number;
        
    @Field({description: `Determines how models are selected for this prompt (Default, Specific, ByPower).`}) 
    @MaxLength(20)
    SelectionStrategy: string;
        
    @Field({description: `When using ByPower selection strategy, determines whether to prefer highest, lowest, or balanced power models.`}) 
    @MaxLength(20)
    PowerPreference: string;
        
    @Field({description: `Controls parallelization: None (no parallelization), StaticCount (use AIPrompt.ParallelCount for total runs), ConfigParam (use config param specified in ParallelConfigParam for total runs), or ModelSpecific (check each AIPromptModel's individual settings).`}) 
    @MaxLength(20)
    ParallelizationMode: string;
        
    @Field(() => Int, {nullable: true, description: `When ParallelizationMode is StaticCount, specifies the number of parallel executions.`}) 
    ParallelCount?: number;
        
    @Field({nullable: true, description: `When ParallelizationMode is ConfigParam, specifies the name of the configuration parameter that contains the parallel count.`}) 
    @MaxLength(100)
    ParallelConfigParam?: string;
        
    @Field({description: `The expected data type of the prompt output: string, number, boolean, date, or object.`}) 
    @MaxLength(50)
    OutputType: string;
        
    @Field({nullable: true, description: `JSON example output when OutputType is "object", used for validating structured outputs.`}) 
    OutputExample?: string;
        
    @Field({description: `Determines how validation failures are handled: Strict (fail), Warn (log warning), or None (ignore).`}) 
    @MaxLength(50)
    ValidationBehavior: string;
        
    @Field(() => Int, {description: `Maximum number of retry attempts for API failures.`}) 
    MaxRetries: number;
        
    @Field(() => Int, {description: `Delay between retry attempts in milliseconds.`}) 
    RetryDelayMS: number;
        
    @Field({description: `Strategy for calculating retry delays: Fixed (same delay each time), Exponential (doubling delay), or Linear (linearly increasing delay).`}) 
    @MaxLength(20)
    RetryStrategy: string;
        
    @Field({nullable: true, description: `References another prompt that selects the best result from multiple parallel executions.`}) 
    @MaxLength(36)
    ResultSelectorPromptID?: string;
        
    @Field(() => Boolean, {description: `When true, results from this prompt will be cached for potential reuse.`}) 
    EnableCaching: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time-to-live in seconds for cached results. NULL means results never expire.`}) 
    CacheTTLSeconds?: number;
        
    @Field({description: `Method for matching cached results: Exact (string matching) or Vector (embedding similarity).`}) 
    @MaxLength(20)
    CacheMatchType: string;
        
    @Field(() => Float, {nullable: true, description: `Threshold (0-1) for vector similarity matching. Higher values require closer matches.`}) 
    CacheSimilarityThreshold?: number;
        
    @Field(() => Boolean, {description: `When true, the AI model must match for a cache hit. When false, results from any model can be used.`}) 
    CacheMustMatchModel: boolean;
        
    @Field(() => Boolean, {description: `When true, the vendor must match for a cache hit. When false, results from any vendor can be used.`}) 
    CacheMustMatchVendor: boolean;
        
    @Field(() => Boolean, {description: `When true, the agent context must match for a cache hit. When false, agent-specific and non-agent results can be used interchangeably.`}) 
    CacheMustMatchAgent: boolean;
        
    @Field(() => Boolean, {description: `When true, the configuration must match for a cache hit. When false, results from any configuration can be used.`}) 
    CacheMustMatchConfig: boolean;
        
    @Field({description: `Determines how the prompt is used in conversation: System (always first message), User (positioned by PromptPosition), Assistant (positioned by PromptPosition), or SystemOrUser (try system first, fallback to user last if system slot taken)`}) 
    @MaxLength(20)
    PromptRole: string;
        
    @Field({description: `Controls message placement for User and Assistant role prompts: First (beginning of conversation) or Last (end of conversation). Not used for System role prompts which are always first`}) 
    @MaxLength(20)
    PromptPosition: string;
        
    @Field(() => Float, {nullable: true, description: `Default temperature setting for this prompt. Controls randomness in the output. 0 = more focused and deterministic, 2 = more random and creative. Can be overridden at runtime.`}) 
    Temperature?: number;
        
    @Field(() => Float, {nullable: true, description: `Default TopP (nucleus sampling) for this prompt. Only consider tokens with cumulative probability up to this value. 1 = consider all tokens. Can be overridden at runtime.`}) 
    TopP?: number;
        
    @Field(() => Int, {nullable: true, description: `Default TopK sampling for this prompt. Only sample from the top K tokens. Lower values reduce randomness. Can be overridden at runtime.`}) 
    TopK?: number;
        
    @Field(() => Float, {nullable: true, description: `Default MinP (minimum probability) for this prompt. Tokens with probability below this threshold are filtered out. Can be overridden at runtime.`}) 
    MinP?: number;
        
    @Field(() => Float, {nullable: true, description: `Default frequency penalty for this prompt. Penalizes tokens based on their frequency in the text. Positive values decrease likelihood of repetition. Can be overridden at runtime.`}) 
    FrequencyPenalty?: number;
        
    @Field(() => Float, {nullable: true, description: `Default presence penalty for this prompt. Penalizes tokens that have appeared in the text. Positive values increase topic diversity. Can be overridden at runtime.`}) 
    PresencePenalty?: number;
        
    @Field(() => Int, {nullable: true, description: `Default random seed for this prompt. Used for deterministic generation. Same seed produces same output. Can be overridden at runtime.`}) 
    Seed?: number;
        
    @Field({nullable: true, description: `Default stop sequences for this prompt. Comma-delimited list of sequences that will stop generation when encountered. Can be overridden at runtime.`}) 
    @MaxLength(1000)
    StopSequences?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Default setting for including log probabilities in the response. Can be overridden at runtime.`}) 
    IncludeLogProbs?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Default number of top log probabilities to include when IncludeLogProbs is true. Can be overridden at runtime.`}) 
    TopLogProbs?: number;
        
    @Field({description: `Failover strategy to use when the primary model fails. Options: SameModelDifferentVendor, NextBestModel, PowerRank, None`}) 
    @MaxLength(50)
    FailoverStrategy: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of failover attempts before giving up`}) 
    FailoverMaxAttempts?: number;
        
    @Field(() => Int, {nullable: true, description: `Initial delay in seconds between failover attempts`}) 
    FailoverDelaySeconds?: number;
        
    @Field({description: `Strategy for selecting failover models. Options: PreferSameModel, PreferDifferentModel, RequireSameModel`}) 
    @MaxLength(50)
    FailoverModelStrategy: string;
        
    @Field({description: `Types of errors that should trigger failover. Options: All, NetworkOnly, RateLimitOnly, ServiceErrorOnly`}) 
    @MaxLength(50)
    FailoverErrorScope: string;
        
    @Field(() => Int, {nullable: true, description: `Effort level for this specific prompt (1-100, where 1=minimal effort, 100=maximum effort). Higher values request more thorough reasoning and analysis. Can be overridden by agent DefaultPromptEffortLevel or runtime parameters.`}) 
    EffortLevel?: number;
        
    @Field() 
    @MaxLength(255)
    Template: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Category?: string;
        
    @Field() 
    @MaxLength(255)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    AIModelType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ResultSelectorPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootResultSelectorPromptID?: string;
        
    @Field(() => [MJAIResultCache_])
    MJAIResultCache_AIPromptIDArray: MJAIResultCache_[]; // Link to MJAIResultCache
    
    @Field(() => [MJAIConfiguration_])
    MJAIConfigurations_DefaultPromptForContextCompressionIDArray: MJAIConfiguration_[]; // Link to MJAIConfigurations
    
    @Field(() => [MJAIAgentType_])
    MJAIAgentTypes_SystemPromptIDArray: MJAIAgentType_[]; // Link to MJAIAgentTypes
    
    @Field(() => [MJAIAgentAction_])
    MJAIAgentActions_CompactPromptIDArray: MJAIAgentAction_[]; // Link to MJAIAgentActions
    
    @Field(() => [MJAIConfiguration_])
    MJAIConfigurations_DefaultPromptForContextSummarizationIDArray: MJAIConfiguration_[]; // Link to MJAIConfigurations
    
    @Field(() => [MJAIPrompt_])
    MJAIPrompts_ResultSelectorPromptIDArray: MJAIPrompt_[]; // Link to MJAIPrompts
    
    @Field(() => [MJAIPromptModel_])
    MJAIPromptModels_PromptIDArray: MJAIPromptModel_[]; // Link to MJAIPromptModels
    
    @Field(() => [MJAIAgentPrompt_])
    MJAIAgentPrompts_PromptIDArray: MJAIAgentPrompt_[]; // Link to MJAIAgentPrompts
    
    @Field(() => [MJAIAgentStep_])
    MJAIAgentSteps_PromptIDArray: MJAIAgentStep_[]; // Link to MJAIAgentSteps
    
    @Field(() => [MJAIPromptRun_])
    MJAIPromptRuns_PromptIDArray: MJAIPromptRun_[]; // Link to MJAIPromptRuns
    
    @Field(() => [MJAIAgent_])
    MJAIAgents_ContextCompressionPromptIDArray: MJAIAgent_[]; // Link to MJAIAgents
    
    @Field(() => [MJAction_])
    MJActions_DefaultCompactPromptIDArray: MJAction_[]; // Link to MJActions
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompts
//****************************************************************************
@InputType()
export class CreateMJAIPromptInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat: string | null;

    @Field({ nullable: true })
    AIModelTypeID: string | null;

    @Field(() => Int, { nullable: true })
    MinPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string;

    @Field({ nullable: true })
    PowerPreference?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount: number | null;

    @Field({ nullable: true })
    ParallelConfigParam: string | null;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputExample: string | null;

    @Field({ nullable: true })
    ValidationBehavior?: string;

    @Field(() => Int, { nullable: true })
    MaxRetries?: number;

    @Field(() => Int, { nullable: true })
    RetryDelayMS?: number;

    @Field({ nullable: true })
    RetryStrategy?: string;

    @Field({ nullable: true })
    ResultSelectorPromptID: string | null;

    @Field(() => Boolean, { nullable: true })
    EnableCaching?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLSeconds: number | null;

    @Field({ nullable: true })
    CacheMatchType?: string;

    @Field(() => Float, { nullable: true })
    CacheSimilarityThreshold: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchModel?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchVendor?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchAgent?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchConfig?: boolean;

    @Field({ nullable: true })
    PromptRole?: string;

    @Field({ nullable: true })
    PromptPosition?: string;

    @Field(() => Float, { nullable: true })
    Temperature: number | null;

    @Field(() => Float, { nullable: true })
    TopP: number | null;

    @Field(() => Int, { nullable: true })
    TopK: number | null;

    @Field(() => Float, { nullable: true })
    MinP: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty: number | null;

    @Field(() => Int, { nullable: true })
    Seed: number | null;

    @Field({ nullable: true })
    StopSequences: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeLogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs: number | null;

    @Field({ nullable: true })
    FailoverStrategy?: string;

    @Field(() => Int, { nullable: true })
    FailoverMaxAttempts?: number | null;

    @Field(() => Int, { nullable: true })
    FailoverDelaySeconds?: number | null;

    @Field({ nullable: true })
    FailoverModelStrategy?: string;

    @Field({ nullable: true })
    FailoverErrorScope?: string;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompts
//****************************************************************************
@InputType()
export class UpdateMJAIPromptInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat?: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string | null;

    @Field(() => Int, { nullable: true })
    MinPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string;

    @Field({ nullable: true })
    PowerPreference?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number | null;

    @Field({ nullable: true })
    ParallelConfigParam?: string | null;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputExample?: string | null;

    @Field({ nullable: true })
    ValidationBehavior?: string;

    @Field(() => Int, { nullable: true })
    MaxRetries?: number;

    @Field(() => Int, { nullable: true })
    RetryDelayMS?: number;

    @Field({ nullable: true })
    RetryStrategy?: string;

    @Field({ nullable: true })
    ResultSelectorPromptID?: string | null;

    @Field(() => Boolean, { nullable: true })
    EnableCaching?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLSeconds?: number | null;

    @Field({ nullable: true })
    CacheMatchType?: string;

    @Field(() => Float, { nullable: true })
    CacheSimilarityThreshold?: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchModel?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchVendor?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchAgent?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchConfig?: boolean;

    @Field({ nullable: true })
    PromptRole?: string;

    @Field({ nullable: true })
    PromptPosition?: string;

    @Field(() => Float, { nullable: true })
    Temperature?: number | null;

    @Field(() => Float, { nullable: true })
    TopP?: number | null;

    @Field(() => Int, { nullable: true })
    TopK?: number | null;

    @Field(() => Float, { nullable: true })
    MinP?: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty?: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty?: number | null;

    @Field(() => Int, { nullable: true })
    Seed?: number | null;

    @Field({ nullable: true })
    StopSequences?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeLogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs?: number | null;

    @Field({ nullable: true })
    FailoverStrategy?: string;

    @Field(() => Int, { nullable: true })
    FailoverMaxAttempts?: number | null;

    @Field(() => Int, { nullable: true })
    FailoverDelaySeconds?: number | null;

    @Field({ nullable: true })
    FailoverModelStrategy?: string;

    @Field({ nullable: true })
    FailoverErrorScope?: string;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompts
//****************************************************************************
@ObjectType()
export class RunMJAIPromptViewResult {
    @Field(() => [MJAIPrompt_])
    Results: MJAIPrompt_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPrompt_)
export class MJAIPromptResolver extends ResolverBase {
    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPrompt_, { nullable: true })
    async MJAIPrompt(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPrompt_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPrompts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIResultCache_])
    async MJAIResultCache_AIPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIResultCaches')} WHERE ${provider.QuoteIdentifier('AIPromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIConfiguration_])
    async MJAIConfigurations_DefaultPromptForContextCompressionIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIConfigurations')} WHERE ${provider.QuoteIdentifier('DefaultPromptForContextCompressionID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentType_])
    async MJAIAgentTypes_SystemPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentTypes')} WHERE ${provider.QuoteIdentifier('SystemPromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentAction_])
    async MJAIAgentActions_CompactPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentActions')} WHERE ${provider.QuoteIdentifier('CompactPromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIConfiguration_])
    async MJAIConfigurations_DefaultPromptForContextSummarizationIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIConfigurations')} WHERE ${provider.QuoteIdentifier('DefaultPromptForContextSummarizationID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPrompt_])
    async MJAIPrompts_ResultSelectorPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPrompts')} WHERE ${provider.QuoteIdentifier('ResultSelectorPromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptModel_])
    async MJAIPromptModels_PromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptModels')} WHERE ${provider.QuoteIdentifier('PromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPrompt_])
    async MJAIAgentPrompts_PromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentPrompts')} WHERE ${provider.QuoteIdentifier('PromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStep_])
    async MJAIAgentSteps_PromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentSteps')} WHERE ${provider.QuoteIdentifier('PromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJAIPromptRuns_PromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('PromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async MJAIAgents_ContextCompressionPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgents')} WHERE ${provider.QuoteIdentifier('ContextCompressionPromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async MJActions_DefaultCompactPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActions')} WHERE ${provider.QuoteIdentifier('DefaultCompactPromptID')}='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPrompt_)
    async CreateMJAIPrompt(
        @Arg('input', () => CreateMJAIPromptInput) input: CreateMJAIPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPrompt_)
    async UpdateMJAIPrompt(
        @Arg('input', () => UpdateMJAIPromptInput) input: UpdateMJAIPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPrompt_)
    async DeleteMJAIPrompt(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Result Cache
//****************************************************************************
@ObjectType({ description: `Stores cached results of AI prompts, including multiple runs for history and tracking purposes.` })
export class MJAIResultCache_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the AI prompt this result corresponds to.`}) 
    @MaxLength(36)
    AIPromptID: string;
        
    @Field({description: `Reference to the AI model that generated this result.`}) 
    @MaxLength(36)
    AIModelID: string;
        
    @Field({description: `Timestamp of when this result was generated.`}) 
    RunAt: Date;
        
    @Field({description: `The prompt text used to generate this result.`}) 
    PromptText: string;
        
    @Field({nullable: true, description: `The text of the result generated by the AI model.`}) 
    ResultText?: string;
        
    @Field({description: `The status of this result, indicating whether it is currently active or expired.`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp of when this result was marked as expired.`}) 
    ExpiredOn?: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The vendor that provided this result.`}) 
    @MaxLength(36)
    VendorID?: string;
        
    @Field({nullable: true, description: `The agent that initiated the request, if any.`}) 
    @MaxLength(36)
    AgentID?: string;
        
    @Field({nullable: true, description: `The configuration used for this execution.`}) 
    @MaxLength(36)
    ConfigurationID?: string;
        
    @Field(() => Int, {nullable: true, description: `Vector representation of the prompt for similarity matching.`}) 
    PromptEmbedding?: number;
        
    @Field({nullable: true, description: `Reference to the AIPromptRun that created this cache entry.`}) 
    @MaxLength(36)
    PromptRunID?: string;
        
    @Field() 
    @MaxLength(255)
    AIPrompt: string;
        
    @Field() 
    @MaxLength(50)
    AIModel: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    PromptRun?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Result Cache
//****************************************************************************
@InputType()
export class CreateMJAIResultCacheInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn: Date | null;

    @Field({ nullable: true })
    VendorID: string | null;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field(() => Int, { nullable: true })
    PromptEmbedding: number | null;

    @Field({ nullable: true })
    PromptRunID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Result Cache
//****************************************************************************
@InputType()
export class UpdateMJAIResultCacheInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn?: Date | null;

    @Field({ nullable: true })
    VendorID?: string | null;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field(() => Int, { nullable: true })
    PromptEmbedding?: number | null;

    @Field({ nullable: true })
    PromptRunID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Result Cache
//****************************************************************************
@ObjectType()
export class RunMJAIResultCacheViewResult {
    @Field(() => [MJAIResultCache_])
    Results: MJAIResultCache_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIResultCache_)
export class MJAIResultCacheResolver extends ResolverBase {
    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Result Cache';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIResultCache_, { nullable: true })
    async MJAIResultCache(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIResultCache_ | null> {
        this.CheckUserReadPermissions('MJ: AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIResultCaches')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Result Cache', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIResultCache_)
    async CreateMJAIResultCache(
        @Arg('input', () => CreateMJAIResultCacheInput) input: CreateMJAIResultCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Result Cache', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIResultCache_)
    async UpdateMJAIResultCache(
        @Arg('input', () => UpdateMJAIResultCacheInput) input: UpdateMJAIResultCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Result Cache', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIResultCache_)
    async DeleteMJAIResultCache(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Result Cache', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendor Type Definitions
//****************************************************************************
@ObjectType({ description: `Defines the possible types of AI vendors, such as Model Developer or Inference Provider.` })
export class MJAIVendorTypeDefinition_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The name of the vendor type.`}) 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the vendor type.`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIModelVendor_])
    MJAIModelVendors_TypeIDArray: MJAIModelVendor_[]; // Link to MJAIModelVendors
    
    @Field(() => [MJAIVendorType_])
    MJAIVendorTypes_TypeIDArray: MJAIVendorType_[]; // Link to MJAIVendorTypes
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Type Definitions
//****************************************************************************
@InputType()
export class CreateMJAIVendorTypeDefinitionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Type Definitions
//****************************************************************************
@InputType()
export class UpdateMJAIVendorTypeDefinitionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendor Type Definitions
//****************************************************************************
@ObjectType()
export class RunMJAIVendorTypeDefinitionViewResult {
    @Field(() => [MJAIVendorTypeDefinition_])
    Results: MJAIVendorTypeDefinition_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIVendorTypeDefinition_)
export class MJAIVendorTypeDefinitionResolver extends ResolverBase {
    @Query(() => RunMJAIVendorTypeDefinitionViewResult)
    async RunMJAIVendorTypeDefinitionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorTypeDefinitionViewResult)
    async RunMJAIVendorTypeDefinitionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorTypeDefinitionViewResult)
    async RunMJAIVendorTypeDefinitionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendor Type Definitions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIVendorTypeDefinition_, { nullable: true })
    async MJAIVendorTypeDefinition(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIVendorTypeDefinition_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendor Type Definitions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIVendorTypeDefinitions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Type Definitions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Vendor Type Definitions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModelVendor_])
    async MJAIModelVendors_TypeIDArray(@Root() mjaivendortypedefinition_: MJAIVendorTypeDefinition_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelVendors')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjaivendortypedefinition_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIVendorType_])
    async MJAIVendorTypes_TypeIDArray(@Root() mjaivendortypedefinition_: MJAIVendorTypeDefinition_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIVendorTypes')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjaivendortypedefinition_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Vendor Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIVendorTypeDefinition_)
    async CreateMJAIVendorTypeDefinition(
        @Arg('input', () => CreateMJAIVendorTypeDefinitionInput) input: CreateMJAIVendorTypeDefinitionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendor Type Definitions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIVendorTypeDefinition_)
    async UpdateMJAIVendorTypeDefinition(
        @Arg('input', () => UpdateMJAIVendorTypeDefinitionInput) input: UpdateMJAIVendorTypeDefinitionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendor Type Definitions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIVendorTypeDefinition_)
    async DeleteMJAIVendorTypeDefinition(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendor Type Definitions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendor Types
//****************************************************************************
@ObjectType({ description: `Associates vendors with their types (Model Developer, Inference Provider) and tracks the status of each role.` })
export class MJAIVendorType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    VendorID: string;
        
    @Field() 
    @MaxLength(36)
    TypeID: string;
        
    @Field(() => Int, {description: `Determines the priority rank of this type for the vendor. Higher values indicate higher priority.`}) 
    Rank: number;
        
    @Field({description: `The current status of this vendor type. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    Vendor: string;
        
    @Field() 
    @MaxLength(50)
    Type: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Types
//****************************************************************************
@InputType()
export class CreateMJAIVendorTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Types
//****************************************************************************
@InputType()
export class UpdateMJAIVendorTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendor Types
//****************************************************************************
@ObjectType()
export class RunMJAIVendorTypeViewResult {
    @Field(() => [MJAIVendorType_])
    Results: MJAIVendorType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIVendorType_)
export class MJAIVendorTypeResolver extends ResolverBase {
    @Query(() => RunMJAIVendorTypeViewResult)
    async RunMJAIVendorTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorTypeViewResult)
    async RunMJAIVendorTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorTypeViewResult)
    async RunMJAIVendorTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendor Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIVendorType_, { nullable: true })
    async MJAIVendorType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIVendorType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIVendorTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Vendor Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIVendorType_)
    async CreateMJAIVendorType(
        @Arg('input', () => CreateMJAIVendorTypeInput) input: CreateMJAIVendorTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendor Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIVendorType_)
    async UpdateMJAIVendorType(
        @Arg('input', () => UpdateMJAIVendorTypeInput) input: UpdateMJAIVendorTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendor Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIVendorType_)
    async DeleteMJAIVendorType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendor Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendors
//****************************************************************************
@ObjectType({ description: `Stores information about AI vendors providing models and/or inference services.` })
export class MJAIVendor_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The unique name of the vendor.`}) 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the vendor and their AI offerings.`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Reference to the type of credential this vendor expects (e.g., API Key, GCP Service Account, Azure Service Principal). Used for type-based default credential resolution when no explicit binding exists, and for UI guidance when creating credentials.`}) 
    @MaxLength(36)
    CredentialTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    CredentialType?: string;
        
    @Field(() => [MJAIPromptModel_])
    MJAIPromptModels_VendorIDArray: MJAIPromptModel_[]; // Link to MJAIPromptModels
    
    @Field(() => [MJAIResultCache_])
    MJAIResultCache_VendorIDArray: MJAIResultCache_[]; // Link to MJAIResultCache
    
    @Field(() => [MJAIModelVendor_])
    MJAIModelVendors_VendorIDArray: MJAIModelVendor_[]; // Link to MJAIModelVendors
    
    @Field(() => [MJAIPromptRun_])
    MJAIPromptRuns_VendorIDArray: MJAIPromptRun_[]; // Link to MJAIPromptRuns
    
    @Field(() => [MJAIVendorType_])
    MJAIVendorTypes_VendorIDArray: MJAIVendorType_[]; // Link to MJAIVendorTypes
    
    @Field(() => [MJAIModelCost_])
    MJAIModelCosts_VendorIDArray: MJAIModelCost_[]; // Link to MJAIModelCosts
    
    @Field(() => [MJAICredentialBinding_])
    MJAICredentialBindings_AIVendorIDArray: MJAICredentialBinding_[]; // Link to MJAICredentialBindings
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_OverrideVendorIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendors
//****************************************************************************
@InputType()
export class CreateMJAIVendorInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CredentialTypeID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendors
//****************************************************************************
@InputType()
export class UpdateMJAIVendorInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CredentialTypeID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendors
//****************************************************************************
@ObjectType()
export class RunMJAIVendorViewResult {
    @Field(() => [MJAIVendor_])
    Results: MJAIVendor_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIVendor_)
export class MJAIVendorResolver extends ResolverBase {
    @Query(() => RunMJAIVendorViewResult)
    async RunMJAIVendorViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorViewResult)
    async RunMJAIVendorViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorViewResult)
    async RunMJAIVendorDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendors';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIVendor_, { nullable: true })
    async MJAIVendor(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIVendor_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIVendors')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Vendors', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIPromptModel_])
    async MJAIPromptModels_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptModels')} WHERE ${provider.QuoteIdentifier('VendorID')}='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async MJAIResultCache_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIResultCaches')} WHERE ${provider.QuoteIdentifier('VendorID')}='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelVendor_])
    async MJAIModelVendors_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelVendors')} WHERE ${provider.QuoteIdentifier('VendorID')}='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJAIPromptRuns_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('VendorID')}='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIVendorType_])
    async MJAIVendorTypes_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIVendorTypes')} WHERE ${provider.QuoteIdentifier('VendorID')}='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Vendor Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelCost_])
    async MJAIModelCosts_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIModelCosts')} WHERE ${provider.QuoteIdentifier('VendorID')}='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAICredentialBinding_])
    async MJAICredentialBindings_AIVendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAICredentialBindings')} WHERE ${provider.QuoteIdentifier('AIVendorID')}='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_OverrideVendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('OverrideVendorID')}='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIVendor_)
    async CreateMJAIVendor(
        @Arg('input', () => CreateMJAIVendorInput) input: CreateMJAIVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendors', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIVendor_)
    async UpdateMJAIVendor(
        @Arg('input', () => UpdateMJAIVendorInput) input: UpdateMJAIVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendors', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIVendor_)
    async DeleteMJAIVendor(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendors', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Application Scopes
//****************************************************************************
@ObjectType({ description: `Defines the scope ceiling for each application with pattern-based rules. Controls which scopes and resource patterns an application can use, regardless of what API keys grant.` })
export class MJAPIApplicationScope_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the application this ceiling rule applies to.`}) 
    @MaxLength(36)
    ApplicationID: string;
        
    @Field({description: `Reference to the scope this rule applies to.`}) 
    @MaxLength(36)
    ScopeID: string;
        
    @Field({nullable: true, description: `Glob pattern for matching resources (e.g., Users,Accounts or Skip* or *). NULL means match all resources.`}) 
    @MaxLength(750)
    ResourcePattern?: string;
        
    @Field({description: `How to interpret the pattern: Include (grant if matches) or Exclude (grant if does NOT match).`}) 
    @MaxLength(20)
    PatternType: string;
        
    @Field(() => Boolean, {description: `If true, this rule explicitly DENIES access. Deny rules trump allow rules at the same priority level.`}) 
    IsDeny: boolean;
        
    @Field(() => Int, {description: `Rule evaluation order. Higher priority rules are evaluated first. Within same priority, deny rules are evaluated before allow rules.`}) 
    Priority: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Application: string;
        
    @Field() 
    @MaxLength(100)
    Scope: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: API Application Scopes
//****************************************************************************
@InputType()
export class CreateMJAPIApplicationScopeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    ScopeID?: string;

    @Field({ nullable: true })
    ResourcePattern: string | null;

    @Field({ nullable: true })
    PatternType?: string;

    @Field(() => Boolean, { nullable: true })
    IsDeny?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Application Scopes
//****************************************************************************
@InputType()
export class UpdateMJAPIApplicationScopeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    ScopeID?: string;

    @Field({ nullable: true })
    ResourcePattern?: string | null;

    @Field({ nullable: true })
    PatternType?: string;

    @Field(() => Boolean, { nullable: true })
    IsDeny?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Application Scopes
//****************************************************************************
@ObjectType()
export class RunMJAPIApplicationScopeViewResult {
    @Field(() => [MJAPIApplicationScope_])
    Results: MJAPIApplicationScope_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIApplicationScope_)
export class MJAPIApplicationScopeResolver extends ResolverBase {
    @Query(() => RunMJAPIApplicationScopeViewResult)
    async RunMJAPIApplicationScopeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIApplicationScopeViewResult)
    async RunMJAPIApplicationScopeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIApplicationScopeViewResult)
    async RunMJAPIApplicationScopeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Application Scopes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIApplicationScope_, { nullable: true })
    async MJAPIApplicationScope(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIApplicationScope_ | null> {
        this.CheckUserReadPermissions('MJ: API Application Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIApplicationScopes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Application Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Application Scopes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAPIApplicationScope_)
    async CreateMJAPIApplicationScope(
        @Arg('input', () => CreateMJAPIApplicationScopeInput) input: CreateMJAPIApplicationScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Application Scopes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIApplicationScope_)
    async UpdateMJAPIApplicationScope(
        @Arg('input', () => UpdateMJAPIApplicationScopeInput) input: UpdateMJAPIApplicationScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Application Scopes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIApplicationScope_)
    async DeleteMJAPIApplicationScope(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Application Scopes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Applications
//****************************************************************************
@ObjectType({ description: `Registry of applications that can consume MemberJunction APIs. Each application defines a scope ceiling that limits what API keys can access when used with that application.` })
export class MJAPIApplication_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name identifying the application (e.g., MJAPI, MCPServer, Portal, CLI).`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Human-readable description of the application and its purpose.`}) 
    @MaxLength(500)
    Description?: string;
        
    @Field(() => Boolean, {description: `Whether this application is currently active. Inactive applications reject all API key authentication.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAPIKeyUsageLog_])
    MJAPIKeyUsageLogs_ApplicationIDArray: MJAPIKeyUsageLog_[]; // Link to MJAPIKeyUsageLogs
    
    @Field(() => [MJAPIApplicationScope_])
    MJAPIApplicationScopes_ApplicationIDArray: MJAPIApplicationScope_[]; // Link to MJAPIApplicationScopes
    
    @Field(() => [MJAPIKeyApplication_])
    MJAPIKeyApplications_ApplicationIDArray: MJAPIKeyApplication_[]; // Link to MJAPIKeyApplications
    
}

//****************************************************************************
// INPUT TYPE for MJ: API Applications
//****************************************************************************
@InputType()
export class CreateMJAPIApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Applications
//****************************************************************************
@InputType()
export class UpdateMJAPIApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Applications
//****************************************************************************
@ObjectType()
export class RunMJAPIApplicationViewResult {
    @Field(() => [MJAPIApplication_])
    Results: MJAPIApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIApplication_)
export class MJAPIApplicationResolver extends ResolverBase {
    @Query(() => RunMJAPIApplicationViewResult)
    async RunMJAPIApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIApplicationViewResult)
    async RunMJAPIApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIApplicationViewResult)
    async RunMJAPIApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIApplication_, { nullable: true })
    async MJAPIApplication(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIApplication_ | null> {
        this.CheckUserReadPermissions('MJ: API Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIApplications')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Applications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAPIKeyUsageLog_])
    async MJAPIKeyUsageLogs_ApplicationIDArray(@Root() mjapiapplication_: MJAPIApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Usage Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyUsageLogs')} WHERE ${provider.QuoteIdentifier('ApplicationID')}='${mjapiapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Usage Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Usage Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIApplicationScope_])
    async MJAPIApplicationScopes_ApplicationIDArray(@Root() mjapiapplication_: MJAPIApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Application Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIApplicationScopes')} WHERE ${provider.QuoteIdentifier('ApplicationID')}='${mjapiapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Application Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Application Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKeyApplication_])
    async MJAPIKeyApplications_ApplicationIDArray(@Root() mjapiapplication_: MJAPIApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyApplications')} WHERE ${provider.QuoteIdentifier('ApplicationID')}='${mjapiapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAPIApplication_)
    async CreateMJAPIApplication(
        @Arg('input', () => CreateMJAPIApplicationInput) input: CreateMJAPIApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIApplication_)
    async UpdateMJAPIApplication(
        @Arg('input', () => UpdateMJAPIApplicationInput) input: UpdateMJAPIApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIApplication_)
    async DeleteMJAPIApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Key Applications
//****************************************************************************
@ObjectType({ description: `Optional binding of API keys to specific applications. If no records exist for a key, it works with all applications. If records exist, the key only works with those specific applications.` })
export class MJAPIKeyApplication_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the API key being bound to an application.`}) 
    @MaxLength(36)
    APIKeyID: string;
        
    @Field({description: `Reference to the application this key is authorized to use.`}) 
    @MaxLength(36)
    ApplicationID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    APIKey: string;
        
    @Field() 
    @MaxLength(100)
    Application: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: API Key Applications
//****************************************************************************
@InputType()
export class CreateMJAPIKeyApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Key Applications
//****************************************************************************
@InputType()
export class UpdateMJAPIKeyApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Key Applications
//****************************************************************************
@ObjectType()
export class RunMJAPIKeyApplicationViewResult {
    @Field(() => [MJAPIKeyApplication_])
    Results: MJAPIKeyApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIKeyApplication_)
export class MJAPIKeyApplicationResolver extends ResolverBase {
    @Query(() => RunMJAPIKeyApplicationViewResult)
    async RunMJAPIKeyApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyApplicationViewResult)
    async RunMJAPIKeyApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyApplicationViewResult)
    async RunMJAPIKeyApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Key Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIKeyApplication_, { nullable: true })
    async MJAPIKeyApplication(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIKeyApplication_ | null> {
        this.CheckUserReadPermissions('MJ: API Key Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyApplications')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Key Applications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAPIKeyApplication_)
    async CreateMJAPIKeyApplication(
        @Arg('input', () => CreateMJAPIKeyApplicationInput) input: CreateMJAPIKeyApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Key Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIKeyApplication_)
    async UpdateMJAPIKeyApplication(
        @Arg('input', () => UpdateMJAPIKeyApplicationInput) input: UpdateMJAPIKeyApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Key Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIKeyApplication_)
    async DeleteMJAPIKeyApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Key Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Key Scopes
//****************************************************************************
@ObjectType({ description: `Junction table linking API keys to their assigned permission scopes. Each key can have multiple scopes, and scopes can be shared across multiple keys.` })
export class MJAPIKeyScope_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    APIKeyID: string;
        
    @Field() 
    @MaxLength(36)
    ScopeID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Glob pattern for matching resources (e.g., Users,Accounts or Skip* or *). NULL means match all resources under this scope.`}) 
    @MaxLength(750)
    ResourcePattern?: string;
        
    @Field({description: `How to interpret the pattern: Include (grant if matches) or Exclude (grant if does NOT match).`}) 
    @MaxLength(20)
    PatternType: string;
        
    @Field(() => Boolean, {description: `If true, this rule explicitly DENIES access. Deny rules trump allow rules at the same priority level.`}) 
    IsDeny: boolean;
        
    @Field(() => Int, {description: `Rule evaluation order. Higher priority rules are evaluated first. Within same priority, deny rules are evaluated before allow rules.`}) 
    Priority: number;
        
    @Field() 
    @MaxLength(255)
    APIKey: string;
        
    @Field() 
    @MaxLength(100)
    Scope: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: API Key Scopes
//****************************************************************************
@InputType()
export class CreateMJAPIKeyScopeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    ScopeID?: string;

    @Field({ nullable: true })
    ResourcePattern: string | null;

    @Field({ nullable: true })
    PatternType?: string;

    @Field(() => Boolean, { nullable: true })
    IsDeny?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Key Scopes
//****************************************************************************
@InputType()
export class UpdateMJAPIKeyScopeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    ScopeID?: string;

    @Field({ nullable: true })
    ResourcePattern?: string | null;

    @Field({ nullable: true })
    PatternType?: string;

    @Field(() => Boolean, { nullable: true })
    IsDeny?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Key Scopes
//****************************************************************************
@ObjectType()
export class RunMJAPIKeyScopeViewResult {
    @Field(() => [MJAPIKeyScope_])
    Results: MJAPIKeyScope_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIKeyScope_)
export class MJAPIKeyScopeResolver extends ResolverBase {
    @Query(() => RunMJAPIKeyScopeViewResult)
    async RunMJAPIKeyScopeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyScopeViewResult)
    async RunMJAPIKeyScopeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyScopeViewResult)
    async RunMJAPIKeyScopeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Key Scopes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIKeyScope_, { nullable: true })
    async MJAPIKeyScope(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIKeyScope_ | null> {
        this.CheckUserReadPermissions('MJ: API Key Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyScopes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Key Scopes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAPIKeyScope_)
    async CreateMJAPIKeyScope(
        @Arg('input', () => CreateMJAPIKeyScopeInput) input: CreateMJAPIKeyScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Key Scopes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIKeyScope_)
    async UpdateMJAPIKeyScope(
        @Arg('input', () => UpdateMJAPIKeyScopeInput) input: UpdateMJAPIKeyScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Key Scopes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIKeyScope_)
    async DeleteMJAPIKeyScope(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Key Scopes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Key Usage Logs
//****************************************************************************
@ObjectType({ description: `Audit log tracking all API key usage for analytics, debugging, and security monitoring. Records each request including endpoint, response status, timing, and client information.` })
export class MJAPIKeyUsageLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    APIKeyID: string;
        
    @Field({description: `The API endpoint path that was accessed (e.g., /mcp, /graphql, /api/v1/entities).`}) 
    @MaxLength(500)
    Endpoint: string;
        
    @Field({nullable: true, description: `The specific operation performed, such as the GraphQL operation name or MCP tool invoked (e.g., Get_Users_Record, Run_Agent).`}) 
    @MaxLength(255)
    Operation?: string;
        
    @Field({description: `HTTP method used for the request (GET, POST, PUT, DELETE, etc.).`}) 
    @MaxLength(10)
    Method: string;
        
    @Field(() => Int, {description: `HTTP response status code returned to the client (e.g., 200 for success, 401 for unauthorized, 500 for server error).`}) 
    StatusCode: number;
        
    @Field(() => Int, {nullable: true, description: `Total time in milliseconds to process the request and return a response. Useful for performance monitoring.`}) 
    ResponseTimeMs?: number;
        
    @Field({nullable: true, description: `Client IP address that made the request. Supports both IPv4 and IPv6 addresses (up to 45 characters).`}) 
    @MaxLength(45)
    IPAddress?: string;
        
    @Field({nullable: true, description: `User-Agent header from the HTTP request, identifying the client application or library making the API call.`}) 
    @MaxLength(500)
    UserAgent?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The application through which this request was made (MJAPI, MCPServer, etc.).`}) 
    @MaxLength(36)
    ApplicationID?: string;
        
    @Field({nullable: true, description: `The specific resource that was requested (e.g., entity name, agent name, query name).`}) 
    @MaxLength(500)
    RequestedResource?: string;
        
    @Field({nullable: true, description: `JSON array containing detailed evaluation of each scope rule checked during authorization.`}) 
    ScopesEvaluated?: string;
        
    @Field({description: `Final authorization result: Allowed, Denied, or NoScopesRequired (for operations that do not require scope checks).`}) 
    @MaxLength(20)
    AuthorizationResult: string;
        
    @Field({nullable: true, description: `When authorization is denied, explains why (e.g., app ceiling blocked, no matching key scope, explicit deny rule).`}) 
    @MaxLength(500)
    DeniedReason?: string;
        
    @Field() 
    @MaxLength(255)
    APIKey: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Application?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: API Key Usage Logs
//****************************************************************************
@InputType()
export class CreateMJAPIKeyUsageLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    Endpoint?: string;

    @Field({ nullable: true })
    Operation: string | null;

    @Field({ nullable: true })
    Method?: string;

    @Field(() => Int, { nullable: true })
    StatusCode?: number;

    @Field(() => Int, { nullable: true })
    ResponseTimeMs: number | null;

    @Field({ nullable: true })
    IPAddress: string | null;

    @Field({ nullable: true })
    UserAgent: string | null;

    @Field({ nullable: true })
    ApplicationID: string | null;

    @Field({ nullable: true })
    RequestedResource: string | null;

    @Field({ nullable: true })
    ScopesEvaluated: string | null;

    @Field({ nullable: true })
    AuthorizationResult?: string;

    @Field({ nullable: true })
    DeniedReason: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Key Usage Logs
//****************************************************************************
@InputType()
export class UpdateMJAPIKeyUsageLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    Endpoint?: string;

    @Field({ nullable: true })
    Operation?: string | null;

    @Field({ nullable: true })
    Method?: string;

    @Field(() => Int, { nullable: true })
    StatusCode?: number;

    @Field(() => Int, { nullable: true })
    ResponseTimeMs?: number | null;

    @Field({ nullable: true })
    IPAddress?: string | null;

    @Field({ nullable: true })
    UserAgent?: string | null;

    @Field({ nullable: true })
    ApplicationID?: string | null;

    @Field({ nullable: true })
    RequestedResource?: string | null;

    @Field({ nullable: true })
    ScopesEvaluated?: string | null;

    @Field({ nullable: true })
    AuthorizationResult?: string;

    @Field({ nullable: true })
    DeniedReason?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Key Usage Logs
//****************************************************************************
@ObjectType()
export class RunMJAPIKeyUsageLogViewResult {
    @Field(() => [MJAPIKeyUsageLog_])
    Results: MJAPIKeyUsageLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIKeyUsageLog_)
export class MJAPIKeyUsageLogResolver extends ResolverBase {
    @Query(() => RunMJAPIKeyUsageLogViewResult)
    async RunMJAPIKeyUsageLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyUsageLogViewResult)
    async RunMJAPIKeyUsageLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyUsageLogViewResult)
    async RunMJAPIKeyUsageLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Key Usage Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIKeyUsageLog_, { nullable: true })
    async MJAPIKeyUsageLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIKeyUsageLog_ | null> {
        this.CheckUserReadPermissions('MJ: API Key Usage Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyUsageLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Usage Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Key Usage Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAPIKeyUsageLog_)
    async CreateMJAPIKeyUsageLog(
        @Arg('input', () => CreateMJAPIKeyUsageLogInput) input: CreateMJAPIKeyUsageLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Key Usage Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIKeyUsageLog_)
    async UpdateMJAPIKeyUsageLog(
        @Arg('input', () => UpdateMJAPIKeyUsageLogInput) input: UpdateMJAPIKeyUsageLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Key Usage Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIKeyUsageLog_)
    async DeleteMJAPIKeyUsageLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Key Usage Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Keys
//****************************************************************************
@ObjectType({ description: `Stores API keys for programmatic access to MemberJunction services. Keys are stored as SHA-256 hashes for security. Each key is associated with a user context and can have multiple permission scopes assigned.` })
export class MJAPIKey_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `SHA-256 hash of the raw API key (64 hexadecimal characters). The raw key is only shown once at creation time and cannot be recovered.`}) 
    @MaxLength(64)
    Hash: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `User-friendly name for identifying the key purpose (e.g., Cowork Integration, CI/CD Pipeline, Mobile App).`}) 
    @MaxLength(255)
    Label: string;
        
    @Field({nullable: true, description: `Optional detailed description of the key's intended use, integration details, or other notes.`}) 
    @MaxLength(1000)
    Description?: string;
        
    @Field({description: `Current lifecycle status of the key. Active keys can be used for authentication; Revoked keys are permanently disabled.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Optional expiration timestamp. Keys with NULL expiration never expire. Expired keys are rejected during authentication.`}) 
    ExpiresAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the most recent successful authentication using this key. Updated on each valid API request.`}) 
    LastUsedAt?: Date;
        
    @Field() 
    @MaxLength(36)
    CreatedByUserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field() 
    @MaxLength(100)
    CreatedByUser: string;
        
    @Field(() => [MJAPIKeyUsageLog_])
    MJAPIKeyUsageLogs_APIKeyIDArray: MJAPIKeyUsageLog_[]; // Link to MJAPIKeyUsageLogs
    
    @Field(() => [MJAPIKeyScope_])
    MJAPIKeyScopes_APIKeyIDArray: MJAPIKeyScope_[]; // Link to MJAPIKeyScopes
    
    @Field(() => [MJAPIKeyApplication_])
    MJAPIKeyApplications_APIKeyIDArray: MJAPIKeyApplication_[]; // Link to MJAPIKeyApplications
    
}

//****************************************************************************
// INPUT TYPE for MJ: API Keys
//****************************************************************************
@InputType()
export class CreateMJAPIKeyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Hash?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Label?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiresAt: Date | null;

    @Field({ nullable: true })
    LastUsedAt: Date | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Keys
//****************************************************************************
@InputType()
export class UpdateMJAPIKeyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Hash?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Label?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field({ nullable: true })
    LastUsedAt?: Date | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Keys
//****************************************************************************
@ObjectType()
export class RunMJAPIKeyViewResult {
    @Field(() => [MJAPIKey_])
    Results: MJAPIKey_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIKey_)
export class MJAPIKeyResolver extends ResolverBase {
    @Query(() => RunMJAPIKeyViewResult)
    async RunMJAPIKeyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyViewResult)
    async RunMJAPIKeyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyViewResult)
    async RunMJAPIKeyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Keys';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIKey_, { nullable: true })
    async MJAPIKey(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIKey_ | null> {
        this.CheckUserReadPermissions('MJ: API Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeys')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Keys', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAPIKeyUsageLog_])
    async MJAPIKeyUsageLogs_APIKeyIDArray(@Root() mjapikey_: MJAPIKey_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Usage Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyUsageLogs')} WHERE ${provider.QuoteIdentifier('APIKeyID')}='${mjapikey_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Usage Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Usage Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKeyScope_])
    async MJAPIKeyScopes_APIKeyIDArray(@Root() mjapikey_: MJAPIKey_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyScopes')} WHERE ${provider.QuoteIdentifier('APIKeyID')}='${mjapikey_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKeyApplication_])
    async MJAPIKeyApplications_APIKeyIDArray(@Root() mjapikey_: MJAPIKey_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyApplications')} WHERE ${provider.QuoteIdentifier('APIKeyID')}='${mjapikey_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAPIKey_)
    async CreateMJAPIKey(
        @Arg('input', () => CreateMJAPIKeyInput) input: CreateMJAPIKeyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Keys', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIKey_)
    async UpdateMJAPIKey(
        @Arg('input', () => UpdateMJAPIKeyInput) input: UpdateMJAPIKeyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Keys', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIKey_)
    async DeleteMJAPIKey(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Keys', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Scopes
//****************************************************************************
@ObjectType({ description: `Defines reusable permission scopes that can be assigned to API keys. Scopes follow a hierarchical naming convention (e.g., entities:read, agents:execute, admin:*) and are grouped by category for organizational purposes.` })
export class MJAPIScope_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique scope identifier following the pattern category:permission (e.g., entities:read, agents:execute, admin:*). Supports wildcard (*) for broad permissions.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `Grouping category for the scope (e.g., Entities, Agents, Admin). Used for organizing and filtering scopes in the UI.`}) 
    @MaxLength(100)
    Category: string;
        
    @Field({nullable: true, description: `Human-readable description explaining what permissions this scope grants.`}) 
    @MaxLength(500)
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Reference to parent scope for hierarchical organization. NULL indicates a root-level scope.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Full hierarchical path of the scope (e.g., entity:runview, agent:execute). Used for matching during authorization.`}) 
    @MaxLength(500)
    FullPath: string;
        
    @Field({nullable: true, description: `Type of resource this scope applies to (Entity, Agent, Query, Mutation, or NULL for abstract grouping scopes).`}) 
    @MaxLength(50)
    ResourceType?: string;
        
    @Field(() => Boolean, {description: `Whether this scope is currently active. Inactive scopes are ignored during authorization.`}) 
    IsActive: boolean;
        
    @Field({nullable: true, description: `JSON configuration for UI presentation. Schema: { "icon": "fa-solid fa-xxx", "color": "#hexcolor" }. Icon should be a Font Awesome class. Color should be a hex color code.`}) 
    UIConfig?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJAPIKeyScope_])
    MJAPIKeyScopes_ScopeIDArray: MJAPIKeyScope_[]; // Link to MJAPIKeyScopes
    
    @Field(() => [MJAPIApplicationScope_])
    MJAPIApplicationScopes_ScopeIDArray: MJAPIApplicationScope_[]; // Link to MJAPIApplicationScopes
    
    @Field(() => [MJAPIScope_])
    MJAPIScopes_ParentIDArray: MJAPIScope_[]; // Link to MJAPIScopes
    
}

//****************************************************************************
// INPUT TYPE for MJ: API Scopes
//****************************************************************************
@InputType()
export class CreateMJAPIScopeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    FullPath?: string;

    @Field({ nullable: true })
    ResourceType: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    UIConfig: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Scopes
//****************************************************************************
@InputType()
export class UpdateMJAPIScopeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    FullPath?: string;

    @Field({ nullable: true })
    ResourceType?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    UIConfig?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Scopes
//****************************************************************************
@ObjectType()
export class RunMJAPIScopeViewResult {
    @Field(() => [MJAPIScope_])
    Results: MJAPIScope_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIScope_)
export class MJAPIScopeResolver extends ResolverBase {
    @Query(() => RunMJAPIScopeViewResult)
    async RunMJAPIScopeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIScopeViewResult)
    async RunMJAPIScopeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIScopeViewResult)
    async RunMJAPIScopeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Scopes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIScope_, { nullable: true })
    async MJAPIScope(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIScope_ | null> {
        this.CheckUserReadPermissions('MJ: API Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIScopes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Scopes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAPIKeyScope_])
    async MJAPIKeyScopes_ScopeIDArray(@Root() mjapiscope_: MJAPIScope_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeyScopes')} WHERE ${provider.QuoteIdentifier('ScopeID')}='${mjapiscope_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIApplicationScope_])
    async MJAPIApplicationScopes_ScopeIDArray(@Root() mjapiscope_: MJAPIScope_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Application Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIApplicationScopes')} WHERE ${provider.QuoteIdentifier('ScopeID')}='${mjapiscope_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Application Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Application Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIScope_])
    async MJAPIScopes_ParentIDArray(@Root() mjapiscope_: MJAPIScope_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIScopes')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjapiscope_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAPIScope_)
    async CreateMJAPIScope(
        @Arg('input', () => CreateMJAPIScopeInput) input: CreateMJAPIScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Scopes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIScope_)
    async UpdateMJAPIScope(
        @Arg('input', () => UpdateMJAPIScopeInput) input: UpdateMJAPIScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Scopes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIScope_)
    async DeleteMJAPIScope(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Scopes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Application Entities
//****************************************************************************
@ObjectType({ description: `List of entities within each application. An application can have any number of entities and an entity can be part of any number of applications.` })
export class MJApplicationEntity_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of this entity within the application, lower numbers appear first in navigation and menus.`}) 
    Sequence: number;
        
    @Field(() => Boolean, {description: `When set to 1, the entity will be included by default for a new user when they first access the application in question`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Application: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(255)
    EntityBaseTable: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    EntityBaseTableCodeName?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Application Entities
//****************************************************************************
@InputType()
export class CreateMJApplicationEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Application Entities
//****************************************************************************
@InputType()
export class UpdateMJApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Application Entities
//****************************************************************************
@ObjectType()
export class RunMJApplicationEntityViewResult {
    @Field(() => [MJApplicationEntity_])
    Results: MJApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplicationEntity_)
export class MJApplicationEntityResolver extends ResolverBase {
    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Application Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplicationEntity_, { nullable: true })
    async MJApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplicationEntity_ | null> {
        this.CheckUserReadPermissions('MJ: Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwApplicationEntities')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Application Entities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJApplicationEntity_)
    async CreateMJApplicationEntity(
        @Arg('input', () => CreateMJApplicationEntityInput) input: CreateMJApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Application Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplicationEntity_)
    async UpdateMJApplicationEntity(
        @Arg('input', () => UpdateMJApplicationEntityInput) input: UpdateMJApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Application Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplicationEntity_)
    async DeleteMJApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Application Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Application Settings
//****************************************************************************
@ObjectType({ description: `Stores configuration settings and preferences for applications, including key-value pairs for runtime parameters and user-specific customizations.` })
export class MJApplicationSetting_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `The setting value, can be simple text, numbers, booleans, or JSON for complex configuration objects.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Application: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Application Settings
//****************************************************************************
@InputType()
export class CreateMJApplicationSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Application Settings
//****************************************************************************
@InputType()
export class UpdateMJApplicationSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Application Settings
//****************************************************************************
@ObjectType()
export class RunMJApplicationSettingViewResult {
    @Field(() => [MJApplicationSetting_])
    Results: MJApplicationSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplicationSetting_)
export class MJApplicationSettingResolver extends ResolverBase {
    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Application Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplicationSetting_, { nullable: true })
    async MJApplicationSetting(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplicationSetting_ | null> {
        this.CheckUserReadPermissions('MJ: Application Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwApplicationSettings')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Application Settings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJApplicationSetting_)
    async CreateMJApplicationSetting(
        @Arg('input', () => CreateMJApplicationSettingInput) input: CreateMJApplicationSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Application Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplicationSetting_)
    async UpdateMJApplicationSetting(
        @Arg('input', () => UpdateMJApplicationSettingInput) input: UpdateMJApplicationSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Application Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplicationSetting_)
    async DeleteMJApplicationSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Application Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Applications
//****************************************************************************
@ObjectType({ description: `Applications are used to group entities in the user interface for ease of user access` })
export class MJApplication_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Specify the CSS class information for the display icon for each application.`}) 
    @MaxLength(500)
    Icon?: string;
        
    @Field(() => Boolean, {description: `If turned on, when a new user first uses the MJ Explorer app, the application records with this turned on will have this application included in their selected application list.`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Comma-delimited list of schema names where entities will be automatically added to the application when created in those schemas`}) 
    SchemaAutoAddNewEntities?: string;
        
    @Field({nullable: true, description: `Hex color code for visual theming (e.g., #4caf50)`}) 
    @MaxLength(20)
    Color?: string;
        
    @Field({nullable: true, description: `JSON array of default navigation items for this application. Parsed by BaseApplication.GetNavItems()`}) 
    DefaultNavItems?: string;
        
    @Field({nullable: true, description: `TypeScript class name for ClassFactory registration (e.g., CRMApplication)`}) 
    @MaxLength(255)
    ClassName?: string;
        
    @Field(() => Int, {description: `Default sequence position when adding this application to a new user's User Applications. Lower values appear first. Used when DefaultForNewUser is true.`}) 
    DefaultSequence: number;
        
    @Field({description: `Application lifecycle status. Pending = not yet ready, Active = available for use, Disabled = temporarily unavailable, Deprecated = being phased out. Only Active applications are shown to users.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({description: `How the application appears in navigation. App Switcher = only in dropdown menu, Nav Bar = permanent icon in top nav, Both = shown in both locations.`}) 
    @MaxLength(20)
    NavigationStyle: string;
        
    @Field({nullable: true, description: `Position of the permanent nav icon when NavigationStyle is Nav Bar or Both. Left of App Switcher = appears before the app switcher, Left of User Menu = appears near the user avatar. Ignored when NavigationStyle is App Switcher.`}) 
    @MaxLength(30)
    TopNavLocation?: string;
        
    @Field(() => Boolean, {description: `When true, the Nav Bar icon for this application is hidden when the application is active. Useful for launcher-style apps like Home that should only be visible when the user is NOT in that app. Only applies when NavigationStyle is Nav Bar or Both.`}) 
    HideNavBarIconWhenActive: boolean;
        
    @Field({description: `URL-friendly slug for the application (e.g., "data-explorer" for "Data Explorer"). Used in URLs instead of the full Name. Auto-generated from Name when AutoUpdatePath is true. Must be unique across all applications.`}) 
    @MaxLength(100)
    Path: string;
        
    @Field(() => Boolean, {description: `When true, Path is automatically generated from Name on save. Set to false to manually control the Path value. Defaults to true for new applications.`}) 
    AutoUpdatePath: boolean;
        
    @Field(() => [MJApplicationEntity_])
    MJApplicationEntities_ApplicationIDArray: MJApplicationEntity_[]; // Link to MJApplicationEntities
    
    @Field(() => [MJUserApplication_])
    MJUserApplications_ApplicationIDArray: MJUserApplication_[]; // Link to MJUserApplications
    
    @Field(() => [MJApplicationSetting_])
    MJApplicationSettings_ApplicationIDArray: MJApplicationSetting_[]; // Link to MJApplicationSettings
    
    @Field(() => [MJDashboard_])
    MJDashboards_ApplicationIDArray: MJDashboard_[]; // Link to MJDashboards
    
    @Field(() => [MJDashboardUserPreference_])
    MJDashboardUserPreferences_ApplicationIDArray: MJDashboardUserPreference_[]; // Link to MJDashboardUserPreferences
    
}

//****************************************************************************
// INPUT TYPE for MJ: Applications
//****************************************************************************
@InputType()
export class CreateMJApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field({ nullable: true })
    SchemaAutoAddNewEntities: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field({ nullable: true })
    DefaultNavItems: string | null;

    @Field({ nullable: true })
    ClassName: string | null;

    @Field(() => Int, { nullable: true })
    DefaultSequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    NavigationStyle?: string;

    @Field({ nullable: true })
    TopNavLocation: string | null;

    @Field(() => Boolean, { nullable: true })
    HideNavBarIconWhenActive?: boolean;

    @Field({ nullable: true })
    Path?: string;

    @Field(() => Boolean, { nullable: true })
    AutoUpdatePath?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Applications
//****************************************************************************
@InputType()
export class UpdateMJApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field({ nullable: true })
    SchemaAutoAddNewEntities?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field({ nullable: true })
    DefaultNavItems?: string | null;

    @Field({ nullable: true })
    ClassName?: string | null;

    @Field(() => Int, { nullable: true })
    DefaultSequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    NavigationStyle?: string;

    @Field({ nullable: true })
    TopNavLocation?: string | null;

    @Field(() => Boolean, { nullable: true })
    HideNavBarIconWhenActive?: boolean;

    @Field({ nullable: true })
    Path?: string;

    @Field(() => Boolean, { nullable: true })
    AutoUpdatePath?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Applications
//****************************************************************************
@ObjectType()
export class RunMJApplicationViewResult {
    @Field(() => [MJApplication_])
    Results: MJApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplication_)
export class MJApplicationResolver extends ResolverBase {
    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplication_, { nullable: true })
    async MJApplication(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplication_ | null> {
        this.CheckUserReadPermissions('MJ: Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwApplications')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Applications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJApplication_])
    async AllMJApplications(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwApplications')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Applications', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJApplicationEntity_])
    async MJApplicationEntities_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwApplicationEntities')} WHERE ${provider.QuoteIdentifier('ApplicationID')}='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Application Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserApplication_])
    async MJUserApplications_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserApplications')} WHERE ${provider.QuoteIdentifier('ApplicationID')}='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJApplicationSetting_])
    async MJApplicationSettings_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Application Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwApplicationSettings')} WHERE ${provider.QuoteIdentifier('ApplicationID')}='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Application Settings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboard_])
    async MJDashboards_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboards')} WHERE ${provider.QuoteIdentifier('ApplicationID')}='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboards', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardUserPreference_])
    async MJDashboardUserPreferences_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardUserPreferences')} WHERE ${provider.QuoteIdentifier('ApplicationID')}='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJApplication_)
    async CreateMJApplication(
        @Arg('input', () => CreateMJApplicationInput) input: CreateMJApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplication_)
    async UpdateMJApplication(
        @Arg('input', () => UpdateMJApplicationInput) input: UpdateMJApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplication_)
    async DeleteMJApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for artifacts with granular access control (Read, Edit, Delete, Share)` })
export class MJArtifactPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ArtifactID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field(() => Boolean, {description: `Whether the user can view/read the artifact`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can modify the artifact or create new versions`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can delete the artifact`}) 
    CanDelete: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can share the artifact with other users`}) 
    CanShare: boolean;
        
    @Field({nullable: true, description: `Foreign key to the User who shared this artifact (if shared)`}) 
    @MaxLength(36)
    SharedByUserID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Artifact: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SharedByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Permissions
//****************************************************************************
@InputType()
export class CreateMJArtifactPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Permissions
//****************************************************************************
@InputType()
export class UpdateMJArtifactPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Permissions
//****************************************************************************
@ObjectType()
export class RunMJArtifactPermissionViewResult {
    @Field(() => [MJArtifactPermission_])
    Results: MJArtifactPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactPermission_)
export class MJArtifactPermissionResolver extends ResolverBase {
    @Query(() => RunMJArtifactPermissionViewResult)
    async RunMJArtifactPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactPermissionViewResult)
    async RunMJArtifactPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactPermissionViewResult)
    async RunMJArtifactPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactPermission_, { nullable: true })
    async MJArtifactPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJArtifactPermission_)
    async CreateMJArtifactPermission(
        @Arg('input', () => CreateMJArtifactPermissionInput) input: CreateMJArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactPermission_)
    async UpdateMJArtifactPermission(
        @Arg('input', () => UpdateMJArtifactPermissionInput) input: UpdateMJArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactPermission_)
    async DeleteMJArtifactPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Types
//****************************************************************************
@ObjectType({ description: `Defines the types of artifacts that can be created within conversations` })
export class MJArtifactType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Display name of the artifact type`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the artifact type`}) 
    Description?: string;
        
    @Field({description: `MIME type or content identifier for this artifact type`}) 
    @MaxLength(100)
    ContentType: string;
        
    @Field(() => Boolean, {description: `Indicates if this artifact type is currently available for use`}) 
    IsEnabled: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Parent artifact type ID for hierarchical artifact type organization. Child types inherit ExtractRules from parent but can override.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true, description: `JSON array of extraction rules defining how to extract attributes from artifact content. Each rule has: name (string), description (string), type (TypeScript type), standardProperty ('name'|'description'|'displayMarkdown'|'displayHtml'|null), extractor (JavaScript code string). Child types inherit parent rules and can override by name.`}) 
    ExtractRules?: string;
        
    @Field({nullable: true, description: `Driver class name for the artifact viewer plugin. References Angular component registered with @RegisterClass decorator.`}) 
    @MaxLength(255)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class name for displaying this artifact type in the UI (e.g., fa-file-code, fa-chart-line)`}) 
    @MaxLength(255)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJConversationArtifact_])
    MJConversationArtifacts_ArtifactTypeIDArray: MJConversationArtifact_[]; // Link to MJConversationArtifacts
    
    @Field(() => [MJAIAgentArtifactType_])
    MJAIAgentArtifactTypes_ArtifactTypeIDArray: MJAIAgentArtifactType_[]; // Link to MJAIAgentArtifactTypes
    
    @Field(() => [MJArtifact_])
    MJArtifacts_TypeIDArray: MJArtifact_[]; // Link to MJArtifacts
    
    @Field(() => [MJArtifactType_])
    MJArtifactTypes_ParentIDArray: MJArtifactType_[]; // Link to MJArtifactTypes
    
    @Field(() => [MJAIAgent_])
    MJAIAgents_DefaultArtifactTypeIDArray: MJAIAgent_[]; // Link to MJAIAgents
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class CreateMJArtifactTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    ExtractRules: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    Icon: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class UpdateMJArtifactTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    ExtractRules?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Types
//****************************************************************************
@ObjectType()
export class RunMJArtifactTypeViewResult {
    @Field(() => [MJArtifactType_])
    Results: MJArtifactType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactType_)
export class MJArtifactTypeResolver extends ResolverBase {
    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactType_, { nullable: true })
    async MJArtifactType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactType_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJConversationArtifact_])
    async MJConversationArtifacts_ArtifactTypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationArtifacts')} WHERE ${provider.QuoteIdentifier('ArtifactTypeID')}='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentArtifactType_])
    async MJAIAgentArtifactTypes_ArtifactTypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentArtifactTypes')} WHERE ${provider.QuoteIdentifier('ArtifactTypeID')}='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Artifact Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifact_])
    async MJArtifacts_TypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifacts')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactType_])
    async MJArtifactTypes_ParentIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactTypes')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async MJAIAgents_DefaultArtifactTypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgents')} WHERE ${provider.QuoteIdentifier('DefaultArtifactTypeID')}='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJArtifactType_)
    async CreateMJArtifactType(
        @Arg('input', () => CreateMJArtifactTypeInput) input: CreateMJArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactType_)
    async UpdateMJArtifactType(
        @Arg('input', () => UpdateMJArtifactTypeInput) input: UpdateMJArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactType_)
    async DeleteMJArtifactType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Uses
//****************************************************************************
@ObjectType({ description: `Audit trail of artifact usage for security and analytics. Tracks each time an artifact is viewed, opened, shared, saved, or exported by users.` })
export class MJArtifactUse_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The specific version of the artifact being used.`}) 
    @MaxLength(36)
    ArtifactVersionID: string;
        
    @Field({description: `The user performing the action.`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `Type of usage: Viewed (artifact displayed), Opened (artifact accessed), Shared (artifact shared with others), Saved (artifact bookmarked), or Exported (artifact downloaded).`}) 
    @MaxLength(20)
    UsageType: string;
        
    @Field({nullable: true, description: `Optional JSON context with additional metadata about the usage event (e.g., source page, referrer, device info).`}) 
    UsageContext?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ArtifactVersion?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Uses
//****************************************************************************
@InputType()
export class CreateMJArtifactUseInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UsageType?: string;

    @Field({ nullable: true })
    UsageContext: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Uses
//****************************************************************************
@InputType()
export class UpdateMJArtifactUseInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UsageType?: string;

    @Field({ nullable: true })
    UsageContext?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Uses
//****************************************************************************
@ObjectType()
export class RunMJArtifactUseViewResult {
    @Field(() => [MJArtifactUse_])
    Results: MJArtifactUse_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactUse_)
export class MJArtifactUseResolver extends ResolverBase {
    @Query(() => RunMJArtifactUseViewResult)
    async RunMJArtifactUseViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactUseViewResult)
    async RunMJArtifactUseViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactUseViewResult)
    async RunMJArtifactUseDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Uses';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactUse_, { nullable: true })
    async MJArtifactUse(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactUse_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Uses', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactUses')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Uses', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Uses', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJArtifactUse_)
    async CreateMJArtifactUse(
        @Arg('input', () => CreateMJArtifactUseInput) input: CreateMJArtifactUseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Uses', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactUse_)
    async UpdateMJArtifactUse(
        @Arg('input', () => UpdateMJArtifactUseInput) input: UpdateMJArtifactUseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Uses', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactUse_)
    async DeleteMJArtifactUse(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Uses', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Version Attributes
//****************************************************************************
@ObjectType({ description: `Stores extracted attribute values from artifact content based on ArtifactType ExtractRules. Prevents re-running extraction logic on every access.` })
export class MJArtifactVersionAttribute_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The artifact version this attribute belongs to`}) 
    @MaxLength(36)
    ArtifactVersionID: string;
        
    @Field({description: `Name of the extracted attribute (matches ExtractRule.name)`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({description: `TypeScript type definition of the value (e.g., 'string', 'number', 'Date', 'Array<{x: number, y: string}>')`}) 
    @MaxLength(500)
    Type: string;
        
    @Field({nullable: true, description: `JSON-serialized extracted value`}) 
    Value?: string;
        
    @Field({nullable: true, description: `Maps this attribute to a standard property for UI rendering: 'name', 'description', 'displayMarkdown', 'displayHtml', or NULL for custom attributes`}) 
    @MaxLength(50)
    StandardProperty?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ArtifactVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Version Attributes
//****************************************************************************
@InputType()
export class CreateMJArtifactVersionAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    StandardProperty: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Version Attributes
//****************************************************************************
@InputType()
export class UpdateMJArtifactVersionAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    StandardProperty?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Version Attributes
//****************************************************************************
@ObjectType()
export class RunMJArtifactVersionAttributeViewResult {
    @Field(() => [MJArtifactVersionAttribute_])
    Results: MJArtifactVersionAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactVersionAttribute_)
export class MJArtifactVersionAttributeResolver extends ResolverBase {
    @Query(() => RunMJArtifactVersionAttributeViewResult)
    async RunMJArtifactVersionAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactVersionAttributeViewResult)
    async RunMJArtifactVersionAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactVersionAttributeViewResult)
    async RunMJArtifactVersionAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Version Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactVersionAttribute_, { nullable: true })
    async MJArtifactVersionAttribute(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactVersionAttribute_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Version Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactVersionAttributes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Version Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Version Attributes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJArtifactVersionAttribute_)
    async CreateMJArtifactVersionAttribute(
        @Arg('input', () => CreateMJArtifactVersionAttributeInput) input: CreateMJArtifactVersionAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Version Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactVersionAttribute_)
    async UpdateMJArtifactVersionAttribute(
        @Arg('input', () => UpdateMJArtifactVersionAttributeInput) input: UpdateMJArtifactVersionAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Version Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactVersionAttribute_)
    async DeleteMJArtifactVersionAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Version Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Versions
//****************************************************************************
@ObjectType({ description: `Version history for artifacts, tracking all changes over time` })
export class MJArtifactVersion_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ArtifactID: string;
        
    @Field(() => Int, {description: `Sequential version number for this artifact`}) 
    VersionNumber: number;
        
    @Field({nullable: true, description: `The content of the artifact at this version`}) 
    Content?: string;
        
    @Field({nullable: true, description: `JSON configuration for this version`}) 
    Configuration?: string;
        
    @Field({nullable: true, description: `User comments specific to this version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `SHA-256 hash of the Content field for duplicate detection and version comparison`}) 
    @MaxLength(500)
    ContentHash?: string;
        
    @Field({nullable: true, description: `Name of this artifact version. Can differ from Artifact.Name as it may evolve with versions.`}) 
    @MaxLength(255)
    Name?: string;
        
    @Field({nullable: true, description: `Description of this artifact version. Can differ from Artifact.Description as it may evolve with versions.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(255)
    Artifact: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field(() => [MJArtifactVersionAttribute_])
    MJArtifactVersionAttributes_ArtifactVersionIDArray: MJArtifactVersionAttribute_[]; // Link to MJArtifactVersionAttributes
    
    @Field(() => [MJCollectionArtifact_])
    MJCollectionArtifacts_ArtifactVersionIDArray: MJCollectionArtifact_[]; // Link to MJCollectionArtifacts
    
    @Field(() => [MJConversationDetailArtifact_])
    MJConversationDetailArtifacts_ArtifactVersionIDArray: MJConversationDetailArtifact_[]; // Link to MJConversationDetailArtifacts
    
    @Field(() => [MJArtifactUse_])
    MJArtifactUses_ArtifactVersionIDArray: MJArtifactUse_[]; // Link to MJArtifactUses
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Versions
//****************************************************************************
@InputType()
export class CreateMJArtifactVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ArtifactID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Content: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ContentHash: string | null;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Versions
//****************************************************************************
@InputType()
export class UpdateMJArtifactVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ArtifactID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Content?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ContentHash?: string | null;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Versions
//****************************************************************************
@ObjectType()
export class RunMJArtifactVersionViewResult {
    @Field(() => [MJArtifactVersion_])
    Results: MJArtifactVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactVersion_)
export class MJArtifactVersionResolver extends ResolverBase {
    @Query(() => RunMJArtifactVersionViewResult)
    async RunMJArtifactVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactVersionViewResult)
    async RunMJArtifactVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactVersionViewResult)
    async RunMJArtifactVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactVersion_, { nullable: true })
    async MJArtifactVersion(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactVersions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Versions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJArtifactVersionAttribute_])
    async MJArtifactVersionAttributes_ArtifactVersionIDArray(@Root() mjartifactversion_: MJArtifactVersion_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Version Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactVersionAttributes')} WHERE ${provider.QuoteIdentifier('ArtifactVersionID')}='${mjartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Version Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Version Attributes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionArtifact_])
    async MJCollectionArtifacts_ArtifactVersionIDArray(@Root() mjartifactversion_: MJArtifactVersion_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollectionArtifacts')} WHERE ${provider.QuoteIdentifier('ArtifactVersionID')}='${mjartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailArtifact_])
    async MJConversationDetailArtifacts_ArtifactVersionIDArray(@Root() mjartifactversion_: MJArtifactVersion_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailArtifacts')} WHERE ${provider.QuoteIdentifier('ArtifactVersionID')}='${mjartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactUse_])
    async MJArtifactUses_ArtifactVersionIDArray(@Root() mjartifactversion_: MJArtifactVersion_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Uses', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactUses')} WHERE ${provider.QuoteIdentifier('ArtifactVersionID')}='${mjartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Uses', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Uses', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJArtifactVersion_)
    async CreateMJArtifactVersion(
        @Arg('input', () => CreateMJArtifactVersionInput) input: CreateMJArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactVersion_)
    async UpdateMJArtifactVersion(
        @Arg('input', () => UpdateMJArtifactVersionInput) input: UpdateMJArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactVersion_)
    async DeleteMJArtifactVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifacts
//****************************************************************************
@ObjectType({ description: `Independent content items (code, documents, charts) that can be linked to multiple conversations and collections. Supports versioning and sharing.` })
export class MJArtifact_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EnvironmentID: string;
        
    @Field({description: `Display name for the artifact`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the artifact contents and purpose`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    TypeID: string;
        
    @Field({nullable: true, description: `User comments about the artifact`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Controls artifact visibility in user-facing lists. "Always" shows in all lists, "System Only" hides from normal views (for system-generated artifacts like agent routing payloads).`}) 
    @MaxLength(20)
    Visibility: string;
        
    @Field() 
    @MaxLength(255)
    Environment: string;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field(() => [MJArtifactVersion_])
    MJArtifactVersions_ArtifactIDArray: MJArtifactVersion_[]; // Link to MJArtifactVersions
    
    @Field(() => [MJCollectionArtifact_])
    MJCollectionArtifacts_ArtifactIDArray: MJCollectionArtifact_[]; // Link to MJCollectionArtifacts
    
    @Field(() => [MJArtifactPermission_])
    MJArtifactPermissions_ArtifactIDArray: MJArtifactPermission_[]; // Link to MJArtifactPermissions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifacts
//****************************************************************************
@InputType()
export class CreateMJArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Visibility?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifacts
//****************************************************************************
@InputType()
export class UpdateMJArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Visibility?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifacts
//****************************************************************************
@ObjectType()
export class RunMJArtifactViewResult {
    @Field(() => [MJArtifact_])
    Results: MJArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifact_)
export class MJArtifactResolver extends ResolverBase {
    @Query(() => RunMJArtifactViewResult)
    async RunMJArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactViewResult)
    async RunMJArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactViewResult)
    async RunMJArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifact_, { nullable: true })
    async MJArtifact(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifacts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifacts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJArtifactVersion_])
    async MJArtifactVersions_ArtifactIDArray(@Root() mjartifact_: MJArtifact_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactVersions')} WHERE ${provider.QuoteIdentifier('ArtifactID')}='${mjartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Versions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionArtifact_])
    async MJCollectionArtifacts_ArtifactIDArray(@Root() mjartifact_: MJArtifact_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollectionArtifacts')} WHERE ${provider.QuoteIdentifier('ArtifactID')}='${mjartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactPermission_])
    async MJArtifactPermissions_ArtifactIDArray(@Root() mjartifact_: MJArtifact_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactPermissions')} WHERE ${provider.QuoteIdentifier('ArtifactID')}='${mjartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJArtifact_)
    async CreateMJArtifact(
        @Arg('input', () => CreateMJArtifactInput) input: CreateMJArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifact_)
    async UpdateMJArtifact(
        @Arg('input', () => UpdateMJArtifactInput) input: UpdateMJArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifact_)
    async DeleteMJArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Audit Log Types
//****************************************************************************
@ObjectType({ description: `Defines the types of events that can be recorded in the audit log, enabling categorization and filtering of system activities.` })
export class MJAuditLogType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    AuthorizationID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Authorization?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJAuditLog_])
    MJAuditLogs_AuditLogTypeNameArray: MJAuditLog_[]; // Link to MJAuditLogs
    
    @Field(() => [MJAuditLogType_])
    MJAuditLogTypes_ParentIDArray: MJAuditLogType_[]; // Link to MJAuditLogTypes
    
}

//****************************************************************************
// INPUT TYPE for MJ: Audit Log Types
//****************************************************************************
@InputType()
export class CreateMJAuditLogTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    AuthorizationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Audit Log Types
//****************************************************************************
@InputType()
export class UpdateMJAuditLogTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    AuthorizationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Audit Log Types
//****************************************************************************
@ObjectType()
export class RunMJAuditLogTypeViewResult {
    @Field(() => [MJAuditLogType_])
    Results: MJAuditLogType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuditLogType_)
export class MJAuditLogTypeResolver extends ResolverBase {
    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Audit Log Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuditLogType_, { nullable: true })
    async MJAuditLogType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuditLogType_ | null> {
        this.CheckUserReadPermissions('MJ: Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Audit Log Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAuditLogType_])
    async AllMJAuditLogTypes(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogTypes')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Log Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Audit Log Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAuditLog_])
    async MJAuditLogs_AuditLogTypeNameArray(@Root() mjauditlogtype_: MJAuditLogType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogs')} WHERE ${provider.QuoteIdentifier('AuditLogTypeName')}='${mjauditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Audit Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLogType_])
    async MJAuditLogTypes_ParentIDArray(@Root() mjauditlogtype_: MJAuditLogType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogTypes')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjauditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Audit Log Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAuditLogType_)
    async CreateMJAuditLogType(
        @Arg('input', () => CreateMJAuditLogTypeInput) input: CreateMJAuditLogTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Audit Log Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuditLogType_)
    async UpdateMJAuditLogType(
        @Arg('input', () => UpdateMJAuditLogTypeInput) input: UpdateMJAuditLogTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Audit Log Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAuditLogType_)
    async DeleteMJAuditLogType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Audit Log Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Audit Logs
//****************************************************************************
@ObjectType({ description: `Tracks system events and user actions for security, compliance, and debugging purposes, providing a complete audit trail. Any application can write entries to this entity.` })
export class MJAuditLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    @MaxLength(36)
    AuditLogTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(50)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `JSON-formatted additional context about the audited event, including before/after values, parameters, or other relevant data.`}) 
    Details?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    EntityID?: string;
        
    @Field({nullable: true, description: `The primary key value of the record that was affected by this audited action, enabling direct lookup of the modified data.`}) 
    @MaxLength(450)
    RecordID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field() 
    @MaxLength(50)
    AuditLogType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Authorization?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Audit Logs
//****************************************************************************
@InputType()
export class CreateMJAuditLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Details: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Audit Logs
//****************************************************************************
@InputType()
export class UpdateMJAuditLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Audit Logs
//****************************************************************************
@ObjectType()
export class RunMJAuditLogViewResult {
    @Field(() => [MJAuditLog_])
    Results: MJAuditLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuditLog_)
export class MJAuditLogResolver extends ResolverBase {
    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Audit Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuditLog_, { nullable: true })
    async MJAuditLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuditLog_ | null> {
        this.CheckUserReadPermissions('MJ: Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Audit Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAuditLog_)
    async CreateMJAuditLog(
        @Arg('input', () => CreateMJAuditLogInput) input: CreateMJAuditLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Audit Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuditLog_)
    async UpdateMJAuditLog(
        @Arg('input', () => UpdateMJAuditLogInput) input: UpdateMJAuditLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Audit Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAuditLog_)
    async DeleteMJAuditLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Audit Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Authorization Roles
//****************************************************************************
@ObjectType({ description: `Links authorizations to roles, defining which permissions are granted to users assigned to specific roles in the system.` })
export class MJAuthorizationRole_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    AuthorizationID: string;
        
    @Field() 
    @MaxLength(36)
    RoleID: string;
        
    @Field({description: `Specifies whether this authorization is granted to ('grant') or explicitly denied ('deny') for the role.`}) 
    @MaxLength(10)
    Type: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Authorization: string;
        
    @Field() 
    @MaxLength(50)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Authorization Roles
//****************************************************************************
@InputType()
export class CreateMJAuthorizationRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field({ nullable: true })
    Type?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Authorization Roles
//****************************************************************************
@InputType()
export class UpdateMJAuthorizationRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Authorization Roles
//****************************************************************************
@ObjectType()
export class RunMJAuthorizationRoleViewResult {
    @Field(() => [MJAuthorizationRole_])
    Results: MJAuthorizationRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuthorizationRole_)
export class MJAuthorizationRoleResolver extends ResolverBase {
    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Authorization Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuthorizationRole_, { nullable: true })
    async MJAuthorizationRole(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuthorizationRole_ | null> {
        this.CheckUserReadPermissions('MJ: Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuthorizationRoles')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Authorization Roles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAuthorizationRole_])
    async AllMJAuthorizationRoles(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuthorizationRoles')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Authorization Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Authorization Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAuthorizationRole_)
    async CreateMJAuthorizationRole(
        @Arg('input', () => CreateMJAuthorizationRoleInput) input: CreateMJAuthorizationRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Authorization Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuthorizationRole_)
    async UpdateMJAuthorizationRole(
        @Arg('input', () => UpdateMJAuthorizationRoleInput) input: UpdateMJAuthorizationRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Authorization Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAuthorizationRole_)
    async DeleteMJAuthorizationRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Authorization Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Authorizations
//****************************************************************************
@ObjectType({ description: `Stores the fundamental permissions and access rights that can be granted to users and roles throughout the system.` })
export class MJAuthorization_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field(() => Boolean, {description: `Indicates whether this authorization is currently active and can be granted to users or roles.`}) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, Audit Log records are created whenever this authorization is invoked for a user`}) 
    UseAuditLog: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJAuthorizationRole_])
    MJAuthorizationRoles_AuthorizationIDArray: MJAuthorizationRole_[]; // Link to MJAuthorizationRoles
    
    @Field(() => [MJAuthorization_])
    MJAuthorizations_ParentIDArray: MJAuthorization_[]; // Link to MJAuthorizations
    
    @Field(() => [MJAuditLogType_])
    MJAuditLogTypes_AuthorizationNameArray: MJAuditLogType_[]; // Link to MJAuditLogTypes
    
    @Field(() => [MJAuditLog_])
    MJAuditLogs_AuthorizationNameArray: MJAuditLog_[]; // Link to MJAuditLogs
    
    @Field(() => [MJActionAuthorization_])
    MJActionAuthorizations_AuthorizationIDArray: MJActionAuthorization_[]; // Link to MJActionAuthorizations
    
}

//****************************************************************************
// INPUT TYPE for MJ: Authorizations
//****************************************************************************
@InputType()
export class CreateMJAuthorizationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    UseAuditLog?: boolean;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Authorizations
//****************************************************************************
@InputType()
export class UpdateMJAuthorizationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    UseAuditLog?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Authorizations
//****************************************************************************
@ObjectType()
export class RunMJAuthorizationViewResult {
    @Field(() => [MJAuthorization_])
    Results: MJAuthorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuthorization_)
export class MJAuthorizationResolver extends ResolverBase {
    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Authorizations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuthorization_, { nullable: true })
    async MJAuthorization(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuthorization_ | null> {
        this.CheckUserReadPermissions('MJ: Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuthorizations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Authorizations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAuthorization_])
    async AllMJAuthorizations(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuthorizations')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Authorizations', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Authorizations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAuthorizationRole_])
    async MJAuthorizationRoles_AuthorizationIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuthorizationRoles')} WHERE ${provider.QuoteIdentifier('AuthorizationID')}='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Authorization Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuthorization_])
    async MJAuthorizations_ParentIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuthorizations')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Authorizations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLogType_])
    async MJAuditLogTypes_AuthorizationNameArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogTypes')} WHERE ${provider.QuoteIdentifier('AuthorizationName')}='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Audit Log Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async MJAuditLogs_AuthorizationNameArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogs')} WHERE ${provider.QuoteIdentifier('AuthorizationName')}='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Audit Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionAuthorization_])
    async MJActionAuthorizations_AuthorizationIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionAuthorizations')} WHERE ${provider.QuoteIdentifier('AuthorizationID')}='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Authorizations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAuthorization_)
    async CreateMJAuthorization(
        @Arg('input', () => CreateMJAuthorizationInput) input: CreateMJAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Authorizations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuthorization_)
    async UpdateMJAuthorization(
        @Arg('input', () => UpdateMJAuthorizationInput) input: UpdateMJAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Authorizations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAuthorization_)
    async DeleteMJAuthorization(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Authorizations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Collection Artifacts
//****************************************************************************
@ObjectType({ description: `Links collections to specific artifact versions. Each collection can contain multiple versions of the same artifact.` })
export class MJCollectionArtifact_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CollectionID: string;
        
    @Field(() => Int, {description: `Sequence number for ordering artifacts within a collection`}) 
    Sequence: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Required. Specific version of the artifact saved to this collection. Collections store version-specific artifacts to enable proper version tracking and Links tab filtering.`}) 
    @MaxLength(36)
    ArtifactVersionID: string;
        
    @Field() 
    @MaxLength(255)
    Collection: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ArtifactVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Collection Artifacts
//****************************************************************************
@InputType()
export class CreateMJCollectionArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CollectionID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    ArtifactVersionID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Collection Artifacts
//****************************************************************************
@InputType()
export class UpdateMJCollectionArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CollectionID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Collection Artifacts
//****************************************************************************
@ObjectType()
export class RunMJCollectionArtifactViewResult {
    @Field(() => [MJCollectionArtifact_])
    Results: MJCollectionArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCollectionArtifact_)
export class MJCollectionArtifactResolver extends ResolverBase {
    @Query(() => RunMJCollectionArtifactViewResult)
    async RunMJCollectionArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionArtifactViewResult)
    async RunMJCollectionArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionArtifactViewResult)
    async RunMJCollectionArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Collection Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCollectionArtifact_, { nullable: true })
    async MJCollectionArtifact(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCollectionArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Collection Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollectionArtifacts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Collection Artifacts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCollectionArtifact_)
    async CreateMJCollectionArtifact(
        @Arg('input', () => CreateMJCollectionArtifactInput) input: CreateMJCollectionArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Collection Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCollectionArtifact_)
    async UpdateMJCollectionArtifact(
        @Arg('input', () => UpdateMJCollectionArtifactInput) input: UpdateMJCollectionArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Collection Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCollectionArtifact_)
    async DeleteMJCollectionArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Collection Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Collection Permissions
//****************************************************************************
@ObjectType({ description: `Manages sharing permissions for collections, allowing granular access control` })
export class MJCollectionPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CollectionID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field(() => Boolean, {description: `Always 1 - users must have read permission to access a shared collection`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Can share this collection with others (but cannot grant more permissions than they have)`}) 
    CanShare: boolean;
        
    @Field(() => Boolean, {description: `Can add/remove artifacts to/from this collection`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Can delete the collection, child collections, and artifacts`}) 
    CanDelete: boolean;
        
    @Field({nullable: true, description: `The user who shared this collection (NULL if shared by owner)`}) 
    @MaxLength(36)
    SharedByUserID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Collection: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SharedByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Collection Permissions
//****************************************************************************
@InputType()
export class CreateMJCollectionPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CollectionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    SharedByUserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Collection Permissions
//****************************************************************************
@InputType()
export class UpdateMJCollectionPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CollectionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    SharedByUserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Collection Permissions
//****************************************************************************
@ObjectType()
export class RunMJCollectionPermissionViewResult {
    @Field(() => [MJCollectionPermission_])
    Results: MJCollectionPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCollectionPermission_)
export class MJCollectionPermissionResolver extends ResolverBase {
    @Query(() => RunMJCollectionPermissionViewResult)
    async RunMJCollectionPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionPermissionViewResult)
    async RunMJCollectionPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionPermissionViewResult)
    async RunMJCollectionPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Collection Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCollectionPermission_, { nullable: true })
    async MJCollectionPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCollectionPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Collection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollectionPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Collection Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCollectionPermission_)
    async CreateMJCollectionPermission(
        @Arg('input', () => CreateMJCollectionPermissionInput) input: CreateMJCollectionPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Collection Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCollectionPermission_)
    async UpdateMJCollectionPermission(
        @Arg('input', () => UpdateMJCollectionPermissionInput) input: UpdateMJCollectionPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Collection Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCollectionPermission_)
    async DeleteMJCollectionPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Collection Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Collections
//****************************************************************************
@ObjectType({ description: `Organizational folders for storing and categorizing artifacts. Supports nested folder structure for hierarchical organization.` })
export class MJCollection_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Display name for the collection`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the collection purpose`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for UI display`}) 
    @MaxLength(50)
    Icon?: string;
        
    @Field({nullable: true, description: `Hex color code for UI display (#RRGGBB format)`}) 
    @MaxLength(7)
    Color?: string;
        
    @Field(() => Int, {nullable: true, description: `Display sequence for ordering collections in UI`}) 
    Sequence?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The user who owns this collection and has full permissions`}) 
    @MaxLength(36)
    OwnerID?: string;
        
    @Field() 
    @MaxLength(255)
    Environment: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Owner?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJCollectionArtifact_])
    MJCollectionArtifacts_CollectionIDArray: MJCollectionArtifact_[]; // Link to MJCollectionArtifacts
    
    @Field(() => [MJCollectionPermission_])
    MJCollectionPermissions_CollectionIDArray: MJCollectionPermission_[]; // Link to MJCollectionPermissions
    
    @Field(() => [MJCollection_])
    MJCollections_ParentIDArray: MJCollection_[]; // Link to MJCollections
    
}

//****************************************************************************
// INPUT TYPE for MJ: Collections
//****************************************************************************
@InputType()
export class CreateMJCollectionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field(() => Int, { nullable: true })
    Sequence: number | null;

    @Field({ nullable: true })
    OwnerID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Collections
//****************************************************************************
@InputType()
export class UpdateMJCollectionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number | null;

    @Field({ nullable: true })
    OwnerID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Collections
//****************************************************************************
@ObjectType()
export class RunMJCollectionViewResult {
    @Field(() => [MJCollection_])
    Results: MJCollection_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCollection_)
export class MJCollectionResolver extends ResolverBase {
    @Query(() => RunMJCollectionViewResult)
    async RunMJCollectionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionViewResult)
    async RunMJCollectionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionViewResult)
    async RunMJCollectionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Collections';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCollection_, { nullable: true })
    async MJCollection(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCollection_ | null> {
        this.CheckUserReadPermissions('MJ: Collections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollections')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Collections', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCollectionArtifact_])
    async MJCollectionArtifacts_CollectionIDArray(@Root() mjcollection_: MJCollection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollectionArtifacts')} WHERE ${provider.QuoteIdentifier('CollectionID')}='${mjcollection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionPermission_])
    async MJCollectionPermissions_CollectionIDArray(@Root() mjcollection_: MJCollection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollectionPermissions')} WHERE ${provider.QuoteIdentifier('CollectionID')}='${mjcollection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollection_])
    async MJCollections_ParentIDArray(@Root() mjcollection_: MJCollection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollections')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjcollection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCollection_)
    async CreateMJCollection(
        @Arg('input', () => CreateMJCollectionInput) input: CreateMJCollectionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Collections', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCollection_)
    async UpdateMJCollection(
        @Arg('input', () => UpdateMJCollectionInput) input: UpdateMJCollectionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Collections', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCollection_)
    async DeleteMJCollection(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Collections', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Communication Base Message Types
//****************************************************************************
@ObjectType({ description: `Base message types and their supported functionalities.` })
export class MJCommunicationBaseMessageType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The unique identifier for this message type, used for routing and processing communications.`}) 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates if attachments are supported.`}) 
    SupportsAttachments: boolean;
        
    @Field(() => Boolean, {description: `Indicates if a subject line is supported.`}) 
    SupportsSubjectLine: boolean;
        
    @Field(() => Boolean, {description: `Indicates if HTML content is supported.`}) 
    SupportsHtml: boolean;
        
    @Field(() => Int, {nullable: true, description: `The maximum size in bytes for the message.`}) 
    MaxBytes?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJCommunicationProviderMessageType_])
    MJCommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray: MJCommunicationProviderMessageType_[]; // Link to MJCommunicationProviderMessageTypes
    
    @Field(() => [MJEntityCommunicationMessageType_])
    MJEntityCommunicationMessageTypes_BaseMessageTypeIDArray: MJEntityCommunicationMessageType_[]; // Link to MJEntityCommunicationMessageTypes
    
}

//****************************************************************************
// INPUT TYPE for MJ: Communication Base Message Types
//****************************************************************************
@InputType()
export class CreateMJCommunicationBaseMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Communication Base Message Types
//****************************************************************************
@InputType()
export class UpdateMJCommunicationBaseMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Communication Base Message Types
//****************************************************************************
@ObjectType()
export class RunMJCommunicationBaseMessageTypeViewResult {
    @Field(() => [MJCommunicationBaseMessageType_])
    Results: MJCommunicationBaseMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationBaseMessageType_)
export class MJCommunicationBaseMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Communication Base Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationBaseMessageType_, { nullable: true })
    async MJCommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationBaseMessageType_ | null> {
        this.CheckUserReadPermissions('MJ: Communication Base Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationBaseMessageTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Base Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Communication Base Message Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationProviderMessageType_])
    async MJCommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray(@Root() mjcommunicationbasemessagetype_: MJCommunicationBaseMessageType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationProviderMessageTypes')} WHERE ${provider.QuoteIdentifier('CommunicationBaseMessageTypeID')}='${mjcommunicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Communication Provider Message Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityCommunicationMessageType_])
    async MJEntityCommunicationMessageTypes_BaseMessageTypeIDArray(@Root() mjcommunicationbasemessagetype_: MJCommunicationBaseMessageType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityCommunicationMessageTypes')} WHERE ${provider.QuoteIdentifier('BaseMessageTypeID')}='${mjcommunicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Communication Message Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCommunicationBaseMessageType_)
    async CreateMJCommunicationBaseMessageType(
        @Arg('input', () => CreateMJCommunicationBaseMessageTypeInput) input: CreateMJCommunicationBaseMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Communication Base Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationBaseMessageType_)
    async UpdateMJCommunicationBaseMessageType(
        @Arg('input', () => UpdateMJCommunicationBaseMessageTypeInput) input: UpdateMJCommunicationBaseMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Communication Base Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationBaseMessageType_)
    async DeleteMJCommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Communication Base Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Communication Logs
//****************************************************************************
@ObjectType({ description: `Logs of sent and received messages.` })
export class MJCommunicationLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(36)
    CommunicationProviderMessageTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CommunicationRunID?: string;
        
    @Field({description: `The direction of the communication log (Sending or Receiving).`}) 
    @MaxLength(20)
    Direction: string;
        
    @Field({description: `The date and time when the message was logged.`}) 
    MessageDate: Date;
        
    @Field({description: `The status of the logged message (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `The content of the logged message.`}) 
    MessageContent?: string;
        
    @Field({nullable: true, description: `The error message if the message sending failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(255)
    CommunicationProviderMessageType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    CommunicationRun?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Communication Logs
//****************************************************************************
@InputType()
export class CreateMJCommunicationLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Communication Logs
//****************************************************************************
@InputType()
export class UpdateMJCommunicationLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID?: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Communication Logs
//****************************************************************************
@ObjectType()
export class RunMJCommunicationLogViewResult {
    @Field(() => [MJCommunicationLog_])
    Results: MJCommunicationLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationLog_)
export class MJCommunicationLogResolver extends ResolverBase {
    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Communication Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationLog_, { nullable: true })
    async MJCommunicationLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationLog_ | null> {
        this.CheckUserReadPermissions('MJ: Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Communication Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCommunicationLog_)
    async CreateMJCommunicationLog(
        @Arg('input', () => CreateMJCommunicationLogInput) input: CreateMJCommunicationLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Communication Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationLog_)
    async UpdateMJCommunicationLog(
        @Arg('input', () => UpdateMJCommunicationLogInput) input: UpdateMJCommunicationLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Communication Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationLog_)
    async DeleteMJCommunicationLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Communication Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Communication Provider Message Types
//****************************************************************************
@ObjectType({ description: `Providers and their supported message types with additional attributes.` })
export class MJCommunicationProviderMessageType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(36)
    CommunicationBaseMessageTypeID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({description: `The status of the provider message type (Disabled or Active).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Additional attributes specific to the provider message type.`}) 
    AdditionalAttributes?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(100)
    CommunicationBaseMessageType: string;
        
    @Field(() => [MJCommunicationLog_])
    MJCommunicationLogs_CommunicationProviderMessageTypeIDArray: MJCommunicationLog_[]; // Link to MJCommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for MJ: Communication Provider Message Types
//****************************************************************************
@InputType()
export class CreateMJCommunicationProviderMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Communication Provider Message Types
//****************************************************************************
@InputType()
export class UpdateMJCommunicationProviderMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Communication Provider Message Types
//****************************************************************************
@ObjectType()
export class RunMJCommunicationProviderMessageTypeViewResult {
    @Field(() => [MJCommunicationProviderMessageType_])
    Results: MJCommunicationProviderMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationProviderMessageType_)
export class MJCommunicationProviderMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Communication Provider Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationProviderMessageType_, { nullable: true })
    async MJCommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationProviderMessageType_ | null> {
        this.CheckUserReadPermissions('MJ: Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationProviderMessageTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Communication Provider Message Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationLog_])
    async MJCommunicationLogs_CommunicationProviderMessageTypeIDArray(@Root() mjcommunicationprovidermessagetype_: MJCommunicationProviderMessageType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationLogs')} WHERE ${provider.QuoteIdentifier('CommunicationProviderMessageTypeID')}='${mjcommunicationprovidermessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Communication Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCommunicationProviderMessageType_)
    async CreateMJCommunicationProviderMessageType(
        @Arg('input', () => CreateMJCommunicationProviderMessageTypeInput) input: CreateMJCommunicationProviderMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Communication Provider Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationProviderMessageType_)
    async UpdateMJCommunicationProviderMessageType(
        @Arg('input', () => UpdateMJCommunicationProviderMessageTypeInput) input: UpdateMJCommunicationProviderMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Communication Provider Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationProviderMessageType_)
    async DeleteMJCommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Communication Provider Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Communication Providers
//****************************************************************************
@ObjectType({ description: `All supported communication providers.` })
export class MJCommunicationProvider_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The status of the communication provider (Disabled or Active).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports sending messages.`}) 
    SupportsSending: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports receiving messages.`}) 
    SupportsReceiving: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports sending messages at a specific time`}) 
    SupportsScheduledSending: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports forwarding messages to another recipient `}) 
    SupportsForwarding: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports replying to messages`}) 
    SupportsReplying: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports creating draft messages`}) 
    SupportsDrafts: boolean;
        
    @Field(() => [MJCommunicationProviderMessageType_])
    MJCommunicationProviderMessageTypes_CommunicationProviderIDArray: MJCommunicationProviderMessageType_[]; // Link to MJCommunicationProviderMessageTypes
    
    @Field(() => [MJCommunicationLog_])
    MJCommunicationLogs_CommunicationProviderIDArray: MJCommunicationLog_[]; // Link to MJCommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for MJ: Communication Providers
//****************************************************************************
@InputType()
export class CreateMJCommunicationProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsDrafts?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Communication Providers
//****************************************************************************
@InputType()
export class UpdateMJCommunicationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsDrafts?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Communication Providers
//****************************************************************************
@ObjectType()
export class RunMJCommunicationProviderViewResult {
    @Field(() => [MJCommunicationProvider_])
    Results: MJCommunicationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationProvider_)
export class MJCommunicationProviderResolver extends ResolverBase {
    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Communication Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationProvider_, { nullable: true })
    async MJCommunicationProvider(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationProvider_ | null> {
        this.CheckUserReadPermissions('MJ: Communication Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationProviders')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Communication Providers', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationProviderMessageType_])
    async MJCommunicationProviderMessageTypes_CommunicationProviderIDArray(@Root() mjcommunicationprovider_: MJCommunicationProvider_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationProviderMessageTypes')} WHERE ${provider.QuoteIdentifier('CommunicationProviderID')}='${mjcommunicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Communication Provider Message Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCommunicationLog_])
    async MJCommunicationLogs_CommunicationProviderIDArray(@Root() mjcommunicationprovider_: MJCommunicationProvider_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationLogs')} WHERE ${provider.QuoteIdentifier('CommunicationProviderID')}='${mjcommunicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Communication Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCommunicationProvider_)
    async CreateMJCommunicationProvider(
        @Arg('input', () => CreateMJCommunicationProviderInput) input: CreateMJCommunicationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Communication Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationProvider_)
    async UpdateMJCommunicationProvider(
        @Arg('input', () => UpdateMJCommunicationProviderInput) input: UpdateMJCommunicationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Communication Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationProvider_)
    async DeleteMJCommunicationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Communication Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Communication Runs
//****************************************************************************
@ObjectType({ description: `Runs of bulk message sends and receives.` })
export class MJCommunicationRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `The direction of the communication run (Sending or Receiving).`}) 
    @MaxLength(20)
    Direction: string;
        
    @Field({description: `The status of the communication run (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field({nullable: true, description: `The error message if the communication run failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field(() => [MJCommunicationLog_])
    MJCommunicationLogs_CommunicationRunIDArray: MJCommunicationLog_[]; // Link to MJCommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for MJ: Communication Runs
//****************************************************************************
@InputType()
export class CreateMJCommunicationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Communication Runs
//****************************************************************************
@InputType()
export class UpdateMJCommunicationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Communication Runs
//****************************************************************************
@ObjectType()
export class RunMJCommunicationRunViewResult {
    @Field(() => [MJCommunicationRun_])
    Results: MJCommunicationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationRun_)
export class MJCommunicationRunResolver extends ResolverBase {
    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Communication Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationRun_, { nullable: true })
    async MJCommunicationRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationRun_ | null> {
        this.CheckUserReadPermissions('MJ: Communication Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Communication Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationLog_])
    async MJCommunicationLogs_CommunicationRunIDArray(@Root() mjcommunicationrun_: MJCommunicationRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationLogs')} WHERE ${provider.QuoteIdentifier('CommunicationRunID')}='${mjcommunicationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Communication Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCommunicationRun_)
    async CreateMJCommunicationRun(
        @Arg('input', () => CreateMJCommunicationRunInput) input: CreateMJCommunicationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Communication Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationRun_)
    async UpdateMJCommunicationRun(
        @Arg('input', () => UpdateMJCommunicationRunInput) input: UpdateMJCommunicationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Communication Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationRun_)
    async DeleteMJCommunicationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Communication Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Companies
//****************************************************************************
@ObjectType({ description: `A list of organizational units within your business. These can be subsidiaries or divisions or other units. Companies are used to organizae employee records and also for separating integrations if you have multiple integrations of the same type of system.` })
export class MJCompany_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field() 
    @MaxLength(200)
    Description: string;
        
    @Field({nullable: true, description: `The primary website URL for this company or division.`}) 
    @MaxLength(100)
    Website?: string;
        
    @Field({nullable: true, description: `URL pointing to the company's logo image, used for branding in the UI.`}) 
    @MaxLength(500)
    LogoURL?: string;
        
    @Field({nullable: true, description: `The primary email domain associated with this company, used for employee email validation and SSO configuration.`}) 
    @MaxLength(255)
    Domain?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEmployee_])
    MJEmployees_CompanyIDArray: MJEmployee_[]; // Link to MJEmployees
    
    @Field(() => [MJCompanyIntegration_])
    MJCompanyIntegrations_CompanyNameArray: MJCompanyIntegration_[]; // Link to MJCompanyIntegrations
    
    @Field(() => [MJWorkflow_])
    MJWorkflows_CompanyNameArray: MJWorkflow_[]; // Link to MJWorkflows
    
    @Field(() => [MJMCPServerConnection_])
    MJMCPServerConnections_CompanyIDArray: MJMCPServerConnection_[]; // Link to MJMCPServerConnections
    
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_CompanyIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
    @Field(() => [MJAIAgentExample_])
    MJAIAgentExamples_CompanyIDArray: MJAIAgentExample_[]; // Link to MJAIAgentExamples
    
}

//****************************************************************************
// INPUT TYPE for MJ: Companies
//****************************************************************************
@InputType()
export class CreateMJCompanyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;

    @Field({ nullable: true })
    Domain: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Companies
//****************************************************************************
@InputType()
export class UpdateMJCompanyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field({ nullable: true })
    Domain?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Companies
//****************************************************************************
@ObjectType()
export class RunMJCompanyViewResult {
    @Field(() => [MJCompany_])
    Results: MJCompany_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompany_)
export class MJCompanyResolver extends ResolverBase {
    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Companies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompany_, { nullable: true })
    async MJCompany(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompany_ | null> {
        this.CheckUserReadPermissions('MJ: Companies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanies')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Companies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Companies', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJCompany_])
    async AllMJCompanies(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Companies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanies')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Companies', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Companies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEmployee_])
    async MJEmployees_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployees')} WHERE ${provider.QuoteIdentifier('CompanyID')}='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employees', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegration_])
    async MJCompanyIntegrations_CompanyNameArray(@Root() mjcompany_: MJCompany_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrations')} WHERE ${provider.QuoteIdentifier('CompanyName')}='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJWorkflow_])
    async MJWorkflows_CompanyNameArray(@Root() mjcompany_: MJCompany_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkflows')} WHERE ${provider.QuoteIdentifier('CompanyName')}='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Workflows', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnection_])
    async MJMCPServerConnections_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnections')} WHERE ${provider.QuoteIdentifier('CompanyID')}='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('CompanyID')}='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJAIAgentExamples_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('CompanyID')}='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCompany_)
    async CreateMJCompany(
        @Arg('input', () => CreateMJCompanyInput) input: CreateMJCompanyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Companies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompany_)
    async UpdateMJCompany(
        @Arg('input', () => UpdateMJCompanyInput) input: UpdateMJCompanyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Companies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompany_)
    async DeleteMJCompany(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Companies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Company Integration Record Maps
//****************************************************************************
@ObjectType({ description: `Maps records between internal entities and external system identifiers, maintaining synchronization between MemberJunction and integrated platforms.` })
export class MJCompanyIntegrationRecordMap_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CompanyIntegrationID: string;
        
    @Field({description: `The unique identifier for this record in the external integrated system.`}) 
    @MaxLength(750)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `The internal MemberJunction record ID that corresponds to the external system record.`}) 
    @MaxLength(750)
    EntityRecordID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    CompanyIntegration: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Company Integration Record Maps
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRecordMapInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Company Integration Record Maps
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRecordMapInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Company Integration Record Maps
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRecordMapViewResult {
    @Field(() => [MJCompanyIntegrationRecordMap_])
    Results: MJCompanyIntegrationRecordMap_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRecordMap_)
export class MJCompanyIntegrationRecordMapResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Company Integration Record Maps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRecordMap_, { nullable: true })
    async MJCompanyIntegrationRecordMap(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRecordMap_ | null> {
        this.CheckUserReadPermissions('MJ: Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRecordMaps')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Company Integration Record Maps', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCompanyIntegrationRecordMap_)
    async CreateMJCompanyIntegrationRecordMap(
        @Arg('input', () => CreateMJCompanyIntegrationRecordMapInput) input: CreateMJCompanyIntegrationRecordMapInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Company Integration Record Maps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRecordMap_)
    async UpdateMJCompanyIntegrationRecordMap(
        @Arg('input', () => UpdateMJCompanyIntegrationRecordMapInput) input: UpdateMJCompanyIntegrationRecordMapInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Company Integration Record Maps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegrationRecordMap_)
    async DeleteMJCompanyIntegrationRecordMap(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Company Integration Record Maps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Company Integration Run API Logs
//****************************************************************************
@ObjectType({ description: `Logs detailed API calls and responses during integration runs, including request/response payloads, status codes, and timing information.` })
export class MJCompanyIntegrationRunAPILog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CompanyIntegrationRunID: string;
        
    @Field({description: `Timestamp when this API call was executed during the integration run.`}) 
    ExecutedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether the API call completed successfully or encountered an error.`}) 
    IsSuccess: boolean;
        
    @Field({nullable: true, description: `HTTP method used for the API call (GET, POST, PUT, DELETE, PATCH).`}) 
    @MaxLength(12)
    RequestMethod?: string;
        
    @Field({nullable: true, description: `The complete URL that was called, including query parameters.`}) 
    URL?: string;
        
    @Field({nullable: true, description: `JSON-formatted request body or parameters sent with the API call.`}) 
    Parameters?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    CompanyIntegrationRun: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Company Integration Run API Logs
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunAPILogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod: string | null;

    @Field({ nullable: true })
    URL: string | null;

    @Field({ nullable: true })
    Parameters: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Company Integration Run API Logs
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunAPILogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod?: string | null;

    @Field({ nullable: true })
    URL?: string | null;

    @Field({ nullable: true })
    Parameters?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Company Integration Run API Logs
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunAPILogViewResult {
    @Field(() => [MJCompanyIntegrationRunAPILog_])
    Results: MJCompanyIntegrationRunAPILog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRunAPILog_)
export class MJCompanyIntegrationRunAPILogResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Company Integration Run API Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRunAPILog_, { nullable: true })
    async MJCompanyIntegrationRunAPILog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRunAPILog_ | null> {
        this.CheckUserReadPermissions('MJ: Company Integration Run API Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRunAPILogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Company Integration Run API Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCompanyIntegrationRunAPILog_)
    async CreateMJCompanyIntegrationRunAPILog(
        @Arg('input', () => CreateMJCompanyIntegrationRunAPILogInput) input: CreateMJCompanyIntegrationRunAPILogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Company Integration Run API Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRunAPILog_)
    async UpdateMJCompanyIntegrationRunAPILog(
        @Arg('input', () => UpdateMJCompanyIntegrationRunAPILogInput) input: UpdateMJCompanyIntegrationRunAPILogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Company Integration Run API Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegrationRunAPILog_)
    async DeleteMJCompanyIntegrationRunAPILog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Company Integration Run API Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Company Integration Run Details
//****************************************************************************
@ObjectType({ description: `Tracks individual record-level operations within an integration run, including success/failure status and error details for each processed item.` })
export class MJCompanyIntegrationRunDetail_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CompanyIntegrationRunID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `The ID of the specific record being processed in this integration operation.`}) 
    @MaxLength(450)
    RecordID: string;
        
    @Field({description: `The type of operation performed (INSERT, UPDATE, DELETE, SYNC).`}) 
    @MaxLength(20)
    Action: string;
        
    @Field({description: `Timestamp when this specific record operation was executed.`}) 
    ExecutedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this individual record operation succeeded or failed.`}) 
    IsSuccess: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field({nullable: true}) 
    RunStartedAt?: Date;
        
    @Field({nullable: true}) 
    RunEndedAt?: Date;
        
    @Field(() => [MJErrorLog_])
    MJErrorLogs_CompanyIntegrationRunDetailIDArray: MJErrorLog_[]; // Link to MJErrorLogs
    
}

//****************************************************************************
// INPUT TYPE for MJ: Company Integration Run Details
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Company Integration Run Details
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Company Integration Run Details
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunDetailViewResult {
    @Field(() => [MJCompanyIntegrationRunDetail_])
    Results: MJCompanyIntegrationRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRunDetail_)
export class MJCompanyIntegrationRunDetailResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Company Integration Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRunDetail_, { nullable: true })
    async MJCompanyIntegrationRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRunDetail_ | null> {
        this.CheckUserReadPermissions('MJ: Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRunDetails')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Company Integration Run Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJErrorLog_])
    async MJErrorLogs_CompanyIntegrationRunDetailIDArray(@Root() mjcompanyintegrationrundetail_: MJCompanyIntegrationRunDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwErrorLogs')} WHERE ${provider.QuoteIdentifier('CompanyIntegrationRunDetailID')}='${mjcompanyintegrationrundetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Error Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCompanyIntegrationRunDetail_)
    async CreateMJCompanyIntegrationRunDetail(
        @Arg('input', () => CreateMJCompanyIntegrationRunDetailInput) input: CreateMJCompanyIntegrationRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Company Integration Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRunDetail_)
    async UpdateMJCompanyIntegrationRunDetail(
        @Arg('input', () => UpdateMJCompanyIntegrationRunDetailInput) input: UpdateMJCompanyIntegrationRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Company Integration Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegrationRunDetail_)
    async DeleteMJCompanyIntegrationRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Company Integration Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Company Integration Runs
//****************************************************************************
@ObjectType({ description: `Records execution history of company integrations, including start/end times, overall status, and aggregate statistics for monitoring and troubleshooting.` })
export class MJCompanyIntegrationRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(36)
    RunByUserID: string;
        
    @Field({nullable: true}) 
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    EndedAt?: Date;
        
    @Field(() => Int, {description: `The total number of records processed during this integration run.`}) 
    TotalRecords: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the integration run. Possible values: Pending, In Progress, Success, Failed.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Optional error log information for the integration run.`}) 
    ErrorLog?: string;
        
    @Field({nullable: true, description: `Optional configuration data in JSON format for the request that started the integration run for audit purposes.`}) 
    ConfigData?: string;
        
    @Field() 
    @MaxLength(100)
    Integration: string;
        
    @Field() 
    @MaxLength(50)
    Company: string;
        
    @Field() 
    @MaxLength(100)
    RunByUser: string;
        
    @Field(() => [MJCompanyIntegrationRunAPILog_])
    MJCompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray: MJCompanyIntegrationRunAPILog_[]; // Link to MJCompanyIntegrationRunAPILogs
    
    @Field(() => [MJErrorLog_])
    MJErrorLogs_CompanyIntegrationRunIDArray: MJErrorLog_[]; // Link to MJErrorLogs
    
    @Field(() => [MJCompanyIntegrationRunDetail_])
    MJCompanyIntegrationRunDetails_CompanyIntegrationRunIDArray: MJCompanyIntegrationRunDetail_[]; // Link to MJCompanyIntegrationRunDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Company Integration Runs
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ConfigData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Company Integration Runs
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ConfigData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Company Integration Runs
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunViewResult {
    @Field(() => [MJCompanyIntegrationRun_])
    Results: MJCompanyIntegrationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRun_)
export class MJCompanyIntegrationRunResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Company Integration Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRun_, { nullable: true })
    async MJCompanyIntegrationRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRun_ | null> {
        this.CheckUserReadPermissions('MJ: Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Company Integration Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCompanyIntegrationRunAPILog_])
    async MJCompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integration Run API Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRunAPILogs')} WHERE ${provider.QuoteIdentifier('CompanyIntegrationRunID')}='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integration Run API Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJErrorLog_])
    async MJErrorLogs_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwErrorLogs')} WHERE ${provider.QuoteIdentifier('CompanyIntegrationRunID')}='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Error Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRunDetail_])
    async MJCompanyIntegrationRunDetails_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRunDetails')} WHERE ${provider.QuoteIdentifier('CompanyIntegrationRunID')}='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integration Run Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCompanyIntegrationRun_)
    async CreateMJCompanyIntegrationRun(
        @Arg('input', () => CreateMJCompanyIntegrationRunInput) input: CreateMJCompanyIntegrationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Company Integration Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRun_)
    async UpdateMJCompanyIntegrationRun(
        @Arg('input', () => UpdateMJCompanyIntegrationRunInput) input: UpdateMJCompanyIntegrationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Company Integration Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegrationRun_)
    async DeleteMJCompanyIntegrationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Company Integration Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Company Integrations
//****************************************************************************
@ObjectType({ description: `Links individual company records to specific integrations` })
export class MJCompanyIntegration_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    CompanyID: string;
        
    @Field() 
    @MaxLength(36)
    IntegrationID: string;
        
    @Field(() => Boolean, {nullable: true, description: `Controls whether this integration is currently active for the company.`}) 
    IsActive?: boolean;
        
    @Field({nullable: true, description: `OAuth access token for authenticating with the external system.`}) 
    @MaxLength(255)
    AccessToken?: string;
        
    @Field({nullable: true, description: `OAuth refresh token used to obtain new access tokens when they expire.`}) 
    @MaxLength(255)
    RefreshToken?: string;
        
    @Field({nullable: true, description: `Timestamp when the current access token expires and needs to be refreshed.`}) 
    TokenExpirationDate?: Date;
        
    @Field({nullable: true, description: `API key for systems using key-based authentication instead of OAuth.`}) 
    @MaxLength(255)
    APIKey?: string;
        
    @Field({nullable: true, description: `The company's identifier in the external system, used for API calls.`}) 
    @MaxLength(100)
    ExternalSystemID?: string;
        
    @Field(() => Boolean, {description: `Indicates if data can only be read from the external system, not written back.`}) 
    IsExternalSystemReadOnly: boolean;
        
    @Field({nullable: true, description: `OAuth client ID for this integration instance.`}) 
    @MaxLength(255)
    ClientID?: string;
        
    @Field({nullable: true, description: `OAuth client secret for authentication, should be encrypted at rest.`}) 
    @MaxLength(255)
    ClientSecret?: string;
        
    @Field({nullable: true, description: `Flexible field for storing integration-specific configuration or metadata.`}) 
    @MaxLength(255)
    CustomAttribute1?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `User-friendly name for the company integration instance, typically in the format "Company: Integration".`}) 
    @MaxLength(255)
    Name: string;
        
    @Field() 
    @MaxLength(50)
    Company: string;
        
    @Field() 
    @MaxLength(100)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DriverClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DriverImportPath?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    LastRunID?: string;
        
    @Field({nullable: true}) 
    LastRunStartedAt?: Date;
        
    @Field({nullable: true}) 
    LastRunEndedAt?: Date;
        
    @Field(() => [MJList_])
    MJLists_CompanyIntegrationIDArray: MJList_[]; // Link to MJLists
    
    @Field(() => [MJEmployeeCompanyIntegration_])
    MJEmployeeCompanyIntegrations_CompanyIntegrationIDArray: MJEmployeeCompanyIntegration_[]; // Link to MJEmployeeCompanyIntegrations
    
    @Field(() => [MJCompanyIntegrationRun_])
    MJCompanyIntegrationRuns_CompanyIntegrationIDArray: MJCompanyIntegrationRun_[]; // Link to MJCompanyIntegrationRuns
    
    @Field(() => [MJCompanyIntegrationRecordMap_])
    MJCompanyIntegrationRecordMaps_CompanyIntegrationIDArray: MJCompanyIntegrationRecordMap_[]; // Link to MJCompanyIntegrationRecordMaps
    
}

//****************************************************************************
// INPUT TYPE for MJ: Company Integrations
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive: boolean | null;

    @Field({ nullable: true })
    AccessToken: string | null;

    @Field({ nullable: true })
    RefreshToken: string | null;

    @Field({ nullable: true })
    TokenExpirationDate: Date | null;

    @Field({ nullable: true })
    APIKey: string | null;

    @Field({ nullable: true })
    ExternalSystemID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsExternalSystemReadOnly?: boolean;

    @Field({ nullable: true })
    ClientID: string | null;

    @Field({ nullable: true })
    ClientSecret: string | null;

    @Field({ nullable: true })
    CustomAttribute1: string | null;

    @Field({ nullable: true })
    Name?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Company Integrations
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean | null;

    @Field({ nullable: true })
    AccessToken?: string | null;

    @Field({ nullable: true })
    RefreshToken?: string | null;

    @Field({ nullable: true })
    TokenExpirationDate?: Date | null;

    @Field({ nullable: true })
    APIKey?: string | null;

    @Field({ nullable: true })
    ExternalSystemID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsExternalSystemReadOnly?: boolean;

    @Field({ nullable: true })
    ClientID?: string | null;

    @Field({ nullable: true })
    ClientSecret?: string | null;

    @Field({ nullable: true })
    CustomAttribute1?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Company Integrations
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationViewResult {
    @Field(() => [MJCompanyIntegration_])
    Results: MJCompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegration_)
export class MJCompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Company Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegration_, { nullable: true })
    async MJCompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegration_ | null> {
        this.CheckUserReadPermissions('MJ: Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Company Integrations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJList_])
    async MJLists_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwLists')} WHERE ${provider.QuoteIdentifier('CompanyIntegrationID')}='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Lists', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeCompanyIntegration_])
    async MJEmployeeCompanyIntegrations_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeCompanyIntegrations')} WHERE ${provider.QuoteIdentifier('CompanyIntegrationID')}='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employee Company Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRun_])
    async MJCompanyIntegrationRuns_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRuns')} WHERE ${provider.QuoteIdentifier('CompanyIntegrationID')}='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integration Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRecordMap_])
    async MJCompanyIntegrationRecordMaps_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRecordMaps')} WHERE ${provider.QuoteIdentifier('CompanyIntegrationID')}='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integration Record Maps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCompanyIntegration_)
    async CreateMJCompanyIntegration(
        @Arg('input', () => CreateMJCompanyIntegrationInput) input: CreateMJCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Company Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegration_)
    async UpdateMJCompanyIntegration(
        @Arg('input', () => UpdateMJCompanyIntegrationInput) input: UpdateMJCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Company Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegration_)
    async DeleteMJCompanyIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Company Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Dependencies
//****************************************************************************
@ObjectType({ description: `Tracks component-to-component dependencies for composition` })
export class MJComponentDependency_ {
    @Field({description: `Primary key for component dependency`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign key to parent Component that has the dependency`}) 
    @MaxLength(36)
    ComponentID: string;
        
    @Field({description: `Foreign key to the Component that is depended upon`}) 
    @MaxLength(36)
    DependencyComponentID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    Component: string;
        
    @Field() 
    @MaxLength(500)
    DependencyComponent: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Component Dependencies
//****************************************************************************
@InputType()
export class CreateMJComponentDependencyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    DependencyComponentID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Dependencies
//****************************************************************************
@InputType()
export class UpdateMJComponentDependencyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    DependencyComponentID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Dependencies
//****************************************************************************
@ObjectType()
export class RunMJComponentDependencyViewResult {
    @Field(() => [MJComponentDependency_])
    Results: MJComponentDependency_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponentDependency_)
export class MJComponentDependencyResolver extends ResolverBase {
    @Query(() => RunMJComponentDependencyViewResult)
    async RunMJComponentDependencyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentDependencyViewResult)
    async RunMJComponentDependencyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentDependencyViewResult)
    async RunMJComponentDependencyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Dependencies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponentDependency_, { nullable: true })
    async MJComponentDependency(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponentDependency_ | null> {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponentDependencies')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Component Dependencies', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJComponentDependency_)
    async CreateMJComponentDependency(
        @Arg('input', () => CreateMJComponentDependencyInput) input: CreateMJComponentDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Dependencies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponentDependency_)
    async UpdateMJComponentDependency(
        @Arg('input', () => UpdateMJComponentDependencyInput) input: UpdateMJComponentDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Dependencies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponentDependency_)
    async DeleteMJComponentDependency(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Dependencies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Libraries
//****************************************************************************
@ObjectType({ description: `Catalog of third-party JavaScript libraries that components can depend on` })
export class MJComponentLibrary_ {
    @Field({description: `Primary key for the component library`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `NPM-style package name (e.g., recharts, lodash, @memberjunction/lib-name)`}) 
    @MaxLength(500)
    Name: string;
        
    @Field({nullable: true, description: `User-friendly display name for the library`}) 
    @MaxLength(500)
    DisplayName?: string;
        
    @Field({nullable: true, description: `Library version number`}) 
    @MaxLength(100)
    Version?: string;
        
    @Field({nullable: true, description: `Global variable name when loaded (e.g., _ for lodash, React for react)`}) 
    @MaxLength(255)
    GlobalVariable?: string;
        
    @Field({nullable: true, description: `Library category: Core, Runtime, UI, Charting, Utility, or Other`}) 
    @MaxLength(100)
    Category?: string;
        
    @Field({nullable: true, description: `CDN URL for loading the library JavaScript`}) 
    @MaxLength(1000)
    CDNUrl?: string;
        
    @Field({nullable: true, description: `Optional CDN URL for loading library CSS`}) 
    @MaxLength(1000)
    CDNCssUrl?: string;
        
    @Field({nullable: true, description: `Description of the library and its capabilities`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the component library. Active: fully supported; Deprecated: works but shows console warning; Disabled: throws error if used`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `JSON configuration for library-specific lint rules that are applied during component validation. This field contains structured rules that define how components using this library should be validated, including DOM element requirements, initialization patterns, lifecycle methods, and common error patterns. Example structure: {"initialization": {"constructorName": "Chart", "elementType": "canvas"}, "lifecycle": {"requiredMethods": ["render"], "cleanupMethods": ["destroy"]}}. The linter dynamically applies these rules based on the libraries referenced in a component spec, enabling extensible validation without hardcoding library-specific logic.`}) 
    LintRules?: string;
        
    @Field({nullable: true, description: `JSON object defining dependencies for this component library. Format: { "libraryName": "versionSpec", ... }. Version specifications follow NPM-style syntax (e.g., "~1.0.0", "^1.2.3", "2.3.4"). Dependencies are loaded before this library to ensure proper execution context.`}) 
    Dependencies?: string;
        
    @Field({description: `Controls how the library can be used: Direct (by components), Dependency (only as dependency), or Both`}) 
    @MaxLength(50)
    UsageType: string;
        
    @Field(() => [MJComponentLibraryLink_])
    MJComponentLibraryLinks_LibraryIDArray: MJComponentLibraryLink_[]; // Link to MJComponentLibraryLinks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Component Libraries
//****************************************************************************
@InputType()
export class CreateMJComponentLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    Version: string | null;

    @Field({ nullable: true })
    GlobalVariable: string | null;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    CDNUrl: string | null;

    @Field({ nullable: true })
    CDNCssUrl: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LintRules: string | null;

    @Field({ nullable: true })
    Dependencies: string | null;

    @Field({ nullable: true })
    UsageType?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Libraries
//****************************************************************************
@InputType()
export class UpdateMJComponentLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    Version?: string | null;

    @Field({ nullable: true })
    GlobalVariable?: string | null;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    CDNUrl?: string | null;

    @Field({ nullable: true })
    CDNCssUrl?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LintRules?: string | null;

    @Field({ nullable: true })
    Dependencies?: string | null;

    @Field({ nullable: true })
    UsageType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Libraries
//****************************************************************************
@ObjectType()
export class RunMJComponentLibraryViewResult {
    @Field(() => [MJComponentLibrary_])
    Results: MJComponentLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponentLibrary_)
export class MJComponentLibraryResolver extends ResolverBase {
    @Query(() => RunMJComponentLibraryViewResult)
    async RunMJComponentLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentLibraryViewResult)
    async RunMJComponentLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentLibraryViewResult)
    async RunMJComponentLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponentLibrary_, { nullable: true })
    async MJComponentLibrary(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponentLibrary_ | null> {
        this.CheckUserReadPermissions('MJ: Component Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponentLibraries')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Component Libraries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJComponentLibraryLink_])
    async MJComponentLibraryLinks_LibraryIDArray(@Root() mjcomponentlibrary_: MJComponentLibrary_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponentLibraryLinks')} WHERE ${provider.QuoteIdentifier('LibraryID')}='${mjcomponentlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Component Library Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJComponentLibrary_)
    async CreateMJComponentLibrary(
        @Arg('input', () => CreateMJComponentLibraryInput) input: CreateMJComponentLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponentLibrary_)
    async UpdateMJComponentLibrary(
        @Arg('input', () => UpdateMJComponentLibraryInput) input: UpdateMJComponentLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponentLibrary_)
    async DeleteMJComponentLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Library Links
//****************************************************************************
@ObjectType({ description: `Links components to their third-party library dependencies` })
export class MJComponentLibraryLink_ {
    @Field({description: `Primary key for component-library relationship`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign key to Component that depends on the library`}) 
    @MaxLength(36)
    ComponentID: string;
        
    @Field({description: `Foreign key to ComponentLibrary that the component depends on`}) 
    @MaxLength(36)
    LibraryID: string;
        
    @Field({nullable: true, description: `Minimum version requirement using semantic versioning (e.g., ^1.0.0, ~2.5.0)`}) 
    @MaxLength(100)
    MinVersion?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    Component: string;
        
    @Field() 
    @MaxLength(500)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Component Library Links
//****************************************************************************
@InputType()
export class CreateMJComponentLibraryLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    MinVersion: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Library Links
//****************************************************************************
@InputType()
export class UpdateMJComponentLibraryLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    MinVersion?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Library Links
//****************************************************************************
@ObjectType()
export class RunMJComponentLibraryLinkViewResult {
    @Field(() => [MJComponentLibraryLink_])
    Results: MJComponentLibraryLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponentLibraryLink_)
export class MJComponentLibraryLinkResolver extends ResolverBase {
    @Query(() => RunMJComponentLibraryLinkViewResult)
    async RunMJComponentLibraryLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentLibraryLinkViewResult)
    async RunMJComponentLibraryLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentLibraryLinkViewResult)
    async RunMJComponentLibraryLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Library Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponentLibraryLink_, { nullable: true })
    async MJComponentLibraryLink(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponentLibraryLink_ | null> {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponentLibraryLinks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Component Library Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJComponentLibraryLink_)
    async CreateMJComponentLibraryLink(
        @Arg('input', () => CreateMJComponentLibraryLinkInput) input: CreateMJComponentLibraryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Library Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponentLibraryLink_)
    async UpdateMJComponentLibraryLink(
        @Arg('input', () => UpdateMJComponentLibraryLinkInput) input: UpdateMJComponentLibraryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Library Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponentLibraryLink_)
    async DeleteMJComponentLibraryLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Library Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Registries
//****************************************************************************
@ObjectType({ description: `Registry catalog for component sources, similar to NPM registry but supporting multiple sources` })
export class MJComponentRegistry_ {
    @Field({description: `Primary key for the component registry`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Name of the registry (e.g., MemberJunction Registry, NPM, Internal Registry)`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of the registry and its purpose`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Registry endpoint URI (e.g., https://registry.memberjunction.org)`}) 
    @MaxLength(500)
    URI?: string;
        
    @Field({nullable: true, description: `Type of registry: public, private, or internal`}) 
    @MaxLength(50)
    Type?: string;
        
    @Field({nullable: true, description: `API version supported by the registry for compatibility`}) 
    @MaxLength(50)
    APIVersion?: string;
        
    @Field({nullable: true, description: `Current status of the registry: active, deprecated, or offline`}) 
    @MaxLength(50)
    Status?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJComponent_])
    MJComponents_SourceRegistryIDArray: MJComponent_[]; // Link to MJComponents
    
}

//****************************************************************************
// INPUT TYPE for MJ: Component Registries
//****************************************************************************
@InputType()
export class CreateMJComponentRegistryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    URI: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    APIVersion: string | null;

    @Field({ nullable: true })
    Status: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Registries
//****************************************************************************
@InputType()
export class UpdateMJComponentRegistryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    URI?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    APIVersion?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Registries
//****************************************************************************
@ObjectType()
export class RunMJComponentRegistryViewResult {
    @Field(() => [MJComponentRegistry_])
    Results: MJComponentRegistry_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponentRegistry_)
export class MJComponentRegistryResolver extends ResolverBase {
    @Query(() => RunMJComponentRegistryViewResult)
    async RunMJComponentRegistryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentRegistryViewResult)
    async RunMJComponentRegistryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentRegistryViewResult)
    async RunMJComponentRegistryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Registries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponentRegistry_, { nullable: true })
    async MJComponentRegistry(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponentRegistry_ | null> {
        this.CheckUserReadPermissions('MJ: Component Registries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponentRegistries')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Registries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Component Registries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJComponent_])
    async MJComponents_SourceRegistryIDArray(@Root() mjcomponentregistry_: MJComponentRegistry_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponents')} WHERE ${provider.QuoteIdentifier('SourceRegistryID')}='${mjcomponentregistry_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Components', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJComponentRegistry_)
    async CreateMJComponentRegistry(
        @Arg('input', () => CreateMJComponentRegistryInput) input: CreateMJComponentRegistryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Registries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponentRegistry_)
    async UpdateMJComponentRegistry(
        @Arg('input', () => UpdateMJComponentRegistryInput) input: UpdateMJComponentRegistryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Registries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponentRegistry_)
    async DeleteMJComponentRegistry(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Registries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Components
//****************************************************************************
@ObjectType({ description: `Main catalog of reusable components with versioning and registry support` })
export class MJComponent_ {
    @Field({description: `Immutable UUID that remains the same across all systems`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true, description: `Hierarchical namespace path (e.g., dashboards/sales for local, @memberjunction/dashboards/financial for external)`}) 
    Namespace?: string;
        
    @Field({description: `Component name within the namespace (e.g., revenue-tracker)`}) 
    @MaxLength(500)
    Name: string;
        
    @Field({description: `Semantic version number (e.g., 1.0.0, 1.2.3-beta)`}) 
    @MaxLength(50)
    Version: string;
        
    @Field(() => Int, {description: `Numeric sequence for sorting versions`}) 
    VersionSequence: number;
        
    @Field({nullable: true, description: `User-friendly display title for the component`}) 
    @MaxLength(1000)
    Title?: string;
        
    @Field({nullable: true, description: `[READ-ONLY] Detailed description of the component functionality. This field is automatically synchronized from the Specification.description field and should not be edited directly. To update this value, edit the component spec file.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Component type: report, dashboard, form, table, chart, navigation, search, widget, utility, or other`}) 
    @MaxLength(255)
    Type?: string;
        
    @Field({nullable: true, description: `Publication status: draft, published, or deprecated`}) 
    @MaxLength(50)
    Status?: string;
        
    @Field({nullable: true, description: `Name of the component developer or author`}) 
    @MaxLength(255)
    DeveloperName?: string;
        
    @Field({nullable: true, description: `Contact email for the component developer`}) 
    @MaxLength(255)
    DeveloperEmail?: string;
        
    @Field({nullable: true, description: `Organization name of the component developer`}) 
    @MaxLength(255)
    DeveloperOrganization?: string;
        
    @Field({nullable: true, description: `Foreign key to ComponentRegistry - NULL for local components, populated for replicated ones`}) 
    @MaxLength(36)
    SourceRegistryID?: string;
        
    @Field({nullable: true, description: `Timestamp when the component was replicated from external registry (NULL for local components)`}) 
    ReplicatedAt?: Date;
        
    @Field({nullable: true, description: `Last synchronization timestamp with the source registry`}) 
    LastSyncedAt?: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Complete JSON specification object for the component`}) 
    Specification: string;
        
    @Field({nullable: true, description: `[READ-ONLY] Functional requirements describing what the component should accomplish. This field is automatically synchronized from the Specification.functionalRequirements field and should not be edited directly. To update this value, edit the component spec file.`}) 
    FunctionalRequirements?: string;
        
    @Field({nullable: true, description: `[READ-ONLY] Technical design describing how the component is implemented. This field is automatically synchronized from the Specification.technicalDesign field and should not be edited directly. To update this value, edit the component spec file.`}) 
    TechnicalDesign?: string;
        
    @Field({nullable: true, description: `Vector embedding of the functional requirements for similarity search`}) 
    FunctionalRequirementsVector?: string;
        
    @Field({nullable: true, description: `Vector embedding of the technical design for similarity search`}) 
    TechnicalDesignVector?: string;
        
    @Field(() => Boolean, {description: `Indicates if the component has custom properties defined in its specification. Components with custom props cannot be used directly by deterministic containers.`}) 
    HasCustomProps: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the component has custom events defined in its specification. Components with custom events may have limited functionality in generic containers.`}) 
    HasCustomEvents: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the component requires data access (utilities object with md, rv, rq). Used to determine if component needs data context.`}) 
    RequiresData: boolean;
        
    @Field(() => Int, {description: `Number of component dependencies defined in the specification. Used to assess component complexity.`}) 
    DependencyCount: number;
        
    @Field({nullable: true, description: `The ID of the AI model used to generate the vector embedding for the technical design`}) 
    TechnicalDesignVectorEmbeddingModelID?: string;
        
    @Field({nullable: true, description: `The ID of the AI model used to generate the vector embedding for the functional requirements`}) 
    FunctionalRequirementsVectorEmbeddingModelID?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the component has any custom properties that are marked as required. This is auto-calculated based on the component's properties array to identify components with mandatory custom configuration.`}) 
    HasRequiredCustomProps: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SourceRegistry?: string;
        
    @Field(() => [MJComponentDependency_])
    MJComponentDependencies_DependencyComponentIDArray: MJComponentDependency_[]; // Link to MJComponentDependencies
    
    @Field(() => [MJComponentLibraryLink_])
    MJComponentLibraryLinks_ComponentIDArray: MJComponentLibraryLink_[]; // Link to MJComponentLibraryLinks
    
    @Field(() => [MJComponentDependency_])
    MJComponentDependencies_ComponentIDArray: MJComponentDependency_[]; // Link to MJComponentDependencies
    
}

//****************************************************************************
// INPUT TYPE for MJ: Components
//****************************************************************************
@InputType()
export class CreateMJComponentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Namespace: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Version?: string;

    @Field(() => Int, { nullable: true })
    VersionSequence?: number;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    DeveloperName: string | null;

    @Field({ nullable: true })
    DeveloperEmail: string | null;

    @Field({ nullable: true })
    DeveloperOrganization: string | null;

    @Field({ nullable: true })
    SourceRegistryID: string | null;

    @Field({ nullable: true })
    ReplicatedAt: Date | null;

    @Field({ nullable: true })
    LastSyncedAt: Date | null;

    @Field({ nullable: true })
    Specification?: string;

    @Field({ nullable: true })
    FunctionalRequirements: string | null;

    @Field({ nullable: true })
    TechnicalDesign: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVector: string | null;

    @Field({ nullable: true })
    TechnicalDesignVector: string | null;

    @Field(() => Boolean, { nullable: true })
    HasCustomProps?: boolean;

    @Field(() => Boolean, { nullable: true })
    HasCustomEvents?: boolean;

    @Field(() => Boolean, { nullable: true })
    RequiresData?: boolean;

    @Field(() => Int, { nullable: true })
    DependencyCount?: number;

    @Field({ nullable: true })
    TechnicalDesignVectorEmbeddingModelID: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVectorEmbeddingModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    HasRequiredCustomProps?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Components
//****************************************************************************
@InputType()
export class UpdateMJComponentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Namespace?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Version?: string;

    @Field(() => Int, { nullable: true })
    VersionSequence?: number;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    DeveloperName?: string | null;

    @Field({ nullable: true })
    DeveloperEmail?: string | null;

    @Field({ nullable: true })
    DeveloperOrganization?: string | null;

    @Field({ nullable: true })
    SourceRegistryID?: string | null;

    @Field({ nullable: true })
    ReplicatedAt?: Date | null;

    @Field({ nullable: true })
    LastSyncedAt?: Date | null;

    @Field({ nullable: true })
    Specification?: string;

    @Field({ nullable: true })
    FunctionalRequirements?: string | null;

    @Field({ nullable: true })
    TechnicalDesign?: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVector?: string | null;

    @Field({ nullable: true })
    TechnicalDesignVector?: string | null;

    @Field(() => Boolean, { nullable: true })
    HasCustomProps?: boolean;

    @Field(() => Boolean, { nullable: true })
    HasCustomEvents?: boolean;

    @Field(() => Boolean, { nullable: true })
    RequiresData?: boolean;

    @Field(() => Int, { nullable: true })
    DependencyCount?: number;

    @Field({ nullable: true })
    TechnicalDesignVectorEmbeddingModelID?: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVectorEmbeddingModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    HasRequiredCustomProps?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Components
//****************************************************************************
@ObjectType()
export class RunMJComponentViewResult {
    @Field(() => [MJComponent_])
    Results: MJComponent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponent_)
export class MJComponentResolver extends ResolverBase {
    @Query(() => RunMJComponentViewResult)
    async RunMJComponentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentViewResult)
    async RunMJComponentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentViewResult)
    async RunMJComponentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Components';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponent_, { nullable: true })
    async MJComponent(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponent_ | null> {
        this.CheckUserReadPermissions('MJ: Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponents')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Components', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJComponentDependency_])
    async MJComponentDependencies_DependencyComponentIDArray(@Root() mjcomponent_: MJComponent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponentDependencies')} WHERE ${provider.QuoteIdentifier('DependencyComponentID')}='${mjcomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Component Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJComponentLibraryLink_])
    async MJComponentLibraryLinks_ComponentIDArray(@Root() mjcomponent_: MJComponent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponentLibraryLinks')} WHERE ${provider.QuoteIdentifier('ComponentID')}='${mjcomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Component Library Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJComponentDependency_])
    async MJComponentDependencies_ComponentIDArray(@Root() mjcomponent_: MJComponent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwComponentDependencies')} WHERE ${provider.QuoteIdentifier('ComponentID')}='${mjcomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Component Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJComponent_)
    async CreateMJComponent(
        @Arg('input', () => CreateMJComponentInput) input: CreateMJComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Components', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponent_)
    async UpdateMJComponent(
        @Arg('input', () => UpdateMJComponentInput) input: UpdateMJComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Components', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponent_)
    async DeleteMJComponent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Components', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content File Types
//****************************************************************************
@ObjectType({ description: `Defines supported file types for content management, including extensions and processing rules for different content formats.` })
export class MJContentFileType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `The file extension (e.g., .pdf, .docx, .jpg) used to identify this content type.`}) 
    @MaxLength(255)
    FileExtension?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJContentSource_])
    MJContentSources_ContentFileTypeIDArray: MJContentSource_[]; // Link to MJContentSources
    
    @Field(() => [MJContentItem_])
    MJContentItems_ContentFileTypeIDArray: MJContentItem_[]; // Link to MJContentItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Content File Types
//****************************************************************************
@InputType()
export class CreateMJContentFileTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content File Types
//****************************************************************************
@InputType()
export class UpdateMJContentFileTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content File Types
//****************************************************************************
@ObjectType()
export class RunMJContentFileTypeViewResult {
    @Field(() => [MJContentFileType_])
    Results: MJContentFileType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentFileType_)
export class MJContentFileTypeResolver extends ResolverBase {
    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content File Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentFileType_, { nullable: true })
    async MJContentFileType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentFileType_ | null> {
        this.CheckUserReadPermissions('MJ: Content File Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentFileTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content File Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content File Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async MJContentSources_ContentFileTypeIDArray(@Root() mjcontentfiletype_: MJContentFileType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentSources')} WHERE ${provider.QuoteIdentifier('ContentFileTypeID')}='${mjcontentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Sources', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async MJContentItems_ContentFileTypeIDArray(@Root() mjcontentfiletype_: MJContentFileType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItems')} WHERE ${provider.QuoteIdentifier('ContentFileTypeID')}='${mjcontentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentFileType_)
    async CreateMJContentFileType(
        @Arg('input', () => CreateMJContentFileTypeInput) input: CreateMJContentFileTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content File Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentFileType_)
    async UpdateMJContentFileType(
        @Arg('input', () => UpdateMJContentFileTypeInput) input: UpdateMJContentFileTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content File Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentFileType_)
    async DeleteMJContentFileType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content File Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Item Attributes
//****************************************************************************
@ObjectType({ description: `Stores metadata attributes extracted with prompting for content items, enabling flexible key-value properties and custom fields for content classification.` })
export class MJContentItemAttribute_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ContentItemID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `The extracted or assigned value for this attribute on the content item.`}) 
    Value: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(250)
    ContentItem?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Content Item Attributes
//****************************************************************************
@InputType()
export class CreateMJContentItemAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Item Attributes
//****************************************************************************
@InputType()
export class UpdateMJContentItemAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Item Attributes
//****************************************************************************
@ObjectType()
export class RunMJContentItemAttributeViewResult {
    @Field(() => [MJContentItemAttribute_])
    Results: MJContentItemAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItemAttribute_)
export class MJContentItemAttributeResolver extends ResolverBase {
    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Item Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItemAttribute_, { nullable: true })
    async MJContentItemAttribute(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItemAttribute_ | null> {
        this.CheckUserReadPermissions('MJ: Content Item Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItemAttributes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Item Attributes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentItemAttribute_)
    async CreateMJContentItemAttribute(
        @Arg('input', () => CreateMJContentItemAttributeInput) input: CreateMJContentItemAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Item Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItemAttribute_)
    async UpdateMJContentItemAttribute(
        @Arg('input', () => UpdateMJContentItemAttributeInput) input: UpdateMJContentItemAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Item Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItemAttribute_)
    async DeleteMJContentItemAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Item Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Item Tags
//****************************************************************************
@ObjectType({ description: `Links tags to content items for categorization, searchability, and content discovery across the system.` })
export class MJContentItemTag_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ItemID: string;
        
    @Field({description: `The tag text applied to the content item for categorization and search.`}) 
    @MaxLength(200)
    Tag: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(250)
    Item?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Content Item Tags
//****************************************************************************
@InputType()
export class CreateMJContentItemTagInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Item Tags
//****************************************************************************
@InputType()
export class UpdateMJContentItemTagInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Item Tags
//****************************************************************************
@ObjectType()
export class RunMJContentItemTagViewResult {
    @Field(() => [MJContentItemTag_])
    Results: MJContentItemTag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItemTag_)
export class MJContentItemTagResolver extends ResolverBase {
    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Item Tags';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItemTag_, { nullable: true })
    async MJContentItemTag(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItemTag_ | null> {
        this.CheckUserReadPermissions('MJ: Content Item Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItemTags')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Item Tags', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentItemTag_)
    async CreateMJContentItemTag(
        @Arg('input', () => CreateMJContentItemTagInput) input: CreateMJContentItemTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Item Tags', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItemTag_)
    async UpdateMJContentItemTag(
        @Arg('input', () => UpdateMJContentItemTagInput) input: UpdateMJContentItemTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Item Tags', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItemTag_)
    async DeleteMJContentItemTag(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Item Tags', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Items
//****************************************************************************
@ObjectType({ description: `Stores extracted text from content assets, as well as the source location, versioning, and links to extracted tags and attributes.` })
export class MJContentItem_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ContentSourceID: string;
        
    @Field({nullable: true}) 
    @MaxLength(250)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(36)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(36)
    ContentFileTypeID: string;
        
    @Field({nullable: true, description: `Hash value of the content used to detect changes and prevent duplicate processing.`}) 
    @MaxLength(100)
    Checksum?: string;
        
    @Field({description: `The source location URL where this content was retrieved from.`}) 
    @MaxLength(2000)
    URL: string;
        
    @Field({nullable: true, description: `The extracted text content from the source document or file.`}) 
    Text?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ContentSource?: string;
        
    @Field() 
    @MaxLength(255)
    ContentType: string;
        
    @Field() 
    @MaxLength(255)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(255)
    ContentFileType: string;
        
    @Field(() => [MJContentItemAttribute_])
    MJContentItemAttributes_ContentItemIDArray: MJContentItemAttribute_[]; // Link to MJContentItemAttributes
    
    @Field(() => [MJContentItemTag_])
    MJContentItemTags_ItemIDArray: MJContentItemTag_[]; // Link to MJContentItemTags
    
}

//****************************************************************************
// INPUT TYPE for MJ: Content Items
//****************************************************************************
@InputType()
export class CreateMJContentItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Items
//****************************************************************************
@InputType()
export class UpdateMJContentItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum?: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Items
//****************************************************************************
@ObjectType()
export class RunMJContentItemViewResult {
    @Field(() => [MJContentItem_])
    Results: MJContentItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItem_)
export class MJContentItemResolver extends ResolverBase {
    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItem_, { nullable: true })
    async MJContentItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItem_ | null> {
        this.CheckUserReadPermissions('MJ: Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentItemAttribute_])
    async MJContentItemAttributes_ContentItemIDArray(@Root() mjcontentitem_: MJContentItem_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Item Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItemAttributes')} WHERE ${provider.QuoteIdentifier('ContentItemID')}='${mjcontentitem_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Item Attributes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItemTag_])
    async MJContentItemTags_ItemIDArray(@Root() mjcontentitem_: MJContentItem_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Item Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItemTags')} WHERE ${provider.QuoteIdentifier('ItemID')}='${mjcontentitem_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Item Tags', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentItem_)
    async CreateMJContentItem(
        @Arg('input', () => CreateMJContentItemInput) input: CreateMJContentItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItem_)
    async UpdateMJContentItem(
        @Arg('input', () => UpdateMJContentItemInput) input: UpdateMJContentItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItem_)
    async DeleteMJContentItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Process Runs
//****************************************************************************
@ObjectType({ description: `Tracks execution of content tagging workflows, logging the status and details of each execution and ensuring efficient processing of content.` })
export class MJContentProcessRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    SourceID: string;
        
    @Field({nullable: true, description: `Timestamp when the content processing workflow began execution.`}) 
    StartTime?: Date;
        
    @Field({nullable: true, description: `Timestamp when the content processing workflow completed or failed.`}) 
    EndTime?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Status?: string;
        
    @Field(() => Int, {nullable: true, description: `Count of content items successfully processed during this run.`}) 
    ProcessedItems?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Source?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Content Process Runs
//****************************************************************************
@InputType()
export class CreateMJContentProcessRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime: Date | null;

    @Field({ nullable: true })
    EndTime: Date | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Process Runs
//****************************************************************************
@InputType()
export class UpdateMJContentProcessRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime?: Date | null;

    @Field({ nullable: true })
    EndTime?: Date | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Process Runs
//****************************************************************************
@ObjectType()
export class RunMJContentProcessRunViewResult {
    @Field(() => [MJContentProcessRun_])
    Results: MJContentProcessRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentProcessRun_)
export class MJContentProcessRunResolver extends ResolverBase {
    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Process Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentProcessRun_, { nullable: true })
    async MJContentProcessRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentProcessRun_ | null> {
        this.CheckUserReadPermissions('MJ: Content Process Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentProcessRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Process Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentProcessRun_)
    async CreateMJContentProcessRun(
        @Arg('input', () => CreateMJContentProcessRunInput) input: CreateMJContentProcessRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Process Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentProcessRun_)
    async UpdateMJContentProcessRun(
        @Arg('input', () => UpdateMJContentProcessRunInput) input: UpdateMJContentProcessRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Process Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentProcessRun_)
    async DeleteMJContentProcessRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Process Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Source Params
//****************************************************************************
@ObjectType({ description: `Stores configuration parameters for specific content source instances, customizing how content is retrieved and processed from each source.` })
export class MJContentSourceParam_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ContentSourceID: string;
        
    @Field({description: `Reference to the parameter definition in Content Source Type Params.`}) 
    @MaxLength(36)
    ContentSourceTypeParamID: string;
        
    @Field({description: `The configured value for this parameter on this specific content source.`}) 
    Value: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ContentSource?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Content Source Params
//****************************************************************************
@InputType()
export class CreateMJContentSourceParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Source Params
//****************************************************************************
@InputType()
export class UpdateMJContentSourceParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Source Params
//****************************************************************************
@ObjectType()
export class RunMJContentSourceParamViewResult {
    @Field(() => [MJContentSourceParam_])
    Results: MJContentSourceParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceParam_)
export class MJContentSourceParamResolver extends ResolverBase {
    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Source Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceParam_, { nullable: true })
    async MJContentSourceParam(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceParam_ | null> {
        this.CheckUserReadPermissions('MJ: Content Source Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentSourceParams')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Source Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentSourceParam_)
    async CreateMJContentSourceParam(
        @Arg('input', () => CreateMJContentSourceParamInput) input: CreateMJContentSourceParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Source Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceParam_)
    async UpdateMJContentSourceParam(
        @Arg('input', () => UpdateMJContentSourceParamInput) input: UpdateMJContentSourceParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Source Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceParam_)
    async DeleteMJContentSourceParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Source Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Source Type Params
//****************************************************************************
@ObjectType({ description: `Defines required and optional parameters for content source types, establishing the configuration for each source type.` })
export class MJContentSourceTypeParam_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Data type of the parameter (string, number, boolean, date, etc.).`}) 
    @MaxLength(50)
    Type?: string;
        
    @Field({nullable: true, description: `Default value to use if not specified when configuring a content source.`}) 
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this parameter must be provided when setting up a content source.`}) 
    IsRequired: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Content Source Type Params
//****************************************************************************
@InputType()
export class CreateMJContentSourceTypeParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Source Type Params
//****************************************************************************
@InputType()
export class UpdateMJContentSourceTypeParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Source Type Params
//****************************************************************************
@ObjectType()
export class RunMJContentSourceTypeParamViewResult {
    @Field(() => [MJContentSourceTypeParam_])
    Results: MJContentSourceTypeParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceTypeParam_)
export class MJContentSourceTypeParamResolver extends ResolverBase {
    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Source Type Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceTypeParam_, { nullable: true })
    async MJContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceTypeParam_ | null> {
        this.CheckUserReadPermissions('MJ: Content Source Type Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentSourceTypeParams')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Source Type Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Source Type Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentSourceTypeParam_)
    async CreateMJContentSourceTypeParam(
        @Arg('input', () => CreateMJContentSourceTypeParamInput) input: CreateMJContentSourceTypeParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Source Type Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceTypeParam_)
    async UpdateMJContentSourceTypeParam(
        @Arg('input', () => UpdateMJContentSourceTypeParamInput) input: UpdateMJContentSourceTypeParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Source Type Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceTypeParam_)
    async DeleteMJContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Source Type Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Source Types
//****************************************************************************
@ObjectType({ description: `Catalogs available content source types such as file systems, APIs, websites, databases, and cloud storage platforms with their capabilities.` })
export class MJContentSourceType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJContentSource_])
    MJContentSources_ContentSourceTypeIDArray: MJContentSource_[]; // Link to MJContentSources
    
    @Field(() => [MJContentItem_])
    MJContentItems_ContentSourceTypeIDArray: MJContentItem_[]; // Link to MJContentItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Content Source Types
//****************************************************************************
@InputType()
export class CreateMJContentSourceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Source Types
//****************************************************************************
@InputType()
export class UpdateMJContentSourceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Source Types
//****************************************************************************
@ObjectType()
export class RunMJContentSourceTypeViewResult {
    @Field(() => [MJContentSourceType_])
    Results: MJContentSourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceType_)
export class MJContentSourceTypeResolver extends ResolverBase {
    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Source Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceType_, { nullable: true })
    async MJContentSourceType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceType_ | null> {
        this.CheckUserReadPermissions('MJ: Content Source Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentSourceTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Source Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Source Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async MJContentSources_ContentSourceTypeIDArray(@Root() mjcontentsourcetype_: MJContentSourceType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentSources')} WHERE ${provider.QuoteIdentifier('ContentSourceTypeID')}='${mjcontentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Sources', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async MJContentItems_ContentSourceTypeIDArray(@Root() mjcontentsourcetype_: MJContentSourceType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItems')} WHERE ${provider.QuoteIdentifier('ContentSourceTypeID')}='${mjcontentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentSourceType_)
    async CreateMJContentSourceType(
        @Arg('input', () => CreateMJContentSourceTypeInput) input: CreateMJContentSourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Source Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceType_)
    async UpdateMJContentSourceType(
        @Arg('input', () => UpdateMJContentSourceTypeInput) input: UpdateMJContentSourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Source Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceType_)
    async DeleteMJContentSourceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Source Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Sources
//****************************************************************************
@ObjectType({ description: `Configures connections to external content repositories and systems from which content is imported, synchronized, and tagged.` })
export class MJContentSource_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Name?: string;
        
    @Field() 
    @MaxLength(36)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(36)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(36)
    ContentFileTypeID: string;
        
    @Field({description: `Base URL or connection string for accessing this content source.`}) 
    @MaxLength(2000)
    URL: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    ContentType: string;
        
    @Field() 
    @MaxLength(255)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(255)
    ContentFileType: string;
        
    @Field(() => [MJContentProcessRun_])
    MJContentProcessRuns_SourceIDArray: MJContentProcessRun_[]; // Link to MJContentProcessRuns
    
    @Field(() => [MJContentSourceParam_])
    MJContentSourceParams_ContentSourceIDArray: MJContentSourceParam_[]; // Link to MJContentSourceParams
    
    @Field(() => [MJContentItem_])
    MJContentItems_ContentSourceIDArray: MJContentItem_[]; // Link to MJContentItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Content Sources
//****************************************************************************
@InputType()
export class CreateMJContentSourceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Sources
//****************************************************************************
@InputType()
export class UpdateMJContentSourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Sources
//****************************************************************************
@ObjectType()
export class RunMJContentSourceViewResult {
    @Field(() => [MJContentSource_])
    Results: MJContentSource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSource_)
export class MJContentSourceResolver extends ResolverBase {
    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Sources';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSource_, { nullable: true })
    async MJContentSource(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSource_ | null> {
        this.CheckUserReadPermissions('MJ: Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentSources')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Sources', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentProcessRun_])
    async MJContentProcessRuns_SourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Process Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentProcessRuns')} WHERE ${provider.QuoteIdentifier('SourceID')}='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Process Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentSourceParam_])
    async MJContentSourceParams_ContentSourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Source Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentSourceParams')} WHERE ${provider.QuoteIdentifier('ContentSourceID')}='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Source Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async MJContentItems_ContentSourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItems')} WHERE ${provider.QuoteIdentifier('ContentSourceID')}='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentSource_)
    async CreateMJContentSource(
        @Arg('input', () => CreateMJContentSourceInput) input: CreateMJContentSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Sources', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSource_)
    async UpdateMJContentSource(
        @Arg('input', () => UpdateMJContentSourceInput) input: UpdateMJContentSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Sources', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSource_)
    async DeleteMJContentSource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Sources', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Type Attributes
//****************************************************************************
@ObjectType({ description: `Defines the attributes available for extraction via prompt for each content type.` })
export class MJContentTypeAttribute_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the Content Type this attribute belongs to.`}) 
    @MaxLength(36)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `The AI prompt template used to extract this attribute from content.`}) 
    Prompt: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Content Type Attributes
//****************************************************************************
@InputType()
export class CreateMJContentTypeAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Type Attributes
//****************************************************************************
@InputType()
export class UpdateMJContentTypeAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Type Attributes
//****************************************************************************
@ObjectType()
export class RunMJContentTypeAttributeViewResult {
    @Field(() => [MJContentTypeAttribute_])
    Results: MJContentTypeAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentTypeAttribute_)
export class MJContentTypeAttributeResolver extends ResolverBase {
    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Type Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentTypeAttribute_, { nullable: true })
    async MJContentTypeAttribute(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentTypeAttribute_ | null> {
        this.CheckUserReadPermissions('MJ: Content Type Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentTypeAttributes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Type Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Type Attributes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentTypeAttribute_)
    async CreateMJContentTypeAttribute(
        @Arg('input', () => CreateMJContentTypeAttributeInput) input: CreateMJContentTypeAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Type Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentTypeAttribute_)
    async UpdateMJContentTypeAttribute(
        @Arg('input', () => UpdateMJContentTypeAttributeInput) input: UpdateMJContentTypeAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Type Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentTypeAttribute_)
    async DeleteMJContentTypeAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Type Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Content Types
//****************************************************************************
@ObjectType({ description: `Defines categories of content with specific schemas, behaviors, and processing rules for structured content management.` })
export class MJContentType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    AIModelID: string;
        
    @Field(() => Int, {description: `Minimum number of tags that must be applied to content of this type.`}) 
    MinTags: number;
        
    @Field(() => Int, {description: `Maximum number of tags allowed on content of this type.`}) 
    MaxTags: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    AIModel: string;
        
    @Field(() => [MJContentSource_])
    MJContentSources_ContentTypeIDArray: MJContentSource_[]; // Link to MJContentSources
    
    @Field(() => [MJContentItem_])
    MJContentItems_ContentTypeIDArray: MJContentItem_[]; // Link to MJContentItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Content Types
//****************************************************************************
@InputType()
export class CreateMJContentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Content Types
//****************************************************************************
@InputType()
export class UpdateMJContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Content Types
//****************************************************************************
@ObjectType()
export class RunMJContentTypeViewResult {
    @Field(() => [MJContentType_])
    Results: MJContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentType_)
export class MJContentTypeResolver extends ResolverBase {
    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Content Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentType_, { nullable: true })
    async MJContentType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentType_ | null> {
        this.CheckUserReadPermissions('MJ: Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Content Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async MJContentSources_ContentTypeIDArray(@Root() mjcontenttype_: MJContentType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentSources')} WHERE ${provider.QuoteIdentifier('ContentTypeID')}='${mjcontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Sources', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async MJContentItems_ContentTypeIDArray(@Root() mjcontenttype_: MJContentType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwContentItems')} WHERE ${provider.QuoteIdentifier('ContentTypeID')}='${mjcontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Content Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentType_)
    async CreateMJContentType(
        @Arg('input', () => CreateMJContentTypeInput) input: CreateMJContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Content Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentType_)
    async UpdateMJContentType(
        @Arg('input', () => UpdateMJContentTypeInput) input: UpdateMJContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Content Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentType_)
    async DeleteMJContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Content Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for conversation artifacts` })
export class MJConversationArtifactPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the artifact this permission applies to`}) 
    @MaxLength(36)
    ConversationArtifactID: string;
        
    @Field({description: `User this permission applies to`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `Level of access granted (Read, Edit, Owner)`}) 
    @MaxLength(20)
    AccessLevel: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    ConversationArtifact: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactPermissionViewResult {
    @Field(() => [MJConversationArtifactPermission_])
    Results: MJConversationArtifactPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifactPermission_)
export class MJConversationArtifactPermissionResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifactPermission_, { nullable: true })
    async MJConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifactPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationArtifactPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJConversationArtifactPermission_)
    async CreateMJConversationArtifactPermission(
        @Arg('input', () => CreateMJConversationArtifactPermissionInput) input: CreateMJConversationArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifact Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifactPermission_)
    async UpdateMJConversationArtifactPermission(
        @Arg('input', () => UpdateMJConversationArtifactPermissionInput) input: UpdateMJConversationArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifact Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifactPermission_)
    async DeleteMJConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType({ description: `Stores versions of conversation artifacts` })
export class MJConversationArtifactVersion_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the parent artifact`}) 
    @MaxLength(36)
    ConversationArtifactID: string;
        
    @Field(() => Int, {description: `Sequential version number (starting from 1) for this artifact`}) 
    Version: number;
        
    @Field({description: `JSON configuration and metadata for this artifact version`}) 
    Configuration: string;
        
    @Field({nullable: true, description: `Actual content of the artifact, if stored separately from configuration`}) 
    Content?: string;
        
    @Field({nullable: true, description: `User comments specific to this version`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    ConversationArtifact: string;
        
    @Field(() => [MJConversationDetail_])
    MJConversationDetails_ArtifactVersionIDArray: MJConversationDetail_[]; // Link to MJConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactVersionViewResult {
    @Field(() => [MJConversationArtifactVersion_])
    Results: MJConversationArtifactVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifactVersion_)
export class MJConversationArtifactVersionResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifactVersion_, { nullable: true })
    async MJConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifactVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationArtifactVersions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJConversationDetail_])
    async MJConversationDetails_ArtifactVersionIDArray(@Root() mjconversationartifactversion_: MJConversationArtifactVersion_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetails')} WHERE ${provider.QuoteIdentifier('ArtifactVersionID')}='${mjconversationartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJConversationArtifactVersion_)
    async CreateMJConversationArtifactVersion(
        @Arg('input', () => CreateMJConversationArtifactVersionInput) input: CreateMJConversationArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifact Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifactVersion_)
    async UpdateMJConversationArtifactVersion(
        @Arg('input', () => UpdateMJConversationArtifactVersionInput) input: UpdateMJConversationArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifact Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifactVersion_)
    async DeleteMJConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType({ description: `Stores metadata for artifacts created within conversations` })
export class MJConversationArtifact_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Display name of the artifact`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Extended description of the artifact`}) 
    Description?: string;
        
    @Field({description: `Reference to the conversation this artifact belongs to`}) 
    @MaxLength(36)
    ConversationID: string;
        
    @Field({description: `Reference to the type of artifact`}) 
    @MaxLength(36)
    ArtifactTypeID: string;
        
    @Field({description: `Controls who can view this artifact (None, SpecificUsers, Everyone, Public)`}) 
    @MaxLength(50)
    SharingScope: string;
        
    @Field({nullable: true, description: `User comments about the artifact`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Conversation?: string;
        
    @Field() 
    @MaxLength(100)
    ArtifactType: string;
        
    @Field(() => [MJConversationArtifactPermission_])
    MJConversationArtifactPermissions_ConversationArtifactIDArray: MJConversationArtifactPermission_[]; // Link to MJConversationArtifactPermissions
    
    @Field(() => [MJConversationArtifactVersion_])
    MJConversationArtifactVersions_ConversationArtifactIDArray: MJConversationArtifactVersion_[]; // Link to MJConversationArtifactVersions
    
    @Field(() => [MJConversationDetail_])
    MJConversationDetails_ArtifactIDArray: MJConversationDetail_[]; // Link to MJConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactViewResult {
    @Field(() => [MJConversationArtifact_])
    Results: MJConversationArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifact_)
export class MJConversationArtifactResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifact_, { nullable: true })
    async MJConversationArtifact(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationArtifacts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJConversationArtifactPermission_])
    async MJConversationArtifactPermissions_ConversationArtifactIDArray(@Root() mjconversationartifact_: MJConversationArtifact_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationArtifactPermissions')} WHERE ${provider.QuoteIdentifier('ConversationArtifactID')}='${mjconversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationArtifactVersion_])
    async MJConversationArtifactVersions_ConversationArtifactIDArray(@Root() mjconversationartifact_: MJConversationArtifact_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationArtifactVersions')} WHERE ${provider.QuoteIdentifier('ConversationArtifactID')}='${mjconversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async MJConversationDetails_ArtifactIDArray(@Root() mjconversationartifact_: MJConversationArtifact_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetails')} WHERE ${provider.QuoteIdentifier('ArtifactID')}='${mjconversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJConversationArtifact_)
    async CreateMJConversationArtifact(
        @Arg('input', () => CreateMJConversationArtifactInput) input: CreateMJConversationArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifact_)
    async UpdateMJConversationArtifact(
        @Arg('input', () => UpdateMJConversationArtifactInput) input: UpdateMJConversationArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifact_)
    async DeleteMJConversationArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Detail Artifacts
//****************************************************************************
@ObjectType({ description: `Junction table tracking many-to-many relationship between conversation messages and artifact versions, with directionality tracking` })
export class MJConversationDetailArtifact_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign key to ConversationDetail - the conversation message associated with this artifact`}) 
    @MaxLength(36)
    ConversationDetailID: string;
        
    @Field({description: `Foreign key to ArtifactVersion - the specific artifact version linked to this conversation message`}) 
    @MaxLength(36)
    ArtifactVersionID: string;
        
    @Field({description: `Direction of artifact flow: Input (fed to agent) or Output (produced by agent)`}) 
    @MaxLength(20)
    Direction: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    ConversationDetail: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ArtifactVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Artifacts
//****************************************************************************
@InputType()
export class CreateMJConversationDetailArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    Direction?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Artifacts
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Detail Artifacts
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailArtifactViewResult {
    @Field(() => [MJConversationDetailArtifact_])
    Results: MJConversationDetailArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetailArtifact_)
export class MJConversationDetailArtifactResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailArtifactViewResult)
    async RunMJConversationDetailArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailArtifactViewResult)
    async RunMJConversationDetailArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailArtifactViewResult)
    async RunMJConversationDetailArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Detail Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetailArtifact_, { nullable: true })
    async MJConversationDetailArtifact(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetailArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Detail Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailArtifacts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Detail Artifacts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJConversationDetailArtifact_)
    async CreateMJConversationDetailArtifact(
        @Arg('input', () => CreateMJConversationDetailArtifactInput) input: CreateMJConversationDetailArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Detail Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetailArtifact_)
    async UpdateMJConversationDetailArtifact(
        @Arg('input', () => UpdateMJConversationDetailArtifactInput) input: UpdateMJConversationDetailArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Detail Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetailArtifact_)
    async DeleteMJConversationDetailArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Detail Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Detail Attachments
//****************************************************************************
@ObjectType({ description: `Stores attachments (images, videos, audio, documents) for conversation messages. Supports both inline base64 storage for small files and reference to MJStorage for large files.` })
export class MJConversationDetailAttachment_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ConversationDetailID: string;
        
    @Field({description: `The modality type of this attachment (Image, Audio, Video, File, etc.). References the AIModality table.`}) 
    @MaxLength(36)
    ModalityID: string;
        
    @Field({description: `MIME type of the attachment (e.g., image/png, video/mp4, audio/mp3).`}) 
    @MaxLength(100)
    MimeType: string;
        
    @Field({nullable: true, description: `Original filename of the attachment. Supports long cloud storage paths up to 4000 characters.`}) 
    @MaxLength(4000)
    FileName?: string;
        
    @Field(() => Int, {description: `Size of the attachment in bytes.`}) 
    FileSizeBytes: number;
        
    @Field(() => Int, {nullable: true, description: `Width in pixels for images and videos.`}) 
    Width?: number;
        
    @Field(() => Int, {nullable: true, description: `Height in pixels for images and videos.`}) 
    Height?: number;
        
    @Field(() => Int, {nullable: true, description: `Duration in seconds for audio and video files.`}) 
    DurationSeconds?: number;
        
    @Field({nullable: true, description: `Base64-encoded file data for small attachments stored inline. Mutually exclusive with FileID - exactly one must be populated.`}) 
    InlineData?: string;
        
    @Field({nullable: true, description: `Reference to File entity for large attachments stored in MJStorage. Mutually exclusive with InlineData - exactly one must be populated.`}) 
    @MaxLength(36)
    FileID?: string;
        
    @Field(() => Int, {description: `Display order for multiple attachments in a message. Lower numbers appear first.`}) 
    DisplayOrder: number;
        
    @Field({nullable: true, description: `Base64-encoded thumbnail image for quick preview display. Max 200px on longest side.`}) 
    ThumbnailBase64?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Description of the attachment providing context about its content and purpose.`}) 
    Description?: string;
        
    @Field() 
    ConversationDetail: string;
        
    @Field() 
    @MaxLength(50)
    Modality: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    File?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Attachments
//****************************************************************************
@InputType()
export class CreateMJConversationDetailAttachmentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number;

    @Field(() => Int, { nullable: true })
    Width: number | null;

    @Field(() => Int, { nullable: true })
    Height: number | null;

    @Field(() => Int, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    InlineData: string | null;

    @Field({ nullable: true })
    FileID: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    ThumbnailBase64: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Attachments
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailAttachmentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName?: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number;

    @Field(() => Int, { nullable: true })
    Width?: number | null;

    @Field(() => Int, { nullable: true })
    Height?: number | null;

    @Field(() => Int, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    InlineData?: string | null;

    @Field({ nullable: true })
    FileID?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    ThumbnailBase64?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Detail Attachments
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailAttachmentViewResult {
    @Field(() => [MJConversationDetailAttachment_])
    Results: MJConversationDetailAttachment_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetailAttachment_)
export class MJConversationDetailAttachmentResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailAttachmentViewResult)
    async RunMJConversationDetailAttachmentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailAttachmentViewResult)
    async RunMJConversationDetailAttachmentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailAttachmentViewResult)
    async RunMJConversationDetailAttachmentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Detail Attachments';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetailAttachment_, { nullable: true })
    async MJConversationDetailAttachment(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetailAttachment_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Detail Attachments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailAttachments')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Attachments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Detail Attachments', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJConversationDetailAttachment_)
    async CreateMJConversationDetailAttachment(
        @Arg('input', () => CreateMJConversationDetailAttachmentInput) input: CreateMJConversationDetailAttachmentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Detail Attachments', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetailAttachment_)
    async UpdateMJConversationDetailAttachment(
        @Arg('input', () => UpdateMJConversationDetailAttachmentInput) input: UpdateMJConversationDetailAttachmentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Detail Attachments', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetailAttachment_)
    async DeleteMJConversationDetailAttachment(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Detail Attachments', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Detail Ratings
//****************************************************************************
@ObjectType({ description: `Stores per-user ratings for conversation messages, supporting multi-user conversations where each user can independently rate messages.` })
export class MJConversationDetailRating_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The conversation message being rated.`}) 
    @MaxLength(36)
    ConversationDetailID: string;
        
    @Field({description: `The user providing the rating.`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field(() => Int, {description: `Rating on a 1-10 scale where 1 is thumbs down and 10 is thumbs up.`}) 
    Rating: number;
        
    @Field({nullable: true, description: `Optional textual feedback from the user about this message.`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    ConversationDetail: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Ratings
//****************************************************************************
@InputType()
export class CreateMJConversationDetailRatingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    Rating?: number;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Ratings
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailRatingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    Rating?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Detail Ratings
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailRatingViewResult {
    @Field(() => [MJConversationDetailRating_])
    Results: MJConversationDetailRating_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetailRating_)
export class MJConversationDetailRatingResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailRatingViewResult)
    async RunMJConversationDetailRatingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailRatingViewResult)
    async RunMJConversationDetailRatingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailRatingViewResult)
    async RunMJConversationDetailRatingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Detail Ratings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetailRating_, { nullable: true })
    async MJConversationDetailRating(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetailRating_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Detail Ratings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailRatings')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Ratings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Detail Ratings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJConversationDetailRating_)
    async CreateMJConversationDetailRating(
        @Arg('input', () => CreateMJConversationDetailRatingInput) input: CreateMJConversationDetailRatingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Detail Ratings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetailRating_)
    async UpdateMJConversationDetailRating(
        @Arg('input', () => UpdateMJConversationDetailRatingInput) input: UpdateMJConversationDetailRatingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Detail Ratings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetailRating_)
    async DeleteMJConversationDetailRating(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Detail Ratings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Details
//****************************************************************************
@ObjectType({ description: `Stores individual messages, responses, and interactions within a conversation, maintaining the complete dialogue history with timestamps.` })
export class MJConversationDetail_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ConversationID: string;
        
    @Field({nullable: true, description: `External system identifier for this message, used for integration scenarios.`}) 
    @MaxLength(100)
    ExternalID?: string;
        
    @Field({description: `The role of the message sender (user, assistant, system, function).`}) 
    @MaxLength(20)
    Role: string;
        
    @Field({description: `The actual content of the message in the conversation.`}) 
    Message: string;
        
    @Field({nullable: true, description: `Error message if this conversation turn encountered a problem.`}) 
    Error?: string;
        
    @Field(() => Boolean, {description: `Flag indicating if this message should be hidden from end users (system messages, function calls, etc.).`}) 
    HiddenToUser: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `This column is used to capture user feedback as a rating scale. The scale ranges from 1 to 10, where 1 might represent thumbs down, and 10 might represent thumbs up or the highest rating in a star-based scale.`}) 
    UserRating?: number;
        
    @Field({nullable: true, description: `This column is used to store user text feedback about a given AI response, describing what they liked or disliked.`}) 
    UserFeedback?: string;
        
    @Field({nullable: true, description: `This column stores human or AI-generated reflections on how to improve future responses based on the user feedback and the AI output generated for prior messages in the conversation.`}) 
    ReflectionInsights?: string;
        
    @Field({nullable: true, description: `This column optionally stores a summary of the entire conversation leading up to this particular conversation detail record. It is used in long-running conversations to optimize performance by summarizing earlier parts.`}) 
    SummaryOfEarlierConversation?: string;
        
    @Field({nullable: true, description: `This field, when populated, overrides the UserID at the Conversation level to specify a different user created the message.`}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field({nullable: true, description: `Optional reference to a conversation artifact associated with this conversation detail`}) 
    @MaxLength(36)
    ArtifactID?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific version of a conversation artifact associated with this conversation detail`}) 
    @MaxLength(36)
    ArtifactVersionID?: string;
        
    @Field(() => Int, {nullable: true, description: `Duration in milliseconds representing how long the AI response processing took to complete for this conversation detail.`}) 
    CompletionTime?: number;
        
    @Field(() => Boolean, {description: `Indicates if this message is pinned within the conversation for easy reference`}) 
    IsPinned: boolean;
        
    @Field({nullable: true, description: `Optional reference to parent message for threaded conversations. NULL for top-level messages.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true, description: `Denormalized agent ID for quick lookup of agent name and icon without joining through AgentRun`}) 
    @MaxLength(36)
    AgentID?: string;
        
    @Field({description: `Status of the conversation message. Complete indicates finished processing, In-Progress indicates active agent work, Error indicates processing failed.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `DEPRECATED: Use ResponseForm, ActionableCommands, and AutomaticCommands instead. Legacy field for simple text-based suggested responses. Replaced in v2.118 by more powerful structured forms and commands system. Retained for historical data only.`}) 
    SuggestedResponses?: string;
        
    @Field({nullable: true, description: `Optional Foreign Key - Links this conversation detail to a test run if this message was part of a test conversation. Allows filtering and analyzing test-specific conversation turns.`}) 
    @MaxLength(36)
    TestRunID?: string;
        
    @Field({nullable: true, description: `JSON object containing agent response form definition with questions and validation rules. Supports 8 question types: text, textarea, email, number, currency, date, datetime, choices (buttongroup/radio/dropdown/checkbox). Used for collecting structured user input with proper validation.`}) 
    ResponseForm?: string;
        
    @Field({nullable: true, description: `JSON array of actionable commands that user can trigger (shown as clickable buttons/links). Supports open:resource (navigate to records/dashboards/reports/forms) and open:url (external links). Typically used after completing work to provide easy navigation to created/modified resources.`}) 
    ActionableCommands?: string;
        
    @Field({nullable: true, description: `JSON array of automatic commands that execute immediately when received (no user interaction). Supports refresh:data (refresh entity data or caches) and notification (show toast messages). Used for keeping UI in sync after agent makes changes and providing user feedback.`}) 
    AutomaticCommands?: string;
        
    @Field(() => Boolean, {description: `Indicates if the original message content was modified after initial creation. Set automatically by the server when the Message field is changed on update.`}) 
    OriginalMessageChanged: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Artifact?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ArtifactVersion?: string;
        
    @Field({nullable: true}) 
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    TestRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJReport_])
    MJReports_ConversationDetailIDArray: MJReport_[]; // Link to MJReports
    
    @Field(() => [MJConversationDetailArtifact_])
    MJConversationDetailArtifacts_ConversationDetailIDArray: MJConversationDetailArtifact_[]; // Link to MJConversationDetailArtifacts
    
    @Field(() => [MJConversationDetailAttachment_])
    MJConversationDetailAttachments_ConversationDetailIDArray: MJConversationDetailAttachment_[]; // Link to MJConversationDetailAttachments
    
    @Field(() => [MJConversationDetailRating_])
    MJConversationDetailRatings_ConversationDetailIDArray: MJConversationDetailRating_[]; // Link to MJConversationDetailRatings
    
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_SourceConversationDetailIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_ConversationDetailIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
    @Field(() => [MJConversationDetail_])
    MJConversationDetails_ParentIDArray: MJConversationDetail_[]; // Link to MJConversationDetails
    
    @Field(() => [MJTask_])
    MJTasks_ConversationDetailIDArray: MJTask_[]; // Link to MJTasks
    
    @Field(() => [MJAIAgentExample_])
    MJAIAgentExamples_SourceConversationDetailIDArray: MJAIAgentExample_[]; // Link to MJAIAgentExamples
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Details
//****************************************************************************
@InputType()
export class CreateMJConversationDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating: number | null;

    @Field({ nullable: true })
    UserFeedback: string | null;

    @Field({ nullable: true })
    ReflectionInsights: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    ArtifactID: string | null;

    @Field({ nullable: true })
    ArtifactVersionID: string | null;

    @Field(() => Int, { nullable: true })
    CompletionTime: number | null;

    @Field(() => Boolean, { nullable: true })
    IsPinned?: boolean;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SuggestedResponses: string | null;

    @Field({ nullable: true })
    TestRunID: string | null;

    @Field({ nullable: true })
    ResponseForm: string | null;

    @Field({ nullable: true })
    ActionableCommands: string | null;

    @Field({ nullable: true })
    AutomaticCommands: string | null;

    @Field(() => Boolean, { nullable: true })
    OriginalMessageChanged?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Details
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error?: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating?: number | null;

    @Field({ nullable: true })
    UserFeedback?: string | null;

    @Field({ nullable: true })
    ReflectionInsights?: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    ArtifactID?: string | null;

    @Field({ nullable: true })
    ArtifactVersionID?: string | null;

    @Field(() => Int, { nullable: true })
    CompletionTime?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsPinned?: boolean;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SuggestedResponses?: string | null;

    @Field({ nullable: true })
    TestRunID?: string | null;

    @Field({ nullable: true })
    ResponseForm?: string | null;

    @Field({ nullable: true })
    ActionableCommands?: string | null;

    @Field({ nullable: true })
    AutomaticCommands?: string | null;

    @Field(() => Boolean, { nullable: true })
    OriginalMessageChanged?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Details
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailViewResult {
    @Field(() => [MJConversationDetail_])
    Results: MJConversationDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetail_)
export class MJConversationDetailResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetail_, { nullable: true })
    async MJConversationDetail(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetail_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetails')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async MJReports_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('ConversationDetailID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailArtifact_])
    async MJConversationDetailArtifacts_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailArtifacts')} WHERE ${provider.QuoteIdentifier('ConversationDetailID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailAttachment_])
    async MJConversationDetailAttachments_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Attachments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailAttachments')} WHERE ${provider.QuoteIdentifier('ConversationDetailID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Attachments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Attachments', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailRating_])
    async MJConversationDetailRatings_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Ratings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailRatings')} WHERE ${provider.QuoteIdentifier('ConversationDetailID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Ratings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Ratings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_SourceConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('SourceConversationDetailID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('ConversationDetailID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async MJConversationDetails_ParentIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetails')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJTasks_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTasks')} WHERE ${provider.QuoteIdentifier('ConversationDetailID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJAIAgentExamples_SourceConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('SourceConversationDetailID')}='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJConversationDetail_)
    async CreateMJConversationDetail(
        @Arg('input', () => CreateMJConversationDetailInput) input: CreateMJConversationDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetail_)
    async UpdateMJConversationDetail(
        @Arg('input', () => UpdateMJConversationDetailInput) input: UpdateMJConversationDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetail_)
    async DeleteMJConversationDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversations
//****************************************************************************
@ObjectType({ description: `Tracks conversation sessions between users and AI agents or between users, including context, participants, and metadata.` })
export class MJConversation_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true, description: `External system identifier for cross-system conversation tracking.`}) 
    @MaxLength(500)
    ExternalID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The type or category of conversation (Skip, Support, Chat, etc.).`}) 
    @MaxLength(50)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates if this conversation has been archived and should not appear in active lists.`}) 
    IsArchived: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `ID of a related record this conversation is about (support ticket, order, etc.).`}) 
    @MaxLength(500)
    LinkedRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    DataContextID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Tracks the processing status of the conversation: Available, Processing`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    @MaxLength(36)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ProjectID?: string;
        
    @Field(() => Boolean, {description: `Indicates if this conversation is pinned to the top of lists`}) 
    IsPinned: boolean;
        
    @Field({nullable: true, description: `Optional Foreign Key - Links this conversation to a test run if this conversation was generated as part of a test. Enables tracking test conversations separately from production conversations.`}) 
    @MaxLength(36)
    TestRunID?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    LinkedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    DataContext?: string;
        
    @Field() 
    @MaxLength(255)
    Environment: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Project?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    TestRun?: string;
        
    @Field(() => [MJConversationDetail_])
    MJConversationDetails_ConversationIDArray: MJConversationDetail_[]; // Link to MJConversationDetails
    
    @Field(() => [MJReport_])
    MJReports_ConversationIDArray: MJReport_[]; // Link to MJReports
    
    @Field(() => [MJConversationArtifact_])
    MJConversationArtifacts_ConversationIDArray: MJConversationArtifact_[]; // Link to MJConversationArtifacts
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_ConversationIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_SourceConversationIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
    @Field(() => [MJAIAgentExample_])
    MJAIAgentExamples_SourceConversationIDArray: MJAIAgentExample_[]; // Link to MJAIAgentExamples
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversations
//****************************************************************************
@InputType()
export class CreateMJConversationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ProjectID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsPinned?: boolean;

    @Field({ nullable: true })
    TestRunID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversations
//****************************************************************************
@InputType()
export class UpdateMJConversationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ProjectID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsPinned?: boolean;

    @Field({ nullable: true })
    TestRunID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversations
//****************************************************************************
@ObjectType()
export class RunMJConversationViewResult {
    @Field(() => [MJConversation_])
    Results: MJConversation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversation_)
export class MJConversationResolver extends ResolverBase {
    @Query(() => RunMJConversationViewResult)
    async RunMJConversationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationViewResult)
    async RunMJConversationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationViewResult)
    async RunMJConversationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversation_, { nullable: true })
    async MJConversation(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversation_ | null> {
        this.CheckUserReadPermissions('MJ: Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJConversationDetail_])
    async MJConversationDetails_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetails')} WHERE ${provider.QuoteIdentifier('ConversationID')}='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async MJReports_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('ConversationID')}='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationArtifact_])
    async MJConversationArtifacts_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationArtifacts')} WHERE ${provider.QuoteIdentifier('ConversationID')}='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('ConversationID')}='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_SourceConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('SourceConversationID')}='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJAIAgentExamples_SourceConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('SourceConversationID')}='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJConversation_)
    async CreateMJConversation(
        @Arg('input', () => CreateMJConversationInput) input: CreateMJConversationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversation_)
    async UpdateMJConversation(
        @Arg('input', () => UpdateMJConversationInput) input: UpdateMJConversationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversation_)
    async DeleteMJConversation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Credential Categories
//****************************************************************************
@ObjectType({ description: `Hierarchical organization for credentials. Allows grouping credentials by service type, department, or any organizational structure.` })
export class MJCredentialCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Display name for the category.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the category.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Parent category for hierarchical organization. NULL for root categories.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for UI display (e.g., fa-solid fa-folder).`}) 
    @MaxLength(100)
    IconClass?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJCredentialCategory_])
    MJCredentialCategories_ParentIDArray: MJCredentialCategory_[]; // Link to MJCredentialCategories
    
    @Field(() => [MJCredential_])
    MJCredentials_CategoryIDArray: MJCredential_[]; // Link to MJCredentials
    
}

//****************************************************************************
// INPUT TYPE for MJ: Credential Categories
//****************************************************************************
@InputType()
export class CreateMJCredentialCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    IconClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Credential Categories
//****************************************************************************
@InputType()
export class UpdateMJCredentialCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Credential Categories
//****************************************************************************
@ObjectType()
export class RunMJCredentialCategoryViewResult {
    @Field(() => [MJCredentialCategory_])
    Results: MJCredentialCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCredentialCategory_)
export class MJCredentialCategoryResolver extends ResolverBase {
    @Query(() => RunMJCredentialCategoryViewResult)
    async RunMJCredentialCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialCategoryViewResult)
    async RunMJCredentialCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialCategoryViewResult)
    async RunMJCredentialCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Credential Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCredentialCategory_, { nullable: true })
    async MJCredentialCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCredentialCategory_ | null> {
        this.CheckUserReadPermissions('MJ: Credential Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCredentialCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credential Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Credential Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCredentialCategory_])
    async MJCredentialCategories_ParentIDArray(@Root() mjcredentialcategory_: MJCredentialCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Credential Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCredentialCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjcredentialcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credential Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Credential Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCredential_])
    async MJCredentials_CategoryIDArray(@Root() mjcredentialcategory_: MJCredentialCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Credentials', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCredentials')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjcredentialcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credentials', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Credentials', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCredentialCategory_)
    async CreateMJCredentialCategory(
        @Arg('input', () => CreateMJCredentialCategoryInput) input: CreateMJCredentialCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Credential Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCredentialCategory_)
    async UpdateMJCredentialCategory(
        @Arg('input', () => UpdateMJCredentialCategoryInput) input: UpdateMJCredentialCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Credential Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCredentialCategory_)
    async DeleteMJCredentialCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Credential Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Credential Types
//****************************************************************************
@ObjectType({ description: `Defines credential templates for different services (e.g., OpenAI, SendGrid). Uses JSON Schema to define required fields and validation rules.` })
export class MJCredentialType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name for the credential type (e.g., OpenAI, SendGrid, AWS S3).`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the credential type.`}) 
    Description?: string;
        
    @Field({description: `High-level category: AI, Communication, Storage, Authentication, Database, or Integration.`}) 
    @MaxLength(50)
    Category: string;
        
    @Field({description: `JSON Schema defining the required fields for this credential type. Includes field names, types, validation rules, and UI hints.`}) 
    FieldSchema: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for UI display (e.g., fa-brands fa-openai).`}) 
    @MaxLength(100)
    IconClass?: string;
        
    @Field({nullable: true, description: `Optional URL endpoint to validate credentials against the service provider.`}) 
    @MaxLength(500)
    ValidationEndpoint?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJCredential_])
    MJCredentials_CredentialTypeIDArray: MJCredential_[]; // Link to MJCredentials
    
    @Field(() => [MJMCPServer_])
    MJMCPServers_CredentialTypeIDArray: MJMCPServer_[]; // Link to MJMCPServers
    
    @Field(() => [MJAIVendor_])
    MJAIVendors_CredentialTypeIDArray: MJAIVendor_[]; // Link to MJAIVendors
    
}

//****************************************************************************
// INPUT TYPE for MJ: Credential Types
//****************************************************************************
@InputType()
export class CreateMJCredentialTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    FieldSchema?: string;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    ValidationEndpoint: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Credential Types
//****************************************************************************
@InputType()
export class UpdateMJCredentialTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    FieldSchema?: string;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    ValidationEndpoint?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Credential Types
//****************************************************************************
@ObjectType()
export class RunMJCredentialTypeViewResult {
    @Field(() => [MJCredentialType_])
    Results: MJCredentialType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCredentialType_)
export class MJCredentialTypeResolver extends ResolverBase {
    @Query(() => RunMJCredentialTypeViewResult)
    async RunMJCredentialTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialTypeViewResult)
    async RunMJCredentialTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialTypeViewResult)
    async RunMJCredentialTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Credential Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCredentialType_, { nullable: true })
    async MJCredentialType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCredentialType_ | null> {
        this.CheckUserReadPermissions('MJ: Credential Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCredentialTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credential Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Credential Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCredential_])
    async MJCredentials_CredentialTypeIDArray(@Root() mjcredentialtype_: MJCredentialType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Credentials', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCredentials')} WHERE ${provider.QuoteIdentifier('CredentialTypeID')}='${mjcredentialtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credentials', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Credentials', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServer_])
    async MJMCPServers_CredentialTypeIDArray(@Root() mjcredentialtype_: MJCredentialType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Servers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServers')} WHERE ${provider.QuoteIdentifier('CredentialTypeID')}='${mjcredentialtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Servers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Servers', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIVendor_])
    async MJAIVendors_CredentialTypeIDArray(@Root() mjcredentialtype_: MJCredentialType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIVendors')} WHERE ${provider.QuoteIdentifier('CredentialTypeID')}='${mjcredentialtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Vendors', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCredentialType_)
    async CreateMJCredentialType(
        @Arg('input', () => CreateMJCredentialTypeInput) input: CreateMJCredentialTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Credential Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCredentialType_)
    async UpdateMJCredentialType(
        @Arg('input', () => UpdateMJCredentialTypeInput) input: UpdateMJCredentialTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Credential Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCredentialType_)
    async DeleteMJCredentialType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Credential Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Credentials
//****************************************************************************
@ObjectType({ description: `Stores credential instances with encrypted values. All access should go through CredentialEngine for proper audit logging.` })
export class MJCredential_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the credential type that defines the schema for this credential.`}) 
    @MaxLength(36)
    CredentialTypeID: string;
        
    @Field({nullable: true, description: `Optional category for organizational grouping.`}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field({description: `Human-readable name for this credential (e.g., Production SendGrid, Development OpenAI).`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of this credential instance.`}) 
    Description?: string;
        
    @Field({description: `Encrypted JSON blob containing all credential values. This field uses MemberJunction field-level encryption.`}) 
    Values: string;
        
    @Field(() => Boolean, {description: `If true, this is the default credential for its type when no specific credential is requested.`}) 
    IsDefault: boolean;
        
    @Field(() => Boolean, {description: `If false, the credential is disabled and will not be used.`}) 
    IsActive: boolean;
        
    @Field({nullable: true, description: `Optional expiration date. Expired credentials are treated as inactive.`}) 
    ExpiresAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the last successful validation against the provider.`}) 
    LastValidatedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the last time this credential was used.`}) 
    LastUsedAt?: Date;
        
    @Field({nullable: true, description: `Optional Font Awesome icon class to override the type icon for this specific credential.`}) 
    @MaxLength(100)
    IconClass?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    CredentialType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Category?: string;
        
    @Field(() => [MJOAuthToken_])
    MJOAuthTokens_CredentialIDArray: MJOAuthToken_[]; // Link to MJOAuthTokens
    
    @Field(() => [MJFileStorageAccount_])
    MJFileStorageAccounts_CredentialIDArray: MJFileStorageAccount_[]; // Link to MJFileStorageAccounts
    
    @Field(() => [MJMCPServerConnection_])
    MJMCPServerConnections_CredentialIDArray: MJMCPServerConnection_[]; // Link to MJMCPServerConnections
    
    @Field(() => [MJAICredentialBinding_])
    MJAICredentialBindings_CredentialIDArray: MJAICredentialBinding_[]; // Link to MJAICredentialBindings
    
}

//****************************************************************************
// INPUT TYPE for MJ: Credentials
//****************************************************************************
@InputType()
export class CreateMJCredentialInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CredentialTypeID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Values?: string;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    ExpiresAt: Date | null;

    @Field({ nullable: true })
    LastValidatedAt: Date | null;

    @Field({ nullable: true })
    LastUsedAt: Date | null;

    @Field({ nullable: true })
    IconClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Credentials
//****************************************************************************
@InputType()
export class UpdateMJCredentialInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CredentialTypeID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Values?: string;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field({ nullable: true })
    LastValidatedAt?: Date | null;

    @Field({ nullable: true })
    LastUsedAt?: Date | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Credentials
//****************************************************************************
@ObjectType()
export class RunMJCredentialViewResult {
    @Field(() => [MJCredential_])
    Results: MJCredential_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCredential_)
export class MJCredentialResolver extends ResolverBase {
    @Query(() => RunMJCredentialViewResult)
    async RunMJCredentialViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialViewResult)
    async RunMJCredentialViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialViewResult)
    async RunMJCredentialDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Credentials';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCredential_, { nullable: true })
    async MJCredential(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCredential_ | null> {
        this.CheckUserReadPermissions('MJ: Credentials', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCredentials')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credentials', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Credentials', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJOAuthToken_])
    async MJOAuthTokens_CredentialIDArray(@Root() mjcredential_: MJCredential_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Tokens', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthTokens')} WHERE ${provider.QuoteIdentifier('CredentialID')}='${mjcredential_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Tokens', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Tokens', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJFileStorageAccount_])
    async MJFileStorageAccounts_CredentialIDArray(@Root() mjcredential_: MJCredential_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: File Storage Accounts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileStorageAccounts')} WHERE ${provider.QuoteIdentifier('CredentialID')}='${mjcredential_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Storage Accounts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: File Storage Accounts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnection_])
    async MJMCPServerConnections_CredentialIDArray(@Root() mjcredential_: MJCredential_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnections')} WHERE ${provider.QuoteIdentifier('CredentialID')}='${mjcredential_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAICredentialBinding_])
    async MJAICredentialBindings_CredentialIDArray(@Root() mjcredential_: MJCredential_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAICredentialBindings')} WHERE ${provider.QuoteIdentifier('CredentialID')}='${mjcredential_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCredential_)
    async CreateMJCredential(
        @Arg('input', () => CreateMJCredentialInput) input: CreateMJCredentialInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Credentials', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCredential_)
    async UpdateMJCredential(
        @Arg('input', () => UpdateMJCredentialInput) input: UpdateMJCredentialInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Credentials', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCredential_)
    async DeleteMJCredential(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Credentials', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Categories
//****************************************************************************
@ObjectType({ description: `Organizes dashboards into logical groupings for navigation and access control, supporting hierarchical categorization.` })
export class MJDashboardCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJDashboard_])
    MJDashboards_CategoryIDArray: MJDashboard_[]; // Link to MJDashboards
    
    @Field(() => [MJDashboardCategory_])
    MJDashboardCategories_ParentIDArray: MJDashboardCategory_[]; // Link to MJDashboardCategories
    
    @Field(() => [MJDashboardCategoryPermission_])
    MJDashboardCategoryPermissions_DashboardCategoryIDArray: MJDashboardCategoryPermission_[]; // Link to MJDashboardCategoryPermissions
    
    @Field(() => [MJDashboardCategoryLink_])
    MJDashboardCategoryLinks_DashboardCategoryIDArray: MJDashboardCategoryLink_[]; // Link to MJDashboardCategoryLinks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Categories
//****************************************************************************
@InputType()
export class CreateMJDashboardCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Categories
//****************************************************************************
@InputType()
export class UpdateMJDashboardCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Categories
//****************************************************************************
@ObjectType()
export class RunMJDashboardCategoryViewResult {
    @Field(() => [MJDashboardCategory_])
    Results: MJDashboardCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardCategory_)
export class MJDashboardCategoryResolver extends ResolverBase {
    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardCategory_, { nullable: true })
    async MJDashboardCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardCategory_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDashboard_])
    async MJDashboards_CategoryIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboards')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboards', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategory_])
    async MJDashboardCategories_ParentIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryPermission_])
    async MJDashboardCategoryPermissions_DashboardCategoryIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategoryPermissions')} WHERE ${provider.QuoteIdentifier('DashboardCategoryID')}='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryLink_])
    async MJDashboardCategoryLinks_DashboardCategoryIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategoryLinks')} WHERE ${provider.QuoteIdentifier('DashboardCategoryID')}='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDashboardCategory_)
    async CreateMJDashboardCategory(
        @Arg('input', () => CreateMJDashboardCategoryInput) input: CreateMJDashboardCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardCategory_)
    async UpdateMJDashboardCategory(
        @Arg('input', () => UpdateMJDashboardCategoryInput) input: UpdateMJDashboardCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardCategory_)
    async DeleteMJDashboardCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Category Links
//****************************************************************************
@ObjectType({ description: `Allows users to organize shared dashboards into their own category structure. Creates a link/reference to a dashboard without duplicating it. Users can optionally provide a custom display name and control ordering within their folders.` })
export class MJDashboardCategoryLink_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    DashboardID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true, description: `The category in the user's personal folder structure. NULL means the dashboard appears at root level.`}) 
    @MaxLength(36)
    DashboardCategoryID?: string;
        
    @Field({nullable: true, description: `Optional user-friendly alias for the dashboard within this user's view. If NULL, uses the original dashboard name.`}) 
    @MaxLength(255)
    DisplayName?: string;
        
    @Field(() => Int, {description: `Display order of this dashboard within the user's category. Lower values appear first.`}) 
    Sequence: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Dashboard: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DashboardCategory?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Category Links
//****************************************************************************
@InputType()
export class CreateMJDashboardCategoryLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    DashboardCategoryID: string | null;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Category Links
//****************************************************************************
@InputType()
export class UpdateMJDashboardCategoryLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    DashboardCategoryID?: string | null;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Category Links
//****************************************************************************
@ObjectType()
export class RunMJDashboardCategoryLinkViewResult {
    @Field(() => [MJDashboardCategoryLink_])
    Results: MJDashboardCategoryLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardCategoryLink_)
export class MJDashboardCategoryLinkResolver extends ResolverBase {
    @Query(() => RunMJDashboardCategoryLinkViewResult)
    async RunMJDashboardCategoryLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryLinkViewResult)
    async RunMJDashboardCategoryLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryLinkViewResult)
    async RunMJDashboardCategoryLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Category Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardCategoryLink_, { nullable: true })
    async MJDashboardCategoryLink(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardCategoryLink_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Category Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategoryLinks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Category Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardCategoryLink_)
    async CreateMJDashboardCategoryLink(
        @Arg('input', () => CreateMJDashboardCategoryLinkInput) input: CreateMJDashboardCategoryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Category Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardCategoryLink_)
    async UpdateMJDashboardCategoryLink(
        @Arg('input', () => UpdateMJDashboardCategoryLinkInput) input: UpdateMJDashboardCategoryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Category Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardCategoryLink_)
    async DeleteMJDashboardCategoryLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Category Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Category Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for dashboard categories (folders). Permissions cascade to all dashboards within the category. Enables sharing entire folders of dashboards with granular access control.` })
export class MJDashboardCategoryPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    DashboardCategoryID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field(() => Boolean, {description: `Whether the user can view dashboards within this category`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can modify dashboards within this category`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can add new dashboards to or remove dashboards from this category`}) 
    CanAddRemove: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can share this category with other users`}) 
    CanShare: boolean;
        
    @Field({nullable: true, description: `The user who granted this permission. NULL if shared by the category owner.`}) 
    @MaxLength(36)
    SharedByUserID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    DashboardCategory: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SharedByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Category Permissions
//****************************************************************************
@InputType()
export class CreateMJDashboardCategoryPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardCategoryID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanAddRemove?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Category Permissions
//****************************************************************************
@InputType()
export class UpdateMJDashboardCategoryPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardCategoryID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanAddRemove?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Category Permissions
//****************************************************************************
@ObjectType()
export class RunMJDashboardCategoryPermissionViewResult {
    @Field(() => [MJDashboardCategoryPermission_])
    Results: MJDashboardCategoryPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardCategoryPermission_)
export class MJDashboardCategoryPermissionResolver extends ResolverBase {
    @Query(() => RunMJDashboardCategoryPermissionViewResult)
    async RunMJDashboardCategoryPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryPermissionViewResult)
    async RunMJDashboardCategoryPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryPermissionViewResult)
    async RunMJDashboardCategoryPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Category Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardCategoryPermission_, { nullable: true })
    async MJDashboardCategoryPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardCategoryPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Category Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategoryPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Category Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardCategoryPermission_)
    async CreateMJDashboardCategoryPermission(
        @Arg('input', () => CreateMJDashboardCategoryPermissionInput) input: CreateMJDashboardCategoryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Category Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardCategoryPermission_)
    async UpdateMJDashboardCategoryPermission(
        @Arg('input', () => UpdateMJDashboardCategoryPermissionInput) input: UpdateMJDashboardCategoryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Category Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardCategoryPermission_)
    async DeleteMJDashboardCategoryPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Category Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Part Types
//****************************************************************************
@ObjectType({ description: `Stores available panel types for metadata-driven dashboards. Each panel type defines a driver class for rendering content and an optional config dialog for setup UI.` })
export class MJDashboardPartType_ {
    @Field({description: `Primary key`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name for the panel type (e.g., View, Query, Artifact, WebURL, Custom)`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this panel type displays and its capabilities`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for the panel type (e.g., fa-solid fa-table)`}) 
    @MaxLength(100)
    Icon?: string;
        
    @Field({description: `The @RegisterClass name for the panel renderer component that extends DashboardBasePanelRenderer`}) 
    @MaxLength(255)
    DriverClass: string;
        
    @Field({nullable: true, description: `The @RegisterClass name for the configuration dialog component that extends DashboardBasePanelConfigDialog`}) 
    @MaxLength(255)
    ConfigDialogClass?: string;
        
    @Field({nullable: true, description: `JSON object containing default configuration values for new panels of this type`}) 
    DefaultConfig?: string;
        
    @Field(() => Int, {description: `Display order in panel type selection UI (lower numbers appear first)`}) 
    SortOrder: number;
        
    @Field(() => Boolean, {description: `Whether this panel type is currently available for use`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Part Types
//****************************************************************************
@InputType()
export class CreateMJDashboardPartTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    ConfigDialogClass: string | null;

    @Field({ nullable: true })
    DefaultConfig: string | null;

    @Field(() => Int, { nullable: true })
    SortOrder?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Part Types
//****************************************************************************
@InputType()
export class UpdateMJDashboardPartTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    ConfigDialogClass?: string | null;

    @Field({ nullable: true })
    DefaultConfig?: string | null;

    @Field(() => Int, { nullable: true })
    SortOrder?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Part Types
//****************************************************************************
@ObjectType()
export class RunMJDashboardPartTypeViewResult {
    @Field(() => [MJDashboardPartType_])
    Results: MJDashboardPartType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardPartType_)
export class MJDashboardPartTypeResolver extends ResolverBase {
    @Query(() => RunMJDashboardPartTypeViewResult)
    async RunMJDashboardPartTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardPartTypeViewResult)
    async RunMJDashboardPartTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardPartTypeViewResult)
    async RunMJDashboardPartTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Part Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardPartType_, { nullable: true })
    async MJDashboardPartType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardPartType_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Part Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardPartTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Part Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Part Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardPartType_)
    async CreateMJDashboardPartType(
        @Arg('input', () => CreateMJDashboardPartTypeInput) input: CreateMJDashboardPartTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Part Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardPartType_)
    async UpdateMJDashboardPartType(
        @Arg('input', () => UpdateMJDashboardPartTypeInput) input: UpdateMJDashboardPartTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Part Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardPartType_)
    async DeleteMJDashboardPartType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Part Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for dashboards with granular access control (Read, Edit, Delete, Share). Each record grants a specific user access to a dashboard with configurable permission levels.` })
export class MJDashboardPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    DashboardID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field(() => Boolean, {description: `Whether the user can view the dashboard and its contents`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can modify the dashboard layout, add/remove parts, or change settings`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can delete the dashboard entirely`}) 
    CanDelete: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can share the dashboard with other users`}) 
    CanShare: boolean;
        
    @Field({nullable: true, description: `The user who granted this permission. NULL if shared by the dashboard owner.`}) 
    @MaxLength(36)
    SharedByUserID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Dashboard: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SharedByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Permissions
//****************************************************************************
@InputType()
export class CreateMJDashboardPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Permissions
//****************************************************************************
@InputType()
export class UpdateMJDashboardPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Permissions
//****************************************************************************
@ObjectType()
export class RunMJDashboardPermissionViewResult {
    @Field(() => [MJDashboardPermission_])
    Results: MJDashboardPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardPermission_)
export class MJDashboardPermissionResolver extends ResolverBase {
    @Query(() => RunMJDashboardPermissionViewResult)
    async RunMJDashboardPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardPermissionViewResult)
    async RunMJDashboardPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardPermissionViewResult)
    async RunMJDashboardPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardPermission_, { nullable: true })
    async MJDashboardPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardPermission_)
    async CreateMJDashboardPermission(
        @Arg('input', () => CreateMJDashboardPermissionInput) input: CreateMJDashboardPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardPermission_)
    async UpdateMJDashboardPermission(
        @Arg('input', () => UpdateMJDashboardPermissionInput) input: UpdateMJDashboardPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardPermission_)
    async DeleteMJDashboardPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard User Preferences
//****************************************************************************
@ObjectType({ description: `Stores dashboard preferences for users and system defaults. The absence of a record for a dashboard means it is not shown.` })
export class MJDashboardUserPreference_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true, description: `User that these preferences belong to, NULL for system defaults`}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field({description: `Dashboard that this preference refers to`}) 
    @MaxLength(36)
    DashboardID: string;
        
    @Field({description: `Scope of the preference (Global or App)`}) 
    @MaxLength(20)
    Scope: string;
        
    @Field({nullable: true, description: `Application that this preference applies to (only for App scope)`}) 
    @MaxLength(36)
    ApplicationID?: string;
        
    @Field(() => Int, {description: `Order in which to display the dashboard`}) 
    DisplayOrder: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
    @Field() 
    @MaxLength(255)
    Dashboard: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Application?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User Preferences
//****************************************************************************
@InputType()
export class CreateMJDashboardUserPreferenceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User Preferences
//****************************************************************************
@InputType()
export class UpdateMJDashboardUserPreferenceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard User Preferences
//****************************************************************************
@ObjectType()
export class RunMJDashboardUserPreferenceViewResult {
    @Field(() => [MJDashboardUserPreference_])
    Results: MJDashboardUserPreference_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardUserPreference_)
export class MJDashboardUserPreferenceResolver extends ResolverBase {
    @Query(() => RunMJDashboardUserPreferenceViewResult)
    async RunMJDashboardUserPreferenceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardUserPreferenceViewResult)
    async RunMJDashboardUserPreferenceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardUserPreferenceViewResult)
    async RunMJDashboardUserPreferenceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard User Preferences';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardUserPreference_, { nullable: true })
    async MJDashboardUserPreference(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardUserPreference_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardUserPreferences')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardUserPreference_)
    async CreateMJDashboardUserPreference(
        @Arg('input', () => CreateMJDashboardUserPreferenceInput) input: CreateMJDashboardUserPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard User Preferences', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardUserPreference_)
    async UpdateMJDashboardUserPreference(
        @Arg('input', () => UpdateMJDashboardUserPreferenceInput) input: UpdateMJDashboardUserPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard User Preferences', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardUserPreference_)
    async DeleteMJDashboardUserPreference(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard User Preferences', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard User States
//****************************************************************************
@ObjectType({ description: `Stores user-specific dashboard state information` })
export class MJDashboardUserState_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Dashboard that this state applies to`}) 
    @MaxLength(36)
    DashboardID: string;
        
    @Field({description: `User that this state belongs to`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true, description: `JSON object containing user-specific dashboard state`}) 
    UserState?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Dashboard: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User States
//****************************************************************************
@InputType()
export class CreateMJDashboardUserStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UserState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User States
//****************************************************************************
@InputType()
export class UpdateMJDashboardUserStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UserState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard User States
//****************************************************************************
@ObjectType()
export class RunMJDashboardUserStateViewResult {
    @Field(() => [MJDashboardUserState_])
    Results: MJDashboardUserState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardUserState_)
export class MJDashboardUserStateResolver extends ResolverBase {
    @Query(() => RunMJDashboardUserStateViewResult)
    async RunMJDashboardUserStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardUserStateViewResult)
    async RunMJDashboardUserStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardUserStateViewResult)
    async RunMJDashboardUserStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard User States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardUserState_, { nullable: true })
    async MJDashboardUserState(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardUserState_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardUserStates')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard User States', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardUserState_)
    async CreateMJDashboardUserState(
        @Arg('input', () => CreateMJDashboardUserStateInput) input: CreateMJDashboardUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard User States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardUserState_)
    async UpdateMJDashboardUserState(
        @Arg('input', () => UpdateMJDashboardUserStateInput) input: UpdateMJDashboardUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard User States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardUserState_)
    async DeleteMJDashboardUserState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard User States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboards
//****************************************************************************
@ObjectType({ description: `Dashboards are used to group resources into a single display pane for an end-user` })
export class MJDashboard_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field({description: `JSON configuration defining the dashboard layout, widgets, data sources, and display options.`}) 
    UIConfigDetails: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Dashboard type supporting Config (metadata-driven), Code (compiled TypeScript), and Dynamic Code (Skip-generated runtime JavaScript/React) options`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `Base64 encoded image or URL to an image thumbnail for the dashboard`}) 
    Thumbnail?: string;
        
    @Field({description: `Scope of the dashboard: Global or App-specific`}) 
    @MaxLength(20)
    Scope: string;
        
    @Field({nullable: true, description: `Associated Application ID if Scope is App, otherwise NULL`}) 
    @MaxLength(36)
    ApplicationID?: string;
        
    @Field({nullable: true, description: `Specifies the runtime class that will be used for the Dashboard when Type is set to 'Code'. This class contains the custom logic and implementation for code-based dashboards.`}) 
    @MaxLength(255)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Used to identify the dashboard for code-base dashboards. Allows reuse of the same DriverClass for multiple dashboards that can be rendered differently.`}) 
    @MaxLength(255)
    Code?: string;
        
    @Field() 
    @MaxLength(36)
    EnvironmentID: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Application?: string;
        
    @Field() 
    @MaxLength(255)
    Environment: string;
        
    @Field(() => [MJDashboardUserState_])
    MJDashboardUserStates_DashboardIDArray: MJDashboardUserState_[]; // Link to MJDashboardUserStates
    
    @Field(() => [MJDashboardCategoryLink_])
    MJDashboardCategoryLinks_DashboardIDArray: MJDashboardCategoryLink_[]; // Link to MJDashboardCategoryLinks
    
    @Field(() => [MJDashboardUserPreference_])
    MJDashboardUserPreferences_DashboardIDArray: MJDashboardUserPreference_[]; // Link to MJDashboardUserPreferences
    
    @Field(() => [MJDashboardPermission_])
    MJDashboardPermissions_DashboardIDArray: MJDashboardPermission_[]; // Link to MJDashboardPermissions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboards
//****************************************************************************
@InputType()
export class CreateMJDashboardInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Thumbnail: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    EnvironmentID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboards
//****************************************************************************
@InputType()
export class UpdateMJDashboardInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboards
//****************************************************************************
@ObjectType()
export class RunMJDashboardViewResult {
    @Field(() => [MJDashboard_])
    Results: MJDashboard_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboard_)
export class MJDashboardResolver extends ResolverBase {
    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboards';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboard_, { nullable: true })
    async MJDashboard(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboard_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboards')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboards', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDashboardUserState_])
    async MJDashboardUserStates_DashboardIDArray(@Root() mjdashboard_: MJDashboard_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardUserStates')} WHERE ${provider.QuoteIdentifier('DashboardID')}='${mjdashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryLink_])
    async MJDashboardCategoryLinks_DashboardIDArray(@Root() mjdashboard_: MJDashboard_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategoryLinks')} WHERE ${provider.QuoteIdentifier('DashboardID')}='${mjdashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardUserPreference_])
    async MJDashboardUserPreferences_DashboardIDArray(@Root() mjdashboard_: MJDashboard_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardUserPreferences')} WHERE ${provider.QuoteIdentifier('DashboardID')}='${mjdashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardPermission_])
    async MJDashboardPermissions_DashboardIDArray(@Root() mjdashboard_: MJDashboard_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardPermissions')} WHERE ${provider.QuoteIdentifier('DashboardID')}='${mjdashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDashboard_)
    async CreateMJDashboard(
        @Arg('input', () => CreateMJDashboardInput) input: CreateMJDashboardInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboards', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboard_)
    async UpdateMJDashboard(
        @Arg('input', () => UpdateMJDashboardInput) input: UpdateMJDashboardInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboards', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboard_)
    async DeleteMJDashboard(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboards', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Data Context Items
//****************************************************************************
@ObjectType({ description: `Data Context Items store information about each item within a Data Context. Each item stores a link to a view, query, or raw sql statement and can optionally cache the JSON representing the last run of that data object as well.` })
export class MJDataContextItem_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    DataContextID: string;
        
    @Field({description: `The type of the item, either "view", "query", "full_entity", "single_record", or "sql"`}) 
    @MaxLength(50)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    QueryID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    EntityID?: string;
        
    @Field({nullable: true, description: `The Primary Key value for the record, only used when Type='single_record'`}) 
    @MaxLength(450)
    RecordID?: string;
        
    @Field({nullable: true, description: `Only used when Type=sql`}) 
    SQL?: string;
        
    @Field({nullable: true, description: `Optionally used to cache results of an item. This can be used for performance optimization, and also for having snapshots of data for historical comparisons.`}) 
    DataJSON?: string;
        
    @Field({nullable: true, description: `If DataJSON is populated, this field will show the date the the data was captured`}) 
    LastRefreshedAt?: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Optional programmatic identifier for this data context item. Must be unique within the DataContext and follow JavaScript naming conventions (letters, numbers, underscore, starting with letter or underscore). Used for improved code generation and programmatic access to data context items.`}) 
    @MaxLength(255)
    CodeName?: string;
        
    @Field() 
    @MaxLength(255)
    DataContext: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    View?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Query?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Data Context Items
//****************************************************************************
@InputType()
export class CreateMJDataContextItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID: string | null;

    @Field({ nullable: true })
    QueryID: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    DataJSON: string | null;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CodeName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Data Context Items
//****************************************************************************
@InputType()
export class UpdateMJDataContextItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID?: string | null;

    @Field({ nullable: true })
    QueryID?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    DataJSON?: string | null;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CodeName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Data Context Items
//****************************************************************************
@ObjectType()
export class RunMJDataContextItemViewResult {
    @Field(() => [MJDataContextItem_])
    Results: MJDataContextItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataContextItem_)
export class MJDataContextItemResolver extends ResolverBase {
    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Data Context Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataContextItem_, { nullable: true })
    async MJDataContextItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataContextItem_ | null> {
        this.CheckUserReadPermissions('MJ: Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDataContextItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Data Context Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDataContextItem_)
    async CreateMJDataContextItem(
        @Arg('input', () => CreateMJDataContextItemInput) input: CreateMJDataContextItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Data Context Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDataContextItem_)
    async UpdateMJDataContextItem(
        @Arg('input', () => UpdateMJDataContextItemInput) input: UpdateMJDataContextItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Data Context Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDataContextItem_)
    async DeleteMJDataContextItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Data Context Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Data Contexts
//****************************************************************************
@ObjectType({ description: `Data Contexts are a primitive within the MemberJunction architecture. They store information about data contexts which are groups of data including views, queries, or raw SQL statements. Data contexts can be used in conversations, reports and more.` })
export class MJDataContext_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true, description: `Timestamp of when the data in this context was last refreshed or recalculated.`}) 
    LastRefreshedAt?: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field(() => [MJDataContextItem_])
    MJDataContextItems_DataContextIDArray: MJDataContextItem_[]; // Link to MJDataContextItems
    
    @Field(() => [MJReport_])
    MJReports_DataContextIDArray: MJReport_[]; // Link to MJReports
    
    @Field(() => [MJConversation_])
    MJConversations_DataContextIDArray: MJConversation_[]; // Link to MJConversations
    
}

//****************************************************************************
// INPUT TYPE for MJ: Data Contexts
//****************************************************************************
@InputType()
export class CreateMJDataContextInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Data Contexts
//****************************************************************************
@InputType()
export class UpdateMJDataContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Data Contexts
//****************************************************************************
@ObjectType()
export class RunMJDataContextViewResult {
    @Field(() => [MJDataContext_])
    Results: MJDataContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataContext_)
export class MJDataContextResolver extends ResolverBase {
    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Data Contexts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataContext_, { nullable: true })
    async MJDataContext(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataContext_ | null> {
        this.CheckUserReadPermissions('MJ: Data Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDataContexts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Data Contexts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDataContextItem_])
    async MJDataContextItems_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDataContextItems')} WHERE ${provider.QuoteIdentifier('DataContextID')}='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Data Context Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async MJReports_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('DataContextID')}='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async MJConversations_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversations')} WHERE ${provider.QuoteIdentifier('DataContextID')}='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDataContext_)
    async CreateMJDataContext(
        @Arg('input', () => CreateMJDataContextInput) input: CreateMJDataContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Data Contexts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDataContext_)
    async UpdateMJDataContext(
        @Arg('input', () => UpdateMJDataContextInput) input: UpdateMJDataContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Data Contexts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDataContext_)
    async DeleteMJDataContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Data Contexts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dataset Items
//****************************************************************************
@ObjectType({ description: `A single item in a Dataset and can be sourced from multiple methods.` })
export class MJDatasetItem_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique code identifier for this dataset item within its parent dataset.`}) 
    @MaxLength(50)
    Code: string;
        
    @Field() 
    @MaxLength(36)
    DatasetID: string;
        
    @Field(() => Int, {description: `Order in which this item should be processed or displayed within the dataset.`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({nullable: true, description: `SQL WHERE clause to filter data when this dataset item is sourced from a query.`}) 
    WhereClause?: string;
        
    @Field({description: `The date field name used for incremental updates and change detection.`}) 
    @MaxLength(100)
    DateFieldToCheck: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional column to store a comma-delimited list of columns for the DatasetItem`}) 
    Columns?: string;
        
    @Field() 
    @MaxLength(100)
    Dataset: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dataset Items
//****************************************************************************
@InputType()
export class CreateMJDatasetItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    DatasetID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    WhereClause: string | null;

    @Field({ nullable: true })
    DateFieldToCheck?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Columns: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dataset Items
//****************************************************************************
@InputType()
export class UpdateMJDatasetItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    DatasetID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    WhereClause?: string | null;

    @Field({ nullable: true })
    DateFieldToCheck?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Columns?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dataset Items
//****************************************************************************
@ObjectType()
export class RunMJDatasetItemViewResult {
    @Field(() => [MJDatasetItem_])
    Results: MJDatasetItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDatasetItem_)
export class MJDatasetItemResolver extends ResolverBase {
    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dataset Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDatasetItem_, { nullable: true })
    async MJDatasetItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDatasetItem_ | null> {
        this.CheckUserReadPermissions('MJ: Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDatasetItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dataset Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDatasetItem_)
    async CreateMJDatasetItem(
        @Arg('input', () => CreateMJDatasetItemInput) input: CreateMJDatasetItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dataset Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDatasetItem_)
    async UpdateMJDatasetItem(
        @Arg('input', () => UpdateMJDatasetItemInput) input: UpdateMJDatasetItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dataset Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDatasetItem_)
    async DeleteMJDatasetItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dataset Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Datasets
//****************************************************************************
@ObjectType({ description: `Cacheable sets of data that can span one or more items` })
export class MJDataset_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJDatasetItem_])
    MJDatasetItems_DatasetNameArray: MJDatasetItem_[]; // Link to MJDatasetItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Datasets
//****************************************************************************
@InputType()
export class CreateMJDatasetInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Datasets
//****************************************************************************
@InputType()
export class UpdateMJDatasetInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Datasets
//****************************************************************************
@ObjectType()
export class RunMJDatasetViewResult {
    @Field(() => [MJDataset_])
    Results: MJDataset_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataset_)
export class MJDatasetResolver extends ResolverBase {
    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Datasets';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataset_, { nullable: true })
    async MJDataset(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataset_ | null> {
        this.CheckUserReadPermissions('MJ: Datasets', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDatasets')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Datasets', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Datasets', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDatasetItem_])
    async MJDatasetItems_DatasetNameArray(@Root() mjdataset_: MJDataset_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDatasetItems')} WHERE ${provider.QuoteIdentifier('DatasetName')}='${mjdataset_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dataset Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDataset_)
    async CreateMJDataset(
        @Arg('input', () => CreateMJDatasetInput) input: CreateMJDatasetInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Datasets', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDataset_)
    async UpdateMJDataset(
        @Arg('input', () => UpdateMJDatasetInput) input: UpdateMJDatasetInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Datasets', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDataset_)
    async DeleteMJDataset(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Datasets', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Duplicate Run Detail Matches
//****************************************************************************
@ObjectType({ description: `Records individual matching pairs of potentially duplicate records identified during a duplicate detection run with confidence scores.` })
export class MJDuplicateRunDetailMatch_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    DuplicateRunDetailID: string;
        
    @Field({description: `Either Vector or SP`}) 
    @MaxLength(20)
    MatchSource: string;
        
    @Field({description: `The ID of the record identified as a potential duplicate match.`}) 
    @MaxLength(500)
    MatchRecordID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 designating the computed probability of a match`}) 
    MatchProbability: number;
        
    @Field({description: `Timestamp when this duplicate match was identified.`}) 
    MatchedAt: Date;
        
    @Field({description: `The action to take for this match (Ignore, Merge, Delete).`}) 
    @MaxLength(20)
    Action: string;
        
    @Field({description: `Current approval status of the proposed action (Pending, Approved, Rejected).`}) 
    @MaxLength(20)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RecordMergeLogID?: string;
        
    @Field({description: `Status of the merge operation if Action is Merge (Pending, Complete, Failed).`}) 
    @MaxLength(20)
    MergeStatus: string;
        
    @Field({description: `Timestamp when records were merged, if applicable.`}) 
    MergedAt: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    DuplicateRunDetail: string;
        
    @Field({nullable: true}) 
    @MaxLength(450)
    RecordMergeLog?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunDetailMatchInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunDetailMatchInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Duplicate Run Detail Matches
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunDetailMatchViewResult {
    @Field(() => [MJDuplicateRunDetailMatch_])
    Results: MJDuplicateRunDetailMatch_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRunDetailMatch_)
export class MJDuplicateRunDetailMatchResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Duplicate Run Detail Matches';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRunDetailMatch_, { nullable: true })
    async MJDuplicateRunDetailMatch(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRunDetailMatch_ | null> {
        this.CheckUserReadPermissions('MJ: Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRunDetailMatches')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Duplicate Run Detail Matches', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDuplicateRunDetailMatch_)
    async CreateMJDuplicateRunDetailMatch(
        @Arg('input', () => CreateMJDuplicateRunDetailMatchInput) input: CreateMJDuplicateRunDetailMatchInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Duplicate Run Detail Matches', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRunDetailMatch_)
    async UpdateMJDuplicateRunDetailMatch(
        @Arg('input', () => UpdateMJDuplicateRunDetailMatchInput) input: UpdateMJDuplicateRunDetailMatchInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Duplicate Run Detail Matches', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDuplicateRunDetailMatch_)
    async DeleteMJDuplicateRunDetailMatch(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Duplicate Run Detail Matches', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Duplicate Run Details
//****************************************************************************
@ObjectType({ description: `Stores detailed results for each record analyzed in a duplicate detection run, including match status and processing metadata.` })
export class MJDuplicateRunDetail_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    DuplicateRunID: string;
        
    @Field({description: `The ID of the record being analyzed for duplicates.`}) 
    @MaxLength(500)
    RecordID: string;
        
    @Field({description: `Status of duplicate analysis for this record (Pending, Complete, Error).`}) 
    @MaxLength(20)
    MatchStatus: string;
        
    @Field({nullable: true, description: `If MatchStatus=Skipped, this field can be used to store the reason why the record was skipped`}) 
    SkippedReason?: string;
        
    @Field({nullable: true, description: `If MatchStatus='Error' this field can be used to track the error from that phase of the process for logging/diagnostics.`}) 
    MatchErrorMessage?: string;
        
    @Field({description: `Status of any merge operations for this record (Not Applicable, Pending, Complete, Failed).`}) 
    @MaxLength(20)
    MergeStatus: string;
        
    @Field({nullable: true, description: `Error details if merge operation failed for this record.`}) 
    MergeErrorMessage?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    DuplicateRun: string;
        
    @Field(() => [MJDuplicateRunDetailMatch_])
    MJDuplicateRunDetailMatches_DuplicateRunDetailIDArray: MJDuplicateRunDetailMatch_[]; // Link to MJDuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for MJ: Duplicate Run Details
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason: string | null;

    @Field({ nullable: true })
    MatchErrorMessage: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Duplicate Run Details
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason?: string | null;

    @Field({ nullable: true })
    MatchErrorMessage?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Duplicate Run Details
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunDetailViewResult {
    @Field(() => [MJDuplicateRunDetail_])
    Results: MJDuplicateRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRunDetail_)
export class MJDuplicateRunDetailResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Duplicate Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRunDetail_, { nullable: true })
    async MJDuplicateRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRunDetail_ | null> {
        this.CheckUserReadPermissions('MJ: Duplicate Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRunDetails')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Duplicate Run Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDuplicateRunDetailMatch_])
    async MJDuplicateRunDetailMatches_DuplicateRunDetailIDArray(@Root() mjduplicaterundetail_: MJDuplicateRunDetail_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRunDetailMatches')} WHERE ${provider.QuoteIdentifier('DuplicateRunDetailID')}='${mjduplicaterundetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Duplicate Run Detail Matches', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDuplicateRunDetail_)
    async CreateMJDuplicateRunDetail(
        @Arg('input', () => CreateMJDuplicateRunDetailInput) input: CreateMJDuplicateRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Duplicate Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRunDetail_)
    async UpdateMJDuplicateRunDetail(
        @Arg('input', () => UpdateMJDuplicateRunDetailInput) input: UpdateMJDuplicateRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Duplicate Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDuplicateRunDetail_)
    async DeleteMJDuplicateRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Duplicate Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Duplicate Runs
//****************************************************************************
@ObjectType({ description: `Manages execution of duplicate detection processes across entities, tracking configuration, progress, and summary results.` })
export class MJDuplicateRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(36)
    StartedByUserID: string;
        
    @Field() 
    @MaxLength(36)
    SourceListID: string;
        
    @Field() 
    StartedAt: Date;
        
    @Field({nullable: true}) 
    EndedAt?: Date;
        
    @Field({description: `Overall approval status for the duplicate run results (Pending, Approved, Rejected).`}) 
    @MaxLength(20)
    ApprovalStatus: string;
        
    @Field({nullable: true, description: `Comments or notes regarding the approval decision for this duplicate run.`}) 
    ApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ApprovedByUserID?: string;
        
    @Field({description: `Current processing status of the duplicate detection run (Pending, Running, Complete, Failed).`}) 
    @MaxLength(20)
    ProcessingStatus: string;
        
    @Field({nullable: true, description: `Error details if the duplicate detection run failed.`}) 
    ProcessingErrorMessage?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    StartedByUser: string;
        
    @Field() 
    @MaxLength(100)
    SourceList: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ApprovedByUser?: string;
        
    @Field(() => [MJDuplicateRunDetail_])
    MJDuplicateRunDetails_DuplicateRunIDArray: MJDuplicateRunDetail_[]; // Link to MJDuplicateRunDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Duplicate Runs
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments: string | null;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Duplicate Runs
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments?: string | null;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Duplicate Runs
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunViewResult {
    @Field(() => [MJDuplicateRun_])
    Results: MJDuplicateRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRun_)
export class MJDuplicateRunResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Duplicate Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRun_, { nullable: true })
    async MJDuplicateRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRun_ | null> {
        this.CheckUserReadPermissions('MJ: Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Duplicate Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDuplicateRunDetail_])
    async MJDuplicateRunDetails_DuplicateRunIDArray(@Root() mjduplicaterun_: MJDuplicateRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Duplicate Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRunDetails')} WHERE ${provider.QuoteIdentifier('DuplicateRunID')}='${mjduplicaterun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Duplicate Run Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDuplicateRun_)
    async CreateMJDuplicateRun(
        @Arg('input', () => CreateMJDuplicateRunInput) input: CreateMJDuplicateRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Duplicate Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRun_)
    async UpdateMJDuplicateRun(
        @Arg('input', () => UpdateMJDuplicateRunInput) input: UpdateMJDuplicateRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Duplicate Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDuplicateRun_)
    async DeleteMJDuplicateRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Duplicate Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Employee Company Integrations
//****************************************************************************
@ObjectType({ description: `Maps employees to their external identifiers in integrated systems, maintaining synchronization across platforms.` })
export class MJEmployeeCompanyIntegration_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(36)
    CompanyIntegrationID: string;
        
    @Field({description: `The employee's unique identifier in the external integrated system.`}) 
    @MaxLength(750)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean, {description: `Indicates if this employee integration mapping is currently active.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(81)
    Employee?: string;
        
    @Field() 
    @MaxLength(255)
    CompanyIntegration: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Employee Company Integrations
//****************************************************************************
@InputType()
export class CreateMJEmployeeCompanyIntegrationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Employee Company Integrations
//****************************************************************************
@InputType()
export class UpdateMJEmployeeCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Employee Company Integrations
//****************************************************************************
@ObjectType()
export class RunMJEmployeeCompanyIntegrationViewResult {
    @Field(() => [MJEmployeeCompanyIntegration_])
    Results: MJEmployeeCompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeCompanyIntegration_)
export class MJEmployeeCompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Employee Company Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeCompanyIntegration_, { nullable: true })
    async MJEmployeeCompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeCompanyIntegration_ | null> {
        this.CheckUserReadPermissions('MJ: Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeCompanyIntegrations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Employee Company Integrations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEmployeeCompanyIntegration_)
    async CreateMJEmployeeCompanyIntegration(
        @Arg('input', () => CreateMJEmployeeCompanyIntegrationInput) input: CreateMJEmployeeCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Employee Company Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployeeCompanyIntegration_)
    async UpdateMJEmployeeCompanyIntegration(
        @Arg('input', () => UpdateMJEmployeeCompanyIntegrationInput) input: UpdateMJEmployeeCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Employee Company Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployeeCompanyIntegration_)
    async DeleteMJEmployeeCompanyIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Employee Company Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Employee Roles
//****************************************************************************
@ObjectType({ description: `Links employees to their assigned roles within the organization, managing role-based permissions and responsibilities.` })
export class MJEmployeeRole_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(36)
    RoleID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(81)
    Employee?: string;
        
    @Field() 
    @MaxLength(50)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Employee Roles
//****************************************************************************
@InputType()
export class CreateMJEmployeeRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Employee Roles
//****************************************************************************
@InputType()
export class UpdateMJEmployeeRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Employee Roles
//****************************************************************************
@ObjectType()
export class RunMJEmployeeRoleViewResult {
    @Field(() => [MJEmployeeRole_])
    Results: MJEmployeeRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeRole_)
export class MJEmployeeRoleResolver extends ResolverBase {
    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Employee Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeRole_, { nullable: true })
    async MJEmployeeRole(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeRole_ | null> {
        this.CheckUserReadPermissions('MJ: Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeRoles')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Employee Roles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEmployeeRole_)
    async CreateMJEmployeeRole(
        @Arg('input', () => CreateMJEmployeeRoleInput) input: CreateMJEmployeeRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Employee Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployeeRole_)
    async UpdateMJEmployeeRole(
        @Arg('input', () => UpdateMJEmployeeRoleInput) input: UpdateMJEmployeeRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Employee Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployeeRole_)
    async DeleteMJEmployeeRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Employee Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Employee Skills
//****************************************************************************
@ObjectType({ description: `Tracks skills, competencies, and certifications associated with employees for resource planning and team composition.` })
export class MJEmployeeSkill_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(36)
    SkillID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(81)
    Employee?: string;
        
    @Field() 
    @MaxLength(50)
    Skill: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Employee Skills
//****************************************************************************
@InputType()
export class CreateMJEmployeeSkillInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    SkillID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Employee Skills
//****************************************************************************
@InputType()
export class UpdateMJEmployeeSkillInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    SkillID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Employee Skills
//****************************************************************************
@ObjectType()
export class RunMJEmployeeSkillViewResult {
    @Field(() => [MJEmployeeSkill_])
    Results: MJEmployeeSkill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeSkill_)
export class MJEmployeeSkillResolver extends ResolverBase {
    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Employee Skills';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeSkill_, { nullable: true })
    async MJEmployeeSkill(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeSkill_ | null> {
        this.CheckUserReadPermissions('MJ: Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeSkills')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Employee Skills', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEmployeeSkill_)
    async CreateMJEmployeeSkill(
        @Arg('input', () => CreateMJEmployeeSkillInput) input: CreateMJEmployeeSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Employee Skills', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployeeSkill_)
    async UpdateMJEmployeeSkill(
        @Arg('input', () => UpdateMJEmployeeSkillInput) input: UpdateMJEmployeeSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Employee Skills', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployeeSkill_)
    async DeleteMJEmployeeSkill(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Employee Skills', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Employees
//****************************************************************************
@ObjectType({ description: `A list of employees across all units of your organization` })
export class MJEmployee_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Business Central Management ID - unique identifier for cross-system employee tracking.`}) 
    @MaxLength(36)
    BCMID: string;
        
    @Field({description: `Employee's first name or given name.`}) 
    @MaxLength(30)
    FirstName: string;
        
    @Field({description: `Employee's last name or surname.`}) 
    @MaxLength(50)
    LastName: string;
        
    @Field() 
    @MaxLength(36)
    CompanyID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    SupervisorID?: string;
        
    @Field({nullable: true, description: `Employee's job title or position within the organization.`}) 
    @MaxLength(50)
    Title?: string;
        
    @Field({description: `Employee's primary email address, must be unique across the system.`}) 
    @MaxLength(100)
    Email: string;
        
    @Field({nullable: true, description: `Employee's primary phone number for business contact.`}) 
    @MaxLength(20)
    Phone?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the employee is currently active in the organization.`}) 
    Active: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(81)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(81)
    Supervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(30)
    SupervisorFirstName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    SupervisorLastName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SupervisorEmail?: string;
        
    @Field(() => [MJEmployee_])
    MJEmployees_SupervisorIDArray: MJEmployee_[]; // Link to MJEmployees
    
    @Field(() => [MJEmployeeCompanyIntegration_])
    MJEmployeeCompanyIntegrations_EmployeeIDArray: MJEmployeeCompanyIntegration_[]; // Link to MJEmployeeCompanyIntegrations
    
    @Field(() => [MJEmployeeRole_])
    MJEmployeeRoles_EmployeeIDArray: MJEmployeeRole_[]; // Link to MJEmployeeRoles
    
    @Field(() => [MJEmployeeSkill_])
    MJEmployeeSkills_EmployeeIDArray: MJEmployeeSkill_[]; // Link to MJEmployeeSkills
    
    @Field(() => [MJUser_])
    MJUsers_EmployeeIDArray: MJUser_[]; // Link to MJUsers
    
}

//****************************************************************************
// INPUT TYPE for MJ: Employees
//****************************************************************************
@InputType()
export class CreateMJEmployeeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Employees
//****************************************************************************
@InputType()
export class UpdateMJEmployeeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Employees
//****************************************************************************
@ObjectType()
export class RunMJEmployeeViewResult {
    @Field(() => [MJEmployee_])
    Results: MJEmployee_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployee_)
export class MJEmployeeResolver extends ResolverBase {
    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Employees';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployee_, { nullable: true })
    async MJEmployee(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployee_ | null> {
        this.CheckUserReadPermissions('MJ: Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployees')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Employees', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEmployee_])
    async AllMJEmployees(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployees')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employees', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employees', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEmployee_])
    async MJEmployees_SupervisorIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployees')} WHERE ${provider.QuoteIdentifier('SupervisorID')}='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employees', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeCompanyIntegration_])
    async MJEmployeeCompanyIntegrations_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeCompanyIntegrations')} WHERE ${provider.QuoteIdentifier('EmployeeID')}='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employee Company Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeRole_])
    async MJEmployeeRoles_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeRoles')} WHERE ${provider.QuoteIdentifier('EmployeeID')}='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employee Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeSkill_])
    async MJEmployeeSkills_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeSkills')} WHERE ${provider.QuoteIdentifier('EmployeeID')}='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employee Skills', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUser_])
    async MJUsers_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUsers')} WHERE ${provider.QuoteIdentifier('EmployeeID')}='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Users', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEmployee_)
    async CreateMJEmployee(
        @Arg('input', () => CreateMJEmployeeInput) input: CreateMJEmployeeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Employees', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployee_)
    async UpdateMJEmployee(
        @Arg('input', () => UpdateMJEmployeeInput) input: UpdateMJEmployeeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Employees', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployee_)
    async DeleteMJEmployee(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Employees', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Encryption Algorithms
//****************************************************************************
@ObjectType({ description: `Defines available encryption algorithms and their configuration parameters. AES-256-GCM is the recommended algorithm for new implementations.` })
export class MJEncryptionAlgorithm_ {
    @Field({description: `Unique identifier for the algorithm.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Algorithm name (e.g., AES-256-GCM). Must match the format used in encrypted values.`}) 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true, description: `Description of the algorithm and when to use it.`}) 
    Description?: string;
        
    @Field({description: `Node.js crypto module algorithm identifier (e.g., aes-256-gcm).`}) 
    @MaxLength(50)
    NodeCryptoName: string;
        
    @Field(() => Int, {description: `Required key length in bits (e.g., 256 for AES-256).`}) 
    KeyLengthBits: number;
        
    @Field(() => Int, {description: `Required initialization vector length in bytes (e.g., 12 for GCM, 16 for CBC).`}) 
    IVLengthBytes: number;
        
    @Field(() => Boolean, {description: `Whether this algorithm provides Authenticated Encryption with Associated Data (AEAD). AEAD algorithms like GCM detect tampering.`}) 
    IsAEAD: boolean;
        
    @Field(() => Boolean, {description: `Whether this algorithm is available for use.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEncryptionKey_])
    MJEncryptionKeys_EncryptionAlgorithmIDArray: MJEncryptionKey_[]; // Link to MJEncryptionKeys
    
}

//****************************************************************************
// INPUT TYPE for MJ: Encryption Algorithms
//****************************************************************************
@InputType()
export class CreateMJEncryptionAlgorithmInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    NodeCryptoName?: string;

    @Field(() => Int, { nullable: true })
    KeyLengthBits?: number;

    @Field(() => Int, { nullable: true })
    IVLengthBytes?: number;

    @Field(() => Boolean, { nullable: true })
    IsAEAD?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Encryption Algorithms
//****************************************************************************
@InputType()
export class UpdateMJEncryptionAlgorithmInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    NodeCryptoName?: string;

    @Field(() => Int, { nullable: true })
    KeyLengthBits?: number;

    @Field(() => Int, { nullable: true })
    IVLengthBytes?: number;

    @Field(() => Boolean, { nullable: true })
    IsAEAD?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Encryption Algorithms
//****************************************************************************
@ObjectType()
export class RunMJEncryptionAlgorithmViewResult {
    @Field(() => [MJEncryptionAlgorithm_])
    Results: MJEncryptionAlgorithm_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEncryptionAlgorithm_)
export class MJEncryptionAlgorithmResolver extends ResolverBase {
    @Query(() => RunMJEncryptionAlgorithmViewResult)
    async RunMJEncryptionAlgorithmViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionAlgorithmViewResult)
    async RunMJEncryptionAlgorithmViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionAlgorithmViewResult)
    async RunMJEncryptionAlgorithmDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Encryption Algorithms';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEncryptionAlgorithm_, { nullable: true })
    async MJEncryptionAlgorithm(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEncryptionAlgorithm_ | null> {
        this.CheckUserReadPermissions('MJ: Encryption Algorithms', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEncryptionAlgorithms')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Algorithms', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Encryption Algorithms', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEncryptionKey_])
    async MJEncryptionKeys_EncryptionAlgorithmIDArray(@Root() mjencryptionalgorithm_: MJEncryptionAlgorithm_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Encryption Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEncryptionKeys')} WHERE ${provider.QuoteIdentifier('EncryptionAlgorithmID')}='${mjencryptionalgorithm_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Encryption Keys', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEncryptionAlgorithm_)
    async CreateMJEncryptionAlgorithm(
        @Arg('input', () => CreateMJEncryptionAlgorithmInput) input: CreateMJEncryptionAlgorithmInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Encryption Algorithms', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEncryptionAlgorithm_)
    async UpdateMJEncryptionAlgorithm(
        @Arg('input', () => UpdateMJEncryptionAlgorithmInput) input: UpdateMJEncryptionAlgorithmInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Encryption Algorithms', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEncryptionAlgorithm_)
    async DeleteMJEncryptionAlgorithm(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Encryption Algorithms', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Encryption Key Sources
//****************************************************************************
@ObjectType({ description: `Defines sources for retrieving encryption keys (environment variables, vault services, config files, etc.). Key sources are pluggable providers that implement the EncryptionKeySourceBase class.` })
export class MJEncryptionKeySource_ {
    @Field({description: `Unique identifier for the key source.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name for this key source (e.g., Environment Variable, AWS KMS).`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Human-readable description of this key source and usage instructions.`}) 
    Description?: string;
        
    @Field({description: `TypeScript class name that implements EncryptionKeySourceBase (e.g., EnvVarKeySource).`}) 
    @MaxLength(255)
    DriverClass: string;
        
    @Field({nullable: true, description: `Package path where the driver class is exported (e.g., @memberjunction/encryption).`}) 
    @MaxLength(500)
    DriverImportPath?: string;
        
    @Field({nullable: true, description: `JSON template describing the configuration options for this key source.`}) 
    ConfigTemplate?: string;
        
    @Field(() => Boolean, {description: `Whether this key source is available for use.`}) 
    IsActive: boolean;
        
    @Field({description: `Current status: Active, Inactive, or Deprecated.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEncryptionKey_])
    MJEncryptionKeys_EncryptionKeySourceIDArray: MJEncryptionKey_[]; // Link to MJEncryptionKeys
    
}

//****************************************************************************
// INPUT TYPE for MJ: Encryption Key Sources
//****************************************************************************
@InputType()
export class CreateMJEncryptionKeySourceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    ConfigTemplate: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Encryption Key Sources
//****************************************************************************
@InputType()
export class UpdateMJEncryptionKeySourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    ConfigTemplate?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Encryption Key Sources
//****************************************************************************
@ObjectType()
export class RunMJEncryptionKeySourceViewResult {
    @Field(() => [MJEncryptionKeySource_])
    Results: MJEncryptionKeySource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEncryptionKeySource_)
export class MJEncryptionKeySourceResolver extends ResolverBase {
    @Query(() => RunMJEncryptionKeySourceViewResult)
    async RunMJEncryptionKeySourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionKeySourceViewResult)
    async RunMJEncryptionKeySourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionKeySourceViewResult)
    async RunMJEncryptionKeySourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Encryption Key Sources';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEncryptionKeySource_, { nullable: true })
    async MJEncryptionKeySource(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEncryptionKeySource_ | null> {
        this.CheckUserReadPermissions('MJ: Encryption Key Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEncryptionKeySources')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Key Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Encryption Key Sources', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEncryptionKey_])
    async MJEncryptionKeys_EncryptionKeySourceIDArray(@Root() mjencryptionkeysource_: MJEncryptionKeySource_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Encryption Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEncryptionKeys')} WHERE ${provider.QuoteIdentifier('EncryptionKeySourceID')}='${mjencryptionkeysource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Encryption Keys', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEncryptionKeySource_)
    async CreateMJEncryptionKeySource(
        @Arg('input', () => CreateMJEncryptionKeySourceInput) input: CreateMJEncryptionKeySourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Encryption Key Sources', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEncryptionKeySource_)
    async UpdateMJEncryptionKeySource(
        @Arg('input', () => UpdateMJEncryptionKeySourceInput) input: UpdateMJEncryptionKeySourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Encryption Key Sources', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEncryptionKeySource_)
    async DeleteMJEncryptionKeySource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Encryption Key Sources', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Encryption Keys
//****************************************************************************
@ObjectType({ description: `Defines encryption keys used for field-level encryption. Keys are NOT stored in the database - only references to external key sources. Configure one or more keys and assign them to entity fields.` })
export class MJEncryptionKey_ {
    @Field({description: `Unique identifier for the encryption key configuration.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name for this key (e.g., PII Master Key, API Secrets Key).`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Description of this key purpose and scope.`}) 
    Description?: string;
        
    @Field({description: `References the key source that provides the key material.`}) 
    @MaxLength(36)
    EncryptionKeySourceID: string;
        
    @Field({description: `References the algorithm to use for encryption/decryption.`}) 
    @MaxLength(36)
    EncryptionAlgorithmID: string;
        
    @Field({description: `Source-specific lookup value (e.g., environment variable name, vault path).`}) 
    @MaxLength(500)
    KeyLookupValue: string;
        
    @Field({description: `Version string for key rotation tracking. Incremented during rotation.`}) 
    @MaxLength(20)
    KeyVersion: string;
        
    @Field({description: `Prefix marker for encrypted values (default: $ENC$).`}) 
    @MaxLength(20)
    Marker: string;
        
    @Field(() => Boolean, {description: `Whether this key can be used for new encryption operations.`}) 
    IsActive: boolean;
        
    @Field({description: `Current status: Active, Inactive, Rotating, or Expired.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `When the current key version was activated.`}) 
    ActivatedAt?: Date;
        
    @Field({nullable: true, description: `Optional expiration date. Keys past this date cannot be used for new encryption.`}) 
    ExpiresAt?: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    EncryptionKeySource: string;
        
    @Field() 
    @MaxLength(50)
    EncryptionAlgorithm: string;
        
    @Field(() => [MJEntityField_])
    MJEntityFields_EncryptionKeyIDArray: MJEntityField_[]; // Link to MJEntityFields
    
}

//****************************************************************************
// INPUT TYPE for MJ: Encryption Keys
//****************************************************************************
@InputType()
export class CreateMJEncryptionKeyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EncryptionKeySourceID?: string;

    @Field({ nullable: true })
    EncryptionAlgorithmID?: string;

    @Field({ nullable: true })
    KeyLookupValue?: string;

    @Field({ nullable: true })
    KeyVersion?: string;

    @Field({ nullable: true })
    Marker?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActivatedAt: Date | null;

    @Field({ nullable: true })
    ExpiresAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Encryption Keys
//****************************************************************************
@InputType()
export class UpdateMJEncryptionKeyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EncryptionKeySourceID?: string;

    @Field({ nullable: true })
    EncryptionAlgorithmID?: string;

    @Field({ nullable: true })
    KeyLookupValue?: string;

    @Field({ nullable: true })
    KeyVersion?: string;

    @Field({ nullable: true })
    Marker?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActivatedAt?: Date | null;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Encryption Keys
//****************************************************************************
@ObjectType()
export class RunMJEncryptionKeyViewResult {
    @Field(() => [MJEncryptionKey_])
    Results: MJEncryptionKey_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEncryptionKey_)
export class MJEncryptionKeyResolver extends ResolverBase {
    @Query(() => RunMJEncryptionKeyViewResult)
    async RunMJEncryptionKeyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionKeyViewResult)
    async RunMJEncryptionKeyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionKeyViewResult)
    async RunMJEncryptionKeyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Encryption Keys';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEncryptionKey_, { nullable: true })
    async MJEncryptionKey(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEncryptionKey_ | null> {
        this.CheckUserReadPermissions('MJ: Encryption Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEncryptionKeys')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Encryption Keys', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityField_])
    async MJEntityFields_EncryptionKeyIDArray(@Root() mjencryptionkey_: MJEncryptionKey_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityFields')} WHERE ${provider.QuoteIdentifier('EncryptionKeyID')}='${mjencryptionkey_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEncryptionKey_)
    async CreateMJEncryptionKey(
        @Arg('input', () => CreateMJEncryptionKeyInput) input: CreateMJEncryptionKeyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Encryption Keys', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEncryptionKey_)
    async UpdateMJEncryptionKey(
        @Arg('input', () => UpdateMJEncryptionKeyInput) input: UpdateMJEncryptionKeyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Encryption Keys', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEncryptionKey_)
    async DeleteMJEncryptionKey(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Encryption Keys', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entities
//****************************************************************************
@ObjectType({ description: `Catalog of all entities across all schemas` })
export class MJEntity_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `The canonical, unique name for this entity. For entities in schemas with an EntityNamePrefix configured (e.g., "MJ: " for the core schema), the Name includes the prefix: "MJ: AI Models", "MJ: Users", etc. This is the value used in GetEntityObject(), RunView({ EntityName }), and @RegisterClass decorators. The DisplayName column provides the shorter, UI-friendly alternative without the prefix.`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Optional suffix appended to entity names for display purposes.`}) 
    @MaxLength(255)
    NameSuffix?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the underlying view (first choice) or table (second choice), the Description column in the entity definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field({description: `The underlying database table name for this entity.`}) 
    @MaxLength(255)
    BaseTable: string;
        
    @Field({description: `The "wrapper" database view used for querying this entity with joins and computed fields.`}) 
    @MaxLength(255)
    BaseView: string;
        
    @Field(() => Boolean, {description: `When set to 0, CodeGen no longer generates a base view for the entity.`}) 
    BaseViewGenerated: boolean;
        
    @Field({description: `Database schema containing this entity's table and view.`}) 
    @MaxLength(255)
    SchemaName: string;
        
    @Field(() => Boolean, {description: `Indicates if this is a virtual entity without a physical database table.`}) 
    VirtualEntity: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, changes made via the MemberJunction architecture will result in tracking records being created in the RecordChange table. In addition, when turned on CodeGen will ensure that your table has two fields: __mj_CreatedAt and __mj_UpdatedAt which are special fields used in conjunction with the RecordChange table to track changes to rows in your entity.`}) 
    TrackRecordChanges: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, accessing a record by an end-user will result in an Audit Log record being created`}) 
    AuditRecordAccess: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, users running a view against this entity will result in an Audit Log record being created.`}) 
    AuditViewRuns: boolean;
        
    @Field(() => Boolean, {description: `If set to 0, the entity will not be available at all in the GraphQL API or the object model.`}) 
    IncludeInAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, a GraphQL query will be enabled that allows access to all rows in the entity.`}) 
    AllowAllRowsAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if updates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if creates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowCreateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if deletes are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowDeleteAPI: boolean;
        
    @Field(() => Boolean, {description: `Set to 1 if a custom resolver has been created for the entity.`}) 
    CustomResolverAPI: boolean;
        
    @Field(() => Boolean, {description: `Enabling this bit will result in search being possible at the API and UI layers`}) 
    AllowUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `Whether full-text search indexing is enabled for this entity.`}) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true, description: `Name of the SQL Server full-text catalog if search is enabled.`}) 
    @MaxLength(255)
    FullTextCatalog?: string;
        
    @Field(() => Boolean, {description: `Indicates if the full-text catalog was auto-generated by CodeGen.`}) 
    FullTextCatalogGenerated: boolean;
        
    @Field({nullable: true, description: `Name of the full-text index on this entity's table.`}) 
    @MaxLength(255)
    FullTextIndex?: string;
        
    @Field(() => Boolean, {description: `Indicates if the full-text index was auto-generated by CodeGen.`}) 
    FullTextIndexGenerated: boolean;
        
    @Field({nullable: true, description: `Name of the function used for full-text searching this entity.`}) 
    @MaxLength(255)
    FullTextSearchFunction?: string;
        
    @Field(() => Boolean, {description: `Indicates if the search function was auto-generated by CodeGen.`}) 
    FullTextSearchFunctionGenerated: boolean;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of rows to return in user-created views for this entity.`}) 
    UserViewMaxRows?: number;
        
    @Field({nullable: true, description: `Name of the stored procedure for creating records in this entity.`}) 
    @MaxLength(255)
    spCreate?: string;
        
    @Field({nullable: true, description: `Name of the stored procedure for updating records in this entity.`}) 
    @MaxLength(255)
    spUpdate?: string;
        
    @Field({nullable: true, description: `Name of the stored procedure for deleting records in this entity.`}) 
    @MaxLength(255)
    spDelete?: string;
        
    @Field(() => Boolean, {description: `Indicates if the create procedure was auto-generated by CodeGen.`}) 
    spCreateGenerated: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the update procedure was auto-generated by CodeGen.`}) 
    spUpdateGenerated: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the delete procedure was auto-generated by CodeGen.`}) 
    spDeleteGenerated: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, the deleted spDelete will pre-process deletion to related entities that have 1:M cardinality with this entity. This does not have effect if spDeleteGenerated = 0`}) 
    CascadeDeletes: boolean;
        
    @Field({description: `Hard deletes physically remove rows from the underlying BaseTable. Soft deletes do not remove rows but instead mark the row as deleted by using the special field __mj_DeletedAt which will automatically be added to the entity's basetable by the CodeGen tool.`}) 
    @MaxLength(10)
    DeleteType: string;
        
    @Field(() => Boolean, {description: `This field must be turned on in order to enable merging of records for the entity. For AllowRecordMerge to be turned on, AllowDeleteAPI must be set to 1, and DeleteType must be set to Soft`}) 
    AllowRecordMerge: boolean;
        
    @Field({nullable: true, description: `When specified, this stored procedure is used to find matching records in this particular entity. The convention is to pass in the primary key(s) columns for the given entity to the procedure and the return will be zero to many rows where there is a column for each primary key field(s) and a ProbabilityScore (numeric(1,12)) column that has a 0 to 1 value of the probability of a match.`}) 
    @MaxLength(255)
    spMatch?: string;
        
    @Field({description: `When another entity links to this entity with a foreign key, this is the default component type that will be used in the UI. CodeGen will populate the RelatedEntityDisplayType column in the Entity Fields entity with whatever is provided here whenever a new foreign key is detected by CodeGen. The selection can be overridden on a per-foreign-key basis in each row of the Entity Fields entity.`}) 
    @MaxLength(20)
    RelationshipDefaultDisplayType: string;
        
    @Field(() => Boolean, {description: `Indicates if the default user form was auto-generated for this entity.`}) 
    UserFormGenerated: boolean;
        
    @Field({nullable: true, description: `TypeScript class name for the entity subclass in the codebase.`}) 
    @MaxLength(255)
    EntityObjectSubclassName?: string;
        
    @Field({nullable: true, description: `Import path for the entity subclass in the TypeScript codebase.`}) 
    @MaxLength(255)
    EntityObjectSubclassImport?: string;
        
    @Field({nullable: true, description: `Used to specify a field within the entity that in turn contains the field name that will be used for record-level communication preferences. For example in a hypothetical entity called Contacts, say there is a field called PreferredComm and that field had possible values of Email1, SMS, and Phone, and those value in turn corresponded to field names in the entity. Each record in the Contacts entity could have a specific preference for which field would be used for communication. The MJ Communication Framework will use this information when available, as a priority ahead of the data in the Entity Communication Fields entity which is entity-level and not record-level.`}) 
    @MaxLength(255)
    PreferredCommunicationField?: string;
        
    @Field({nullable: true, description: `Optional, specify an icon (CSS Class) for each entity for display in the UI`}) 
    @MaxLength(500)
    Icon?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional, comma-delimited string indicating the default scope for entity visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for simple defaults for filtering entity visibility, not security enforcement.`}) 
    @MaxLength(100)
    ScopeDefault?: string;
        
    @Field({description: `Determines how entity rows should be packaged for external use. Options include None, Sample, and All. Defaults to None.`}) 
    @MaxLength(20)
    RowsToPackWithSchema: string;
        
    @Field({description: `Defines the sampling method for row packing when RowsToPackWithSchema is set to Sample. Options include random, top n, and bottom n. Defaults to random.`}) 
    @MaxLength(20)
    RowsToPackSampleMethod: string;
        
    @Field(() => Int, {description: `The number of rows to pack when RowsToPackWithSchema is set to Sample, based on the designated sampling method. Defaults to 0.`}) 
    RowsToPackSampleCount: number;
        
    @Field({nullable: true, description: `An optional ORDER BY clause for row packing when RowsToPackWithSchema is set to Sample. Allows custom ordering for selected entity data when using top n and bottom n.`}) 
    RowsToPackSampleOrder?: string;
        
    @Field(() => Int, {nullable: true, description: `Frequency in hours for automatically performing row counts on this entity. If NULL, automatic row counting is disabled. If greater than 0, schedules recurring SELECT COUNT(*) queries at the specified interval.`}) 
    AutoRowCountFrequency?: number;
        
    @Field(() => Int, {nullable: true, description: `Cached row count for this entity, populated by automatic row count processes when AutoRowCountFrequency is configured.`}) 
    RowCount?: number;
        
    @Field({nullable: true, description: `Timestamp indicating when the last automatic row count was performed for this entity.`}) 
    RowCountRunAt?: Date;
        
    @Field({description: `Status of the entity. Active: fully functional; Deprecated: functional but generates console warnings when used; Disabled: not available for use even though metadata and physical table remain.`}) 
    @MaxLength(25)
    Status: string;
        
    @Field({nullable: true, description: `User-friendly display name shown in the Explorer UI and other interfaces. When set, this is used instead of the entity Name for display purposes. Typically contains the entity name without the schema prefix  e.g., "AI Models" when Name is "MJ: AI Models". If NULL, the UI falls back to using the full Name.`}) 
    @MaxLength(255)
    DisplayName?: string;
        
    @Field(() => Boolean, {description: `When false (default), child types are disjoint - a record can only be one child type at a time. When true, a record can simultaneously exist as multiple child types (e.g., a Person can be both a Member and a Volunteer).`}) 
    AllowMultipleSubtypes: boolean;
        
    @Field({nullable: true, description: `Schema-based programmatic code name derived from the entity Name. Uses GetClassNameSchemaPrefix(SchemaName) as the prefix, then strips EntityNamePrefix from the Name and removes spaces. For "__mj" schema with entity "MJ: AI Models", this produces "MJAIModels". For entities in other schemas, the sanitized schema name is prepended. Used in GraphQL type generation and internal code references.`}) 
    CodeName?: string;
        
    @Field({nullable: true, description: `Schema-based programmatic class name used for TypeScript entity classes, Zod schemas, and Angular form components. Computed as GetProgrammaticName(GetClassNameSchemaPrefix(SchemaName) + BaseTable + NameSuffix). The prefix is derived from SchemaName (guaranteed unique by SQL Server), not from EntityNamePrefix. For the core __mj schema, the prefix is "MJ"; for all other schemas it is the alphanumeric-sanitized schema name. This prevents cross-schema collisions and aligns with GraphQL type naming in getGraphQLTypeNameBase().`}) 
    ClassName?: string;
        
    @Field({nullable: true}) 
    BaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ParentEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ParentBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ParentBaseView?: string;
        
    @Field(() => [MJEntityPermission_])
    MJEntityPermissions_EntityIDArray: MJEntityPermission_[]; // Link to MJEntityPermissions
    
    @Field(() => [MJEntityRelationship_])
    MJEntityRelationships_EntityIDArray: MJEntityRelationship_[]; // Link to MJEntityRelationships
    
    @Field(() => [MJEntityField_])
    MJEntityFields_EntityIDArray: MJEntityField_[]; // Link to MJEntityFields
    
    @Field(() => [MJEntityAIAction_])
    MJEntityAIActions_EntityIDArray: MJEntityAIAction_[]; // Link to MJEntityAIActions
    
    @Field(() => [MJUserRecordLog_])
    MJUserRecordLogs_EntityIDArray: MJUserRecordLog_[]; // Link to MJUserRecordLogs
    
    @Field(() => [MJIntegrationURLFormat_])
    MJIntegrationURLFormats_EntityIDArray: MJIntegrationURLFormat_[]; // Link to MJIntegrationURLFormats
    
    @Field(() => [MJEntity_])
    MJEntities_ParentIDArray: MJEntity_[]; // Link to MJEntities
    
    @Field(() => [MJUserFavorite_])
    MJUserFavorites_EntityIDArray: MJUserFavorite_[]; // Link to MJUserFavorites
    
    @Field(() => [MJCompanyIntegrationRunDetail_])
    MJCompanyIntegrationRunDetails_EntityIDArray: MJCompanyIntegrationRunDetail_[]; // Link to MJCompanyIntegrationRunDetails
    
    @Field(() => [MJApplicationEntity_])
    MJApplicationEntities_EntityIDArray: MJApplicationEntity_[]; // Link to MJApplicationEntities
    
    @Field(() => [MJUserApplicationEntity_])
    MJUserApplicationEntities_EntityIDArray: MJUserApplicationEntity_[]; // Link to MJUserApplicationEntities
    
    @Field(() => [MJList_])
    MJLists_EntityIDArray: MJList_[]; // Link to MJLists
    
    @Field(() => [MJUserView_])
    MJUserViews_EntityIDArray: MJUserView_[]; // Link to MJUserViews
    
    @Field(() => [MJRecordChange_])
    MJRecordChanges_EntityIDArray: MJRecordChange_[]; // Link to MJRecordChanges
    
    @Field(() => [MJAuditLog_])
    MJAuditLogs_EntityIDArray: MJAuditLog_[]; // Link to MJAuditLogs
    
    @Field(() => [MJResourceType_])
    MJResourceTypes_EntityIDArray: MJResourceType_[]; // Link to MJResourceTypes
    
    @Field(() => [MJTaggedItem_])
    MJTaggedItems_EntityIDArray: MJTaggedItem_[]; // Link to MJTaggedItems
    
    @Field(() => [MJDatasetItem_])
    MJDatasetItems_EntityIDArray: MJDatasetItem_[]; // Link to MJDatasetItems
    
    @Field(() => [MJCompanyIntegrationRecordMap_])
    MJCompanyIntegrationRecordMaps_EntityIDArray: MJCompanyIntegrationRecordMap_[]; // Link to MJCompanyIntegrationRecordMaps
    
    @Field(() => [MJRecordMergeLog_])
    MJRecordMergeLogs_EntityIDArray: MJRecordMergeLog_[]; // Link to MJRecordMergeLogs
    
    @Field(() => [MJQueryField_])
    MJQueryFields_SourceEntityIDArray: MJQueryField_[]; // Link to MJQueryFields
    
    @Field(() => [MJConversation_])
    MJConversations_LinkedEntityIDArray: MJConversation_[]; // Link to MJConversations
    
    @Field(() => [MJEntityDocument_])
    MJEntityDocuments_EntityIDArray: MJEntityDocument_[]; // Link to MJEntityDocuments
    
    @Field(() => [MJDataContextItem_])
    MJDataContextItems_EntityIDArray: MJDataContextItem_[]; // Link to MJDataContextItems
    
    @Field(() => [MJUser_])
    MJUsers_LinkedEntityIDArray: MJUser_[]; // Link to MJUsers
    
    @Field(() => [MJEntityRecordDocument_])
    MJEntityRecordDocuments_EntityIDArray: MJEntityRecordDocument_[]; // Link to MJEntityRecordDocuments
    
    @Field(() => [MJFileEntityRecordLink_])
    MJFileEntityRecordLinks_EntityIDArray: MJFileEntityRecordLink_[]; // Link to MJFileEntityRecordLinks
    
    @Field(() => [MJUserViewCategory_])
    MJUserViewCategories_EntityIDArray: MJUserViewCategory_[]; // Link to MJUserViewCategories
    
    @Field(() => [MJEntitySetting_])
    MJEntitySettings_EntityIDArray: MJEntitySetting_[]; // Link to MJEntitySettings
    
    @Field(() => [MJDuplicateRun_])
    MJDuplicateRuns_EntityIDArray: MJDuplicateRun_[]; // Link to MJDuplicateRuns
    
    @Field(() => [MJEntityAction_])
    MJEntityActions_EntityIDArray: MJEntityAction_[]; // Link to MJEntityActions
    
    @Field(() => [MJTemplateParam_])
    MJTemplateParams_EntityIDArray: MJTemplateParam_[]; // Link to MJTemplateParams
    
    @Field(() => [MJRecommendation_])
    MJRecommendations_SourceEntityIDArray: MJRecommendation_[]; // Link to MJRecommendations
    
    @Field(() => [MJRecommendationItem_])
    MJRecommendationItems_DestinationEntityIDArray: MJRecommendationItem_[]; // Link to MJRecommendationItems
    
    @Field(() => [MJEntityCommunicationMessageType_])
    MJEntityCommunicationMessageTypes_EntityIDArray: MJEntityCommunicationMessageType_[]; // Link to MJEntityCommunicationMessageTypes
    
    @Field(() => [MJQueryEntity_])
    MJQueryEntities_EntityIDArray: MJQueryEntity_[]; // Link to MJQueryEntities
    
    @Field(() => [MJAccessControlRule_])
    MJAccessControlRules_EntityIDArray: MJAccessControlRule_[]; // Link to MJAccessControlRules
    
    @Field(() => [MJRecordLink_])
    MJRecordLinks_SourceEntityIDArray: MJRecordLink_[]; // Link to MJRecordLinks
    
    @Field(() => [MJAIAgentExample_])
    MJAIAgentExamples_PrimaryScopeEntityIDArray: MJAIAgentExample_[]; // Link to MJAIAgentExamples
    
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_PrimaryScopeEntityIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
    @Field(() => [MJVersionLabel_])
    MJVersionLabels_EntityIDArray: MJVersionLabel_[]; // Link to MJVersionLabels
    
    @Field(() => [MJVersionLabelItem_])
    MJVersionLabelItems_EntityIDArray: MJVersionLabelItem_[]; // Link to MJVersionLabelItems
    
    @Field(() => [MJGeneratedCode_])
    MJGeneratedCodes_LinkedEntityIDArray: MJGeneratedCode_[]; // Link to MJGeneratedCodes
    
    @Field(() => [MJRecordLink_])
    MJRecordLinks_TargetEntityIDArray: MJRecordLink_[]; // Link to MJRecordLinks
    
    @Field(() => [MJTestRun_])
    MJTestRuns_TargetLogEntityIDArray: MJTestRun_[]; // Link to MJTestRuns
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_PrimaryScopeEntityIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Entities
//****************************************************************************
@InputType()
export class CreateMJEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate: string | null;

    @Field({ nullable: true })
    spUpdate: string | null;

    @Field({ nullable: true })
    spDelete: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder: string | null;

    @Field(() => Int, { nullable: true })
    AutoRowCountFrequency: number | null;

    @Field(() => Int, { nullable: true })
    RowCount: number | null;

    @Field({ nullable: true })
    RowCountRunAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field(() => Boolean, { nullable: true })
    AllowMultipleSubtypes?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entities
//****************************************************************************
@InputType()
export class UpdateMJEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate?: string | null;

    @Field({ nullable: true })
    spUpdate?: string | null;

    @Field({ nullable: true })
    spDelete?: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch?: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName?: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport?: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder?: string | null;

    @Field(() => Int, { nullable: true })
    AutoRowCountFrequency?: number | null;

    @Field(() => Int, { nullable: true })
    RowCount?: number | null;

    @Field({ nullable: true })
    RowCountRunAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field(() => Boolean, { nullable: true })
    AllowMultipleSubtypes?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entities
//****************************************************************************
@ObjectType()
export class RunMJEntityViewResult {
    @Field(() => [MJEntity_])
    Results: MJEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntity_)
export class MJEntityResolverBase extends ResolverBase {
    @Query(() => RunMJEntityViewResult)
    async RunMJEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityViewResult)
    async RunMJEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityViewResult)
    async RunMJEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntity_, { nullable: true })
    async MJEntity(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntity_ | null> {
        this.CheckUserReadPermissions('MJ: Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntities')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntity_])
    async AllMJEntities(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntities')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entities', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityPermission_])
    async MJEntityPermissions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityPermissions')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityRelationship_])
    async MJEntityRelationships_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRelationships')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityField_])
    async MJEntityFields_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityFields')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async MJEntityAIActions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityAIActions')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserRecordLog_])
    async MJUserRecordLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserRecordLogs')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Record Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJIntegrationURLFormat_])
    async MJIntegrationURLFormats_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwIntegrationURLFormats')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Integration URL Formats', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntity_])
    async MJEntities_ParentIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntities')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserFavorite_])
    async MJUserFavorites_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserFavorites')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Favorites', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRunDetail_])
    async MJCompanyIntegrationRunDetails_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRunDetails')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integration Run Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJApplicationEntity_])
    async MJApplicationEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwApplicationEntities')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Application Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserApplicationEntity_])
    async MJUserApplicationEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserApplicationEntities')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Application Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async MJLists_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwLists')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Lists', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async MJUserViews_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViews')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Views', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async MJRecordChanges_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordChanges')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Changes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async MJAuditLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogs')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Audit Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourceType_])
    async MJResourceTypes_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Resource Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourceTypes')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Resource Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTaggedItem_])
    async MJTaggedItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTaggedItems')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tagged Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDatasetItem_])
    async MJDatasetItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDatasetItems')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dataset Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRecordMap_])
    async MJCompanyIntegrationRecordMaps_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRecordMaps')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integration Record Maps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordMergeLog_])
    async MJRecordMergeLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordMergeLogs')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Merge Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryField_])
    async MJQueryFields_SourceEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryFields')} WHERE ${provider.QuoteIdentifier('SourceEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async MJConversations_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversations')} WHERE ${provider.QuoteIdentifier('LinkedEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async MJEntityDocuments_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocuments')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async MJDataContextItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDataContextItems')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Data Context Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUser_])
    async MJUsers_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUsers')} WHERE ${provider.QuoteIdentifier('LinkedEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Users', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityRecordDocument_])
    async MJEntityRecordDocuments_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRecordDocuments')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Record Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJFileEntityRecordLink_])
    async MJFileEntityRecordLinks_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileEntityRecordLinks')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: File Entity Record Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserViewCategory_])
    async MJUserViewCategories_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewCategories')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User View Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntitySetting_])
    async MJEntitySettings_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntitySettings')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Settings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async MJDuplicateRuns_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRuns')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Duplicate Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAction_])
    async MJEntityActions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActions')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplateParam_])
    async MJTemplateParams_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateParams')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Template Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecommendation_])
    async MJRecommendations_SourceEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendations')} WHERE ${provider.QuoteIdentifier('SourceEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Recommendations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecommendationItem_])
    async MJRecommendationItems_DestinationEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendationItems')} WHERE ${provider.QuoteIdentifier('DestinationEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Recommendation Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityCommunicationMessageType_])
    async MJEntityCommunicationMessageTypes_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityCommunicationMessageTypes')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Communication Message Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryEntity_])
    async MJQueryEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryEntities')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAccessControlRule_])
    async MJAccessControlRules_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Access Control Rules', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAccessControlRules')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Access Control Rules', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Access Control Rules', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordLink_])
    async MJRecordLinks_SourceEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordLinks')} WHERE ${provider.QuoteIdentifier('SourceEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJAIAgentExamples_PrimaryScopeEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('PrimaryScopeEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_PrimaryScopeEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('PrimaryScopeEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabel_])
    async MJVersionLabels_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Labels', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabels')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Labels', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Labels', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabelItem_])
    async MJVersionLabelItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabelItems')} WHERE ${provider.QuoteIdentifier('EntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async MJGeneratedCodes_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwGeneratedCodes')} WHERE ${provider.QuoteIdentifier('LinkedEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Generated Codes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordLink_])
    async MJRecordLinks_TargetEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordLinks')} WHERE ${provider.QuoteIdentifier('TargetEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestRun_])
    async MJTestRuns_TargetLogEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRuns')} WHERE ${provider.QuoteIdentifier('TargetLogEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_PrimaryScopeEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('PrimaryScopeEntityID')}='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntity_)
    async CreateMJEntity(
        @Arg('input', () => CreateMJEntityInput) input: CreateMJEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntity_)
    async UpdateMJEntity(
        @Arg('input', () => UpdateMJEntityInput) input: UpdateMJEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntity_)
    async DeleteMJEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Action Filters
//****************************************************************************
@ObjectType({ description: `Optional use. Maps Action Filters to specific EntityAction instances, specifying execution order and status. This allows for pre-processing before an Action actually is fired off, to check for various state/dirty/value conditions.` })
export class MJEntityActionFilter_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(36)
    ActionFilterID: string;
        
    @Field(() => Int, {description: `Order of filter execution.`}) 
    Sequence: number;
        
    @Field({description: `Status of the entity action filter (Pending, Active, Disabled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(425)
    EntityAction: string;
        
    @Field() 
    ActionFilter: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Action Filters
//****************************************************************************
@InputType()
export class CreateMJEntityActionFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Action Filters
//****************************************************************************
@InputType()
export class UpdateMJEntityActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Action Filters
//****************************************************************************
@ObjectType()
export class RunMJEntityActionFilterViewResult {
    @Field(() => [MJEntityActionFilter_])
    Results: MJEntityActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionFilter_)
export class MJEntityActionFilterResolver extends ResolverBase {
    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Action Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionFilter_, { nullable: true })
    async MJEntityActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionFilter_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionFilters')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Action Filters', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityActionFilter_)
    async CreateMJEntityActionFilter(
        @Arg('input', () => CreateMJEntityActionFilterInput) input: CreateMJEntityActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Action Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionFilter_)
    async UpdateMJEntityActionFilter(
        @Arg('input', () => UpdateMJEntityActionFilterInput) input: UpdateMJEntityActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Action Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionFilter_)
    async DeleteMJEntityActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Action Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Action Invocation Types
//****************************************************************************
@ObjectType({ description: `Stores the possible invocation types of an action within the context of an entity. Examples would be: Record Created/Updated/Deleted/Accessed as well as things like View or List where you could run an EntityAction against an entire set of records in a view or list  either by user click or programmatically.` })
export class MJEntityActionInvocationType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Name of the invocation type such as Record Created/Updated/etc.`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of the invocation type.`}) 
    Description?: string;
        
    @Field(() => Int, {description: `Order in which this invocation type appears in UI lists and menus.`}) 
    DisplaySequence: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityActionInvocation_])
    MJEntityActionInvocations_InvocationTypeIDArray: MJEntityActionInvocation_[]; // Link to MJEntityActionInvocations
    
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Action Invocation Types
//****************************************************************************
@InputType()
export class CreateMJEntityActionInvocationTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Action Invocation Types
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInvocationTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Action Invocation Types
//****************************************************************************
@ObjectType()
export class RunMJEntityActionInvocationTypeViewResult {
    @Field(() => [MJEntityActionInvocationType_])
    Results: MJEntityActionInvocationType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionInvocationType_)
export class MJEntityActionInvocationTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Action Invocation Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionInvocationType_, { nullable: true })
    async MJEntityActionInvocationType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionInvocationType_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Action Invocation Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionInvocationTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Invocation Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Action Invocation Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionInvocation_])
    async MJEntityActionInvocations_InvocationTypeIDArray(@Root() mjentityactioninvocationtype_: MJEntityActionInvocationType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionInvocations')} WHERE ${provider.QuoteIdentifier('InvocationTypeID')}='${mjentityactioninvocationtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Action Invocations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityActionInvocationType_)
    async CreateMJEntityActionInvocationType(
        @Arg('input', () => CreateMJEntityActionInvocationTypeInput) input: CreateMJEntityActionInvocationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Action Invocation Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionInvocationType_)
    async UpdateMJEntityActionInvocationType(
        @Arg('input', () => UpdateMJEntityActionInvocationTypeInput) input: UpdateMJEntityActionInvocationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Action Invocation Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionInvocationType_)
    async DeleteMJEntityActionInvocationType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Action Invocation Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Action Invocations
//****************************************************************************
@ObjectType({ description: `Links invocation types to entity actions  for example you might link a particular EntityAction to just Create Record and you might also have a second item in this table allowing the same Entity Action to be invoked from a User View or List, on demand.` })
export class MJEntityActionInvocation_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(36)
    InvocationTypeID: string;
        
    @Field({description: `Status of the entity action invocation (Pending, Active, Disabled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(425)
    EntityAction: string;
        
    @Field() 
    @MaxLength(255)
    InvocationType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Action Invocations
//****************************************************************************
@InputType()
export class CreateMJEntityActionInvocationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Action Invocations
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInvocationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Action Invocations
//****************************************************************************
@ObjectType()
export class RunMJEntityActionInvocationViewResult {
    @Field(() => [MJEntityActionInvocation_])
    Results: MJEntityActionInvocation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionInvocation_)
export class MJEntityActionInvocationResolver extends ResolverBase {
    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Action Invocations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionInvocation_, { nullable: true })
    async MJEntityActionInvocation(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionInvocation_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionInvocations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Action Invocations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityActionInvocation_)
    async CreateMJEntityActionInvocation(
        @Arg('input', () => CreateMJEntityActionInvocationInput) input: CreateMJEntityActionInvocationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Action Invocations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionInvocation_)
    async UpdateMJEntityActionInvocation(
        @Arg('input', () => UpdateMJEntityActionInvocationInput) input: UpdateMJEntityActionInvocationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Action Invocations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionInvocation_)
    async DeleteMJEntityActionInvocation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Action Invocations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Action Params
//****************************************************************************
@ObjectType({ description: `Stores paramater mappings to enable Entity Actions to automatically invoke Actions` })
export class MJEntityActionParam_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(36)
    ActionParamID: string;
        
    @Field({description: `Type of the value, which can be Static, Entity Object, or Script.`}) 
    @MaxLength(20)
    ValueType: string;
        
    @Field({nullable: true, description: `Value of the parameter, used only when ValueType is Static or Script. When value is Script, any valid JavaScript code can be provided. The script will have access to an object called EntityActionContext. This object will have a property called EntityObject on it that will contain the BaseEntity derived sub-class with the current data for the entity object this action is operating against. The script must provide the parameter value to the EntityActionContext.result property. This scripting capabilty is designed for very small and simple code, for anything of meaningful complexity, create a sub-class instead.`}) 
    Value?: string;
        
    @Field({nullable: true, description: `Additional comments regarding the parameter.`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(425)
    EntityAction: string;
        
    @Field() 
    @MaxLength(255)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Action Params
//****************************************************************************
@InputType()
export class CreateMJEntityActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Action Params
//****************************************************************************
@InputType()
export class UpdateMJEntityActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Action Params
//****************************************************************************
@ObjectType()
export class RunMJEntityActionParamViewResult {
    @Field(() => [MJEntityActionParam_])
    Results: MJEntityActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionParam_)
export class MJEntityActionParamResolver extends ResolverBase {
    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionParam_, { nullable: true })
    async MJEntityActionParam(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionParam_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionParams')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Action Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityActionParam_)
    async CreateMJEntityActionParam(
        @Arg('input', () => CreateMJEntityActionParamInput) input: CreateMJEntityActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionParam_)
    async UpdateMJEntityActionParam(
        @Arg('input', () => UpdateMJEntityActionParamInput) input: UpdateMJEntityActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionParam_)
    async DeleteMJEntityActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Actions
//****************************************************************************
@ObjectType({ description: `Links entities to actions - this is the main place where you define the actions that part of, or available, for a given entity.` })
export class MJEntityAction_ {
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(36)
    ActionID: string;
        
    @Field({description: `Status of the entity action (Pending, Active, Disabled).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(425)
    Action: string;
        
    @Field(() => [MJEntityActionInvocation_])
    MJEntityActionInvocations_EntityActionIDArray: MJEntityActionInvocation_[]; // Link to MJEntityActionInvocations
    
    @Field(() => [MJEntityActionFilter_])
    MJEntityActionFilters_EntityActionIDArray: MJEntityActionFilter_[]; // Link to MJEntityActionFilters
    
    @Field(() => [MJEntityActionParam_])
    MJEntityActionParams_EntityActionIDArray: MJEntityActionParam_[]; // Link to MJEntityActionParams
    
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Actions
//****************************************************************************
@InputType()
export class CreateMJEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Actions
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Actions
//****************************************************************************
@ObjectType()
export class RunMJEntityActionViewResult {
    @Field(() => [MJEntityAction_])
    Results: MJEntityAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityAction_)
export class MJEntityActionResolver extends ResolverBase {
    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityAction_, { nullable: true })
    async MJEntityAction(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityAction_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionInvocation_])
    async MJEntityActionInvocations_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionInvocations')} WHERE ${provider.QuoteIdentifier('EntityActionID')}='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Action Invocations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityActionFilter_])
    async MJEntityActionFilters_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionFilters')} WHERE ${provider.QuoteIdentifier('EntityActionID')}='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Action Filters', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityActionParam_])
    async MJEntityActionParams_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityActionParams')} WHERE ${provider.QuoteIdentifier('EntityActionID')}='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityAction_)
    async CreateMJEntityAction(
        @Arg('input', () => CreateMJEntityActionInput) input: CreateMJEntityActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityAction_)
    async UpdateMJEntityAction(
        @Arg('input', () => UpdateMJEntityActionInput) input: UpdateMJEntityActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityAction_)
    async DeleteMJEntityAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity AI Actions
//****************************************************************************
@ObjectType({ description: `Tracks the AI actions that should be invoked based on changes to records within a given entity.` })
export class MJEntityAIAction_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(36)
    AIModelID: string;
        
    @Field() 
    @MaxLength(36)
    AIActionID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `The AI prompt template used when this action is triggered by entity changes.`}) 
    Prompt?: string;
        
    @Field({description: `The entity event that triggers this AI action (After Save, Before Delete, etc.).`}) 
    @MaxLength(15)
    TriggerEvent: string;
        
    @Field({description: `Message shown to users when this AI action is executed.`}) 
    UserMessage: string;
        
    @Field({description: `Where the AI output should be stored (Field, Message, File).`}) 
    @MaxLength(10)
    OutputType: string;
        
    @Field({nullable: true, description: `The field name where AI output should be stored if OutputType is Field.`}) 
    @MaxLength(50)
    OutputField?: string;
        
    @Field(() => Boolean, {description: `Whether to skip AI processing if the output field already contains data.`}) 
    SkipIfOutputFieldNotEmpty: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    OutputEntityID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(50)
    AIModel: string;
        
    @Field() 
    @MaxLength(50)
    AIAction: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    OutputEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity AI Actions
//****************************************************************************
@InputType()
export class CreateMJEntityAIActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity AI Actions
//****************************************************************************
@InputType()
export class UpdateMJEntityAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField?: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity AI Actions
//****************************************************************************
@ObjectType()
export class RunMJEntityAIActionViewResult {
    @Field(() => [MJEntityAIAction_])
    Results: MJEntityAIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityAIAction_)
export class MJEntityAIActionResolver extends ResolverBase {
    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity AI Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityAIAction_, { nullable: true })
    async MJEntityAIAction(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityAIAction_ | null> {
        this.CheckUserReadPermissions('MJ: Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityAIActions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity AI Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityAIAction_])
    async AllMJEntityAIActions(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityAIActions')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityAIAction_)
    async CreateMJEntityAIAction(
        @Arg('input', () => CreateMJEntityAIActionInput) input: CreateMJEntityAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity AI Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityAIAction_)
    async UpdateMJEntityAIAction(
        @Arg('input', () => UpdateMJEntityAIActionInput) input: UpdateMJEntityAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity AI Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityAIAction_)
    async DeleteMJEntityAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity AI Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Communication Fields
//****************************************************************************
@ObjectType({ description: `Mapping between entity fields and communication base message types with priority` })
export class MJEntityCommunicationField_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityCommunicationMessageTypeID: string;
        
    @Field({description: `Name of the field in the entity that maps to the communication base message type`}) 
    @MaxLength(500)
    FieldName: string;
        
    @Field(() => Int, {description: `Priority of the field for the communication base message type`}) 
    Priority: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    EntityCommunicationMessageType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Communication Fields
//****************************************************************************
@InputType()
export class CreateMJEntityCommunicationFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Communication Fields
//****************************************************************************
@InputType()
export class UpdateMJEntityCommunicationFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Communication Fields
//****************************************************************************
@ObjectType()
export class RunMJEntityCommunicationFieldViewResult {
    @Field(() => [MJEntityCommunicationField_])
    Results: MJEntityCommunicationField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityCommunicationField_)
export class MJEntityCommunicationFieldResolver extends ResolverBase {
    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Communication Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityCommunicationField_, { nullable: true })
    async MJEntityCommunicationField(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityCommunicationField_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Communication Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityCommunicationFields')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Communication Fields', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityCommunicationField_)
    async CreateMJEntityCommunicationField(
        @Arg('input', () => CreateMJEntityCommunicationFieldInput) input: CreateMJEntityCommunicationFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Communication Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityCommunicationField_)
    async UpdateMJEntityCommunicationField(
        @Arg('input', () => UpdateMJEntityCommunicationFieldInput) input: UpdateMJEntityCommunicationFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Communication Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityCommunicationField_)
    async DeleteMJEntityCommunicationField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Communication Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Communication Message Types
//****************************************************************************
@ObjectType({ description: `Mapping between entities and communication base message types` })
export class MJEntityCommunicationMessageType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(36)
    BaseMessageTypeID: string;
        
    @Field(() => Boolean, {description: `Indicates whether the message type is active`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    BaseMessageType: string;
        
    @Field(() => [MJEntityCommunicationField_])
    MJEntityCommunicationFields_EntityCommunicationMessageTypeIDArray: MJEntityCommunicationField_[]; // Link to MJEntityCommunicationFields
    
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Communication Message Types
//****************************************************************************
@InputType()
export class CreateMJEntityCommunicationMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Communication Message Types
//****************************************************************************
@InputType()
export class UpdateMJEntityCommunicationMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Communication Message Types
//****************************************************************************
@ObjectType()
export class RunMJEntityCommunicationMessageTypeViewResult {
    @Field(() => [MJEntityCommunicationMessageType_])
    Results: MJEntityCommunicationMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityCommunicationMessageType_)
export class MJEntityCommunicationMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Communication Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityCommunicationMessageType_, { nullable: true })
    async MJEntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityCommunicationMessageType_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityCommunicationMessageTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Communication Message Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityCommunicationField_])
    async MJEntityCommunicationFields_EntityCommunicationMessageTypeIDArray(@Root() mjentitycommunicationmessagetype_: MJEntityCommunicationMessageType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Communication Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityCommunicationFields')} WHERE ${provider.QuoteIdentifier('EntityCommunicationMessageTypeID')}='${mjentitycommunicationmessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Communication Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityCommunicationMessageType_)
    async CreateMJEntityCommunicationMessageType(
        @Arg('input', () => CreateMJEntityCommunicationMessageTypeInput) input: CreateMJEntityCommunicationMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Communication Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityCommunicationMessageType_)
    async UpdateMJEntityCommunicationMessageType(
        @Arg('input', () => UpdateMJEntityCommunicationMessageTypeInput) input: UpdateMJEntityCommunicationMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Communication Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityCommunicationMessageType_)
    async DeleteMJEntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Communication Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Document Runs
//****************************************************************************
@ObjectType({ description: `Records execution history of document generation processes for entity records, tracking status, timing, and output details.` })
export class MJEntityDocumentRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityDocumentID: string;
        
    @Field({nullable: true}) 
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    EndedAt?: Date;
        
    @Field({description: `Can be Pending, In Progress, Completed, or Failed`}) 
    @MaxLength(15)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(250)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Document Runs
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Document Runs
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Document Runs
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentRunViewResult {
    @Field(() => [MJEntityDocumentRun_])
    Results: MJEntityDocumentRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentRun_)
export class MJEntityDocumentRunResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Document Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentRun_, { nullable: true })
    async MJEntityDocumentRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentRun_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Document Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocumentRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Document Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityDocumentRun_)
    async CreateMJEntityDocumentRun(
        @Arg('input', () => CreateMJEntityDocumentRunInput) input: CreateMJEntityDocumentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Document Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentRun_)
    async UpdateMJEntityDocumentRun(
        @Arg('input', () => UpdateMJEntityDocumentRunInput) input: UpdateMJEntityDocumentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Document Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocumentRun_)
    async DeleteMJEntityDocumentRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Document Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Document Settings
//****************************************************************************
@ObjectType({ description: `Stores configuration for entity-specific document generation.` })
export class MJEntityDocumentSetting_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityDocumentID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `JSON configuration value for this document generation setting.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(250)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Document Settings
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Document Settings
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Document Settings
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentSettingViewResult {
    @Field(() => [MJEntityDocumentSetting_])
    Results: MJEntityDocumentSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentSetting_)
export class MJEntityDocumentSettingResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Document Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentSetting_, { nullable: true })
    async MJEntityDocumentSetting(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentSetting_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Document Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocumentSettings')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Document Settings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityDocumentSetting_)
    async CreateMJEntityDocumentSetting(
        @Arg('input', () => CreateMJEntityDocumentSettingInput) input: CreateMJEntityDocumentSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Document Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentSetting_)
    async UpdateMJEntityDocumentSetting(
        @Arg('input', () => UpdateMJEntityDocumentSettingInput) input: UpdateMJEntityDocumentSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Document Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocumentSetting_)
    async DeleteMJEntityDocumentSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Document Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Document Types
//****************************************************************************
@ObjectType({ description: `Defines types of documents that can be generated from entity data.` })
export class MJEntityDocumentType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityDocument_])
    MJEntityDocuments_TypeIDArray: MJEntityDocument_[]; // Link to MJEntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Document Types
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Document Types
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Document Types
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentTypeViewResult {
    @Field(() => [MJEntityDocumentType_])
    Results: MJEntityDocumentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentType_)
export class MJEntityDocumentTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Document Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentType_, { nullable: true })
    async MJEntityDocumentType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentType_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Document Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocumentTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Document Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Document Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityDocument_])
    async MJEntityDocuments_TypeIDArray(@Root() mjentitydocumenttype_: MJEntityDocumentType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocuments')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjentitydocumenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityDocumentType_)
    async CreateMJEntityDocumentType(
        @Arg('input', () => CreateMJEntityDocumentTypeInput) input: CreateMJEntityDocumentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Document Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentType_)
    async UpdateMJEntityDocumentType(
        @Arg('input', () => UpdateMJEntityDocumentTypeInput) input: UpdateMJEntityDocumentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Document Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocumentType_)
    async DeleteMJEntityDocumentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Document Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Documents
//****************************************************************************
@ObjectType({ description: `Stores templates for converting structured entity data into unstructured documents.` })
export class MJEntityDocument_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(250)
    Name: string;
        
    @Field() 
    @MaxLength(36)
    TypeID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(36)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(15)
    Status: string;
        
    @Field() 
    @MaxLength(36)
    TemplateID: string;
        
    @Field() 
    @MaxLength(36)
    AIModelID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered a potential matching record. Value must be <= AbsoluteMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    PotentialMatchThreshold: number;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered an absolute matching record. Value must be >= PotentialMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    AbsoluteMatchThreshold: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(255)
    Template: string;
        
    @Field() 
    @MaxLength(50)
    AIModel: string;
        
    @Field(() => [MJEntityDocumentRun_])
    MJEntityDocumentRuns_EntityDocumentIDArray: MJEntityDocumentRun_[]; // Link to MJEntityDocumentRuns
    
    @Field(() => [MJEntityDocumentSetting_])
    MJEntityDocumentSettings_EntityDocumentIDArray: MJEntityDocumentSetting_[]; // Link to MJEntityDocumentSettings
    
    @Field(() => [MJEntityRecordDocument_])
    MJEntityRecordDocuments_EntityDocumentIDArray: MJEntityRecordDocument_[]; // Link to MJEntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Documents
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Documents
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Documents
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentViewResult {
    @Field(() => [MJEntityDocument_])
    Results: MJEntityDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocument_)
export class MJEntityDocumentResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Documents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocument_, { nullable: true })
    async MJEntityDocument(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocument_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocuments')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Documents', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityDocumentRun_])
    async MJEntityDocumentRuns_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Document Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocumentRuns')} WHERE ${provider.QuoteIdentifier('EntityDocumentID')}='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Document Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocumentSetting_])
    async MJEntityDocumentSettings_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Document Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocumentSettings')} WHERE ${provider.QuoteIdentifier('EntityDocumentID')}='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Document Settings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityRecordDocument_])
    async MJEntityRecordDocuments_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRecordDocuments')} WHERE ${provider.QuoteIdentifier('EntityDocumentID')}='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Record Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityDocument_)
    async CreateMJEntityDocument(
        @Arg('input', () => CreateMJEntityDocumentInput) input: CreateMJEntityDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Documents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocument_)
    async UpdateMJEntityDocument(
        @Arg('input', () => UpdateMJEntityDocumentInput) input: UpdateMJEntityDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Documents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocument_)
    async DeleteMJEntityDocument(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Documents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Field Values
//****************************************************************************
@ObjectType({ description: `Defines allowed values for entity fields with value lists, supporting dropdowns, validations, and data integrity constraints. MJ CodeGen automatically maintains this for columns that have CHECK constraints with IN lists such as "Status IN (A, B, C)"` })
export class MJEntityFieldValue_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityFieldID: string;
        
    @Field(() => Int, {description: `Display order for this value in dropdown lists and UI elements.`}) 
    Sequence: number;
        
    @Field({description: `The actual value stored in the database for this option.`}) 
    @MaxLength(255)
    Value: string;
        
    @Field({nullable: true, description: `Optional code identifier for this value, useful for programmatic access. If not specified, same as Value`}) 
    @MaxLength(50)
    Code?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    EntityField: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Field Values
//****************************************************************************
@InputType()
export class CreateMJEntityFieldValueInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityFieldID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Field Values
//****************************************************************************
@InputType()
export class UpdateMJEntityFieldValueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityFieldID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Field Values
//****************************************************************************
@ObjectType()
export class RunMJEntityFieldValueViewResult {
    @Field(() => [MJEntityFieldValue_])
    Results: MJEntityFieldValue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityFieldValue_)
export class MJEntityFieldValueResolver extends ResolverBase {
    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Field Values';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityFieldValue_, { nullable: true })
    async MJEntityFieldValue(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityFieldValue_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityFieldValues')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Field Values', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityFieldValue_])
    async AllMJEntityFieldValues(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityFieldValues')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Field Values', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Field Values', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityFieldValue_)
    async CreateMJEntityFieldValue(
        @Arg('input', () => CreateMJEntityFieldValueInput) input: CreateMJEntityFieldValueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Field Values', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityFieldValue_)
    async UpdateMJEntityFieldValue(
        @Arg('input', () => UpdateMJEntityFieldValueInput) input: UpdateMJEntityFieldValueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Field Values', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityFieldValue_)
    async DeleteMJEntityFieldValue(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Field Values', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Fields
//****************************************************************************
@ObjectType({ description: `List of all fields within each entity with metadata about each field` })
export class MJEntityField_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of the field within the entity`}) 
    Sequence: number;
        
    @Field({description: `Name of the field within the database table`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `A user friendly alternative to the field name`}) 
    @MaxLength(255)
    DisplayName?: string;
        
    @Field({nullable: true, description: `Descriptive text explaining the purpose of the field`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the column within the underlying view (first choice) or table (second choice), the Description column in the entity field definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity field definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field is part of the primary key for the entity (auto maintained by CodeGen)`}) 
    IsPrimaryKey: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field must have unique values within the entity.`}) 
    IsUnique: boolean;
        
    @Field({nullable: true, description: `Used for generating custom tabs in the generated forms, only utilized if GeneratedFormSection=Category`}) 
    @MaxLength(255)
    Category?: string;
        
    @Field({description: `SQL Data type (auto maintained by CodeGen)`}) 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Int, {nullable: true, description: `SQL data length (auto maintained by CodeGen)`}) 
    Length?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL precision (auto maintained by CodeGen)`}) 
    Precision?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL scale (auto maintained by CodeGen)`}) 
    Scale?: number;
        
    @Field(() => Boolean, {description: `Does the column allow null or not (auto maintained by CodeGen)`}) 
    AllowsNull: boolean;
        
    @Field({nullable: true, description: `If a default value is defined for the field it is stored here (auto maintained by CodeGen)`}) 
    @MaxLength(255)
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `If this field automatically increments within the table, this field is set to 1 (auto maintained by CodeGen)`}) 
    AutoIncrement: boolean;
        
    @Field({description: `Possible Values of None, List, ListOrUserEntry - the last option meaning that the list of possible values are options, but a user can enter anything else desired too.`}) 
    @MaxLength(20)
    ValueListType: string;
        
    @Field({nullable: true, description: `Defines extended behaviors for a field such as for Email, Web URLs, Code, etc.`}) 
    @MaxLength(50)
    ExtendedType?: string;
        
    @Field({nullable: true, description: `The type of code associated with this field. Only used when the ExtendedType field is set to "Code"`}) 
    @MaxLength(50)
    CodeType?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included by default in any new view created by a user.`}) 
    DefaultInView: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    ViewCellTemplate?: string;
        
    @Field(() => Int, {nullable: true, description: `Determines the default width for this field when included in a view`}) 
    DefaultColumnWidth?: number;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be considered updateable by the API and object model. For this field to have effect, the column type must be updateable (e.g. not part of the primary key and not auto-increment)`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, and if AllowUpdateAPI=1, the field can be edited within a view when the view is in edit mode.`}) 
    AllowUpdateInView: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be included in user search queries for both traditional and full text search`}) 
    IncludeInUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, CodeGen will automatically generate a Full Text Catalog/Index in the database and include this field in the search index.`}) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    @MaxLength(500)
    UserSearchParamFormatAPI?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included in the generated form by CodeGen. If set to 0, this field will be excluded from the generated form. For custom forms, this field has no effect as the layout is controlled independently.`}) 
    IncludeInGeneratedForm: boolean;
        
    @Field({description: `When set to Top, the field will be placed in a "top area" on the top of a generated form and visible regardless of which tab is displayed. When set to "category" Options: Top, Category, Details`}) 
    @MaxLength(10)
    GeneratedFormSection: string;
        
    @Field(() => Boolean, {description: `NULL`}) 
    IsVirtual: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be used as the "Name" field for the entity and will be used to display the name of the record in various places in the UI.`}) 
    IsNameField: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RelatedEntityID?: string;
        
    @Field({nullable: true, description: `Name of the field in the Related Entity that this field links to (auto maintained by CodeGen)`}) 
    @MaxLength(255)
    RelatedEntityFieldName?: string;
        
    @Field(() => Boolean, {description: `If set to 1, the "Name" field of the Related Entity will be included in this entity as a virtual field`}) 
    IncludeRelatedEntityNameFieldInBaseView: boolean;
        
    @Field({nullable: true, description: `For foreign key fields, maps which field in the related entity contains the display name. This is used by CodeGen to automatically add in virtual fields for the "Name Field" of the related entity.`}) 
    @MaxLength(255)
    RelatedEntityNameFieldMap?: string;
        
    @Field({description: `Controls the generated form in the MJ Explorer UI - defaults to a search box, other option is a drop down. Possible values are Search and Dropdown`}) 
    @MaxLength(20)
    RelatedEntityDisplayType: string;
        
    @Field({nullable: true, description: `Optional, used for "Soft Keys" to link records to different entity/record combinations on a per-record basis (for example the FileEntityRecordLink table has an EntityID/RecordID field pair. For that entity, the RecordID specifies "EntityID" for this field. This information allows MJ to detect soft keys/links for dependency detection, merging and for preventing orphaned soft-linked records during delete operations.`}) 
    @MaxLength(100)
    EntityIDFieldName?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `A comma-delimited string indicating the default scope for field visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for a simple method of filtering field defaults for visibility, not security enforcement.`}) 
    @MaxLength(100)
    ScopeDefault?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the related entity information should be automatically updated from the database schema. When set to 0, relationships not part of the database schema can be manually defined at the application and AI agent level. Defaults to 1.`}) 
    AutoUpdateRelatedEntityInfo: boolean;
        
    @Field({description: `Determines whether values for the field should be included when the schema is packed. Options: Auto (include manually set or auto-derived values), None (exclude all values), All (include all distinct values from the table). Defaults to Auto.`}) 
    @MaxLength(10)
    ValuesToPackWithSchema: string;
        
    @Field({description: `Current status of the entity field - Active fields are available for use, Deprecated fields are discouraged but still functional, Disabled fields are not available for use`}) 
    @MaxLength(25)
    Status: string;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update IsNameField; when 0, user has locked this field`}) 
    AutoUpdateIsNameField: boolean;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update DefaultInView; when 0, user has locked this field`}) 
    AutoUpdateDefaultInView: boolean;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update Category; when 0, user has locked this field`}) 
    AutoUpdateCategory: boolean;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update DisplayName during CodeGen; when 0, user has locked this field`}) 
    AutoUpdateDisplayName: boolean;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update IncludeInUserSearchAPI during CodeGen; when 0, user has locked this field`}) 
    AutoUpdateIncludeInUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `When true, this field will be encrypted at rest using the specified EncryptionKeyID. Encrypted fields cannot be indexed or searched.`}) 
    Encrypt: boolean;
        
    @Field({nullable: true, description: `References the encryption key to use when Encrypt is true. Required if Encrypt is true.`}) 
    @MaxLength(36)
    EncryptionKeyID?: string;
        
    @Field(() => Boolean, {description: `When true, encrypted fields will be decrypted before returning via API. When false, behavior depends on SendEncryptedValue. Default is false (secure).`}) 
    AllowDecryptInAPI: boolean;
        
    @Field(() => Boolean, {description: `When AllowDecryptInAPI is false: if true, send encrypted ciphertext (e.g., $ENC$...); if false (default), send sentinel value, usually "[!ENCRYPTED$]", indicating a value exists but is protected. Most secure option is false.`}) 
    SendEncryptedValue: boolean;
        
    @Field(() => Boolean, {description: `When 1, indicates IsPrimaryKey was set via metadata (not a database constraint). Protects IsPrimaryKey from being cleared by schema sync.`}) 
    IsSoftPrimaryKey: boolean;
        
    @Field(() => Boolean, {description: `When 1, indicates RelatedEntityID/RelatedEntityFieldName were set via metadata (not a database constraint). Protects these fields from being cleared by schema sync.`}) 
    IsSoftForeignKey: boolean;
        
    @Field({nullable: true, description: `JSON configuration for additional fields to join from the related entity into this entity's base view. Supports modes: extend (add to NameField), override (replace NameField), disable (no joins). Schema: { mode?: string, fields?: [{ field: string, alias?: string }] }`}) 
    RelatedEntityJoinFields?: string;
        
    @Field({nullable: true}) 
    FieldCodeName?: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(255)
    SchemaName: string;
        
    @Field() 
    @MaxLength(255)
    BaseTable: string;
        
    @Field() 
    @MaxLength(255)
    BaseView: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    RelatedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    RelatedEntitySchemaName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    RelatedEntityBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    RelatedEntityBaseView?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field(() => [MJEntityFieldValue_])
    MJEntityFieldValues_EntityFieldIDArray: MJEntityFieldValue_[]; // Link to MJEntityFieldValues
    
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Fields
//****************************************************************************
@InputType()
export class CreateMJEntityFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType: string | null;

    @Field({ nullable: true })
    CodeType: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateIsNameField?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDefaultInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateCategory?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDisplayName?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateIncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    Encrypt?: boolean;

    @Field({ nullable: true })
    EncryptionKeyID: string | null;

    @Field(() => Boolean, { nullable: true })
    AllowDecryptInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    SendEncryptedValue?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsSoftPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsSoftForeignKey?: boolean;

    @Field({ nullable: true })
    RelatedEntityJoinFields: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Fields
//****************************************************************************
@InputType()
export class UpdateMJEntityFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType?: string | null;

    @Field({ nullable: true })
    CodeType?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate?: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth?: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID?: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap?: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateIsNameField?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDefaultInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateCategory?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDisplayName?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateIncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    Encrypt?: boolean;

    @Field({ nullable: true })
    EncryptionKeyID?: string | null;

    @Field(() => Boolean, { nullable: true })
    AllowDecryptInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    SendEncryptedValue?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsSoftPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsSoftForeignKey?: boolean;

    @Field({ nullable: true })
    RelatedEntityJoinFields?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Fields
//****************************************************************************
@ObjectType()
export class RunMJEntityFieldViewResult {
    @Field(() => [MJEntityField_])
    Results: MJEntityField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityField_)
export class MJEntityFieldResolver extends ResolverBase {
    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityField_, { nullable: true })
    async MJEntityField(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityField_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityFields')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Fields', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityField_])
    async AllMJEntityFields(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityFields')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Fields', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityFieldValue_])
    async MJEntityFieldValues_EntityFieldIDArray(@Root() mjentityfield_: MJEntityField_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityFieldValues')} WHERE ${provider.QuoteIdentifier('EntityFieldID')}='${mjentityfield_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Field Values', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityField_)
    async CreateMJEntityField(
        @Arg('input', () => CreateMJEntityFieldInput) input: CreateMJEntityFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityField_)
    async UpdateMJEntityField(
        @Arg('input', () => UpdateMJEntityFieldInput) input: UpdateMJEntityFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityField_)
    async DeleteMJEntityField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Permissions
//****************************************************************************
@ObjectType({ description: `Security settings for each entity` })
export class MJEntityPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(36)
    RoleID: string;
        
    @Field(() => Boolean, {description: `Whether the role/user can create new records in this entity.`}) 
    CanCreate: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can read/view records in this entity.`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can update existing records in this entity.`}) 
    CanUpdate: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can delete records from this entity.`}) 
    CanDelete: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ReadRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CreateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    UpdateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    DeleteRLSFilterID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(50)
    RoleName: string;
        
    @Field({nullable: true}) 
    @MaxLength(250)
    RoleSQLName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    CreateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ReadRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    UpdateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DeleteRLSFilter?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Permissions
//****************************************************************************
@InputType()
export class CreateMJEntityPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Permissions
//****************************************************************************
@InputType()
export class UpdateMJEntityPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID?: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID?: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID?: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Permissions
//****************************************************************************
@ObjectType()
export class RunMJEntityPermissionViewResult {
    @Field(() => [MJEntityPermission_])
    Results: MJEntityPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityPermission_)
export class MJEntityPermissionResolver extends ResolverBase {
    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityPermission_, { nullable: true })
    async MJEntityPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityPermission_])
    async AllMJEntityPermissions(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityPermissions')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Permissions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityPermission_)
    async CreateMJEntityPermission(
        @Arg('input', () => CreateMJEntityPermissionInput) input: CreateMJEntityPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityPermission_)
    async UpdateMJEntityPermission(
        @Arg('input', () => UpdateMJEntityPermissionInput) input: UpdateMJEntityPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityPermission_)
    async DeleteMJEntityPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Record Documents
//****************************************************************************
@ObjectType({ description: `Stores the output for a given entity record for a specific Entity Document. For example if a "Person" entity had a particular template that outputted First and Last name like "#{{FirstName}}\n#{{LastName}}" the Entity Record Document would have a row for each entity record in the Person entity that was run through that particular document and have row values such as "#Jane\n#Doe" and "#Mark\n#Smith".` })
export class MJEntityRecordDocument_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `The ID of the entity record this document was generated for.`}) 
    @MaxLength(450)
    RecordID: string;
        
    @Field() 
    @MaxLength(36)
    EntityDocumentID: string;
        
    @Field({nullable: true, description: `The generated document text after template processing.`}) 
    DocumentText?: string;
        
    @Field() 
    @MaxLength(36)
    VectorIndexID: string;
        
    @Field({nullable: true, description: `Reference to the vector embedding of this document if AI search is enabled.`}) 
    @MaxLength(50)
    VectorID?: string;
        
    @Field({nullable: true, description: `JSON representation of the vector embedding for this document.`}) 
    VectorJSON?: string;
        
    @Field({description: `Timestamp of when the source entity record was last updated.`}) 
    EntityRecordUpdatedAt: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(250)
    EntityDocument: string;
        
    @Field() 
    @MaxLength(255)
    VectorIndex: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Record Documents
//****************************************************************************
@InputType()
export class CreateMJEntityRecordDocumentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID: string | null;

    @Field({ nullable: true })
    VectorJSON: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Record Documents
//****************************************************************************
@InputType()
export class UpdateMJEntityRecordDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText?: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID?: string | null;

    @Field({ nullable: true })
    VectorJSON?: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Record Documents
//****************************************************************************
@ObjectType()
export class RunMJEntityRecordDocumentViewResult {
    @Field(() => [MJEntityRecordDocument_])
    Results: MJEntityRecordDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRecordDocument_)
export class MJEntityRecordDocumentResolver extends ResolverBase {
    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Record Documents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRecordDocument_, { nullable: true })
    async MJEntityRecordDocument(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRecordDocument_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRecordDocuments')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Record Documents', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityRecordDocument_)
    async CreateMJEntityRecordDocument(
        @Arg('input', () => CreateMJEntityRecordDocumentInput) input: CreateMJEntityRecordDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Record Documents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRecordDocument_)
    async UpdateMJEntityRecordDocument(
        @Arg('input', () => UpdateMJEntityRecordDocumentInput) input: UpdateMJEntityRecordDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Record Documents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityRecordDocument_)
    async DeleteMJEntityRecordDocument(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Record Documents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Relationship Display Components
//****************************************************************************
@ObjectType({ description: `This table stores a list of components that are available for displaying relationships in the MJ Explorer UI` })
export class MJEntityRelationshipDisplayComponent_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The type of relationship the component displays. Valid values are "One to Many", "Many to Many", or "Both".`}) 
    @MaxLength(20)
    RelationshipType: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityRelationship_])
    MJEntityRelationships_DisplayComponentIDArray: MJEntityRelationship_[]; // Link to MJEntityRelationships
    
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Relationship Display Components
//****************************************************************************
@InputType()
export class CreateMJEntityRelationshipDisplayComponentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Relationship Display Components
//****************************************************************************
@InputType()
export class UpdateMJEntityRelationshipDisplayComponentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Relationship Display Components
//****************************************************************************
@ObjectType()
export class RunMJEntityRelationshipDisplayComponentViewResult {
    @Field(() => [MJEntityRelationshipDisplayComponent_])
    Results: MJEntityRelationshipDisplayComponent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRelationshipDisplayComponent_)
export class MJEntityRelationshipDisplayComponentResolver extends ResolverBase {
    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Relationship Display Components';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRelationshipDisplayComponent_, { nullable: true })
    async MJEntityRelationshipDisplayComponent(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRelationshipDisplayComponent_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Relationship Display Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRelationshipDisplayComponents')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Relationship Display Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Relationship Display Components', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityRelationship_])
    async MJEntityRelationships_DisplayComponentIDArray(@Root() mjentityrelationshipdisplaycomponent_: MJEntityRelationshipDisplayComponent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRelationships')} WHERE ${provider.QuoteIdentifier('DisplayComponentID')}='${mjentityrelationshipdisplaycomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityRelationshipDisplayComponent_)
    async CreateMJEntityRelationshipDisplayComponent(
        @Arg('input', () => CreateMJEntityRelationshipDisplayComponentInput) input: CreateMJEntityRelationshipDisplayComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Relationship Display Components', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRelationshipDisplayComponent_)
    async UpdateMJEntityRelationshipDisplayComponent(
        @Arg('input', () => UpdateMJEntityRelationshipDisplayComponentInput) input: UpdateMJEntityRelationshipDisplayComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Relationship Display Components', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityRelationshipDisplayComponent_)
    async DeleteMJEntityRelationshipDisplayComponent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Relationship Display Components', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Relationships
//****************************************************************************
@ObjectType({ description: `Metadata about relationships between entities including display preferences for the UI` })
export class MJEntityRelationship_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field(() => Int, {description: `Used for display order in generated forms and in other places in the UI where relationships for an entity are shown`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(36)
    RelatedEntityID: string;
        
    @Field(() => Boolean, {description: `Whether to include related records when fetching the parent entity via API.`}) 
    BundleInAPI: boolean;
        
    @Field(() => Boolean, {description: `Whether to include this relationship when querying all fields of the parent entity.`}) 
    IncludeInParentAllQuery: boolean;
        
    @Field({description: `The cardinality of the relationship (One To Many, Many To Many, One To One).`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `The primary key field of the parent entity in this relationship.`}) 
    @MaxLength(255)
    EntityKeyField?: string;
        
    @Field({description: `The foreign key field in the related entity that references the parent.`}) 
    @MaxLength(255)
    RelatedEntityJoinField: string;
        
    @Field({nullable: true, description: `For many-to-many relationships, the view containing the junction data.`}) 
    @MaxLength(255)
    JoinView?: string;
        
    @Field({nullable: true, description: `For many-to-many, the field in the junction table linking to the parent entity.`}) 
    @MaxLength(255)
    JoinEntityJoinField?: string;
        
    @Field({nullable: true, description: `For many-to-many, the field in the junction table linking to the related entity.`}) 
    @MaxLength(255)
    JoinEntityInverseJoinField?: string;
        
    @Field(() => Boolean, {description: `When unchecked the relationship will NOT be displayed on the generated form`}) 
    DisplayInForm: boolean;
        
    @Field({description: `Where to display this relationship in the UI relative to other entity elements.`}) 
    @MaxLength(50)
    DisplayLocation: string;
        
    @Field({nullable: true, description: `Optional, when specified this value overrides the related entity name for the label on the tab`}) 
    @MaxLength(255)
    DisplayName?: string;
        
    @Field({description: `When Related Entity Icon - uses the icon from the related entity, if one exists. When Custom, uses the value in the DisplayIcon field in this record, and when None, no icon is displayed`}) 
    @MaxLength(50)
    DisplayIconType: string;
        
    @Field({nullable: true, description: `If specified, the icon `}) 
    @MaxLength(255)
    DisplayIcon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    DisplayUserViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    DisplayComponentID?: string;
        
    @Field({nullable: true, description: `If DisplayComponentID is specified, this field can optionally be used to track component-specific and relationship-specific configuration details that will be used by CodeGen to provide to the display component selected.`}) 
    DisplayComponentConfiguration?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this relationship should be automatically updated by CodeGen. When set to 0, the record will not be modified by CodeGen. Defaults to 1.`}) 
    AutoUpdateFromSchema: boolean;
        
    @Field({nullable: true, description: `JSON array of additional field names to include when joining through this relationship (for junction tables, e.g., ["RoleName", "UserEmail"])`}) 
    AdditionalFieldsToInclude?: string;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update AdditionalFieldsToInclude; when 0, user has locked this field`}) 
    AutoUpdateAdditionalFieldsToInclude: boolean;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(255)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(255)
    EntityBaseView: string;
        
    @Field() 
    @MaxLength(255)
    RelatedEntity: string;
        
    @Field() 
    @MaxLength(255)
    RelatedEntityBaseTable: string;
        
    @Field() 
    @MaxLength(255)
    RelatedEntityBaseView: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityBaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DisplayUserViewName?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Relationships
//****************************************************************************
@InputType()
export class CreateMJEntityRelationshipInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon: string | null;

    @Field({ nullable: true })
    DisplayComponentID: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;

    @Field({ nullable: true })
    AdditionalFieldsToInclude: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateAdditionalFieldsToInclude?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Relationships
//****************************************************************************
@InputType()
export class UpdateMJEntityRelationshipInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField?: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView?: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField?: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField?: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon?: string | null;

    @Field({ nullable: true })
    DisplayComponentID?: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;

    @Field({ nullable: true })
    AdditionalFieldsToInclude?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateAdditionalFieldsToInclude?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Relationships
//****************************************************************************
@ObjectType()
export class RunMJEntityRelationshipViewResult {
    @Field(() => [MJEntityRelationship_])
    Results: MJEntityRelationship_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRelationship_)
export class MJEntityRelationshipResolver extends ResolverBase {
    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Relationships';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRelationship_, { nullable: true })
    async MJEntityRelationship(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRelationship_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRelationships')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Relationships', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityRelationship_])
    async AllMJEntityRelationships(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRelationships')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Relationships', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityRelationship_)
    async CreateMJEntityRelationship(
        @Arg('input', () => CreateMJEntityRelationshipInput) input: CreateMJEntityRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Relationships', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRelationship_)
    async UpdateMJEntityRelationship(
        @Arg('input', () => UpdateMJEntityRelationshipInput) input: UpdateMJEntityRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Relationships', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityRelationship_)
    async DeleteMJEntityRelationship(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Relationships', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Entity Settings
//****************************************************************************
@ObjectType({ description: `Stores entity-specific configuration settings, allowing customization of how entities function.` })
export class MJEntitySetting_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `The configuration value for this entity setting, often in JSON format.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Entity Settings
//****************************************************************************
@InputType()
export class CreateMJEntitySettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Entity Settings
//****************************************************************************
@InputType()
export class UpdateMJEntitySettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Entity Settings
//****************************************************************************
@ObjectType()
export class RunMJEntitySettingViewResult {
    @Field(() => [MJEntitySetting_])
    Results: MJEntitySetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntitySetting_)
export class MJEntitySettingResolver extends ResolverBase {
    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Entity Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntitySetting_, { nullable: true })
    async MJEntitySetting(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntitySetting_ | null> {
        this.CheckUserReadPermissions('MJ: Entity Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntitySettings')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Entity Settings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntitySetting_)
    async CreateMJEntitySetting(
        @Arg('input', () => CreateMJEntitySettingInput) input: CreateMJEntitySettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Entity Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntitySetting_)
    async UpdateMJEntitySetting(
        @Arg('input', () => UpdateMJEntitySettingInput) input: UpdateMJEntitySettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Entity Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntitySetting_)
    async DeleteMJEntitySetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Entity Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Environments
//****************************************************************************
@ObjectType({ description: `Top-level container for organizing conversations, artifacts, and collections. Provides isolation and grouping for different teams, clients, or functional areas.` })
export class MJEnvironment_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Display name for the environment`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the environment purpose and scope`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `Indicates if this is the default environment for the organization`}) 
    IsDefault: boolean;
        
    @Field({nullable: true, description: `JSON configuration for environment-specific settings and features`}) 
    Settings?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJProject_])
    MJProjects_EnvironmentIDArray: MJProject_[]; // Link to MJProjects
    
    @Field(() => [MJCollection_])
    MJCollections_EnvironmentIDArray: MJCollection_[]; // Link to MJCollections
    
    @Field(() => [MJArtifact_])
    MJArtifacts_EnvironmentIDArray: MJArtifact_[]; // Link to MJArtifacts
    
    @Field(() => [MJTask_])
    MJTasks_EnvironmentIDArray: MJTask_[]; // Link to MJTasks
    
    @Field(() => [MJDashboard_])
    MJDashboards_EnvironmentIDArray: MJDashboard_[]; // Link to MJDashboards
    
    @Field(() => [MJReport_])
    MJReports_EnvironmentIDArray: MJReport_[]; // Link to MJReports
    
    @Field(() => [MJConversation_])
    MJConversations_EnvironmentIDArray: MJConversation_[]; // Link to MJConversations
    
}

//****************************************************************************
// INPUT TYPE for MJ: Environments
//****************************************************************************
@InputType()
export class CreateMJEnvironmentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Settings: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Environments
//****************************************************************************
@InputType()
export class UpdateMJEnvironmentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Settings?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Environments
//****************************************************************************
@ObjectType()
export class RunMJEnvironmentViewResult {
    @Field(() => [MJEnvironment_])
    Results: MJEnvironment_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEnvironment_)
export class MJEnvironmentResolver extends ResolverBase {
    @Query(() => RunMJEnvironmentViewResult)
    async RunMJEnvironmentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEnvironmentViewResult)
    async RunMJEnvironmentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEnvironmentViewResult)
    async RunMJEnvironmentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Environments';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEnvironment_, { nullable: true })
    async MJEnvironment(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEnvironment_ | null> {
        this.CheckUserReadPermissions('MJ: Environments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEnvironments')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Environments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Environments', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJProject_])
    async MJProjects_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Projects', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwProjects')} WHERE ${provider.QuoteIdentifier('EnvironmentID')}='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Projects', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Projects', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollection_])
    async MJCollections_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollections')} WHERE ${provider.QuoteIdentifier('EnvironmentID')}='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifact_])
    async MJArtifacts_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifacts')} WHERE ${provider.QuoteIdentifier('EnvironmentID')}='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJTasks_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTasks')} WHERE ${provider.QuoteIdentifier('EnvironmentID')}='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboard_])
    async MJDashboards_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboards')} WHERE ${provider.QuoteIdentifier('EnvironmentID')}='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboards', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async MJReports_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('EnvironmentID')}='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async MJConversations_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversations')} WHERE ${provider.QuoteIdentifier('EnvironmentID')}='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEnvironment_)
    async CreateMJEnvironment(
        @Arg('input', () => CreateMJEnvironmentInput) input: CreateMJEnvironmentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Environments', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEnvironment_)
    async UpdateMJEnvironment(
        @Arg('input', () => UpdateMJEnvironmentInput) input: UpdateMJEnvironmentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Environments', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEnvironment_)
    async DeleteMJEnvironment(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Environments', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Error Logs
//****************************************************************************
@ObjectType({ description: `Captures system errors, exceptions, and failures with stack traces, context, and debugging info.` })
export class MJErrorLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CompanyIntegrationRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CompanyIntegrationRunDetailID?: string;
        
    @Field({nullable: true, description: `Error code for categorizing and handling specific error types.`}) 
    @MaxLength(20)
    Code?: string;
        
    @Field({nullable: true, description: `The primary error message describing what went wrong.`}) 
    Message?: string;
        
    @Field({nullable: true, description: `User or system process that encountered this error.`}) 
    @MaxLength(50)
    CreatedBy?: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    Status?: string;
        
    @Field({nullable: true, description: `High-level category for grouping related errors (Database, API, Validation, etc.).`}) 
    @MaxLength(20)
    Category?: string;
        
    @Field({nullable: true, description: `Full error details including stack trace, inner exceptions, and context data.`}) 
    Details?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    CompanyIntegrationRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(450)
    CompanyIntegrationRunDetail?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Error Logs
//****************************************************************************
@InputType()
export class CreateMJErrorLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    Details: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Error Logs
//****************************************************************************
@InputType()
export class UpdateMJErrorLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Error Logs
//****************************************************************************
@ObjectType()
export class RunMJErrorLogViewResult {
    @Field(() => [MJErrorLog_])
    Results: MJErrorLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJErrorLog_)
export class MJErrorLogResolver extends ResolverBase {
    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Error Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJErrorLog_, { nullable: true })
    async MJErrorLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJErrorLog_ | null> {
        this.CheckUserReadPermissions('MJ: Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwErrorLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Error Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJErrorLog_)
    async CreateMJErrorLog(
        @Arg('input', () => CreateMJErrorLogInput) input: CreateMJErrorLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Error Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJErrorLog_)
    async UpdateMJErrorLog(
        @Arg('input', () => UpdateMJErrorLogInput) input: UpdateMJErrorLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Error Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJErrorLog_)
    async DeleteMJErrorLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Error Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Explorer Navigation Items
//****************************************************************************
@ObjectType({ description: `Table to store navigation items for MemberJunction Explorer` })
export class MJExplorerNavigationItem_ {
    @Field({description: `Unique identifier for each navigation item`}) 
    @MaxLength(36)
    ID: string;
        
    @Field(() => Int, {description: `Sequence number for the navigation item, must be unique and greater than 0`}) 
    Sequence: number;
        
    @Field({description: `Unique name of the navigation item displayed to the user`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `The route for the navigation item relative to the app main URL, using Angular syntax like "entity/:entityName"`}) 
    @MaxLength(255)
    Route: string;
        
    @Field(() => Boolean, {description: `Indicates if the navigation item is active; allows turning off items in the UI without deleting them from the metadata`}) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `Controls if the navigation item is shown on the Home screen for MJ Explorer`}) 
    ShowInHomeScreen: boolean;
        
    @Field(() => Boolean, {description: `Controls if the item is shown in the left navigation drawer in the MJ Explorer app or not.`}) 
    ShowInNavigationDrawer: boolean;
        
    @Field({nullable: true, description: `Optional, CSS class for an icon to be displayed with the navigation item`}) 
    @MaxLength(100)
    IconCSSClass?: string;
        
    @Field({nullable: true, description: `Description of the navigation item, shown to the user on hover or in larger displays`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Administrator comments, not shown to the end user in MJ Explorer app`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Explorer Navigation Items
//****************************************************************************
@InputType()
export class CreateMJExplorerNavigationItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Explorer Navigation Items
//****************************************************************************
@InputType()
export class UpdateMJExplorerNavigationItemInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Explorer Navigation Items
//****************************************************************************
@ObjectType()
export class RunMJExplorerNavigationItemViewResult {
    @Field(() => [MJExplorerNavigationItem_])
    Results: MJExplorerNavigationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJExplorerNavigationItem_)
export class MJExplorerNavigationItemResolver extends ResolverBase {
    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Explorer Navigation Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJExplorerNavigationItem_, { nullable: true })
    async MJExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJExplorerNavigationItem_ | null> {
        this.CheckUserReadPermissions('MJ: Explorer Navigation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwExplorerNavigationItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Explorer Navigation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Explorer Navigation Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJExplorerNavigationItem_)
    async CreateMJExplorerNavigationItem(
        @Arg('input', () => CreateMJExplorerNavigationItemInput) input: CreateMJExplorerNavigationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Explorer Navigation Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJExplorerNavigationItem_)
    async UpdateMJExplorerNavigationItem(
        @Arg('input', () => UpdateMJExplorerNavigationItemInput) input: UpdateMJExplorerNavigationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Explorer Navigation Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJExplorerNavigationItem_)
    async DeleteMJExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Explorer Navigation Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: File Categories
//****************************************************************************
@ObjectType({ description: `Organizes files into categories for classification, access control, and lifecycle management across the file storage system.` })
export class MJFileCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJFile_])
    MJFiles_CategoryIDArray: MJFile_[]; // Link to MJFiles
    
    @Field(() => [MJFileCategory_])
    MJFileCategories_ParentIDArray: MJFileCategory_[]; // Link to MJFileCategories
    
}

//****************************************************************************
// INPUT TYPE for MJ: File Categories
//****************************************************************************
@InputType()
export class CreateMJFileCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: File Categories
//****************************************************************************
@InputType()
export class UpdateMJFileCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: File Categories
//****************************************************************************
@ObjectType()
export class RunMJFileCategoryViewResult {
    @Field(() => [MJFileCategory_])
    Results: MJFileCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileCategory_)
export class MJFileCategoryResolver extends ResolverBase {
    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: File Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileCategory_, { nullable: true })
    async MJFileCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileCategory_ | null> {
        this.CheckUserReadPermissions('MJ: File Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: File Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJFile_])
    async MJFiles_CategoryIDArray(@Root() mjfilecategory_: MJFileCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFiles')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjfilecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Files', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJFileCategory_])
    async MJFileCategories_ParentIDArray(@Root() mjfilecategory_: MJFileCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: File Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjfilecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: File Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJFileCategory_)
    async CreateMJFileCategory(
        @Arg('input', () => CreateMJFileCategoryInput) input: CreateMJFileCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: File Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileCategory_)
    async UpdateMJFileCategory(
        @Arg('input', () => UpdateMJFileCategoryInput) input: UpdateMJFileCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: File Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileCategory_)
    async DeleteMJFileCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: File Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: File Entity Record Links
//****************************************************************************
@ObjectType({ description: `Associates files with entity records, enabling attachment management and document relationships throughout the system.` })
export class MJFileEntityRecordLink_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    FileID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `The ID of the entity record this file is attached to.`}) 
    @MaxLength(750)
    RecordID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    File: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: File Entity Record Links
//****************************************************************************
@InputType()
export class CreateMJFileEntityRecordLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: File Entity Record Links
//****************************************************************************
@InputType()
export class UpdateMJFileEntityRecordLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: File Entity Record Links
//****************************************************************************
@ObjectType()
export class RunMJFileEntityRecordLinkViewResult {
    @Field(() => [MJFileEntityRecordLink_])
    Results: MJFileEntityRecordLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileEntityRecordLink_)
export class MJFileEntityRecordLinkResolver extends ResolverBase {
    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: File Entity Record Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileEntityRecordLink_, { nullable: true })
    async MJFileEntityRecordLink(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileEntityRecordLink_ | null> {
        this.CheckUserReadPermissions('MJ: File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileEntityRecordLinks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: File Entity Record Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJFileEntityRecordLink_)
    async CreateMJFileEntityRecordLink(
        @Arg('input', () => CreateMJFileEntityRecordLinkInput) input: CreateMJFileEntityRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: File Entity Record Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileEntityRecordLink_)
    async UpdateMJFileEntityRecordLink(
        @Arg('input', () => UpdateMJFileEntityRecordLinkInput) input: UpdateMJFileEntityRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: File Entity Record Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileEntityRecordLink_)
    async DeleteMJFileEntityRecordLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: File Entity Record Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: File Storage Accounts
//****************************************************************************
@ObjectType({ description: `Enterprise-level file storage accounts. Each account represents a configured connection to a storage provider (e.g., Marketing Dropbox, Engineering Google Drive) with credentials managed centrally.` })
export class MJFileStorageAccount_ {
    @Field({description: `Primary key`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Display name for the storage account (e.g., Marketing Files, Engineering Docs). Must be unique per provider.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Optional description providing additional context about the account purpose or contents.`}) 
    Description?: string;
        
    @Field({description: `Foreign key to FileStorageProvider indicating which storage service this account uses (Dropbox, Google Drive, S3, etc.).`}) 
    @MaxLength(36)
    ProviderID: string;
        
    @Field({description: `Foreign key to Credential containing the authentication details (OAuth tokens, API keys, etc.) for this account. Credentials are decrypted at runtime by the Credential Engine.`}) 
    @MaxLength(36)
    CredentialID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    Provider: string;
        
    @Field() 
    @MaxLength(200)
    Credential: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: File Storage Accounts
//****************************************************************************
@InputType()
export class CreateMJFileStorageAccountInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    CredentialID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: File Storage Accounts
//****************************************************************************
@InputType()
export class UpdateMJFileStorageAccountInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    CredentialID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: File Storage Accounts
//****************************************************************************
@ObjectType()
export class RunMJFileStorageAccountViewResult {
    @Field(() => [MJFileStorageAccount_])
    Results: MJFileStorageAccount_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileStorageAccount_)
export class MJFileStorageAccountResolver extends ResolverBase {
    @Query(() => RunMJFileStorageAccountViewResult)
    async RunMJFileStorageAccountViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageAccountViewResult)
    async RunMJFileStorageAccountViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageAccountViewResult)
    async RunMJFileStorageAccountDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: File Storage Accounts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileStorageAccount_, { nullable: true })
    async MJFileStorageAccount(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileStorageAccount_ | null> {
        this.CheckUserReadPermissions('MJ: File Storage Accounts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileStorageAccounts')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Storage Accounts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: File Storage Accounts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJFileStorageAccount_)
    async CreateMJFileStorageAccount(
        @Arg('input', () => CreateMJFileStorageAccountInput) input: CreateMJFileStorageAccountInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: File Storage Accounts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileStorageAccount_)
    async UpdateMJFileStorageAccount(
        @Arg('input', () => UpdateMJFileStorageAccountInput) input: UpdateMJFileStorageAccountInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: File Storage Accounts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileStorageAccount_)
    async DeleteMJFileStorageAccount(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: File Storage Accounts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: File Storage Providers
//****************************************************************************
@ObjectType({ description: `Configures connections to file storage systems including local, cloud, and network storage with authentication and access rules.` })
export class MJFileStorageProvider_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Identifier for the server-side driver implementation for this storage provider.`}) 
    @MaxLength(100)
    ServerDriverKey: string;
        
    @Field({description: `Identifier for the client-side driver implementation for this storage provider.`}) 
    @MaxLength(100)
    ClientDriverKey: string;
        
    @Field(() => Int, {description: `Priority order for selecting storage providers, lower numbers are preferred.`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `Whether this storage provider is currently available for use.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this storage provider supports native full-text search across file names and content. Providers with native search APIs (Google Drive, SharePoint, Dropbox, Box) have this set to true.`}) 
    SupportsSearch: boolean;
        
    @Field({nullable: true, description: `Optional JSON configuration for providers that don't use Credential Engine. Used as fallback when CredentialID is not set on FileStorageAccount.`}) 
    Configuration?: string;
        
    @Field(() => Boolean, {description: `If true, this provider requires OAuth authentication. Enterprise OAuth integration via Credential Engine is planned but not yet implemented.`}) 
    RequiresOAuth: boolean;
        
    @Field(() => [MJFile_])
    MJFiles_ProviderIDArray: MJFile_[]; // Link to MJFiles
    
    @Field(() => [MJFileStorageAccount_])
    MJFileStorageAccounts_ProviderIDArray: MJFileStorageAccount_[]; // Link to MJFileStorageAccounts
    
    @Field(() => [MJAIConfiguration_])
    MJAIConfigurations_DefaultStorageProviderIDArray: MJAIConfiguration_[]; // Link to MJAIConfigurations
    
    @Field(() => [MJAIAgent_])
    MJAIAgents_AttachmentStorageProviderIDArray: MJAIAgent_[]; // Link to MJAIAgents
    
}

//****************************************************************************
// INPUT TYPE for MJ: File Storage Providers
//****************************************************************************
@InputType()
export class CreateMJFileStorageProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSearch?: boolean;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Boolean, { nullable: true })
    RequiresOAuth?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: File Storage Providers
//****************************************************************************
@InputType()
export class UpdateMJFileStorageProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSearch?: boolean;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Boolean, { nullable: true })
    RequiresOAuth?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: File Storage Providers
//****************************************************************************
@ObjectType()
export class RunMJFileStorageProviderViewResult {
    @Field(() => [MJFileStorageProvider_])
    Results: MJFileStorageProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileStorageProvider_)
export class MJFileStorageProviderResolver extends ResolverBase {
    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: File Storage Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileStorageProvider_, { nullable: true })
    async MJFileStorageProvider(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileStorageProvider_ | null> {
        this.CheckUserReadPermissions('MJ: File Storage Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileStorageProviders')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Storage Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: File Storage Providers', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJFile_])
    async MJFiles_ProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFiles')} WHERE ${provider.QuoteIdentifier('ProviderID')}='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Files', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJFileStorageAccount_])
    async MJFileStorageAccounts_ProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: File Storage Accounts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileStorageAccounts')} WHERE ${provider.QuoteIdentifier('ProviderID')}='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Storage Accounts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: File Storage Accounts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIConfiguration_])
    async MJAIConfigurations_DefaultStorageProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIConfigurations')} WHERE ${provider.QuoteIdentifier('DefaultStorageProviderID')}='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async MJAIAgents_AttachmentStorageProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgents')} WHERE ${provider.QuoteIdentifier('AttachmentStorageProviderID')}='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJFileStorageProvider_)
    async CreateMJFileStorageProvider(
        @Arg('input', () => CreateMJFileStorageProviderInput) input: CreateMJFileStorageProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: File Storage Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileStorageProvider_)
    async UpdateMJFileStorageProvider(
        @Arg('input', () => UpdateMJFileStorageProviderInput) input: UpdateMJFileStorageProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: File Storage Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileStorageProvider_)
    async DeleteMJFileStorageProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: File Storage Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Files
//****************************************************************************
@ObjectType({ description: `Manages file metadata, storage locations, and access control for all files stored within or referenced by the system.` })
export class MJFile_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(500)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(36)
    ProviderID: string;
        
    @Field({nullable: true, description: `MIME type of the file content (e.g., image/jpeg, application/pdf).`}) 
    @MaxLength(255)
    ContentType?: string;
        
    @Field({nullable: true, description: `Storage provider-specific identifier or path for this file.`}) 
    @MaxLength(500)
    ProviderKey?: string;
        
    @Field({description: `Pending, Uploading, Uploaded, Deleting, Deleted`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Category?: string;
        
    @Field() 
    @MaxLength(50)
    Provider: string;
        
    @Field(() => [MJFileEntityRecordLink_])
    MJFileEntityRecordLinks_FileIDArray: MJFileEntityRecordLink_[]; // Link to MJFileEntityRecordLinks
    
    @Field(() => [MJAIPromptRunMedia_])
    MJAIPromptRunMedias_FileIDArray: MJAIPromptRunMedia_[]; // Link to MJAIPromptRunMedias
    
    @Field(() => [MJConversationDetailAttachment_])
    MJConversationDetailAttachments_FileIDArray: MJConversationDetailAttachment_[]; // Link to MJConversationDetailAttachments
    
    @Field(() => [MJAIAgentRunMedia_])
    MJAIAgentRunMedias_FileIDArray: MJAIAgentRunMedia_[]; // Link to MJAIAgentRunMedias
    
}

//****************************************************************************
// INPUT TYPE for MJ: Files
//****************************************************************************
@InputType()
export class CreateMJFileInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType: string | null;

    @Field({ nullable: true })
    ProviderKey: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Files
//****************************************************************************
@InputType()
export class UpdateMJFileInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType?: string | null;

    @Field({ nullable: true })
    ProviderKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Files
//****************************************************************************
@ObjectType()
export class RunMJFileViewResult {
    @Field(() => [MJFile_])
    Results: MJFile_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFile_)
export class MJFileResolver extends ResolverBase {
    @Query(() => RunMJFileViewResult)
    async RunMJFileViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileViewResult)
    async RunMJFileViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileViewResult)
    async RunMJFileDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Files';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFile_, { nullable: true })
    async MJFile(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFile_ | null> {
        this.CheckUserReadPermissions('MJ: Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFiles')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Files', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJFileEntityRecordLink_])
    async MJFileEntityRecordLinks_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwFileEntityRecordLinks')} WHERE ${provider.QuoteIdentifier('FileID')}='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: File Entity Record Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRunMedia_])
    async MJAIPromptRunMedias_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRunMedias')} WHERE ${provider.QuoteIdentifier('FileID')}='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailAttachment_])
    async MJConversationDetailAttachments_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Attachments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailAttachments')} WHERE ${provider.QuoteIdentifier('FileID')}='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Attachments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Attachments', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRunMedia_])
    async MJAIAgentRunMedias_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRunMedias')} WHERE ${provider.QuoteIdentifier('FileID')}='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJFile_)
    async CreateMJFile(
        @Arg('input', () => CreateMJFileInput) input: CreateMJFileInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Files', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFile_)
    async UpdateMJFile(
        @Arg('input', () => UpdateMJFileInput) input: UpdateMJFileInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Files', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFile_)
    async DeleteMJFile(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Files', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Generated Code Categories
//****************************************************************************
@ObjectType({ description: `Categorization for generated code, including optional parent-child relationships.` })
export class MJGeneratedCodeCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Parent category ID, allowing for hierarchical categorization.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJGeneratedCodeCategory_])
    MJGeneratedCodeCategories_ParentIDArray: MJGeneratedCodeCategory_[]; // Link to MJGeneratedCodeCategories
    
    @Field(() => [MJGeneratedCode_])
    MJGeneratedCodes_CategoryIDArray: MJGeneratedCode_[]; // Link to MJGeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for MJ: Generated Code Categories
//****************************************************************************
@InputType()
export class CreateMJGeneratedCodeCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Generated Code Categories
//****************************************************************************
@InputType()
export class UpdateMJGeneratedCodeCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Generated Code Categories
//****************************************************************************
@ObjectType()
export class RunMJGeneratedCodeCategoryViewResult {
    @Field(() => [MJGeneratedCodeCategory_])
    Results: MJGeneratedCodeCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJGeneratedCodeCategory_)
export class MJGeneratedCodeCategoryResolver extends ResolverBase {
    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Generated Code Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJGeneratedCodeCategory_, { nullable: true })
    async MJGeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJGeneratedCodeCategory_ | null> {
        this.CheckUserReadPermissions('MJ: Generated Code Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwGeneratedCodeCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Generated Code Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJGeneratedCodeCategory_])
    async MJGeneratedCodeCategories_ParentIDArray(@Root() mjgeneratedcodecategory_: MJGeneratedCodeCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Generated Code Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwGeneratedCodeCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjgeneratedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Generated Code Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async MJGeneratedCodes_CategoryIDArray(@Root() mjgeneratedcodecategory_: MJGeneratedCodeCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwGeneratedCodes')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjgeneratedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Generated Codes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJGeneratedCodeCategory_)
    async CreateMJGeneratedCodeCategory(
        @Arg('input', () => CreateMJGeneratedCodeCategoryInput) input: CreateMJGeneratedCodeCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Generated Code Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJGeneratedCodeCategory_)
    async UpdateMJGeneratedCodeCategory(
        @Arg('input', () => UpdateMJGeneratedCodeCategoryInput) input: UpdateMJGeneratedCodeCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Generated Code Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJGeneratedCodeCategory_)
    async DeleteMJGeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Generated Code Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Generated Codes
//****************************************************************************
@ObjectType({ description: `Stores LLM-generated code snippets, tracking their source, category, and validation status.` })
export class MJGeneratedCode_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `When the code was generated.`}) 
    GeneratedAt: Date;
        
    @Field({description: `Reference to the category of generated code.`}) 
    @MaxLength(36)
    CategoryID: string;
        
    @Field({description: `AI model responsible for generating this code.`}) 
    @MaxLength(36)
    GeneratedByModelID: string;
        
    @Field({description: `Descriptive name of the generated code.`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the generated code.`}) 
    Description?: string;
        
    @Field({description: `The actual generated code.`}) 
    Code: string;
        
    @Field({description: `Source material used to generate the code, e.g., a SQL CHECK constraint.`}) 
    Source: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `JSON containing the primary key(s) of the record this generated code is associated with.`}) 
    LinkedRecordPrimaryKey?: string;
        
    @Field({description: `Status of the generated code, e.g., Pending, Approved, or Rejected.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({description: `Programming language of the generated code (TypeScript, SQL, HTML, CSS, JavaScript, Python, or Other).`}) 
    @MaxLength(50)
    Language: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Category: string;
        
    @Field() 
    @MaxLength(50)
    GeneratedByModel: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    LinkedEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Generated Codes
//****************************************************************************
@InputType()
export class CreateMJGeneratedCodeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Generated Codes
//****************************************************************************
@InputType()
export class UpdateMJGeneratedCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Generated Codes
//****************************************************************************
@ObjectType()
export class RunMJGeneratedCodeViewResult {
    @Field(() => [MJGeneratedCode_])
    Results: MJGeneratedCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJGeneratedCode_)
export class MJGeneratedCodeResolver extends ResolverBase {
    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Generated Codes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJGeneratedCode_, { nullable: true })
    async MJGeneratedCode(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJGeneratedCode_ | null> {
        this.CheckUserReadPermissions('MJ: Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwGeneratedCodes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Generated Codes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJGeneratedCode_)
    async CreateMJGeneratedCode(
        @Arg('input', () => CreateMJGeneratedCodeInput) input: CreateMJGeneratedCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Generated Codes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJGeneratedCode_)
    async UpdateMJGeneratedCode(
        @Arg('input', () => UpdateMJGeneratedCodeInput) input: UpdateMJGeneratedCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Generated Codes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJGeneratedCode_)
    async DeleteMJGeneratedCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Generated Codes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Integration URL Formats
//****************************************************************************
@ObjectType({ description: `Used to generate web links for end users to easily access resources in a source system. URL Formats support templating to inject various field values at run-time to take a user directly to a resource in a source system.` })
export class MJIntegrationURLFormat_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    IntegrationID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `The URL Format for the given integration including the ability to include markup with fields from the integration`}) 
    @MaxLength(500)
    URLFormat: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    NavigationBaseURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    FullURLFormat?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Integration URL Formats
//****************************************************************************
@InputType()
export class CreateMJIntegrationURLFormatInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    URLFormat?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Integration URL Formats
//****************************************************************************
@InputType()
export class UpdateMJIntegrationURLFormatInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    URLFormat?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Integration URL Formats
//****************************************************************************
@ObjectType()
export class RunMJIntegrationURLFormatViewResult {
    @Field(() => [MJIntegrationURLFormat_])
    Results: MJIntegrationURLFormat_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJIntegrationURLFormat_)
export class MJIntegrationURLFormatResolver extends ResolverBase {
    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Integration URL Formats';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJIntegrationURLFormat_, { nullable: true })
    async MJIntegrationURLFormat(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJIntegrationURLFormat_ | null> {
        this.CheckUserReadPermissions('MJ: Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwIntegrationURLFormats')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Integration URL Formats', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJIntegrationURLFormat_])
    async AllMJIntegrationURLFormats(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwIntegrationURLFormats')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Integration URL Formats', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Integration URL Formats', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJIntegrationURLFormat_)
    async CreateMJIntegrationURLFormat(
        @Arg('input', () => CreateMJIntegrationURLFormatInput) input: CreateMJIntegrationURLFormatInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Integration URL Formats', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJIntegrationURLFormat_)
    async UpdateMJIntegrationURLFormat(
        @Arg('input', () => UpdateMJIntegrationURLFormatInput) input: UpdateMJIntegrationURLFormatInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Integration URL Formats', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJIntegrationURLFormat_)
    async DeleteMJIntegrationURLFormat(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Integration URL Formats', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Integrations
//****************************************************************************
@ObjectType({ description: `Catalog of all integrations that have been configured in the system.` })
export class MJIntegration_ {
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Description?: string;
        
    @Field({nullable: true, description: `Base URL for navigating to records in the external system from MemberJunction.`}) 
    @MaxLength(500)
    NavigationBaseURL?: string;
        
    @Field({nullable: true, description: `The TypeScript/JavaScript class name implementing this integration.`}) 
    @MaxLength(100)
    ClassName?: string;
        
    @Field({nullable: true, description: `Module import path for the integration class in the codebase.`}) 
    @MaxLength(100)
    ImportPath?: string;
        
    @Field(() => Int, {description: `Maximum number of API requests to batch together, -1 for no limit.`}) 
    BatchMaxRequestCount: number;
        
    @Field(() => Int, {description: `Milliseconds to wait before sending a batch of requests, -1 to disable batching.`}) 
    BatchRequestWaitTime: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field(() => [MJIntegrationURLFormat_])
    MJIntegrationURLFormats_IntegrationIDArray: MJIntegrationURLFormat_[]; // Link to MJIntegrationURLFormats
    
    @Field(() => [MJCompanyIntegration_])
    MJCompanyIntegrations_IntegrationNameArray: MJCompanyIntegration_[]; // Link to MJCompanyIntegrations
    
    @Field(() => [MJRecordChange_])
    MJRecordChanges_IntegrationIDArray: MJRecordChange_[]; // Link to MJRecordChanges
    
}

//****************************************************************************
// INPUT TYPE for MJ: Integrations
//****************************************************************************
@InputType()
export class CreateMJIntegrationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    NavigationBaseURL: string | null;

    @Field({ nullable: true })
    ClassName: string | null;

    @Field({ nullable: true })
    ImportPath: string | null;

    @Field(() => Int, { nullable: true })
    BatchMaxRequestCount?: number;

    @Field(() => Int, { nullable: true })
    BatchRequestWaitTime?: number;

    @Field({ nullable: true })
    ID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Integrations
//****************************************************************************
@InputType()
export class UpdateMJIntegrationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    NavigationBaseURL?: string | null;

    @Field({ nullable: true })
    ClassName?: string | null;

    @Field({ nullable: true })
    ImportPath?: string | null;

    @Field(() => Int, { nullable: true })
    BatchMaxRequestCount?: number;

    @Field(() => Int, { nullable: true })
    BatchRequestWaitTime?: number;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Integrations
//****************************************************************************
@ObjectType()
export class RunMJIntegrationViewResult {
    @Field(() => [MJIntegration_])
    Results: MJIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJIntegration_)
export class MJIntegrationResolver extends ResolverBase {
    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJIntegration_, { nullable: true })
    async MJIntegration(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJIntegration_ | null> {
        this.CheckUserReadPermissions('MJ: Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwIntegrations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Integrations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJIntegration_])
    async AllMJIntegrations(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwIntegrations')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Integrations', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJIntegrationURLFormat_])
    async MJIntegrationURLFormats_IntegrationIDArray(@Root() mjintegration_: MJIntegration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwIntegrationURLFormats')} WHERE ${provider.QuoteIdentifier('IntegrationID')}='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Integration URL Formats', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegration_])
    async MJCompanyIntegrations_IntegrationNameArray(@Root() mjintegration_: MJIntegration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrations')} WHERE ${provider.QuoteIdentifier('IntegrationName')}='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async MJRecordChanges_IntegrationIDArray(@Root() mjintegration_: MJIntegration_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordChanges')} WHERE ${provider.QuoteIdentifier('IntegrationID')}='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Changes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJIntegration_)
    async CreateMJIntegration(
        @Arg('input', () => CreateMJIntegrationInput) input: CreateMJIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJIntegration_)
    async UpdateMJIntegration(
        @Arg('input', () => UpdateMJIntegrationInput) input: UpdateMJIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJIntegration_)
    async DeleteMJIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Libraries
//****************************************************************************
@ObjectType({ description: `Stores information about the available libraries, including a list of classes/functions, type definitions, and sample code. You can add additional custom libraries here to make them avaialable to code generation features within the system.` })
export class MJLibrary_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Status of the library, only libraries marked as Active will be available for use by generated code. If a library was once active but no longer is, existing code that used the library will not be affected.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Code showing the types and functions defined in the library to be used for reference by humans and AI`}) 
    TypeDefinitions?: string;
        
    @Field({nullable: true, description: `Examples of code use of the classes and/or functions from within the library`}) 
    SampleCode?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJActionLibrary_])
    MJActionLibraries_LibraryIDArray: MJActionLibrary_[]; // Link to MJActionLibraries
    
    @Field(() => [MJLibraryItem_])
    MJLibraryItems_LibraryIDArray: MJLibraryItem_[]; // Link to MJLibraryItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Libraries
//****************************************************************************
@InputType()
export class CreateMJLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions: string | null;

    @Field({ nullable: true })
    SampleCode: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Libraries
//****************************************************************************
@InputType()
export class UpdateMJLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions?: string | null;

    @Field({ nullable: true })
    SampleCode?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Libraries
//****************************************************************************
@ObjectType()
export class RunMJLibraryViewResult {
    @Field(() => [MJLibrary_])
    Results: MJLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJLibrary_)
export class MJLibraryResolver extends ResolverBase {
    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJLibrary_, { nullable: true })
    async MJLibrary(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJLibrary_ | null> {
        this.CheckUserReadPermissions('MJ: Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwLibraries')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Libraries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJActionLibrary_])
    async MJActionLibraries_LibraryIDArray(@Root() mjlibrary_: MJLibrary_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionLibraries')} WHERE ${provider.QuoteIdentifier('LibraryID')}='${mjlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Libraries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJLibraryItem_])
    async MJLibraryItems_LibraryIDArray(@Root() mjlibrary_: MJLibrary_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Library Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwLibraryItems')} WHERE ${provider.QuoteIdentifier('LibraryID')}='${mjlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Library Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJLibrary_)
    async CreateMJLibrary(
        @Arg('input', () => CreateMJLibraryInput) input: CreateMJLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJLibrary_)
    async UpdateMJLibrary(
        @Arg('input', () => UpdateMJLibraryInput) input: UpdateMJLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJLibrary_)
    async DeleteMJLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Library Items
//****************************************************************************
@ObjectType({ description: `Table to store individual library items` })
export class MJLibraryItem_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field() 
    @MaxLength(36)
    LibraryID: string;
        
    @Field({description: `Type of the library item for example Class, Interface, etc.`}) 
    @MaxLength(50)
    Type: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Library Items
//****************************************************************************
@InputType()
export class CreateMJLibraryItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Library Items
//****************************************************************************
@InputType()
export class UpdateMJLibraryItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Library Items
//****************************************************************************
@ObjectType()
export class RunMJLibraryItemViewResult {
    @Field(() => [MJLibraryItem_])
    Results: MJLibraryItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJLibraryItem_)
export class MJLibraryItemResolver extends ResolverBase {
    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Library Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJLibraryItem_, { nullable: true })
    async MJLibraryItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJLibraryItem_ | null> {
        this.CheckUserReadPermissions('MJ: Library Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwLibraryItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Library Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJLibraryItem_)
    async CreateMJLibraryItem(
        @Arg('input', () => CreateMJLibraryItemInput) input: CreateMJLibraryItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Library Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJLibraryItem_)
    async UpdateMJLibraryItem(
        @Arg('input', () => UpdateMJLibraryItemInput) input: UpdateMJLibraryItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Library Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJLibraryItem_)
    async DeleteMJLibraryItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Library Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: List Categories
//****************************************************************************
@ObjectType({ description: `Groups lists into categories for organization and navigation, supporting hierarchical categorization of user-created lists.` })
export class MJListCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJListCategory_])
    MJListCategories_ParentIDArray: MJListCategory_[]; // Link to MJListCategories
    
    @Field(() => [MJList_])
    MJLists_CategoryIDArray: MJList_[]; // Link to MJLists
    
}

//****************************************************************************
// INPUT TYPE for MJ: List Categories
//****************************************************************************
@InputType()
export class CreateMJListCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: List Categories
//****************************************************************************
@InputType()
export class UpdateMJListCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: List Categories
//****************************************************************************
@ObjectType()
export class RunMJListCategoryViewResult {
    @Field(() => [MJListCategory_])
    Results: MJListCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListCategory_)
export class MJListCategoryResolver extends ResolverBase {
    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: List Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListCategory_, { nullable: true })
    async MJListCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListCategory_ | null> {
        this.CheckUserReadPermissions('MJ: List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: List Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJListCategory_])
    async MJListCategories_ParentIDArray(@Root() mjlistcategory_: MJListCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjlistcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async MJLists_CategoryIDArray(@Root() mjlistcategory_: MJListCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwLists')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjlistcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Lists', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJListCategory_)
    async CreateMJListCategory(
        @Arg('input', () => CreateMJListCategoryInput) input: CreateMJListCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: List Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListCategory_)
    async UpdateMJListCategory(
        @Arg('input', () => UpdateMJListCategoryInput) input: UpdateMJListCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: List Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListCategory_)
    async DeleteMJListCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: List Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: List Details
//****************************************************************************
@ObjectType({ description: `Tracks the records within each list.` })
export class MJListDetail_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ListID: string;
        
    @Field({description: `The ID of the record included in this list.`}) 
    @MaxLength(445)
    RecordID: string;
        
    @Field(() => Int, {description: `Order of this record within the list, for maintaining user-defined sorting.`}) 
    Sequence: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Tracks the status of each individual list detail row to enable processing of various types and the use of the status column for filtering list detail rows within a list that are in a particular state.`}) 
    @MaxLength(30)
    Status: string;
        
    @Field({nullable: true, description: `Optional column that allows for tracking any additional data for each ListDetail row`}) 
    AdditionalData?: string;
        
    @Field() 
    @MaxLength(100)
    List: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: List Details
//****************************************************************************
@InputType()
export class CreateMJListDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: List Details
//****************************************************************************
@InputType()
export class UpdateMJListDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: List Details
//****************************************************************************
@ObjectType()
export class RunMJListDetailViewResult {
    @Field(() => [MJListDetail_])
    Results: MJListDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListDetail_)
export class MJListDetailResolver extends ResolverBase {
    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: List Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListDetail_, { nullable: true })
    async MJListDetail(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListDetail_ | null> {
        this.CheckUserReadPermissions('MJ: List Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListDetails')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: List Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJListDetail_)
    async CreateMJListDetail(
        @Arg('input', () => CreateMJListDetailInput) input: CreateMJListDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: List Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListDetail_)
    async UpdateMJListDetail(
        @Arg('input', () => UpdateMJListDetailInput) input: UpdateMJListDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: List Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListDetail_)
    async DeleteMJListDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: List Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: List Invitations
//****************************************************************************
@ObjectType({ description: `Tracks pending invitations for users to access lists, including external users via email.` })
export class MJListInvitation_ {
    @Field({description: `Unique identifier for the invitation.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The list the user is being invited to.`}) 
    @MaxLength(36)
    ListID: string;
        
    @Field({description: `Email address of the invitee.`}) 
    @MaxLength(255)
    Email: string;
        
    @Field({description: `The role to be assigned upon acceptance (Editor or Viewer).`}) 
    @MaxLength(50)
    Role: string;
        
    @Field({description: `Security token for validating the invitation.`}) 
    @MaxLength(100)
    Token: string;
        
    @Field({description: `When the invitation expires.`}) 
    ExpiresAt: Date;
        
    @Field({description: `The user who created the invitation.`}) 
    @MaxLength(36)
    CreatedByUserID: string;
        
    @Field({description: `Status of the invitation (Pending, Accepted, Expired, Revoked).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    List: string;
        
    @Field() 
    @MaxLength(100)
    CreatedByUser: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: List Invitations
//****************************************************************************
@InputType()
export class CreateMJListInvitationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Token?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: List Invitations
//****************************************************************************
@InputType()
export class UpdateMJListInvitationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Token?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: List Invitations
//****************************************************************************
@ObjectType()
export class RunMJListInvitationViewResult {
    @Field(() => [MJListInvitation_])
    Results: MJListInvitation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListInvitation_)
export class MJListInvitationResolver extends ResolverBase {
    @Query(() => RunMJListInvitationViewResult)
    async RunMJListInvitationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListInvitationViewResult)
    async RunMJListInvitationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListInvitationViewResult)
    async RunMJListInvitationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: List Invitations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListInvitation_, { nullable: true })
    async MJListInvitation(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListInvitation_ | null> {
        this.CheckUserReadPermissions('MJ: List Invitations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListInvitations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Invitations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: List Invitations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJListInvitation_)
    async CreateMJListInvitation(
        @Arg('input', () => CreateMJListInvitationInput) input: CreateMJListInvitationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: List Invitations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListInvitation_)
    async UpdateMJListInvitation(
        @Arg('input', () => UpdateMJListInvitationInput) input: UpdateMJListInvitationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: List Invitations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListInvitation_)
    async DeleteMJListInvitation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: List Invitations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: List Shares
//****************************************************************************
@ObjectType({ description: `Manages user access and permissions for shared lists.` })
export class MJListShare_ {
    @Field({description: `Unique identifier for the share record.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The list being shared.`}) 
    @MaxLength(36)
    ListID: string;
        
    @Field({description: `The user receiving access to the list.`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `The permission level granted (Editor or Viewer).`}) 
    @MaxLength(50)
    Role: string;
        
    @Field({description: `Current status of the share (Active or Pending).`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    List: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: List Shares
//****************************************************************************
@InputType()
export class CreateMJListShareInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: List Shares
//****************************************************************************
@InputType()
export class UpdateMJListShareInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: List Shares
//****************************************************************************
@ObjectType()
export class RunMJListShareViewResult {
    @Field(() => [MJListShare_])
    Results: MJListShare_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListShare_)
export class MJListShareResolver extends ResolverBase {
    @Query(() => RunMJListShareViewResult)
    async RunMJListShareViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListShareViewResult)
    async RunMJListShareViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListShareViewResult)
    async RunMJListShareDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: List Shares';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListShare_, { nullable: true })
    async MJListShare(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListShare_ | null> {
        this.CheckUserReadPermissions('MJ: List Shares', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListShares')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Shares', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: List Shares', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJListShare_)
    async CreateMJListShare(
        @Arg('input', () => CreateMJListShareInput) input: CreateMJListShareInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: List Shares', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListShare_)
    async UpdateMJListShare(
        @Arg('input', () => UpdateMJListShareInput) input: UpdateMJListShareInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: List Shares', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListShare_)
    async DeleteMJListShare(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: List Shares', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Lists
//****************************************************************************
@ObjectType({ description: `Static lists are useful for controlling a set of data for a given entity. These can be used programatically for applications like logging and tracking long-running tasks and also by end users for tracking any particular list of records they want to directly control the set.` })
export class MJList_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field({nullable: true, description: `Identifier for this list in an external system, used for synchronization.`}) 
    @MaxLength(100)
    ExternalSystemRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CompanyIntegrationID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    CompanyIntegration?: string;
        
    @Field(() => [MJListDetail_])
    MJListDetails_ListIDArray: MJListDetail_[]; // Link to MJListDetails
    
    @Field(() => [MJDuplicateRun_])
    MJDuplicateRuns_SourceListIDArray: MJDuplicateRun_[]; // Link to MJDuplicateRuns
    
    @Field(() => [MJListShare_])
    MJListShares_ListIDArray: MJListShare_[]; // Link to MJListShares
    
    @Field(() => [MJListInvitation_])
    MJListInvitations_ListIDArray: MJListInvitation_[]; // Link to MJListInvitations
    
}

//****************************************************************************
// INPUT TYPE for MJ: Lists
//****************************************************************************
@InputType()
export class CreateMJListInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Lists
//****************************************************************************
@InputType()
export class UpdateMJListInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Lists
//****************************************************************************
@ObjectType()
export class RunMJListViewResult {
    @Field(() => [MJList_])
    Results: MJList_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJList_)
export class MJListResolver extends ResolverBase {
    @Query(() => RunMJListViewResult)
    async RunMJListViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListViewResult)
    async RunMJListViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListViewResult)
    async RunMJListDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Lists';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJList_, { nullable: true })
    async MJList(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJList_ | null> {
        this.CheckUserReadPermissions('MJ: Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwLists')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Lists', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJListDetail_])
    async MJListDetails_ListIDArray(@Root() mjlist_: MJList_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListDetails')} WHERE ${provider.QuoteIdentifier('ListID')}='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async MJDuplicateRuns_SourceListIDArray(@Root() mjlist_: MJList_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRuns')} WHERE ${provider.QuoteIdentifier('SourceListID')}='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Duplicate Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListShare_])
    async MJListShares_ListIDArray(@Root() mjlist_: MJList_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Shares', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListShares')} WHERE ${provider.QuoteIdentifier('ListID')}='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Shares', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Shares', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListInvitation_])
    async MJListInvitations_ListIDArray(@Root() mjlist_: MJList_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Invitations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListInvitations')} WHERE ${provider.QuoteIdentifier('ListID')}='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Invitations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Invitations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJList_)
    async CreateMJList(
        @Arg('input', () => CreateMJListInput) input: CreateMJListInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Lists', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJList_)
    async UpdateMJList(
        @Arg('input', () => UpdateMJListInput) input: UpdateMJListInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Lists', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJList_)
    async DeleteMJList(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Lists', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Server Connection Permissions
//****************************************************************************
@ObjectType()
export class MJMCPServerConnectionPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerConnectionID: string;
        
    @Field({nullable: true, description: `FK to User (mutually exclusive with RoleID)`}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field({nullable: true, description: `FK to Role (mutually exclusive with UserID)`}) 
    @MaxLength(36)
    RoleID?: string;
        
    @Field(() => Boolean, {description: `Can invoke tools via this connection`}) 
    CanExecute: boolean;
        
    @Field(() => Boolean, {description: `Can modify connection settings`}) 
    CanModify: boolean;
        
    @Field(() => Boolean, {description: `Can see credential info (but not decrypt)`}) 
    CanViewCredentials: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    MCPServerConnection: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Role?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connection Permissions
//****************************************************************************
@InputType()
export class CreateMJMCPServerConnectionPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field(() => Boolean, { nullable: true })
    CanExecute?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanModify?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanViewCredentials?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connection Permissions
//****************************************************************************
@InputType()
export class UpdateMJMCPServerConnectionPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field(() => Boolean, { nullable: true })
    CanExecute?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanModify?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanViewCredentials?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Server Connection Permissions
//****************************************************************************
@ObjectType()
export class RunMJMCPServerConnectionPermissionViewResult {
    @Field(() => [MJMCPServerConnectionPermission_])
    Results: MJMCPServerConnectionPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServerConnectionPermission_)
export class MJMCPServerConnectionPermissionResolver extends ResolverBase {
    @Query(() => RunMJMCPServerConnectionPermissionViewResult)
    async RunMJMCPServerConnectionPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionPermissionViewResult)
    async RunMJMCPServerConnectionPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionPermissionViewResult)
    async RunMJMCPServerConnectionPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Server Connection Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServerConnectionPermission_, { nullable: true })
    async MJMCPServerConnectionPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServerConnectionPermission_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnectionPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Server Connection Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJMCPServerConnectionPermission_)
    async CreateMJMCPServerConnectionPermission(
        @Arg('input', () => CreateMJMCPServerConnectionPermissionInput) input: CreateMJMCPServerConnectionPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Server Connection Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServerConnectionPermission_)
    async UpdateMJMCPServerConnectionPermission(
        @Arg('input', () => UpdateMJMCPServerConnectionPermissionInput) input: UpdateMJMCPServerConnectionPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Server Connection Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServerConnectionPermission_)
    async DeleteMJMCPServerConnectionPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Server Connection Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Server Connection Tools
//****************************************************************************
@ObjectType()
export class MJMCPServerConnectionTool_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerConnectionID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerToolID: string;
        
    @Field(() => Boolean, {description: `Whether this tool is enabled for the connection`}) 
    IsEnabled: boolean;
        
    @Field({nullable: true, description: `JSON default values for tool inputs`}) 
    DefaultInputValues?: string;
        
    @Field(() => Int, {nullable: true, description: `Override rate limit for this specific tool`}) 
    MaxCallsPerMinute?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    MCPServerConnection: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    MCPServerTool?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connection Tools
//****************************************************************************
@InputType()
export class CreateMJMCPServerConnectionToolInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerToolID?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field({ nullable: true })
    DefaultInputValues: string | null;

    @Field(() => Int, { nullable: true })
    MaxCallsPerMinute: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connection Tools
//****************************************************************************
@InputType()
export class UpdateMJMCPServerConnectionToolInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerToolID?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field({ nullable: true })
    DefaultInputValues?: string | null;

    @Field(() => Int, { nullable: true })
    MaxCallsPerMinute?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Server Connection Tools
//****************************************************************************
@ObjectType()
export class RunMJMCPServerConnectionToolViewResult {
    @Field(() => [MJMCPServerConnectionTool_])
    Results: MJMCPServerConnectionTool_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServerConnectionTool_)
export class MJMCPServerConnectionToolResolver extends ResolverBase {
    @Query(() => RunMJMCPServerConnectionToolViewResult)
    async RunMJMCPServerConnectionToolViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionToolViewResult)
    async RunMJMCPServerConnectionToolViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionToolViewResult)
    async RunMJMCPServerConnectionToolDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Server Connection Tools';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServerConnectionTool_, { nullable: true })
    async MJMCPServerConnectionTool(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServerConnectionTool_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnectionTools')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Server Connection Tools', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJMCPServerConnectionTool_)
    async CreateMJMCPServerConnectionTool(
        @Arg('input', () => CreateMJMCPServerConnectionToolInput) input: CreateMJMCPServerConnectionToolInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Server Connection Tools', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServerConnectionTool_)
    async UpdateMJMCPServerConnectionTool(
        @Arg('input', () => UpdateMJMCPServerConnectionToolInput) input: UpdateMJMCPServerConnectionToolInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Server Connection Tools', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServerConnectionTool_)
    async DeleteMJMCPServerConnectionTool(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Server Connection Tools', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Server Connections
//****************************************************************************
@ObjectType()
export class MJMCPServerConnection_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerID: string;
        
    @Field({description: `Connection name (unique per company)`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `FK to Credential entity (uses existing credential types)`}) 
    @MaxLength(36)
    CredentialID?: string;
        
    @Field({nullable: true, description: `Custom header name for API key auth (default: X-API-Key)`}) 
    @MaxLength(100)
    CustomHeaderName?: string;
        
    @Field({nullable: true, description: `Optional company association. NULL means the connection is global and available to all companies. Non-NULL restricts the connection to that specific company.`}) 
    @MaxLength(36)
    CompanyID?: string;
        
    @Field() 
    @MaxLength(50)
    Status: string;
        
    @Field(() => Boolean, {description: `Auto-sync tools when connecting`}) 
    AutoSyncTools: boolean;
        
    @Field(() => Boolean, {description: `Auto-generate MJ Actions for discovered tools`}) 
    AutoGenerateActions: boolean;
        
    @Field(() => Boolean, {description: `Log all tool calls to execution log`}) 
    LogToolCalls: boolean;
        
    @Field(() => Boolean, {description: `Include input parameters in logs`}) 
    LogInputParameters: boolean;
        
    @Field(() => Boolean, {description: `Include output content in logs`}) 
    LogOutputContent: boolean;
        
    @Field(() => Int, {nullable: true, description: `Max output size to log in bytes (default: 100KB)`}) 
    MaxOutputLogSize?: number;
        
    @Field({nullable: true}) 
    LastConnectedAt?: Date;
        
    @Field({nullable: true}) 
    LastErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON object of environment variables for Stdio transport`}) 
    EnvironmentVars?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    MCPServer: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Credential?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Company?: string;
        
    @Field(() => [MJMCPServerConnectionTool_])
    MJMCPServerConnectionTools_MCPServerConnectionIDArray: MJMCPServerConnectionTool_[]; // Link to MJMCPServerConnectionTools
    
    @Field(() => [MJMCPToolExecutionLog_])
    MJMCPToolExecutionLogs_MCPServerConnectionIDArray: MJMCPToolExecutionLog_[]; // Link to MJMCPToolExecutionLogs
    
    @Field(() => [MJOAuthClientRegistration_])
    MJOAuthClientRegistrations_MCPServerConnectionIDArray: MJOAuthClientRegistration_[]; // Link to MJOAuthClientRegistrations
    
    @Field(() => [MJOAuthToken_])
    MJOAuthTokens_MCPServerConnectionIDArray: MJOAuthToken_[]; // Link to MJOAuthTokens
    
    @Field(() => [MJOAuthAuthorizationState_])
    MJOAuthAuthorizationStates_MCPServerConnectionIDArray: MJOAuthAuthorizationState_[]; // Link to MJOAuthAuthorizationStates
    
    @Field(() => [MJMCPServerConnectionPermission_])
    MJMCPServerConnectionPermissions_MCPServerConnectionIDArray: MJMCPServerConnectionPermission_[]; // Link to MJMCPServerConnectionPermissions
    
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connections
//****************************************************************************
@InputType()
export class CreateMJMCPServerConnectionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CredentialID: string | null;

    @Field({ nullable: true })
    CustomHeaderName: string | null;

    @Field({ nullable: true })
    CompanyID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    AutoSyncTools?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoGenerateActions?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogToolCalls?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogInputParameters?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogOutputContent?: boolean;

    @Field(() => Int, { nullable: true })
    MaxOutputLogSize?: number | null;

    @Field({ nullable: true })
    LastConnectedAt: Date | null;

    @Field({ nullable: true })
    LastErrorMessage: string | null;

    @Field({ nullable: true })
    EnvironmentVars: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connections
//****************************************************************************
@InputType()
export class UpdateMJMCPServerConnectionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CredentialID?: string | null;

    @Field({ nullable: true })
    CustomHeaderName?: string | null;

    @Field({ nullable: true })
    CompanyID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    AutoSyncTools?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoGenerateActions?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogToolCalls?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogInputParameters?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogOutputContent?: boolean;

    @Field(() => Int, { nullable: true })
    MaxOutputLogSize?: number | null;

    @Field({ nullable: true })
    LastConnectedAt?: Date | null;

    @Field({ nullable: true })
    LastErrorMessage?: string | null;

    @Field({ nullable: true })
    EnvironmentVars?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Server Connections
//****************************************************************************
@ObjectType()
export class RunMJMCPServerConnectionViewResult {
    @Field(() => [MJMCPServerConnection_])
    Results: MJMCPServerConnection_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServerConnection_)
export class MJMCPServerConnectionResolver extends ResolverBase {
    @Query(() => RunMJMCPServerConnectionViewResult)
    async RunMJMCPServerConnectionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionViewResult)
    async RunMJMCPServerConnectionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionViewResult)
    async RunMJMCPServerConnectionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Server Connections';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServerConnection_, { nullable: true })
    async MJMCPServerConnection(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServerConnection_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Server Connections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnections')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Server Connections', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJMCPServerConnectionTool_])
    async MJMCPServerConnectionTools_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnectionTools')} WHERE ${provider.QuoteIdentifier('MCPServerConnectionID')}='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPToolExecutionLog_])
    async MJMCPToolExecutionLogs_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Tool Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPToolExecutionLogs')} WHERE ${provider.QuoteIdentifier('MCPServerConnectionID')}='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Tool Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Tool Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOAuthClientRegistration_])
    async MJOAuthClientRegistrations_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Client Registrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthClientRegistrations')} WHERE ${provider.QuoteIdentifier('MCPServerConnectionID')}='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Client Registrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Client Registrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOAuthToken_])
    async MJOAuthTokens_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Tokens', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthTokens')} WHERE ${provider.QuoteIdentifier('MCPServerConnectionID')}='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Tokens', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Tokens', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOAuthAuthorizationState_])
    async MJOAuthAuthorizationStates_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Authorization States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthAuthorizationStates')} WHERE ${provider.QuoteIdentifier('MCPServerConnectionID')}='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Authorization States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Authorization States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnectionPermission_])
    async MJMCPServerConnectionPermissions_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnectionPermissions')} WHERE ${provider.QuoteIdentifier('MCPServerConnectionID')}='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJMCPServerConnection_)
    async CreateMJMCPServerConnection(
        @Arg('input', () => CreateMJMCPServerConnectionInput) input: CreateMJMCPServerConnectionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Server Connections', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServerConnection_)
    async UpdateMJMCPServerConnection(
        @Arg('input', () => UpdateMJMCPServerConnectionInput) input: UpdateMJMCPServerConnectionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Server Connections', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServerConnection_)
    async DeleteMJMCPServerConnection(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Server Connections', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Server Tools
//****************************************************************************
@ObjectType()
export class MJMCPServerTool_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerID: string;
        
    @Field({description: `Tool identifier from the MCP server`}) 
    @MaxLength(255)
    ToolName: string;
        
    @Field({nullable: true, description: `Human-readable title for the tool`}) 
    @MaxLength(255)
    ToolTitle?: string;
        
    @Field({nullable: true}) 
    ToolDescription?: string;
        
    @Field({description: `JSON Schema for tool input parameters`}) 
    InputSchema: string;
        
    @Field({nullable: true, description: `JSON Schema for tool output (if provided)`}) 
    OutputSchema?: string;
        
    @Field({nullable: true, description: `JSON with tool hints (readOnlyHint, destructiveHint, etc.)`}) 
    Annotations?: string;
        
    @Field({description: `Tool status: Active, Inactive, or Deprecated`}) 
    @MaxLength(50)
    Status: string;
        
    @Field() 
    DiscoveredAt: Date;
        
    @Field() 
    LastSeenAt: Date;
        
    @Field({nullable: true, description: `FK to auto-generated Action (if promoted)`}) 
    @MaxLength(36)
    GeneratedActionID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    GeneratedActionCategoryID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    MCPServer: string;
        
    @Field({nullable: true}) 
    @MaxLength(425)
    GeneratedAction?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    GeneratedActionCategory?: string;
        
    @Field(() => [MJMCPServerConnectionTool_])
    MJMCPServerConnectionTools_MCPServerToolIDArray: MJMCPServerConnectionTool_[]; // Link to MJMCPServerConnectionTools
    
    @Field(() => [MJMCPToolExecutionLog_])
    MJMCPToolExecutionLogs_MCPServerToolIDArray: MJMCPToolExecutionLog_[]; // Link to MJMCPToolExecutionLogs
    
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Tools
//****************************************************************************
@InputType()
export class CreateMJMCPServerToolInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    ToolName?: string;

    @Field({ nullable: true })
    ToolTitle: string | null;

    @Field({ nullable: true })
    ToolDescription: string | null;

    @Field({ nullable: true })
    InputSchema?: string;

    @Field({ nullable: true })
    OutputSchema: string | null;

    @Field({ nullable: true })
    Annotations: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DiscoveredAt?: Date;

    @Field({ nullable: true })
    LastSeenAt?: Date;

    @Field({ nullable: true })
    GeneratedActionID: string | null;

    @Field({ nullable: true })
    GeneratedActionCategoryID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Tools
//****************************************************************************
@InputType()
export class UpdateMJMCPServerToolInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    ToolName?: string;

    @Field({ nullable: true })
    ToolTitle?: string | null;

    @Field({ nullable: true })
    ToolDescription?: string | null;

    @Field({ nullable: true })
    InputSchema?: string;

    @Field({ nullable: true })
    OutputSchema?: string | null;

    @Field({ nullable: true })
    Annotations?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DiscoveredAt?: Date;

    @Field({ nullable: true })
    LastSeenAt?: Date;

    @Field({ nullable: true })
    GeneratedActionID?: string | null;

    @Field({ nullable: true })
    GeneratedActionCategoryID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Server Tools
//****************************************************************************
@ObjectType()
export class RunMJMCPServerToolViewResult {
    @Field(() => [MJMCPServerTool_])
    Results: MJMCPServerTool_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServerTool_)
export class MJMCPServerToolResolver extends ResolverBase {
    @Query(() => RunMJMCPServerToolViewResult)
    async RunMJMCPServerToolViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerToolViewResult)
    async RunMJMCPServerToolViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerToolViewResult)
    async RunMJMCPServerToolDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Server Tools';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServerTool_, { nullable: true })
    async MJMCPServerTool(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServerTool_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Server Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerTools')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Server Tools', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJMCPServerConnectionTool_])
    async MJMCPServerConnectionTools_MCPServerToolIDArray(@Root() mjmcpservertool_: MJMCPServerTool_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnectionTools')} WHERE ${provider.QuoteIdentifier('MCPServerToolID')}='${mjmcpservertool_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPToolExecutionLog_])
    async MJMCPToolExecutionLogs_MCPServerToolIDArray(@Root() mjmcpservertool_: MJMCPServerTool_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Tool Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPToolExecutionLogs')} WHERE ${provider.QuoteIdentifier('MCPServerToolID')}='${mjmcpservertool_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Tool Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Tool Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJMCPServerTool_)
    async CreateMJMCPServerTool(
        @Arg('input', () => CreateMJMCPServerToolInput) input: CreateMJMCPServerToolInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Server Tools', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServerTool_)
    async UpdateMJMCPServerTool(
        @Arg('input', () => UpdateMJMCPServerToolInput) input: UpdateMJMCPServerToolInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Server Tools', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServerTool_)
    async DeleteMJMCPServerTool(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Server Tools', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Servers
//****************************************************************************
@ObjectType()
export class MJMCPServer_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique display name for the MCP server`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Server endpoint URL for HTTP/SSE/WebSocket transports`}) 
    @MaxLength(1000)
    ServerURL?: string;
        
    @Field({nullable: true, description: `Executable path for Stdio transport`}) 
    @MaxLength(500)
    Command?: string;
        
    @Field({nullable: true, description: `JSON array of command arguments for Stdio transport`}) 
    CommandArgs?: string;
        
    @Field({description: `Transport type: StreamableHTTP, SSE, Stdio, or WebSocket`}) 
    @MaxLength(50)
    TransportType: string;
        
    @Field({description: `Default auth type: None, Bearer, APIKey, OAuth2, Basic, or Custom`}) 
    @MaxLength(50)
    DefaultAuthType: string;
        
    @Field({nullable: true, description: `Expected credential type for this server`}) 
    @MaxLength(36)
    CredentialTypeID?: string;
        
    @Field({description: `Server status: Active, Inactive, or Deprecated`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({nullable: true}) 
    LastSyncAt?: Date;
        
    @Field(() => Int, {nullable: true}) 
    RateLimitPerMinute?: number;
        
    @Field(() => Int, {nullable: true}) 
    RateLimitPerHour?: number;
        
    @Field(() => Int, {nullable: true}) 
    ConnectionTimeoutMs?: number;
        
    @Field(() => Int, {nullable: true}) 
    RequestTimeoutMs?: number;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    DocumentationURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    IconClass?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Authorization server issuer URL for OAuth 2.1 authentication (e.g., https://auth.example.com).`}) 
    @MaxLength(1000)
    OAuthIssuerURL?: string;
        
    @Field({nullable: true, description: `Space-delimited OAuth scopes to request (e.g., "read write admin").`}) 
    @MaxLength(500)
    OAuthScopes?: string;
        
    @Field(() => Int, {nullable: true, description: `Cache TTL for authorization server metadata in minutes. Default 1440 (24 hours).`}) 
    OAuthMetadataCacheTTLMinutes?: number;
        
    @Field({nullable: true, description: `Pre-configured OAuth client ID (when DCR is not supported).`}) 
    @MaxLength(255)
    OAuthClientID?: string;
        
    @Field({nullable: true, description: `Pre-configured OAuth client secret (encrypted at rest, when DCR is not supported).`}) 
    OAuthClientSecretEncrypted?: string;
        
    @Field(() => Boolean, {description: `Whether to require PKCE for OAuth flows. Always true for OAuth 2.1 compliance.`}) 
    OAuthRequirePKCE: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    CredentialType?: string;
        
    @Field(() => [MJOAuthClientRegistration_])
    MJOAuthClientRegistrations_MCPServerIDArray: MJOAuthClientRegistration_[]; // Link to MJOAuthClientRegistrations
    
    @Field(() => [MJMCPServerTool_])
    MJMCPServerTools_MCPServerIDArray: MJMCPServerTool_[]; // Link to MJMCPServerTools
    
    @Field(() => [MJMCPServerConnection_])
    MJMCPServerConnections_MCPServerIDArray: MJMCPServerConnection_[]; // Link to MJMCPServerConnections
    
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Servers
//****************************************************************************
@InputType()
export class CreateMJMCPServerInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ServerURL: string | null;

    @Field({ nullable: true })
    Command: string | null;

    @Field({ nullable: true })
    CommandArgs: string | null;

    @Field({ nullable: true })
    TransportType?: string;

    @Field({ nullable: true })
    DefaultAuthType?: string;

    @Field({ nullable: true })
    CredentialTypeID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LastSyncAt: Date | null;

    @Field(() => Int, { nullable: true })
    RateLimitPerMinute: number | null;

    @Field(() => Int, { nullable: true })
    RateLimitPerHour: number | null;

    @Field(() => Int, { nullable: true })
    ConnectionTimeoutMs?: number | null;

    @Field(() => Int, { nullable: true })
    RequestTimeoutMs?: number | null;

    @Field({ nullable: true })
    DocumentationURL: string | null;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    OAuthIssuerURL: string | null;

    @Field({ nullable: true })
    OAuthScopes: string | null;

    @Field(() => Int, { nullable: true })
    OAuthMetadataCacheTTLMinutes?: number | null;

    @Field({ nullable: true })
    OAuthClientID: string | null;

    @Field({ nullable: true })
    OAuthClientSecretEncrypted: string | null;

    @Field(() => Boolean, { nullable: true })
    OAuthRequirePKCE?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Servers
//****************************************************************************
@InputType()
export class UpdateMJMCPServerInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ServerURL?: string | null;

    @Field({ nullable: true })
    Command?: string | null;

    @Field({ nullable: true })
    CommandArgs?: string | null;

    @Field({ nullable: true })
    TransportType?: string;

    @Field({ nullable: true })
    DefaultAuthType?: string;

    @Field({ nullable: true })
    CredentialTypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LastSyncAt?: Date | null;

    @Field(() => Int, { nullable: true })
    RateLimitPerMinute?: number | null;

    @Field(() => Int, { nullable: true })
    RateLimitPerHour?: number | null;

    @Field(() => Int, { nullable: true })
    ConnectionTimeoutMs?: number | null;

    @Field(() => Int, { nullable: true })
    RequestTimeoutMs?: number | null;

    @Field({ nullable: true })
    DocumentationURL?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    OAuthIssuerURL?: string | null;

    @Field({ nullable: true })
    OAuthScopes?: string | null;

    @Field(() => Int, { nullable: true })
    OAuthMetadataCacheTTLMinutes?: number | null;

    @Field({ nullable: true })
    OAuthClientID?: string | null;

    @Field({ nullable: true })
    OAuthClientSecretEncrypted?: string | null;

    @Field(() => Boolean, { nullable: true })
    OAuthRequirePKCE?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Servers
//****************************************************************************
@ObjectType()
export class RunMJMCPServerViewResult {
    @Field(() => [MJMCPServer_])
    Results: MJMCPServer_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServer_)
export class MJMCPServerResolver extends ResolverBase {
    @Query(() => RunMJMCPServerViewResult)
    async RunMJMCPServerViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerViewResult)
    async RunMJMCPServerViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerViewResult)
    async RunMJMCPServerDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Servers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServer_, { nullable: true })
    async MJMCPServer(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServer_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Servers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServers')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Servers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Servers', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJOAuthClientRegistration_])
    async MJOAuthClientRegistrations_MCPServerIDArray(@Root() mjmcpserver_: MJMCPServer_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Client Registrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthClientRegistrations')} WHERE ${provider.QuoteIdentifier('MCPServerID')}='${mjmcpserver_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Client Registrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Client Registrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerTool_])
    async MJMCPServerTools_MCPServerIDArray(@Root() mjmcpserver_: MJMCPServer_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerTools')} WHERE ${provider.QuoteIdentifier('MCPServerID')}='${mjmcpserver_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnection_])
    async MJMCPServerConnections_MCPServerIDArray(@Root() mjmcpserver_: MJMCPServer_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnections')} WHERE ${provider.QuoteIdentifier('MCPServerID')}='${mjmcpserver_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJMCPServer_)
    async CreateMJMCPServer(
        @Arg('input', () => CreateMJMCPServerInput) input: CreateMJMCPServerInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Servers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServer_)
    async UpdateMJMCPServer(
        @Arg('input', () => UpdateMJMCPServerInput) input: UpdateMJMCPServerInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Servers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServer_)
    async DeleteMJMCPServer(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Servers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Tool Execution Logs
//****************************************************************************
@ObjectType()
export class MJMCPToolExecutionLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerConnectionID: string;
        
    @Field({nullable: true, description: `FK to MCP Server Tool (null if tool not cached)`}) 
    @MaxLength(36)
    MCPServerToolID?: string;
        
    @Field({description: `Tool name (stored directly for resilience)`}) 
    @MaxLength(255)
    ToolName: string;
        
    @Field({description: `FK to User who initiated the call`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    StartedAt: Date;
        
    @Field({nullable: true}) 
    EndedAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Execution duration in milliseconds`}) 
    DurationMs?: number;
        
    @Field(() => Boolean) 
    Success: boolean;
        
    @Field({nullable: true}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON of input parameters (if logging enabled)`}) 
    InputParameters?: string;
        
    @Field({nullable: true, description: `JSON of output content (if logging enabled)`}) 
    OutputContent?: string;
        
    @Field(() => Boolean, {description: `Whether output was truncated due to size`}) 
    OutputTruncated: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    MCPServerConnection: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    MCPServerTool?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Tool Execution Logs
//****************************************************************************
@InputType()
export class CreateMJMCPToolExecutionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerToolID: string | null;

    @Field({ nullable: true })
    ToolName?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field(() => Int, { nullable: true })
    DurationMs: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    InputParameters: string | null;

    @Field({ nullable: true })
    OutputContent: string | null;

    @Field(() => Boolean, { nullable: true })
    OutputTruncated?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Tool Execution Logs
//****************************************************************************
@InputType()
export class UpdateMJMCPToolExecutionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerToolID?: string | null;

    @Field({ nullable: true })
    ToolName?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    DurationMs?: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    InputParameters?: string | null;

    @Field({ nullable: true })
    OutputContent?: string | null;

    @Field(() => Boolean, { nullable: true })
    OutputTruncated?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Tool Execution Logs
//****************************************************************************
@ObjectType()
export class RunMJMCPToolExecutionLogViewResult {
    @Field(() => [MJMCPToolExecutionLog_])
    Results: MJMCPToolExecutionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPToolExecutionLog_)
export class MJMCPToolExecutionLogResolver extends ResolverBase {
    @Query(() => RunMJMCPToolExecutionLogViewResult)
    async RunMJMCPToolExecutionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPToolExecutionLogViewResult)
    async RunMJMCPToolExecutionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPToolExecutionLogViewResult)
    async RunMJMCPToolExecutionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Tool Execution Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPToolExecutionLog_, { nullable: true })
    async MJMCPToolExecutionLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPToolExecutionLog_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Tool Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPToolExecutionLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Tool Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Tool Execution Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJMCPToolExecutionLog_)
    async CreateMJMCPToolExecutionLog(
        @Arg('input', () => CreateMJMCPToolExecutionLogInput) input: CreateMJMCPToolExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Tool Execution Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPToolExecutionLog_)
    async UpdateMJMCPToolExecutionLog(
        @Arg('input', () => UpdateMJMCPToolExecutionLogInput) input: UpdateMJMCPToolExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Tool Execution Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPToolExecutionLog_)
    async DeleteMJMCPToolExecutionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Tool Execution Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: O Auth Auth Server Metadata Caches
//****************************************************************************
@ObjectType({ description: `Caches OAuth 2.0 Authorization Server Metadata (RFC 8414) to reduce discovery requests.` })
export class MJOAuthAuthServerMetadataCache_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Authorization server issuer identifier URL.`}) 
    @MaxLength(1000)
    IssuerURL: string;
        
    @Field({description: `URL of the authorization endpoint.`}) 
    @MaxLength(1000)
    AuthorizationEndpoint: string;
        
    @Field({description: `URL of the token endpoint.`}) 
    @MaxLength(1000)
    TokenEndpoint: string;
        
    @Field({nullable: true, description: `URL of the dynamic client registration endpoint (RFC 7591).`}) 
    @MaxLength(1000)
    RegistrationEndpoint?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    RevocationEndpoint?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    JwksURI?: string;
        
    @Field({nullable: true}) 
    ScopesSupported?: string;
        
    @Field() 
    ResponseTypesSupported: string;
        
    @Field({nullable: true}) 
    GrantTypesSupported?: string;
        
    @Field({nullable: true}) 
    TokenEndpointAuthMethods?: string;
        
    @Field({nullable: true}) 
    CodeChallengeMethodsSupported?: string;
        
    @Field({description: `Full authorization server metadata JSON for debugging and extensibility.`}) 
    MetadataJSON: string;
        
    @Field() 
    CachedAt: Date;
        
    @Field() 
    ExpiresAt: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for MJ: O Auth Auth Server Metadata Caches
//****************************************************************************
@InputType()
export class CreateMJOAuthAuthServerMetadataCacheInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    AuthorizationEndpoint?: string;

    @Field({ nullable: true })
    TokenEndpoint?: string;

    @Field({ nullable: true })
    RegistrationEndpoint: string | null;

    @Field({ nullable: true })
    RevocationEndpoint: string | null;

    @Field({ nullable: true })
    JwksURI: string | null;

    @Field({ nullable: true })
    ScopesSupported: string | null;

    @Field({ nullable: true })
    ResponseTypesSupported?: string;

    @Field({ nullable: true })
    GrantTypesSupported: string | null;

    @Field({ nullable: true })
    TokenEndpointAuthMethods: string | null;

    @Field({ nullable: true })
    CodeChallengeMethodsSupported: string | null;

    @Field({ nullable: true })
    MetadataJSON?: string;

    @Field({ nullable: true })
    CachedAt?: Date;

    @Field({ nullable: true })
    ExpiresAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for MJ: O Auth Auth Server Metadata Caches
//****************************************************************************
@InputType()
export class UpdateMJOAuthAuthServerMetadataCacheInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    AuthorizationEndpoint?: string;

    @Field({ nullable: true })
    TokenEndpoint?: string;

    @Field({ nullable: true })
    RegistrationEndpoint?: string | null;

    @Field({ nullable: true })
    RevocationEndpoint?: string | null;

    @Field({ nullable: true })
    JwksURI?: string | null;

    @Field({ nullable: true })
    ScopesSupported?: string | null;

    @Field({ nullable: true })
    ResponseTypesSupported?: string;

    @Field({ nullable: true })
    GrantTypesSupported?: string | null;

    @Field({ nullable: true })
    TokenEndpointAuthMethods?: string | null;

    @Field({ nullable: true })
    CodeChallengeMethodsSupported?: string | null;

    @Field({ nullable: true })
    MetadataJSON?: string;

    @Field({ nullable: true })
    CachedAt?: Date;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: O Auth Auth Server Metadata Caches
//****************************************************************************
@ObjectType()
export class RunMJOAuthAuthServerMetadataCacheViewResult {
    @Field(() => [MJOAuthAuthServerMetadataCache_])
    Results: MJOAuthAuthServerMetadataCache_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOAuthAuthServerMetadataCache_)
export class MJOAuthAuthServerMetadataCacheResolver extends ResolverBase {
    @Query(() => RunMJOAuthAuthServerMetadataCacheViewResult)
    async RunMJOAuthAuthServerMetadataCacheViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthAuthServerMetadataCacheViewResult)
    async RunMJOAuthAuthServerMetadataCacheViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthAuthServerMetadataCacheViewResult)
    async RunMJOAuthAuthServerMetadataCacheDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: O Auth Auth Server Metadata Caches';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOAuthAuthServerMetadataCache_, { nullable: true })
    async MJOAuthAuthServerMetadataCache(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOAuthAuthServerMetadataCache_ | null> {
        this.CheckUserReadPermissions('MJ: O Auth Auth Server Metadata Caches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthAuthServerMetadataCaches')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Auth Server Metadata Caches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: O Auth Auth Server Metadata Caches', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOAuthAuthServerMetadataCache_)
    async CreateMJOAuthAuthServerMetadataCache(
        @Arg('input', () => CreateMJOAuthAuthServerMetadataCacheInput) input: CreateMJOAuthAuthServerMetadataCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: O Auth Auth Server Metadata Caches', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOAuthAuthServerMetadataCache_)
    async UpdateMJOAuthAuthServerMetadataCache(
        @Arg('input', () => UpdateMJOAuthAuthServerMetadataCacheInput) input: UpdateMJOAuthAuthServerMetadataCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: O Auth Auth Server Metadata Caches', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOAuthAuthServerMetadataCache_)
    async DeleteMJOAuthAuthServerMetadataCache(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: O Auth Auth Server Metadata Caches', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: O Auth Authorization States
//****************************************************************************
@ObjectType({ description: `Tracks in-progress OAuth authorization flows with PKCE data for security.` })
export class MJOAuthAuthorizationState_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerConnectionID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `Cryptographic state parameter for CSRF protection.`}) 
    @MaxLength(128)
    StateParameter: string;
        
    @Field({description: `PKCE code verifier for token exchange (stored securely, never sent to auth server).`}) 
    @MaxLength(128)
    CodeVerifier: string;
        
    @Field({description: `PKCE code challenge sent to authorization server.`}) 
    @MaxLength(128)
    CodeChallenge: string;
        
    @Field() 
    @MaxLength(1000)
    RedirectURI: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    RequestedScopes?: string;
        
    @Field({description: `Flow status: Pending, Completed, Failed, or Expired.`}) 
    @MaxLength(50)
    Status: string;
        
    @Field() 
    AuthorizationURL: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ErrorCode?: string;
        
    @Field({nullable: true}) 
    ErrorDescription?: string;
        
    @Field() 
    InitiatedAt: Date;
        
    @Field() 
    ExpiresAt: Date;
        
    @Field({nullable: true}) 
    CompletedAt?: Date;
        
    @Field({nullable: true, description: `URL to redirect the user to after OAuth completion. If set, the OAuth callback will redirect here instead of showing a static HTML page.`}) 
    @MaxLength(1000)
    FrontendReturnURL?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    MCPServerConnection: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: O Auth Authorization States
//****************************************************************************
@InputType()
export class CreateMJOAuthAuthorizationStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    StateParameter?: string;

    @Field({ nullable: true })
    CodeVerifier?: string;

    @Field({ nullable: true })
    CodeChallenge?: string;

    @Field({ nullable: true })
    RedirectURI?: string;

    @Field({ nullable: true })
    RequestedScopes: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AuthorizationURL?: string;

    @Field({ nullable: true })
    ErrorCode: string | null;

    @Field({ nullable: true })
    ErrorDescription: string | null;

    @Field({ nullable: true })
    InitiatedAt?: Date;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field({ nullable: true })
    FrontendReturnURL: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: O Auth Authorization States
//****************************************************************************
@InputType()
export class UpdateMJOAuthAuthorizationStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    StateParameter?: string;

    @Field({ nullable: true })
    CodeVerifier?: string;

    @Field({ nullable: true })
    CodeChallenge?: string;

    @Field({ nullable: true })
    RedirectURI?: string;

    @Field({ nullable: true })
    RequestedScopes?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AuthorizationURL?: string;

    @Field({ nullable: true })
    ErrorCode?: string | null;

    @Field({ nullable: true })
    ErrorDescription?: string | null;

    @Field({ nullable: true })
    InitiatedAt?: Date;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field({ nullable: true })
    FrontendReturnURL?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: O Auth Authorization States
//****************************************************************************
@ObjectType()
export class RunMJOAuthAuthorizationStateViewResult {
    @Field(() => [MJOAuthAuthorizationState_])
    Results: MJOAuthAuthorizationState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOAuthAuthorizationState_)
export class MJOAuthAuthorizationStateResolver extends ResolverBase {
    @Query(() => RunMJOAuthAuthorizationStateViewResult)
    async RunMJOAuthAuthorizationStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthAuthorizationStateViewResult)
    async RunMJOAuthAuthorizationStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthAuthorizationStateViewResult)
    async RunMJOAuthAuthorizationStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: O Auth Authorization States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOAuthAuthorizationState_, { nullable: true })
    async MJOAuthAuthorizationState(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOAuthAuthorizationState_ | null> {
        this.CheckUserReadPermissions('MJ: O Auth Authorization States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthAuthorizationStates')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Authorization States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: O Auth Authorization States', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOAuthAuthorizationState_)
    async CreateMJOAuthAuthorizationState(
        @Arg('input', () => CreateMJOAuthAuthorizationStateInput) input: CreateMJOAuthAuthorizationStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: O Auth Authorization States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOAuthAuthorizationState_)
    async UpdateMJOAuthAuthorizationState(
        @Arg('input', () => UpdateMJOAuthAuthorizationStateInput) input: UpdateMJOAuthAuthorizationStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: O Auth Authorization States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOAuthAuthorizationState_)
    async DeleteMJOAuthAuthorizationState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: O Auth Authorization States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: O Auth Client Registrations
//****************************************************************************
@ObjectType({ description: `Stores OAuth Dynamic Client Registration (DCR) results per RFC 7591.` })
export class MJOAuthClientRegistration_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The MCP Server Connection this registration belongs to.`}) 
    @MaxLength(36)
    MCPServerConnectionID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerID: string;
        
    @Field() 
    @MaxLength(1000)
    IssuerURL: string;
        
    @Field({description: `OAuth client ID assigned by the authorization server.`}) 
    @MaxLength(500)
    ClientID: string;
        
    @Field({nullable: true, description: `OAuth client secret (encrypted at rest) for confidential clients.`}) 
    ClientSecretEncrypted?: string;
        
    @Field({nullable: true}) 
    ClientIDIssuedAt?: Date;
        
    @Field({nullable: true}) 
    ClientSecretExpiresAt?: Date;
        
    @Field({nullable: true}) 
    RegistrationAccessToken?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    RegistrationClientURI?: string;
        
    @Field() 
    RedirectURIs: string;
        
    @Field() 
    GrantTypes: string;
        
    @Field() 
    ResponseTypes: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Scope?: string;
        
    @Field({description: `Registration status: Active, Expired, or Revoked.`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({description: `Full DCR response JSON for debugging and extensibility.`}) 
    RegistrationResponse: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    MCPServerConnection: string;
        
    @Field() 
    @MaxLength(255)
    MCPServer: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: O Auth Client Registrations
//****************************************************************************
@InputType()
export class CreateMJOAuthClientRegistrationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    ClientID?: string;

    @Field({ nullable: true })
    ClientSecretEncrypted: string | null;

    @Field({ nullable: true })
    ClientIDIssuedAt: Date | null;

    @Field({ nullable: true })
    ClientSecretExpiresAt: Date | null;

    @Field({ nullable: true })
    RegistrationAccessToken: string | null;

    @Field({ nullable: true })
    RegistrationClientURI: string | null;

    @Field({ nullable: true })
    RedirectURIs?: string;

    @Field({ nullable: true })
    GrantTypes?: string;

    @Field({ nullable: true })
    ResponseTypes?: string;

    @Field({ nullable: true })
    Scope: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    RegistrationResponse?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: O Auth Client Registrations
//****************************************************************************
@InputType()
export class UpdateMJOAuthClientRegistrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    ClientID?: string;

    @Field({ nullable: true })
    ClientSecretEncrypted?: string | null;

    @Field({ nullable: true })
    ClientIDIssuedAt?: Date | null;

    @Field({ nullable: true })
    ClientSecretExpiresAt?: Date | null;

    @Field({ nullable: true })
    RegistrationAccessToken?: string | null;

    @Field({ nullable: true })
    RegistrationClientURI?: string | null;

    @Field({ nullable: true })
    RedirectURIs?: string;

    @Field({ nullable: true })
    GrantTypes?: string;

    @Field({ nullable: true })
    ResponseTypes?: string;

    @Field({ nullable: true })
    Scope?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    RegistrationResponse?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: O Auth Client Registrations
//****************************************************************************
@ObjectType()
export class RunMJOAuthClientRegistrationViewResult {
    @Field(() => [MJOAuthClientRegistration_])
    Results: MJOAuthClientRegistration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOAuthClientRegistration_)
export class MJOAuthClientRegistrationResolver extends ResolverBase {
    @Query(() => RunMJOAuthClientRegistrationViewResult)
    async RunMJOAuthClientRegistrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthClientRegistrationViewResult)
    async RunMJOAuthClientRegistrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthClientRegistrationViewResult)
    async RunMJOAuthClientRegistrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: O Auth Client Registrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOAuthClientRegistration_, { nullable: true })
    async MJOAuthClientRegistration(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOAuthClientRegistration_ | null> {
        this.CheckUserReadPermissions('MJ: O Auth Client Registrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthClientRegistrations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Client Registrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: O Auth Client Registrations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOAuthClientRegistration_)
    async CreateMJOAuthClientRegistration(
        @Arg('input', () => CreateMJOAuthClientRegistrationInput) input: CreateMJOAuthClientRegistrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: O Auth Client Registrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOAuthClientRegistration_)
    async UpdateMJOAuthClientRegistration(
        @Arg('input', () => UpdateMJOAuthClientRegistrationInput) input: UpdateMJOAuthClientRegistrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: O Auth Client Registrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOAuthClientRegistration_)
    async DeleteMJOAuthClientRegistration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: O Auth Client Registrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: O Auth Tokens
//****************************************************************************
@ObjectType({ description: `Stores OAuth token metadata for MCP server connections. Actual tokens are stored via CredentialEngine for consistent encryption and audit logging.` })
export class MJOAuthToken_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    MCPServerConnectionID: string;
        
    @Field({nullable: true, description: `Foreign key to Credential table where the OAuth tokens (access and refresh) are stored securely via CredentialEngine.`}) 
    @MaxLength(36)
    CredentialID?: string;
        
    @Field() 
    @MaxLength(50)
    TokenType: string;
        
    @Field({description: `When the access token expires.`}) 
    ExpiresAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Scope?: string;
        
    @Field() 
    @MaxLength(1000)
    IssuerURL: string;
        
    @Field({nullable: true}) 
    LastRefreshAt?: Date;
        
    @Field(() => Int, {description: `Number of times the token has been refreshed.`}) 
    RefreshCount: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    MCPServerConnection: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Credential?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: O Auth Tokens
//****************************************************************************
@InputType()
export class CreateMJOAuthTokenInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    CredentialID: string | null;

    @Field({ nullable: true })
    TokenType?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    Scope: string | null;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    LastRefreshAt: Date | null;

    @Field(() => Int, { nullable: true })
    RefreshCount?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: O Auth Tokens
//****************************************************************************
@InputType()
export class UpdateMJOAuthTokenInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    CredentialID?: string | null;

    @Field({ nullable: true })
    TokenType?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    Scope?: string | null;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    LastRefreshAt?: Date | null;

    @Field(() => Int, { nullable: true })
    RefreshCount?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: O Auth Tokens
//****************************************************************************
@ObjectType()
export class RunMJOAuthTokenViewResult {
    @Field(() => [MJOAuthToken_])
    Results: MJOAuthToken_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOAuthToken_)
export class MJOAuthTokenResolver extends ResolverBase {
    @Query(() => RunMJOAuthTokenViewResult)
    async RunMJOAuthTokenViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthTokenViewResult)
    async RunMJOAuthTokenViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthTokenViewResult)
    async RunMJOAuthTokenDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: O Auth Tokens';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOAuthToken_, { nullable: true })
    async MJOAuthToken(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOAuthToken_ | null> {
        this.CheckUserReadPermissions('MJ: O Auth Tokens', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthTokens')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Tokens', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: O Auth Tokens', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOAuthToken_)
    async CreateMJOAuthToken(
        @Arg('input', () => CreateMJOAuthTokenInput) input: CreateMJOAuthTokenInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: O Auth Tokens', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOAuthToken_)
    async UpdateMJOAuthToken(
        @Arg('input', () => UpdateMJOAuthTokenInput) input: UpdateMJOAuthTokenInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: O Auth Tokens', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOAuthToken_)
    async DeleteMJOAuthToken(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: O Auth Tokens', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Open App Dependencies
//****************************************************************************
@ObjectType({ description: `Inter-app dependency relationships between installed Open Apps` })
export class MJOpenAppDependency_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    OpenAppID: string;
        
    @Field({description: `Name of the app that this app depends on (matches OpenApp.Name)`}) 
    @MaxLength(64)
    DependsOnAppName: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    DependsOnAppID?: string;
        
    @Field({description: `Semver range specifying which versions of the dependency are acceptable (e.g. ^1.0.0)`}) 
    @MaxLength(100)
    VersionRange: string;
        
    @Field({nullable: true, description: `Actual installed version of the dependency (NULL if not yet installed)`}) 
    @MaxLength(50)
    InstalledVersion?: string;
        
    @Field({description: `Whether the dependency is satisfied: Satisfied, Missing, or Incompatible`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(64)
    OpenApp: string;
        
    @Field({nullable: true}) 
    @MaxLength(64)
    DependsOnApp?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Open App Dependencies
//****************************************************************************
@InputType()
export class CreateMJOpenAppDependencyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    OpenAppID?: string;

    @Field({ nullable: true })
    DependsOnAppName?: string;

    @Field({ nullable: true })
    DependsOnAppID: string | null;

    @Field({ nullable: true })
    VersionRange?: string;

    @Field({ nullable: true })
    InstalledVersion: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Open App Dependencies
//****************************************************************************
@InputType()
export class UpdateMJOpenAppDependencyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    OpenAppID?: string;

    @Field({ nullable: true })
    DependsOnAppName?: string;

    @Field({ nullable: true })
    DependsOnAppID?: string | null;

    @Field({ nullable: true })
    VersionRange?: string;

    @Field({ nullable: true })
    InstalledVersion?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Open App Dependencies
//****************************************************************************
@ObjectType()
export class RunMJOpenAppDependencyViewResult {
    @Field(() => [MJOpenAppDependency_])
    Results: MJOpenAppDependency_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOpenAppDependency_)
export class MJOpenAppDependencyResolver extends ResolverBase {
    @Query(() => RunMJOpenAppDependencyViewResult)
    async RunMJOpenAppDependencyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOpenAppDependencyViewResult)
    async RunMJOpenAppDependencyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOpenAppDependencyViewResult)
    async RunMJOpenAppDependencyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Open App Dependencies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOpenAppDependency_, { nullable: true })
    async MJOpenAppDependency(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOpenAppDependency_ | null> {
        this.CheckUserReadPermissions('MJ: Open App Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOpenAppDependencies')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Open App Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Open App Dependencies', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOpenAppDependency_)
    async CreateMJOpenAppDependency(
        @Arg('input', () => CreateMJOpenAppDependencyInput) input: CreateMJOpenAppDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Open App Dependencies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOpenAppDependency_)
    async UpdateMJOpenAppDependency(
        @Arg('input', () => UpdateMJOpenAppDependencyInput) input: UpdateMJOpenAppDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Open App Dependencies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOpenAppDependency_)
    async DeleteMJOpenAppDependency(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Open App Dependencies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Open App Install Histories
//****************************************************************************
@ObjectType({ description: `Audit trail of every install, upgrade, and removal for Open Apps` })
export class MJOpenAppInstallHistory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    OpenAppID: string;
        
    @Field({description: `Semver version that was installed or upgraded to in this operation`}) 
    @MaxLength(50)
    Version: string;
        
    @Field({nullable: true, description: `Version that was installed before this operation (NULL for initial installs)`}) 
    @MaxLength(50)
    PreviousVersion?: string;
        
    @Field({description: `Type of operation performed: Install, Upgrade, or Remove`}) 
    @MaxLength(20)
    Action: string;
        
    @Field({description: `Snapshot of the mj-app.json manifest at the time of this operation`}) 
    ManifestJSON: string;
        
    @Field({nullable: true, description: `Human-readable summary of what happened during this operation`}) 
    Summary?: string;
        
    @Field() 
    @MaxLength(36)
    ExecutedByUserID: string;
        
    @Field(() => Int, {nullable: true, description: `Total wall-clock seconds the operation took to complete`}) 
    DurationSeconds?: number;
        
    @Field({nullable: true, description: `Timestamp when the operation began`}) 
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when the operation completed (success or failure)`}) 
    EndedAt?: Date;
        
    @Field(() => Boolean, {description: `Whether the operation completed successfully (1) or failed (0)`}) 
    Success: boolean;
        
    @Field({nullable: true, description: `Detailed error message if the operation failed`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `Which phase of the operation failed: Schema, Migration, Packages, Config, Hooks, or Record`}) 
    @MaxLength(50)
    ErrorPhase?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(64)
    OpenApp: string;
        
    @Field() 
    @MaxLength(100)
    ExecutedByUser: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Open App Install Histories
//****************************************************************************
@InputType()
export class CreateMJOpenAppInstallHistoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    OpenAppID?: string;

    @Field({ nullable: true })
    Version?: string;

    @Field({ nullable: true })
    PreviousVersion: string | null;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ManifestJSON?: string;

    @Field({ nullable: true })
    Summary: string | null;

    @Field({ nullable: true })
    ExecutedByUserID?: string;

    @Field(() => Int, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ErrorPhase: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Open App Install Histories
//****************************************************************************
@InputType()
export class UpdateMJOpenAppInstallHistoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    OpenAppID?: string;

    @Field({ nullable: true })
    Version?: string;

    @Field({ nullable: true })
    PreviousVersion?: string | null;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ManifestJSON?: string;

    @Field({ nullable: true })
    Summary?: string | null;

    @Field({ nullable: true })
    ExecutedByUserID?: string;

    @Field(() => Int, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ErrorPhase?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Open App Install Histories
//****************************************************************************
@ObjectType()
export class RunMJOpenAppInstallHistoryViewResult {
    @Field(() => [MJOpenAppInstallHistory_])
    Results: MJOpenAppInstallHistory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOpenAppInstallHistory_)
export class MJOpenAppInstallHistoryResolver extends ResolverBase {
    @Query(() => RunMJOpenAppInstallHistoryViewResult)
    async RunMJOpenAppInstallHistoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOpenAppInstallHistoryViewResult)
    async RunMJOpenAppInstallHistoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOpenAppInstallHistoryViewResult)
    async RunMJOpenAppInstallHistoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Open App Install Histories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOpenAppInstallHistory_, { nullable: true })
    async MJOpenAppInstallHistory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOpenAppInstallHistory_ | null> {
        this.CheckUserReadPermissions('MJ: Open App Install Histories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOpenAppInstallHistories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Open App Install Histories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Open App Install Histories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOpenAppInstallHistory_)
    async CreateMJOpenAppInstallHistory(
        @Arg('input', () => CreateMJOpenAppInstallHistoryInput) input: CreateMJOpenAppInstallHistoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Open App Install Histories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOpenAppInstallHistory_)
    async UpdateMJOpenAppInstallHistory(
        @Arg('input', () => UpdateMJOpenAppInstallHistoryInput) input: UpdateMJOpenAppInstallHistoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Open App Install Histories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOpenAppInstallHistory_)
    async DeleteMJOpenAppInstallHistory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Open App Install Histories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Open Apps
//****************************************************************************
@ObjectType({ description: `Tracks all MJ Open Apps installed in this instance` })
export class MJOpenApp_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique lowercase identifier for the app (e.g. acme-crm). Must contain only lowercase letters, digits, and hyphens.`}) 
    @MaxLength(64)
    Name: string;
        
    @Field({description: `Human-readable display name shown in the UI (e.g. Acme CRM)`}) 
    @MaxLength(200)
    DisplayName: string;
        
    @Field({nullable: true, description: `Optional long description of what this app does`}) 
    Description?: string;
        
    @Field({description: `Currently installed semver version string (e.g. 1.2.3)`}) 
    @MaxLength(50)
    Version: string;
        
    @Field({description: `Name of the organization or individual who published the app`}) 
    @MaxLength(200)
    Publisher: string;
        
    @Field({nullable: true, description: `Optional contact email for the publisher`}) 
    @MaxLength(255)
    PublisherEmail?: string;
        
    @Field({nullable: true, description: `Optional website URL for the publisher`}) 
    @MaxLength(500)
    PublisherURL?: string;
        
    @Field({description: `GitHub repository URL where this app is hosted`}) 
    @MaxLength(500)
    RepositoryURL: string;
        
    @Field({nullable: true, description: `Database schema name used by this app for its tables and objects. Unique per instance.`}) 
    @MaxLength(128)
    SchemaName?: string;
        
    @Field({description: `Semver range specifying which MJ versions this app is compatible with (e.g. >=4.0.0 <5.0.0)`}) 
    @MaxLength(100)
    MJVersionRange: string;
        
    @Field({nullable: true, description: `SPDX license identifier for this app (e.g. MIT, Apache-2.0)`}) 
    @MaxLength(50)
    License?: string;
        
    @Field({nullable: true, description: `Optional icon identifier (e.g. Font Awesome class) for UI display`}) 
    @MaxLength(100)
    Icon?: string;
        
    @Field({nullable: true, description: `Optional hex color code for branding in the UI (e.g. #FF5733)`}) 
    @MaxLength(20)
    Color?: string;
        
    @Field({description: `Full mj-app.json manifest stored as JSON for the currently installed version`}) 
    ManifestJSON: string;
        
    @Field({nullable: true, description: `Optional JSON Schema defining the configuration options this app accepts`}) 
    ConfigurationSchemaJSON?: string;
        
    @Field() 
    @MaxLength(36)
    InstalledByUserID: string;
        
    @Field({description: `Current lifecycle status of the app: Active, Disabled, Error, Installing, Upgrading, Removing, or Removed`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    InstalledByUser: string;
        
    @Field(() => [MJOpenAppDependency_])
    MJOpenAppDependencies_OpenAppIDArray: MJOpenAppDependency_[]; // Link to MJOpenAppDependencies
    
    @Field(() => [MJOpenAppDependency_])
    MJOpenAppDependencies_DependsOnAppIDArray: MJOpenAppDependency_[]; // Link to MJOpenAppDependencies
    
    @Field(() => [MJOpenAppInstallHistory_])
    MJOpenAppInstallHistories_OpenAppIDArray: MJOpenAppInstallHistory_[]; // Link to MJOpenAppInstallHistories
    
}

//****************************************************************************
// INPUT TYPE for MJ: Open Apps
//****************************************************************************
@InputType()
export class CreateMJOpenAppInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Version?: string;

    @Field({ nullable: true })
    Publisher?: string;

    @Field({ nullable: true })
    PublisherEmail: string | null;

    @Field({ nullable: true })
    PublisherURL: string | null;

    @Field({ nullable: true })
    RepositoryURL?: string;

    @Field({ nullable: true })
    SchemaName: string | null;

    @Field({ nullable: true })
    MJVersionRange?: string;

    @Field({ nullable: true })
    License: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field({ nullable: true })
    ManifestJSON?: string;

    @Field({ nullable: true })
    ConfigurationSchemaJSON: string | null;

    @Field({ nullable: true })
    InstalledByUserID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Open Apps
//****************************************************************************
@InputType()
export class UpdateMJOpenAppInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Version?: string;

    @Field({ nullable: true })
    Publisher?: string;

    @Field({ nullable: true })
    PublisherEmail?: string | null;

    @Field({ nullable: true })
    PublisherURL?: string | null;

    @Field({ nullable: true })
    RepositoryURL?: string;

    @Field({ nullable: true })
    SchemaName?: string | null;

    @Field({ nullable: true })
    MJVersionRange?: string;

    @Field({ nullable: true })
    License?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field({ nullable: true })
    ManifestJSON?: string;

    @Field({ nullable: true })
    ConfigurationSchemaJSON?: string | null;

    @Field({ nullable: true })
    InstalledByUserID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Open Apps
//****************************************************************************
@ObjectType()
export class RunMJOpenAppViewResult {
    @Field(() => [MJOpenApp_])
    Results: MJOpenApp_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOpenApp_)
export class MJOpenAppResolver extends ResolverBase {
    @Query(() => RunMJOpenAppViewResult)
    async RunMJOpenAppViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOpenAppViewResult)
    async RunMJOpenAppViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOpenAppViewResult)
    async RunMJOpenAppDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Open Apps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOpenApp_, { nullable: true })
    async MJOpenApp(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOpenApp_ | null> {
        this.CheckUserReadPermissions('MJ: Open Apps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOpenApps')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Open Apps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Open Apps', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJOpenAppDependency_])
    async MJOpenAppDependencies_OpenAppIDArray(@Root() mjopenapp_: MJOpenApp_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Open App Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOpenAppDependencies')} WHERE ${provider.QuoteIdentifier('OpenAppID')}='${mjopenapp_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Open App Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Open App Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOpenAppDependency_])
    async MJOpenAppDependencies_DependsOnAppIDArray(@Root() mjopenapp_: MJOpenApp_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Open App Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOpenAppDependencies')} WHERE ${provider.QuoteIdentifier('DependsOnAppID')}='${mjopenapp_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Open App Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Open App Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOpenAppInstallHistory_])
    async MJOpenAppInstallHistories_OpenAppIDArray(@Root() mjopenapp_: MJOpenApp_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Open App Install Histories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOpenAppInstallHistories')} WHERE ${provider.QuoteIdentifier('OpenAppID')}='${mjopenapp_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Open App Install Histories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Open App Install Histories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJOpenApp_)
    async CreateMJOpenApp(
        @Arg('input', () => CreateMJOpenAppInput) input: CreateMJOpenAppInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Open Apps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOpenApp_)
    async UpdateMJOpenApp(
        @Arg('input', () => UpdateMJOpenAppInput) input: UpdateMJOpenAppInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Open Apps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOpenApp_)
    async DeleteMJOpenApp(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Open Apps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Output Delivery Types
//****************************************************************************
@ObjectType({ description: `Defines methods for delivering generated outputs such as email, file storage, API endpoints, or messaging platforms.` })
export class MJOutputDeliveryType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    MJReports_OutputDeliveryTypeIDArray: MJReport_[]; // Link to MJReports
    
}

//****************************************************************************
// INPUT TYPE for MJ: Output Delivery Types
//****************************************************************************
@InputType()
export class CreateMJOutputDeliveryTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Output Delivery Types
//****************************************************************************
@InputType()
export class UpdateMJOutputDeliveryTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Output Delivery Types
//****************************************************************************
@ObjectType()
export class RunMJOutputDeliveryTypeViewResult {
    @Field(() => [MJOutputDeliveryType_])
    Results: MJOutputDeliveryType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputDeliveryType_)
export class MJOutputDeliveryTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Output Delivery Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputDeliveryType_, { nullable: true })
    async MJOutputDeliveryType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputDeliveryType_ | null> {
        this.CheckUserReadPermissions('MJ: Output Delivery Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOutputDeliveryTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Output Delivery Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Output Delivery Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async MJReports_OutputDeliveryTypeIDArray(@Root() mjoutputdeliverytype_: MJOutputDeliveryType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('OutputDeliveryTypeID')}='${mjoutputdeliverytype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJOutputDeliveryType_)
    async CreateMJOutputDeliveryType(
        @Arg('input', () => CreateMJOutputDeliveryTypeInput) input: CreateMJOutputDeliveryTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Output Delivery Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOutputDeliveryType_)
    async UpdateMJOutputDeliveryType(
        @Arg('input', () => UpdateMJOutputDeliveryTypeInput) input: UpdateMJOutputDeliveryTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Output Delivery Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOutputDeliveryType_)
    async DeleteMJOutputDeliveryType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Output Delivery Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Output Format Types
//****************************************************************************
@ObjectType({ description: `Specifies available output formats for generated content including PDF, Excel, CSV, JSON, and custom formats.` })
export class MJOutputFormatType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Configuration or template for how data should be formatted in this output type.`}) 
    DisplayFormat?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    MJReports_OutputFormatTypeIDArray: MJReport_[]; // Link to MJReports
    
}

//****************************************************************************
// INPUT TYPE for MJ: Output Format Types
//****************************************************************************
@InputType()
export class CreateMJOutputFormatTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DisplayFormat: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Output Format Types
//****************************************************************************
@InputType()
export class UpdateMJOutputFormatTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DisplayFormat?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Output Format Types
//****************************************************************************
@ObjectType()
export class RunMJOutputFormatTypeViewResult {
    @Field(() => [MJOutputFormatType_])
    Results: MJOutputFormatType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputFormatType_)
export class MJOutputFormatTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Output Format Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputFormatType_, { nullable: true })
    async MJOutputFormatType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputFormatType_ | null> {
        this.CheckUserReadPermissions('MJ: Output Format Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOutputFormatTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Output Format Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Output Format Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async MJReports_OutputFormatTypeIDArray(@Root() mjoutputformattype_: MJOutputFormatType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('OutputFormatTypeID')}='${mjoutputformattype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJOutputFormatType_)
    async CreateMJOutputFormatType(
        @Arg('input', () => CreateMJOutputFormatTypeInput) input: CreateMJOutputFormatTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Output Format Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOutputFormatType_)
    async UpdateMJOutputFormatType(
        @Arg('input', () => UpdateMJOutputFormatTypeInput) input: UpdateMJOutputFormatTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Output Format Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOutputFormatType_)
    async DeleteMJOutputFormatType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Output Format Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Output Trigger Types
//****************************************************************************
@ObjectType({ description: `Defines events that can trigger output generation such as schedules, data changes, or manual requests.` })
export class MJOutputTriggerType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    MJReports_OutputTriggerTypeIDArray: MJReport_[]; // Link to MJReports
    
}

//****************************************************************************
// INPUT TYPE for MJ: Output Trigger Types
//****************************************************************************
@InputType()
export class CreateMJOutputTriggerTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Output Trigger Types
//****************************************************************************
@InputType()
export class UpdateMJOutputTriggerTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Output Trigger Types
//****************************************************************************
@ObjectType()
export class RunMJOutputTriggerTypeViewResult {
    @Field(() => [MJOutputTriggerType_])
    Results: MJOutputTriggerType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputTriggerType_)
export class MJOutputTriggerTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Output Trigger Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputTriggerType_, { nullable: true })
    async MJOutputTriggerType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputTriggerType_ | null> {
        this.CheckUserReadPermissions('MJ: Output Trigger Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOutputTriggerTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Output Trigger Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Output Trigger Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async MJReports_OutputTriggerTypeIDArray(@Root() mjoutputtriggertype_: MJOutputTriggerType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('OutputTriggerTypeID')}='${mjoutputtriggertype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJOutputTriggerType_)
    async CreateMJOutputTriggerType(
        @Arg('input', () => CreateMJOutputTriggerTypeInput) input: CreateMJOutputTriggerTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Output Trigger Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOutputTriggerType_)
    async UpdateMJOutputTriggerType(
        @Arg('input', () => UpdateMJOutputTriggerTypeInput) input: UpdateMJOutputTriggerTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Output Trigger Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOutputTriggerType_)
    async DeleteMJOutputTriggerType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Output Trigger Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Projects
//****************************************************************************
@ObjectType({ description: `Container for grouping related conversations around a common topic, client, or initiative. Supports nesting for sub-projects.` })
export class MJProject_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Display name for the project`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the project goals and scope`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Hex color code for project badges in UI (#RRGGBB format)`}) 
    @MaxLength(7)
    Color?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for UI display`}) 
    @MaxLength(50)
    Icon?: string;
        
    @Field(() => Boolean, {description: `Indicates if this project is archived and should be hidden from active lists`}) 
    IsArchived: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Environment: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJProject_])
    MJProjects_ParentIDArray: MJProject_[]; // Link to MJProjects
    
    @Field(() => [MJConversation_])
    MJConversations_ProjectIDArray: MJConversation_[]; // Link to MJConversations
    
    @Field(() => [MJTask_])
    MJTasks_ProjectIDArray: MJTask_[]; // Link to MJTasks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Projects
//****************************************************************************
@InputType()
export class CreateMJProjectInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Projects
//****************************************************************************
@InputType()
export class UpdateMJProjectInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Projects
//****************************************************************************
@ObjectType()
export class RunMJProjectViewResult {
    @Field(() => [MJProject_])
    Results: MJProject_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJProject_)
export class MJProjectResolver extends ResolverBase {
    @Query(() => RunMJProjectViewResult)
    async RunMJProjectViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJProjectViewResult)
    async RunMJProjectViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJProjectViewResult)
    async RunMJProjectDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Projects';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJProject_, { nullable: true })
    async MJProject(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJProject_ | null> {
        this.CheckUserReadPermissions('MJ: Projects', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwProjects')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Projects', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Projects', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJProject_])
    async MJProjects_ParentIDArray(@Root() mjproject_: MJProject_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Projects', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwProjects')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjproject_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Projects', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Projects', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async MJConversations_ProjectIDArray(@Root() mjproject_: MJProject_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversations')} WHERE ${provider.QuoteIdentifier('ProjectID')}='${mjproject_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJTasks_ProjectIDArray(@Root() mjproject_: MJProject_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTasks')} WHERE ${provider.QuoteIdentifier('ProjectID')}='${mjproject_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJProject_)
    async CreateMJProject(
        @Arg('input', () => CreateMJProjectInput) input: CreateMJProjectInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Projects', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJProject_)
    async UpdateMJProject(
        @Arg('input', () => UpdateMJProjectInput) input: UpdateMJProjectInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Projects', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJProject_)
    async DeleteMJProject(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Projects', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Public Links
//****************************************************************************
@ObjectType({ description: `Shareable links for external access to artifacts and other resources. Supports password protection and expiration.` })
export class MJPublicLink_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Type of resource being shared (Artifact, Conversation, Collection)`}) 
    @MaxLength(50)
    ResourceType: string;
        
    @Field() 
    @MaxLength(36)
    ResourceID: string;
        
    @Field({description: `Unique token for accessing the shared resource via URL`}) 
    @MaxLength(255)
    Token: string;
        
    @Field({nullable: true, description: `SHA256 hash of optional password for additional security`}) 
    @MaxLength(255)
    PasswordHash?: string;
        
    @Field({nullable: true, description: `Optional expiration date/time for this public link`}) 
    ExpiresAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of times this link can be viewed`}) 
    MaxViews?: number;
        
    @Field(() => Int, {description: `Current count of how many times this link has been viewed`}) 
    CurrentViews: number;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field(() => Boolean, {description: `Indicates if this link is currently active and accessible`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Public Links
//****************************************************************************
@InputType()
export class CreateMJPublicLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ResourceType?: string;

    @Field({ nullable: true })
    ResourceID?: string;

    @Field({ nullable: true })
    Token?: string;

    @Field({ nullable: true })
    PasswordHash: string | null;

    @Field({ nullable: true })
    ExpiresAt: Date | null;

    @Field(() => Int, { nullable: true })
    MaxViews: number | null;

    @Field(() => Int, { nullable: true })
    CurrentViews?: number;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Public Links
//****************************************************************************
@InputType()
export class UpdateMJPublicLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ResourceType?: string;

    @Field({ nullable: true })
    ResourceID?: string;

    @Field({ nullable: true })
    Token?: string;

    @Field({ nullable: true })
    PasswordHash?: string | null;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field(() => Int, { nullable: true })
    MaxViews?: number | null;

    @Field(() => Int, { nullable: true })
    CurrentViews?: number;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Public Links
//****************************************************************************
@ObjectType()
export class RunMJPublicLinkViewResult {
    @Field(() => [MJPublicLink_])
    Results: MJPublicLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJPublicLink_)
export class MJPublicLinkResolver extends ResolverBase {
    @Query(() => RunMJPublicLinkViewResult)
    async RunMJPublicLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJPublicLinkViewResult)
    async RunMJPublicLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJPublicLinkViewResult)
    async RunMJPublicLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Public Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJPublicLink_, { nullable: true })
    async MJPublicLink(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJPublicLink_ | null> {
        this.CheckUserReadPermissions('MJ: Public Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwPublicLinks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Public Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Public Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJPublicLink_)
    async CreateMJPublicLink(
        @Arg('input', () => CreateMJPublicLinkInput) input: CreateMJPublicLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Public Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJPublicLink_)
    async UpdateMJPublicLink(
        @Arg('input', () => UpdateMJPublicLinkInput) input: UpdateMJPublicLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Public Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJPublicLink_)
    async DeleteMJPublicLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Public Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Queries
//****************************************************************************
@ObjectType({ description: `Catalog of stored queries. This is useful for any arbitrary query that is known to be performant and correct and can be reused. Queries can be viewed/run by a user, used programatically via RunQuery, and also used by AI systems for improved reliability instead of dynamically generated SQL. Queries can also improve security since they store the SQL instead of using dynamic SQL.` })
export class MJQuery_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field({nullable: true, description: `The natural language question this query answers, used for AI query selection.`}) 
    UserQuestion?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `The actual SQL query text to execute, may include parameters.`}) 
    SQL?: string;
        
    @Field({nullable: true, description: `Technical documentation of the query logic, performance considerations, and parameter usage.`}) 
    TechnicalDescription?: string;
        
    @Field({nullable: true, description: `The original SQL before any optimization or modification, kept for reference.`}) 
    OriginalSQL?: string;
        
    @Field({nullable: true, description: `User feedback on query accuracy, performance, or suggested improvements.`}) 
    Feedback?: string;
        
    @Field() 
    @MaxLength(15)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Value indicating the quality of the query, higher values mean a better quality`}) 
    QualityRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Higher numbers indicate more execution overhead/time required. Useful for planning which queries to use in various scenarios.`}) 
    ExecutionCostRank?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Automatically set to true when the SQL column contains Nunjucks template markers (e.g., {{ paramName }}). This flag is maintained by the QueryEntityServer for performance optimization and discovery purposes. It allows quick filtering of parameterized queries and enables the UI to show parameter inputs only when needed. The system will automatically update this flag when the SQL content changes.`}) 
    UsesTemplate?: boolean;
        
    @Field(() => Boolean, {description: `When true, all executions of this query will be logged to the Audit Log system for tracking and compliance`}) 
    AuditQueryRuns: boolean;
        
    @Field(() => Boolean, {description: `When true, enables query result caching. Caching behavior depends on CacheValidationSQL: (1) If CacheValidationSQL is NULL, uses simple server-side TTL caching based on CacheTTLMinutes - results are cached on the server and expire after the TTL period. (2) If CacheValidationSQL is set, enables smart client-side caching with freshness validation - client sends cache fingerprint (maxUpdatedAt + rowCount) to server, server validates using CacheValidationSQL and returns 'current' (use cached) or 'stale' (with fresh data). Smart caching provides real-time accuracy while minimizing data transfer.`}) 
    CacheEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time-to-live in minutes for cached query results. NULL uses default TTL.`}) 
    CacheTTLMinutes?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of cached result sets for this query. NULL uses default size limit.`}) 
    CacheMaxSize?: number;
        
    @Field({nullable: true, description: `Optional JSON-serialized embedding vector for the query, used for similarity search and query analysis`}) 
    EmbeddingVector?: string;
        
    @Field({nullable: true, description: `The AI Model used to generate the embedding vector for this query. Required for vector similarity comparisons.`}) 
    @MaxLength(36)
    EmbeddingModelID?: string;
        
    @Field({nullable: true, description: `SQL query used to validate cache freshness for smart caching. When set (and CacheEnabled=true), enables smart cache validation instead of simple TTL expiration. This query MUST return exactly two columns: MaxUpdatedAt (datetime/datetimeoffset) and TotalRows (int). The query has access to the same Nunjucks parameters as the main query SQL. When NULL, caching uses TTL-only behavior based on CacheTTLMinutes. Example: SELECT MAX(__mj_UpdatedAt) AS MaxUpdatedAt, COUNT(*) AS TotalRows FROM Orders WHERE Status = '{{ status }}'`}) 
    CacheValidationSQL?: string;
        
    @Field({description: `The SQL dialect that the SQL column is written in. Defaults to T-SQL for backward compatibility.`}) 
    @MaxLength(36)
    SQLDialectID: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    EmbeddingModel?: string;
        
    @Field() 
    @MaxLength(100)
    SQLDialect: string;
        
    @Field(() => [MJQueryField_])
    MJQueryFields_QueryIDArray: MJQueryField_[]; // Link to MJQueryFields
    
    @Field(() => [MJQueryPermission_])
    MJQueryPermissions_QueryIDArray: MJQueryPermission_[]; // Link to MJQueryPermissions
    
    @Field(() => [MJDataContextItem_])
    MJDataContextItems_QueryIDArray: MJDataContextItem_[]; // Link to MJDataContextItems
    
    @Field(() => [MJQueryParameter_])
    MJQueryParameters_QueryIDArray: MJQueryParameter_[]; // Link to MJQueryParameters
    
    @Field(() => [MJQueryEntity_])
    MJQueryEntities_QueryIDArray: MJQueryEntity_[]; // Link to MJQueryEntities
    
    @Field(() => [MJQuerySQL_])
    MJQuerySQLs_QueryIDArray: MJQuerySQL_[]; // Link to MJQuerySQLs
    
}

//****************************************************************************
// INPUT TYPE for MJ: Queries
//****************************************************************************
@InputType()
export class CreateMJQueryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserQuestion: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    TechnicalDescription: string | null;

    @Field({ nullable: true })
    OriginalSQL: string | null;

    @Field({ nullable: true })
    Feedback: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank: number | null;

    @Field(() => Boolean, { nullable: true })
    UsesTemplate?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    AuditQueryRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLMinutes: number | null;

    @Field(() => Int, { nullable: true })
    CacheMaxSize: number | null;

    @Field({ nullable: true })
    EmbeddingVector: string | null;

    @Field({ nullable: true })
    EmbeddingModelID: string | null;

    @Field({ nullable: true })
    CacheValidationSQL: string | null;

    @Field({ nullable: true })
    SQLDialectID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Queries
//****************************************************************************
@InputType()
export class UpdateMJQueryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserQuestion?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    TechnicalDescription?: string | null;

    @Field({ nullable: true })
    OriginalSQL?: string | null;

    @Field({ nullable: true })
    Feedback?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    UsesTemplate?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    AuditQueryRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLMinutes?: number | null;

    @Field(() => Int, { nullable: true })
    CacheMaxSize?: number | null;

    @Field({ nullable: true })
    EmbeddingVector?: string | null;

    @Field({ nullable: true })
    EmbeddingModelID?: string | null;

    @Field({ nullable: true })
    CacheValidationSQL?: string | null;

    @Field({ nullable: true })
    SQLDialectID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Queries
//****************************************************************************
@ObjectType()
export class RunMJQueryViewResult {
    @Field(() => [MJQuery_])
    Results: MJQuery_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQuery_)
export class MJQueryResolver extends ResolverBase {
    @Query(() => RunMJQueryViewResult)
    async RunMJQueryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryViewResult)
    async RunMJQueryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryViewResult)
    async RunMJQueryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Queries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQuery_, { nullable: true })
    async MJQuery(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQuery_ | null> {
        this.CheckUserReadPermissions('MJ: Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueries')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Queries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQueryField_])
    async MJQueryFields_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryFields')} WHERE ${provider.QuoteIdentifier('QueryID')}='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryPermission_])
    async MJQueryPermissions_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryPermissions')} WHERE ${provider.QuoteIdentifier('QueryID')}='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async MJDataContextItems_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDataContextItems')} WHERE ${provider.QuoteIdentifier('QueryID')}='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Data Context Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryParameter_])
    async MJQueryParameters_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Parameters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryParameters')} WHERE ${provider.QuoteIdentifier('QueryID')}='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Parameters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Parameters', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryEntity_])
    async MJQueryEntities_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryEntities')} WHERE ${provider.QuoteIdentifier('QueryID')}='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQuerySQL_])
    async MJQuerySQLs_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query SQLs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQuerySQLs')} WHERE ${provider.QuoteIdentifier('QueryID')}='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query SQLs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query SQLs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJQuery_)
    async CreateMJQuery(
        @Arg('input', () => CreateMJQueryInput) input: CreateMJQueryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Queries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQuery_)
    async UpdateMJQuery(
        @Arg('input', () => UpdateMJQueryInput) input: UpdateMJQueryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Queries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQuery_)
    async DeleteMJQuery(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Queries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Query Categories
//****************************************************************************
@ObjectType({ description: `Organizes saved queries into categories for discovery and management, supporting folder-like organization of queries.` })
export class MJQueryCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Default cache setting for queries in this category`}) 
    DefaultCacheEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Default TTL in minutes for cached results of queries in this category`}) 
    DefaultCacheTTLMinutes?: number;
        
    @Field(() => Int, {nullable: true, description: `Default maximum cache size for queries in this category`}) 
    DefaultCacheMaxSize?: number;
        
    @Field(() => Boolean, {description: `When true, queries without cache config will inherit from this category`}) 
    CacheInheritanceEnabled: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Parent?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJQueryCategory_])
    MJQueryCategories_ParentIDArray: MJQueryCategory_[]; // Link to MJQueryCategories
    
    @Field(() => [MJQuery_])
    MJQueries_CategoryIDArray: MJQuery_[]; // Link to MJQueries
    
}

//****************************************************************************
// INPUT TYPE for MJ: Query Categories
//****************************************************************************
@InputType()
export class CreateMJQueryCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    DefaultCacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    DefaultCacheTTLMinutes: number | null;

    @Field(() => Int, { nullable: true })
    DefaultCacheMaxSize: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheInheritanceEnabled?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Query Categories
//****************************************************************************
@InputType()
export class UpdateMJQueryCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    DefaultCacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    DefaultCacheTTLMinutes?: number | null;

    @Field(() => Int, { nullable: true })
    DefaultCacheMaxSize?: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheInheritanceEnabled?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Query Categories
//****************************************************************************
@ObjectType()
export class RunMJQueryCategoryViewResult {
    @Field(() => [MJQueryCategory_])
    Results: MJQueryCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryCategory_)
export class MJQueryCategoryResolver extends ResolverBase {
    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Query Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryCategory_, { nullable: true })
    async MJQueryCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryCategory_ | null> {
        this.CheckUserReadPermissions('MJ: Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Query Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQueryCategory_])
    async MJQueryCategories_ParentIDArray(@Root() mjquerycategory_: MJQueryCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjquerycategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQuery_])
    async MJQueries_CategoryIDArray(@Root() mjquerycategory_: MJQueryCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueries')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjquerycategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Queries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJQueryCategory_)
    async CreateMJQueryCategory(
        @Arg('input', () => CreateMJQueryCategoryInput) input: CreateMJQueryCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Query Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryCategory_)
    async UpdateMJQueryCategory(
        @Arg('input', () => UpdateMJQueryCategoryInput) input: UpdateMJQueryCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Query Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryCategory_)
    async DeleteMJQueryCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Query Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Query Entities
//****************************************************************************
@ObjectType({ description: `Tracks which entities are involved in a given query. The Queries table stores SQL and descriptions for stored queries that can be executed and serve as examples for AI.` })
export class MJQueryEntity_ {
    @Field({description: `Unique identifier for the QueryEntity record.`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `References the ID of the query in the Queries table.`}) 
    @MaxLength(36)
    QueryID: string;
        
    @Field({description: `References the ID of the entity in the Entities table.`}) 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates how this entity-query relationship was identified. "AI" means the QueryEntityServer used LLM analysis to parse the SQL/template and identify which MemberJunction entities are referenced (by analyzing table names, joins, and query structure). "Manual" means a user explicitly marked this entity as being used by the query. AI detection helps maintain accurate metadata automatically as queries evolve.`}) 
    @MaxLength(50)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was that this entity is actually used in the query. Only populated when DetectionMethod="AI". Considers factors like: direct table references vs indirect joins, clear entity names vs ambiguous aliases, and context from the query purpose. Lower scores might indicate the entity is only peripherally involved or the detection was uncertain.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    @MaxLength(255)
    Query: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Query Entities
//****************************************************************************
@InputType()
export class CreateMJQueryEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Query Entities
//****************************************************************************
@InputType()
export class UpdateMJQueryEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Query Entities
//****************************************************************************
@ObjectType()
export class RunMJQueryEntityViewResult {
    @Field(() => [MJQueryEntity_])
    Results: MJQueryEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryEntity_)
export class MJQueryEntityResolver extends ResolverBase {
    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Query Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryEntity_, { nullable: true })
    async MJQueryEntity(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryEntity_ | null> {
        this.CheckUserReadPermissions('MJ: Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryEntities')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Query Entities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueryEntity_)
    async CreateMJQueryEntity(
        @Arg('input', () => CreateMJQueryEntityInput) input: CreateMJQueryEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Query Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryEntity_)
    async UpdateMJQueryEntity(
        @Arg('input', () => UpdateMJQueryEntityInput) input: UpdateMJQueryEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Query Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryEntity_)
    async DeleteMJQueryEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Query Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Query Fields
//****************************************************************************
@ObjectType({ description: `Stores field-level metadata for queries including display names, data types, and formatting rules for result presentation.` })
export class MJQueryField_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    QueryID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Int, {description: `Display order of this field in query results.`}) 
    Sequence: number;
        
    @Field({description: `The base type, not including parameters, in SQL. For example this field would be nvarchar or decimal, and wouldn't include type parameters. The SQLFullType field provides that information.`}) 
    @MaxLength(50)
    SQLBaseType: string;
        
    @Field({description: `The full SQL type for the field, for example datetime or nvarchar(10) etc.`}) 
    @MaxLength(100)
    SQLFullType: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    SourceEntityID?: string;
        
    @Field({nullable: true, description: `The original field name from the SQL query if different from the display name.`}) 
    @MaxLength(255)
    SourceFieldName?: string;
        
    @Field(() => Boolean, {description: `Indicates if this field is calculated from other fields rather than directly from the database.`}) 
    IsComputed: boolean;
        
    @Field({nullable: true, description: `Explanation of how this computed field is calculated.`}) 
    ComputationDescription?: string;
        
    @Field(() => Boolean, {description: `Whether this field represents an aggregate or summary value.`}) 
    IsSummary: boolean;
        
    @Field({nullable: true, description: `Description of what this summary field represents and how it's aggregated.`}) 
    SummaryDescription?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates how this field was identified in the query output. "AI" means the QueryEntityServer used LLM analysis to parse the SELECT clause and determine field names, types, and their source entities/columns. This includes handling aliased columns, computed expressions, aggregations, and CASE statements. "Manual" means a user explicitly defined this output field. AI detection ensures the field list stays synchronized with query changes.`}) 
    @MaxLength(50)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was about this field detection. Only populated when DetectionMethod="AI". Factors include: clarity of the SELECT clause, complexity of any expressions or transformations, confidence in type inference, and ability to trace back to source entity/column. Complex computed fields or ambiguous aliases result in lower scores. This helps identify fields that may need manual verification.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    @MaxLength(255)
    Query: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SourceEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Query Fields
//****************************************************************************
@InputType()
export class CreateMJQueryFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID: string | null;

    @Field({ nullable: true })
    SourceFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Query Fields
//****************************************************************************
@InputType()
export class UpdateMJQueryFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID?: string | null;

    @Field({ nullable: true })
    SourceFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription?: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Query Fields
//****************************************************************************
@ObjectType()
export class RunMJQueryFieldViewResult {
    @Field(() => [MJQueryField_])
    Results: MJQueryField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryField_)
export class MJQueryFieldResolver extends ResolverBase {
    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Query Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryField_, { nullable: true })
    async MJQueryField(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryField_ | null> {
        this.CheckUserReadPermissions('MJ: Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryFields')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Query Fields', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueryField_)
    async CreateMJQueryField(
        @Arg('input', () => CreateMJQueryFieldInput) input: CreateMJQueryFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Query Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryField_)
    async UpdateMJQueryField(
        @Arg('input', () => UpdateMJQueryFieldInput) input: UpdateMJQueryFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Query Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryField_)
    async DeleteMJQueryField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Query Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Query Parameters
//****************************************************************************
@ObjectType({ description: `Stores parameter definitions for parameterized queries that use Nunjucks templates. Each parameter represents a dynamic value that can be passed when executing the query. Parameters are automatically extracted from the query template by the QueryEntityServer using LLM analysis, or can be manually defined. The combination of parameter metadata and validation filters creates a self-documenting, type-safe query execution system.` })
export class MJQueryParameter_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    QueryID: string;
        
    @Field({description: `The name of the parameter as it appears in the Nunjucks template. This must match exactly with the parameter reference in the SQL template. For example, if the template contains {{ userEmail | required | email }}, the Name would be "userEmail". Parameter names should follow JavaScript identifier rules: start with a letter, and contain only letters, numbers, and underscores.`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({description: `The data type of the parameter used for validation and type conversion. Valid values are: "string" for text values, "number" for integers or decimals, "date" for date/datetime values (ISO 8601 format expected), "boolean" for true/false values, and "array" for multiple values (typically used with IN clauses). The type determines which validation filters can be applied and how the parameter is processed.`}) 
    @MaxLength(50)
    Type: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether this parameter must be provided when executing the query. When true, the query execution will fail if the parameter is not supplied and no DefaultValue is set. This is automatically determined by the presence of the "required" filter in the template, but can be manually overridden. Required parameters ensure data integrity and prevent unintended query behavior.`}) 
    IsRequired?: boolean;
        
    @Field({nullable: true, description: `The default value to use when the parameter is not provided during query execution. This value must be compatible with the parameter Type. For arrays, use JSON format like ["value1","value2"]. Default values allow queries to have sensible fallbacks while still accepting custom inputs. If a parameter is required (IsRequired=true), the default value is ignored.`}) 
    DefaultValue?: string;
        
    @Field({nullable: true, description: `Human-readable description explaining the purpose and usage of this parameter. This is typically generated by LLM analysis of the query context but can be manually edited. Good descriptions include: what the parameter filters or controls, valid value ranges or formats, business meaning, and any special considerations. This text is shown in UI to help users understand what value to provide.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `A concrete example value demonstrating the proper format for this parameter. Generated by LLM based on the query context and validation filters. For example: "john@example.com" for an email parameter, "2024-01-15" for a date, or "["active","pending"]" for a status array. Sample values help users understand the expected format and can be used in API documentation.`}) 
    SampleValue?: string;
        
    @Field({nullable: true, description: `JSON array of Nunjucks filter definitions that validate and transform the parameter value. Each filter is an object with "name" and optional "args" properties. Filters are applied in order and can include: validation (required, email, min, max), transformation (trim, upper, lower), SQL safety (sqlsafe, sqljoin), and type conversion (number, date). Example: [{"name":"required"},{"name":"email"},{"name":"sqlsafe"}]. The filter chain ensures type safety and prevents SQL injection.`}) 
    ValidationFilters?: string;
        
    @Field({description: `Indicates how this parameter was identified and added to the system. "AI" means it was automatically detected by LLM analysis of the query template, including extraction of parameter name, type inference from filters, and generation of description. "Manual" means it was explicitly defined by a user. This helps track which parameters might need human review and provides transparency about the source of metadata.`}) 
    @MaxLength(50)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was about this parameter detection. Only populated when DetectionMethod="AI". Higher scores indicate the LLM was more confident about the parameter name, type, and usage. Scores above 0.80 are generally reliable, 0.60-0.80 may benefit from human review, and below 0.60 should be manually verified. This helps prioritize which auto-detected parameters need human attention.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Query: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Query Parameters
//****************************************************************************
@InputType()
export class CreateMJQueryParameterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean | null;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SampleValue: string | null;

    @Field({ nullable: true })
    ValidationFilters: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Query Parameters
//****************************************************************************
@InputType()
export class UpdateMJQueryParameterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean | null;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SampleValue?: string | null;

    @Field({ nullable: true })
    ValidationFilters?: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Query Parameters
//****************************************************************************
@ObjectType()
export class RunMJQueryParameterViewResult {
    @Field(() => [MJQueryParameter_])
    Results: MJQueryParameter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryParameter_)
export class MJQueryParameterResolver extends ResolverBase {
    @Query(() => RunMJQueryParameterViewResult)
    async RunMJQueryParameterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryParameterViewResult)
    async RunMJQueryParameterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryParameterViewResult)
    async RunMJQueryParameterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Query Parameters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryParameter_, { nullable: true })
    async MJQueryParameter(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryParameter_ | null> {
        this.CheckUserReadPermissions('MJ: Query Parameters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryParameters')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Parameters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Query Parameters', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueryParameter_)
    async CreateMJQueryParameter(
        @Arg('input', () => CreateMJQueryParameterInput) input: CreateMJQueryParameterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Query Parameters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryParameter_)
    async UpdateMJQueryParameter(
        @Arg('input', () => UpdateMJQueryParameterInput) input: UpdateMJQueryParameterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Query Parameters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryParameter_)
    async DeleteMJQueryParameter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Query Parameters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Query Permissions
//****************************************************************************
@ObjectType({ description: `Controls access to queries by defining which users and roles can run specific queries.` })
export class MJQueryPermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    QueryID: string;
        
    @Field() 
    @MaxLength(36)
    RoleID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Query: string;
        
    @Field() 
    @MaxLength(50)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Query Permissions
//****************************************************************************
@InputType()
export class CreateMJQueryPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Query Permissions
//****************************************************************************
@InputType()
export class UpdateMJQueryPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Query Permissions
//****************************************************************************
@ObjectType()
export class RunMJQueryPermissionViewResult {
    @Field(() => [MJQueryPermission_])
    Results: MJQueryPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryPermission_)
export class MJQueryPermissionResolver extends ResolverBase {
    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Query Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryPermission_, { nullable: true })
    async MJQueryPermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryPermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Query Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueryPermission_)
    async CreateMJQueryPermission(
        @Arg('input', () => CreateMJQueryPermissionInput) input: CreateMJQueryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Query Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryPermission_)
    async UpdateMJQueryPermission(
        @Arg('input', () => UpdateMJQueryPermissionInput) input: UpdateMJQueryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Query Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryPermission_)
    async DeleteMJQueryPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Query Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Query SQLs
//****************************************************************************
@ObjectType()
export class MJQuerySQL_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign key to the query this SQL variant belongs to`}) 
    @MaxLength(36)
    QueryID: string;
        
    @Field({description: `Foreign key to the SQL dialect this SQL is written in`}) 
    @MaxLength(36)
    SQLDialectID: string;
        
    @Field({description: `The SQL query text in the specified dialect. May include Nunjucks template parameters.`}) 
    SQL: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Query: string;
        
    @Field() 
    @MaxLength(100)
    SQLDialect: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Query SQLs
//****************************************************************************
@InputType()
export class CreateMJQuerySQLInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    SQLDialectID?: string;

    @Field({ nullable: true })
    SQL?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Query SQLs
//****************************************************************************
@InputType()
export class UpdateMJQuerySQLInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    SQLDialectID?: string;

    @Field({ nullable: true })
    SQL?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Query SQLs
//****************************************************************************
@ObjectType()
export class RunMJQuerySQLViewResult {
    @Field(() => [MJQuerySQL_])
    Results: MJQuerySQL_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQuerySQL_)
export class MJQuerySQLResolver extends ResolverBase {
    @Query(() => RunMJQuerySQLViewResult)
    async RunMJQuerySQLViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQuerySQLViewResult)
    async RunMJQuerySQLViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQuerySQLViewResult)
    async RunMJQuerySQLDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Query SQLs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQuerySQL_, { nullable: true })
    async MJQuerySQL(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQuerySQL_ | null> {
        this.CheckUserReadPermissions('MJ: Query SQLs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQuerySQLs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query SQLs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Query SQLs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQuerySQL_)
    async CreateMJQuerySQL(
        @Arg('input', () => CreateMJQuerySQLInput) input: CreateMJQuerySQLInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Query SQLs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQuerySQL_)
    async UpdateMJQuerySQL(
        @Arg('input', () => UpdateMJQuerySQLInput) input: UpdateMJQuerySQLInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Query SQLs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQuerySQL_)
    async DeleteMJQuerySQL(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Query SQLs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Queue Tasks
//****************************************************************************
@ObjectType({ description: `Manages asynchronous tasks in processing queues, tracking status, priority, and execution details for background operations.` })
export class MJQueueTask_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    QueueID: string;
        
    @Field() 
    @MaxLength(10)
    Status: string;
        
    @Field({nullable: true}) 
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    EndedAt?: Date;
        
    @Field({nullable: true, description: `JSON payload containing the data needed to process this task.`}) 
    Data?: string;
        
    @Field({nullable: true, description: `JSON configuration options for how this task should be processed.`}) 
    Options?: string;
        
    @Field({nullable: true, description: `Result data from task execution, typically in JSON format.`}) 
    Output?: string;
        
    @Field({nullable: true, description: `Error details if the task failed during processing.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    Queue: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Queue Tasks
//****************************************************************************
@InputType()
export class CreateMJQueueTaskInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Data: string | null;

    @Field({ nullable: true })
    Options: string | null;

    @Field({ nullable: true })
    Output: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Queue Tasks
//****************************************************************************
@InputType()
export class UpdateMJQueueTaskInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Data?: string | null;

    @Field({ nullable: true })
    Options?: string | null;

    @Field({ nullable: true })
    Output?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Queue Tasks
//****************************************************************************
@ObjectType()
export class RunMJQueueTaskViewResult {
    @Field(() => [MJQueueTask_])
    Results: MJQueueTask_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueueTask_)
export class MJQueueTaskResolver extends ResolverBase {
    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Queue Tasks';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueueTask_, { nullable: true })
    async MJQueueTask(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueueTask_ | null> {
        this.CheckUserReadPermissions('MJ: Queue Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueueTasks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Queue Tasks', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueueTask_)
    async CreateMJQueueTask(
        @Arg('input', () => CreateMJQueueTaskInput) input: CreateMJQueueTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Queue Tasks', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueueTask_)
    async UpdateMJQueueTask(
        @Arg('input', () => UpdateMJQueueTaskInput) input: UpdateMJQueueTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Queue Tasks', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueueTask_)
    async DeleteMJQueueTask(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Queue Tasks', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Queue Types
//****************************************************************************
@ObjectType({ description: `Defines different types of processing queues with specific behaviors, priorities, and processing rules for task management.` })
export class MJQueueType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Field DriverClass for entity Queue Types.`}) 
    @MaxLength(100)
    DriverClass: string;
        
    @Field({nullable: true, description: `Field DriverImportPath for entity Queue Types.`}) 
    @MaxLength(200)
    DriverImportPath?: string;
        
    @Field(() => Boolean, {description: `Field IsActive for entity Queue Types.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJQueue_])
    MJQueues_QueueTypeIDArray: MJQueue_[]; // Link to MJQueues
    
}

//****************************************************************************
// INPUT TYPE for MJ: Queue Types
//****************************************************************************
@InputType()
export class CreateMJQueueTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Queue Types
//****************************************************************************
@InputType()
export class UpdateMJQueueTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Queue Types
//****************************************************************************
@ObjectType()
export class RunMJQueueTypeViewResult {
    @Field(() => [MJQueueType_])
    Results: MJQueueType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueueType_)
export class MJQueueTypeResolver extends ResolverBase {
    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Queue Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueueType_, { nullable: true })
    async MJQueueType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueueType_ | null> {
        this.CheckUserReadPermissions('MJ: Queue Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueueTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queue Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Queue Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQueue_])
    async MJQueues_QueueTypeIDArray(@Root() mjqueuetype_: MJQueueType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Queues', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueues')} WHERE ${provider.QuoteIdentifier('QueueTypeID')}='${mjqueuetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queues', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Queues', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJQueueType_)
    async CreateMJQueueType(
        @Arg('input', () => CreateMJQueueTypeInput) input: CreateMJQueueTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Queue Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueueType_)
    async UpdateMJQueueType(
        @Arg('input', () => UpdateMJQueueTypeInput) input: UpdateMJQueueTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Queue Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueueType_)
    async DeleteMJQueueType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Queue Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Queues
//****************************************************************************
@ObjectType({ description: `Queues can be used to async execute long running tasks` })
export class MJQueue_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    QueueTypeID: string;
        
    @Field(() => Boolean, {description: `Field IsActive for entity Queues.`}) 
    IsActive: boolean;
        
    @Field(() => Int, {nullable: true, description: `Field ProcessPID for entity Queues.`}) 
    ProcessPID?: number;
        
    @Field({nullable: true, description: `Field ProcessPlatform for entity Queues.`}) 
    @MaxLength(30)
    ProcessPlatform?: string;
        
    @Field({nullable: true, description: `Field ProcessVersion for entity Queues.`}) 
    @MaxLength(15)
    ProcessVersion?: string;
        
    @Field({nullable: true, description: `Field ProcessCwd for entity Queues.`}) 
    @MaxLength(100)
    ProcessCwd?: string;
        
    @Field({nullable: true, description: `Field ProcessIPAddress for entity Queues.`}) 
    @MaxLength(50)
    ProcessIPAddress?: string;
        
    @Field({nullable: true, description: `Field ProcessMacAddress for entity Queues.`}) 
    @MaxLength(50)
    ProcessMacAddress?: string;
        
    @Field({nullable: true, description: `Field ProcessOSName for entity Queues.`}) 
    @MaxLength(25)
    ProcessOSName?: string;
        
    @Field({nullable: true, description: `Field ProcessOSVersion for entity Queues.`}) 
    @MaxLength(10)
    ProcessOSVersion?: string;
        
    @Field({nullable: true, description: `Field ProcessHostName for entity Queues.`}) 
    @MaxLength(50)
    ProcessHostName?: string;
        
    @Field({nullable: true, description: `Field ProcessUserID for entity Queues.`}) 
    @MaxLength(25)
    ProcessUserID?: string;
        
    @Field({nullable: true, description: `Field ProcessUserName for entity Queues.`}) 
    @MaxLength(50)
    ProcessUserName?: string;
        
    @Field({description: `Field LastHeartbeat for entity Queues.`}) 
    LastHeartbeat: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(50)
    QueueType: string;
        
    @Field(() => [MJQueueTask_])
    MJQueueTasks_QueueIDArray: MJQueueTask_[]; // Link to MJQueueTasks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Queues
//****************************************************************************
@InputType()
export class CreateMJQueueInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID: number | null;

    @Field({ nullable: true })
    ProcessPlatform: string | null;

    @Field({ nullable: true })
    ProcessVersion: string | null;

    @Field({ nullable: true })
    ProcessCwd: string | null;

    @Field({ nullable: true })
    ProcessIPAddress: string | null;

    @Field({ nullable: true })
    ProcessMacAddress: string | null;

    @Field({ nullable: true })
    ProcessOSName: string | null;

    @Field({ nullable: true })
    ProcessOSVersion: string | null;

    @Field({ nullable: true })
    ProcessHostName: string | null;

    @Field({ nullable: true })
    ProcessUserID: string | null;

    @Field({ nullable: true })
    ProcessUserName: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Queues
//****************************************************************************
@InputType()
export class UpdateMJQueueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID?: number | null;

    @Field({ nullable: true })
    ProcessPlatform?: string | null;

    @Field({ nullable: true })
    ProcessVersion?: string | null;

    @Field({ nullable: true })
    ProcessCwd?: string | null;

    @Field({ nullable: true })
    ProcessIPAddress?: string | null;

    @Field({ nullable: true })
    ProcessMacAddress?: string | null;

    @Field({ nullable: true })
    ProcessOSName?: string | null;

    @Field({ nullable: true })
    ProcessOSVersion?: string | null;

    @Field({ nullable: true })
    ProcessHostName?: string | null;

    @Field({ nullable: true })
    ProcessUserID?: string | null;

    @Field({ nullable: true })
    ProcessUserName?: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Queues
//****************************************************************************
@ObjectType()
export class RunMJQueueViewResult {
    @Field(() => [MJQueue_])
    Results: MJQueue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueue_)
export class MJQueueResolver extends ResolverBase {
    @Query(() => RunMJQueueViewResult)
    async RunMJQueueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueViewResult)
    async RunMJQueueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueViewResult)
    async RunMJQueueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Queues';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueue_, { nullable: true })
    async MJQueue(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueue_ | null> {
        this.CheckUserReadPermissions('MJ: Queues', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueues')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queues', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Queues', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQueueTask_])
    async MJQueueTasks_QueueIDArray(@Root() mjqueue_: MJQueue_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Queue Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueueTasks')} WHERE ${provider.QuoteIdentifier('QueueID')}='${mjqueue_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Queue Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJQueue_)
    async CreateMJQueue(
        @Arg('input', () => CreateMJQueueInput) input: CreateMJQueueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Queues', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueue_)
    async UpdateMJQueue(
        @Arg('input', () => UpdateMJQueueInput) input: UpdateMJQueueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Queues', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueue_)
    async DeleteMJQueue(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Queues', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Recommendation Items
//****************************************************************************
@ObjectType({ description: `Table to store individual recommendation items that are the right side of the recommendation which we track in the DestinationEntityID/DestinationEntityRecordID` })
export class MJRecommendationItem_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    RecommendationID: string;
        
    @Field() 
    @MaxLength(36)
    DestinationEntityID: string;
        
    @Field({description: `The record ID of the destination entity`}) 
    @MaxLength(450)
    DestinationEntityRecordID: string;
        
    @Field(() => Float, {nullable: true, description: `A value between 0 and 1 indicating the probability of the match, higher numbers indicating a more certain match/recommendation.`}) 
    MatchProbability?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    Recommendation: string;
        
    @Field() 
    @MaxLength(255)
    DestinationEntity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Recommendation Items
//****************************************************************************
@InputType()
export class CreateMJRecommendationItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Recommendation Items
//****************************************************************************
@InputType()
export class UpdateMJRecommendationItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Recommendation Items
//****************************************************************************
@ObjectType()
export class RunMJRecommendationItemViewResult {
    @Field(() => [MJRecommendationItem_])
    Results: MJRecommendationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationItem_)
export class MJRecommendationItemResolver extends ResolverBase {
    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Recommendation Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationItem_, { nullable: true })
    async MJRecommendationItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationItem_ | null> {
        this.CheckUserReadPermissions('MJ: Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendationItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Recommendation Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJRecommendationItem_)
    async CreateMJRecommendationItem(
        @Arg('input', () => CreateMJRecommendationItemInput) input: CreateMJRecommendationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Recommendation Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationItem_)
    async UpdateMJRecommendationItem(
        @Arg('input', () => UpdateMJRecommendationItemInput) input: UpdateMJRecommendationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Recommendation Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendationItem_)
    async DeleteMJRecommendationItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Recommendation Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Recommendation Providers
//****************************************************************************
@ObjectType({ description: `Recommendation providers details` })
export class MJRecommendationProvider_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJRecommendationRun_])
    MJRecommendationRuns_RecommendationProviderIDArray: MJRecommendationRun_[]; // Link to MJRecommendationRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Recommendation Providers
//****************************************************************************
@InputType()
export class CreateMJRecommendationProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Recommendation Providers
//****************************************************************************
@InputType()
export class UpdateMJRecommendationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Recommendation Providers
//****************************************************************************
@ObjectType()
export class RunMJRecommendationProviderViewResult {
    @Field(() => [MJRecommendationProvider_])
    Results: MJRecommendationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationProvider_)
export class MJRecommendationProviderResolver extends ResolverBase {
    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Recommendation Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationProvider_, { nullable: true })
    async MJRecommendationProvider(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationProvider_ | null> {
        this.CheckUserReadPermissions('MJ: Recommendation Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendationProviders')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendation Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Recommendation Providers', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecommendationRun_])
    async MJRecommendationRuns_RecommendationProviderIDArray(@Root() mjrecommendationprovider_: MJRecommendationProvider_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendationRuns')} WHERE ${provider.QuoteIdentifier('RecommendationProviderID')}='${mjrecommendationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Recommendation Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecommendationProvider_)
    async CreateMJRecommendationProvider(
        @Arg('input', () => CreateMJRecommendationProviderInput) input: CreateMJRecommendationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Recommendation Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationProvider_)
    async UpdateMJRecommendationProvider(
        @Arg('input', () => UpdateMJRecommendationProviderInput) input: UpdateMJRecommendationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Recommendation Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendationProvider_)
    async DeleteMJRecommendationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Recommendation Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Recommendation Runs
//****************************************************************************
@ObjectType({ description: `Recommendation runs log each time a provider is requested to provide recommendations` })
export class MJRecommendationRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    RecommendationProviderID: string;
        
    @Field({description: `The start date of the recommendation run`}) 
    StartDate: Date;
        
    @Field({nullable: true, description: `The end date of the recommendation run`}) 
    EndDate?: Date;
        
    @Field({description: `The status of the recommendation run`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    RunByUserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    RecommendationProvider: string;
        
    @Field() 
    @MaxLength(100)
    RunByUser: string;
        
    @Field(() => [MJRecommendation_])
    MJRecommendations_RecommendationRunIDArray: MJRecommendation_[]; // Link to MJRecommendations
    
}

//****************************************************************************
// INPUT TYPE for MJ: Recommendation Runs
//****************************************************************************
@InputType()
export class CreateMJRecommendationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Recommendation Runs
//****************************************************************************
@InputType()
export class UpdateMJRecommendationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Recommendation Runs
//****************************************************************************
@ObjectType()
export class RunMJRecommendationRunViewResult {
    @Field(() => [MJRecommendationRun_])
    Results: MJRecommendationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationRun_)
export class MJRecommendationRunResolver extends ResolverBase {
    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Recommendation Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationRun_, { nullable: true })
    async MJRecommendationRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationRun_ | null> {
        this.CheckUserReadPermissions('MJ: Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendationRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Recommendation Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecommendation_])
    async MJRecommendations_RecommendationRunIDArray(@Root() mjrecommendationrun_: MJRecommendationRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendations')} WHERE ${provider.QuoteIdentifier('RecommendationRunID')}='${mjrecommendationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Recommendations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecommendationRun_)
    async CreateMJRecommendationRun(
        @Arg('input', () => CreateMJRecommendationRunInput) input: CreateMJRecommendationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Recommendation Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationRun_)
    async UpdateMJRecommendationRun(
        @Arg('input', () => UpdateMJRecommendationRunInput) input: UpdateMJRecommendationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Recommendation Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendationRun_)
    async DeleteMJRecommendationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Recommendation Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Recommendations
//****************************************************************************
@ObjectType({ description: `Recommendation headers that store the left side of the recommendation which we track in the SourceEntityID/SourceEntityRecordID` })
export class MJRecommendation_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    RecommendationRunID: string;
        
    @Field() 
    @MaxLength(36)
    SourceEntityID: string;
        
    @Field({description: `The record ID of the source entity`}) 
    SourceEntityRecordID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    RecommendationRun: string;
        
    @Field() 
    @MaxLength(255)
    SourceEntity: string;
        
    @Field(() => [MJRecommendationItem_])
    MJRecommendationItems_RecommendationIDArray: MJRecommendationItem_[]; // Link to MJRecommendationItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Recommendations
//****************************************************************************
@InputType()
export class CreateMJRecommendationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Recommendations
//****************************************************************************
@InputType()
export class UpdateMJRecommendationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Recommendations
//****************************************************************************
@ObjectType()
export class RunMJRecommendationViewResult {
    @Field(() => [MJRecommendation_])
    Results: MJRecommendation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendation_)
export class MJRecommendationResolver extends ResolverBase {
    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Recommendations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendation_, { nullable: true })
    async MJRecommendation(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendation_ | null> {
        this.CheckUserReadPermissions('MJ: Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Recommendations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecommendationItem_])
    async MJRecommendationItems_RecommendationIDArray(@Root() mjrecommendation_: MJRecommendation_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendationItems')} WHERE ${provider.QuoteIdentifier('RecommendationID')}='${mjrecommendation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Recommendation Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecommendation_)
    async CreateMJRecommendation(
        @Arg('input', () => CreateMJRecommendationInput) input: CreateMJRecommendationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Recommendations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendation_)
    async UpdateMJRecommendation(
        @Arg('input', () => UpdateMJRecommendationInput) input: UpdateMJRecommendationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Recommendations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendation_)
    async DeleteMJRecommendation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Recommendations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Record Change Replay Runs
//****************************************************************************
@ObjectType({ description: `Table to track the runs of replaying external record changes` })
export class MJRecordChangeReplayRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Timestamp when the replay run started`}) 
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the replay run ended`}) 
    EndedAt?: Date;
        
    @Field({description: `Status of the replay run (Pending, In Progress, Complete, Error)`}) 
    @MaxLength(50)
    Status: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field(() => [MJRecordChange_])
    MJRecordChanges_ReplayRunIDArray: MJRecordChange_[]; // Link to MJRecordChanges
    
}

//****************************************************************************
// INPUT TYPE for MJ: Record Change Replay Runs
//****************************************************************************
@InputType()
export class CreateMJRecordChangeReplayRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Record Change Replay Runs
//****************************************************************************
@InputType()
export class UpdateMJRecordChangeReplayRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Record Change Replay Runs
//****************************************************************************
@ObjectType()
export class RunMJRecordChangeReplayRunViewResult {
    @Field(() => [MJRecordChangeReplayRun_])
    Results: MJRecordChangeReplayRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordChangeReplayRun_)
export class MJRecordChangeReplayRunResolver extends ResolverBase {
    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Record Change Replay Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordChangeReplayRun_, { nullable: true })
    async MJRecordChangeReplayRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordChangeReplayRun_ | null> {
        this.CheckUserReadPermissions('MJ: Record Change Replay Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordChangeReplayRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Record Change Replay Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecordChange_])
    async MJRecordChanges_ReplayRunIDArray(@Root() mjrecordchangereplayrun_: MJRecordChangeReplayRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordChanges')} WHERE ${provider.QuoteIdentifier('ReplayRunID')}='${mjrecordchangereplayrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Changes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecordChangeReplayRun_)
    async CreateMJRecordChangeReplayRun(
        @Arg('input', () => CreateMJRecordChangeReplayRunInput) input: CreateMJRecordChangeReplayRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Record Change Replay Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordChangeReplayRun_)
    async UpdateMJRecordChangeReplayRun(
        @Arg('input', () => UpdateMJRecordChangeReplayRunInput) input: UpdateMJRecordChangeReplayRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Record Change Replay Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordChangeReplayRun_)
    async DeleteMJRecordChangeReplayRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Record Change Replay Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Record Changes
//****************************************************************************
@ObjectType({ description: `For entities that have TrackRecordChanges=1, Record Changes will store the history of all changes made within the system. For integrations you can directly add values here if you have inbound signals indicating records were changed in a source system. This entity only automatically captures Record Changes if they were made within the system.` })
export class MJRecordChange_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `Field RecordID for entity Record Changes.`}) 
    @MaxLength(750)
    RecordID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `Create, Update, or Delete`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({description: `Internal or External`}) 
    @MaxLength(20)
    Source: string;
        
    @Field({description: `The date/time that the change occured.`}) 
    ChangedAt: Date;
        
    @Field({description: `JSON structure that describes what was changed in a structured format.`}) 
    ChangesJSON: string;
        
    @Field({description: `A generated, human-readable description of what was changed.`}) 
    ChangesDescription: string;
        
    @Field({description: `A complete snapshot of the record AFTER the change was applied in a JSON format that can be parsed.`}) 
    FullRecordJSON: string;
        
    @Field({description: `For internal record changes generated within MJ, the status is immediately Complete. For external changes that are detected, the workflow starts off as Pending, then In Progress and finally either Complete or Error`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({nullable: true, description: `Field ErrorLog for entity Record Changes.`}) 
    ErrorLog?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ReplayRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    IntegrationID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field({description: `Field CreatedAt for entity Record Changes.`}) 
    CreatedAt: Date;
        
    @Field({description: `Field UpdatedAt for entity Record Changes.`}) 
    UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ReplayRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Integration?: string;
        
    @Field(() => [MJVersionLabelItem_])
    MJVersionLabelItems_RecordChangeIDArray: MJVersionLabelItem_[]; // Link to MJVersionLabelItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Record Changes
//****************************************************************************
@InputType()
export class CreateMJRecordChangeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ReplayRunID: string | null;

    @Field({ nullable: true })
    IntegrationID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Record Changes
//****************************************************************************
@InputType()
export class UpdateMJRecordChangeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ReplayRunID?: string | null;

    @Field({ nullable: true })
    IntegrationID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Record Changes
//****************************************************************************
@ObjectType()
export class RunMJRecordChangeViewResult {
    @Field(() => [MJRecordChange_])
    Results: MJRecordChange_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordChange_)
export class MJRecordChangeResolver extends ResolverBase {
    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Record Changes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordChange_, { nullable: true })
    async MJRecordChange(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordChange_ | null> {
        this.CheckUserReadPermissions('MJ: Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordChanges')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Record Changes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJVersionLabelItem_])
    async MJVersionLabelItems_RecordChangeIDArray(@Root() mjrecordchange_: MJRecordChange_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabelItems')} WHERE ${provider.QuoteIdentifier('RecordChangeID')}='${mjrecordchange_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecordChange_)
    async CreateMJRecordChange(
        @Arg('input', () => CreateMJRecordChangeInput) input: CreateMJRecordChangeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Record Changes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordChange_)
    async UpdateMJRecordChange(
        @Arg('input', () => UpdateMJRecordChangeInput) input: UpdateMJRecordChangeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Record Changes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordChange_)
    async DeleteMJRecordChange(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Record Changes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Record Links
//****************************************************************************
@ObjectType({ description: `Generic linking table that can connect any two records in the system, providing a flexible relationship management system.` })
export class MJRecordLink_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    SourceEntityID: string;
        
    @Field({description: `Primary key value(s) of the source record - scalar for simple PKs or JSON KeyValuePair array for composite PKs`}) 
    @MaxLength(500)
    SourceRecordID: string;
        
    @Field() 
    @MaxLength(36)
    TargetEntityID: string;
        
    @Field({description: `Primary key value(s) of the target record - scalar for simple PKs or JSON KeyValuePair array for composite PKs`}) 
    @MaxLength(500)
    TargetRecordID: string;
        
    @Field({nullable: true, description: `Application-specific relationship type describing how the records are related`}) 
    @MaxLength(50)
    LinkType?: string;
        
    @Field(() => Int, {nullable: true, description: `Display sequence for ordering linked records in UI`}) 
    Sequence?: number;
        
    @Field({nullable: true, description: `JSON field for storing additional link-specific metadata`}) 
    Metadata?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    SourceEntity: string;
        
    @Field() 
    @MaxLength(255)
    TargetEntity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Record Links
//****************************************************************************
@InputType()
export class CreateMJRecordLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceRecordID?: string;

    @Field({ nullable: true })
    TargetEntityID?: string;

    @Field({ nullable: true })
    TargetRecordID?: string;

    @Field({ nullable: true })
    LinkType: string | null;

    @Field(() => Int, { nullable: true })
    Sequence: number | null;

    @Field({ nullable: true })
    Metadata: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Record Links
//****************************************************************************
@InputType()
export class UpdateMJRecordLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceRecordID?: string;

    @Field({ nullable: true })
    TargetEntityID?: string;

    @Field({ nullable: true })
    TargetRecordID?: string;

    @Field({ nullable: true })
    LinkType?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number | null;

    @Field({ nullable: true })
    Metadata?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Record Links
//****************************************************************************
@ObjectType()
export class RunMJRecordLinkViewResult {
    @Field(() => [MJRecordLink_])
    Results: MJRecordLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordLink_)
export class MJRecordLinkResolver extends ResolverBase {
    @Query(() => RunMJRecordLinkViewResult)
    async RunMJRecordLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordLinkViewResult)
    async RunMJRecordLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordLinkViewResult)
    async RunMJRecordLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Record Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordLink_, { nullable: true })
    async MJRecordLink(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordLink_ | null> {
        this.CheckUserReadPermissions('MJ: Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordLinks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Record Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJRecordLink_)
    async CreateMJRecordLink(
        @Arg('input', () => CreateMJRecordLinkInput) input: CreateMJRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Record Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordLink_)
    async UpdateMJRecordLink(
        @Arg('input', () => UpdateMJRecordLinkInput) input: UpdateMJRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Record Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordLink_)
    async DeleteMJRecordLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Record Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Record Merge Deletion Logs
//****************************************************************************
@ObjectType({ description: `Tracks records deleted during merge operations, maintaining an audit trail of data consolidation activities.` })
export class MJRecordMergeDeletionLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    RecordMergeLogID: string;
        
    @Field({description: `Field DeletedRecordID for entity Record Merge Deletion Logs.`}) 
    @MaxLength(750)
    DeletedRecordID: string;
        
    @Field() 
    @MaxLength(10)
    Status: string;
        
    @Field({nullable: true, description: `Field ProcessingLog for entity Record Merge Deletion Logs.`}) 
    ProcessingLog?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(450)
    RecordMergeLog: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class CreateMJRecordMergeDeletionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class UpdateMJRecordMergeDeletionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Record Merge Deletion Logs
//****************************************************************************
@ObjectType()
export class RunMJRecordMergeDeletionLogViewResult {
    @Field(() => [MJRecordMergeDeletionLog_])
    Results: MJRecordMergeDeletionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordMergeDeletionLog_)
export class MJRecordMergeDeletionLogResolver extends ResolverBase {
    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Record Merge Deletion Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordMergeDeletionLog_, { nullable: true })
    async MJRecordMergeDeletionLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordMergeDeletionLog_ | null> {
        this.CheckUserReadPermissions('MJ: Record Merge Deletion Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordMergeDeletionLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Record Merge Deletion Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJRecordMergeDeletionLog_)
    async CreateMJRecordMergeDeletionLog(
        @Arg('input', () => CreateMJRecordMergeDeletionLogInput) input: CreateMJRecordMergeDeletionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Record Merge Deletion Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordMergeDeletionLog_)
    async UpdateMJRecordMergeDeletionLog(
        @Arg('input', () => UpdateMJRecordMergeDeletionLogInput) input: UpdateMJRecordMergeDeletionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Record Merge Deletion Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordMergeDeletionLog_)
    async DeleteMJRecordMergeDeletionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Record Merge Deletion Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Record Merge Logs
//****************************************************************************
@ObjectType({ description: `Records the history of record merge operations including source records, target records, and merge rules applied.` })
export class MJRecordMergeLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `The ID of the record that survived the merge and contains the consolidated data.`}) 
    @MaxLength(450)
    SurvivingRecordID: string;
        
    @Field() 
    @MaxLength(36)
    InitiatedByUserID: string;
        
    @Field({description: `Field ApprovalStatus for entity Record Merge Logs.`}) 
    @MaxLength(10)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ApprovedByUserID?: string;
        
    @Field({description: `Field ProcessingStatus for entity Record Merge Logs.`}) 
    @MaxLength(10)
    ProcessingStatus: string;
        
    @Field({description: `Field ProcessingStartedAt for entity Record Merge Logs.`}) 
    ProcessingStartedAt: Date;
        
    @Field({nullable: true, description: `Field ProcessingEndedAt for entity Record Merge Logs.`}) 
    ProcessingEndedAt?: Date;
        
    @Field({nullable: true, description: `Detailed log of the merge process including field mappings and decisions.`}) 
    ProcessingLog?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    InitiatedByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ApprovedByUser?: string;
        
    @Field(() => [MJRecordMergeDeletionLog_])
    MJRecordMergeDeletionLogs_RecordMergeLogIDArray: MJRecordMergeDeletionLog_[]; // Link to MJRecordMergeDeletionLogs
    
    @Field(() => [MJDuplicateRunDetailMatch_])
    MJDuplicateRunDetailMatches_RecordMergeLogIDArray: MJDuplicateRunDetailMatch_[]; // Link to MJDuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for MJ: Record Merge Logs
//****************************************************************************
@InputType()
export class CreateMJRecordMergeLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt: Date | null;

    @Field({ nullable: true })
    ProcessingLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Record Merge Logs
//****************************************************************************
@InputType()
export class UpdateMJRecordMergeLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt?: Date | null;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Record Merge Logs
//****************************************************************************
@ObjectType()
export class RunMJRecordMergeLogViewResult {
    @Field(() => [MJRecordMergeLog_])
    Results: MJRecordMergeLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordMergeLog_)
export class MJRecordMergeLogResolver extends ResolverBase {
    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Record Merge Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordMergeLog_, { nullable: true })
    async MJRecordMergeLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordMergeLog_ | null> {
        this.CheckUserReadPermissions('MJ: Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordMergeLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Record Merge Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecordMergeDeletionLog_])
    async MJRecordMergeDeletionLogs_RecordMergeLogIDArray(@Root() mjrecordmergelog_: MJRecordMergeLog_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Merge Deletion Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordMergeDeletionLogs')} WHERE ${provider.QuoteIdentifier('RecordMergeLogID')}='${mjrecordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Merge Deletion Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRunDetailMatch_])
    async MJDuplicateRunDetailMatches_RecordMergeLogIDArray(@Root() mjrecordmergelog_: MJRecordMergeLog_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRunDetailMatches')} WHERE ${provider.QuoteIdentifier('RecordMergeLogID')}='${mjrecordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Duplicate Run Detail Matches', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecordMergeLog_)
    async CreateMJRecordMergeLog(
        @Arg('input', () => CreateMJRecordMergeLogInput) input: CreateMJRecordMergeLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Record Merge Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordMergeLog_)
    async UpdateMJRecordMergeLog(
        @Arg('input', () => UpdateMJRecordMergeLogInput) input: UpdateMJRecordMergeLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Record Merge Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordMergeLog_)
    async DeleteMJRecordMergeLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Record Merge Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report Categories
//****************************************************************************
@ObjectType({ description: `Organizes reports into logical groupings for navigation, access control, and discovery within the reporting system.` })
export class MJReportCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJReportCategory_])
    MJReportCategories_ParentIDArray: MJReportCategory_[]; // Link to MJReportCategories
    
    @Field(() => [MJReport_])
    MJReports_CategoryIDArray: MJReport_[]; // Link to MJReports
    
}

//****************************************************************************
// INPUT TYPE for MJ: Report Categories
//****************************************************************************
@InputType()
export class CreateMJReportCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report Categories
//****************************************************************************
@InputType()
export class UpdateMJReportCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report Categories
//****************************************************************************
@ObjectType()
export class RunMJReportCategoryViewResult {
    @Field(() => [MJReportCategory_])
    Results: MJReportCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportCategory_)
export class MJReportCategoryResolver extends ResolverBase {
    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportCategory_, { nullable: true })
    async MJReportCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportCategory_ | null> {
        this.CheckUserReadPermissions('MJ: Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Report Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReportCategory_])
    async MJReportCategories_ParentIDArray(@Root() mjreportcategory_: MJReportCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjreportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async MJReports_CategoryIDArray(@Root() mjreportcategory_: MJReportCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjreportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJReportCategory_)
    async CreateMJReportCategory(
        @Arg('input', () => CreateMJReportCategoryInput) input: CreateMJReportCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportCategory_)
    async UpdateMJReportCategory(
        @Arg('input', () => UpdateMJReportCategoryInput) input: UpdateMJReportCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportCategory_)
    async DeleteMJReportCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report Snapshots
//****************************************************************************
@ObjectType({ description: `Stores point-in-time captures of report outputs, preserving historical data and enabling comparison over time.` })
export class MJReportSnapshot_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ReportID: string;
        
    @Field({description: `Field ResultSet for entity Report Snapshots.`}) 
    ResultSet: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Report: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report Snapshots
//****************************************************************************
@InputType()
export class CreateMJReportSnapshotInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report Snapshots
//****************************************************************************
@InputType()
export class UpdateMJReportSnapshotInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report Snapshots
//****************************************************************************
@ObjectType()
export class RunMJReportSnapshotViewResult {
    @Field(() => [MJReportSnapshot_])
    Results: MJReportSnapshot_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportSnapshot_)
export class MJReportSnapshotResolver extends ResolverBase {
    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report Snapshots';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportSnapshot_, { nullable: true })
    async MJReportSnapshot(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportSnapshot_ | null> {
        this.CheckUserReadPermissions('MJ: Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportSnapshots')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Report Snapshots', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJReportSnapshot_)
    async CreateMJReportSnapshot(
        @Arg('input', () => CreateMJReportSnapshotInput) input: CreateMJReportSnapshotInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report Snapshots', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportSnapshot_)
    async UpdateMJReportSnapshot(
        @Arg('input', () => UpdateMJReportSnapshotInput) input: UpdateMJReportSnapshotInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report Snapshots', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportSnapshot_)
    async DeleteMJReportSnapshot(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report Snapshots', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report User States
//****************************************************************************
@ObjectType({ description: `Tracks individual user state within interactive reports` })
export class MJReportUserState_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ReportID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true, description: `JSON serialized state of user interaction with the report`}) 
    ReportState?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Report: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class CreateMJReportUserStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class UpdateMJReportUserStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report User States
//****************************************************************************
@ObjectType()
export class RunMJReportUserStateViewResult {
    @Field(() => [MJReportUserState_])
    Results: MJReportUserState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportUserState_)
export class MJReportUserStateResolver extends ResolverBase {
    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report User States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportUserState_, { nullable: true })
    async MJReportUserState(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportUserState_ | null> {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportUserStates')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Report User States', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJReportUserState_)
    async CreateMJReportUserState(
        @Arg('input', () => CreateMJReportUserStateInput) input: CreateMJReportUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report User States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportUserState_)
    async UpdateMJReportUserState(
        @Arg('input', () => UpdateMJReportUserStateInput) input: UpdateMJReportUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report User States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportUserState_)
    async DeleteMJReportUserState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report User States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report Versions
//****************************************************************************
@ObjectType({ description: `Stores iterations of report logic, structure, and layout changes` })
export class MJReportVersion_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ReportID: string;
        
    @Field(() => Int, {description: `Report version number, sequential per report starting at 1`}) 
    VersionNumber: number;
        
    @Field({description: `Name of this report version`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of this report version`}) 
    Description?: string;
        
    @Field({nullable: true, description: `JSON configuration of report structure, layout and logic`}) 
    Configuration?: string;
        
    @Field(() => Boolean, {description: `Indicates if the data context was updated in this version`}) 
    DataContextUpdated: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Report: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class CreateMJReportVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class UpdateMJReportVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report Versions
//****************************************************************************
@ObjectType()
export class RunMJReportVersionViewResult {
    @Field(() => [MJReportVersion_])
    Results: MJReportVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportVersion_)
export class MJReportVersionResolver extends ResolverBase {
    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportVersion_, { nullable: true })
    async MJReportVersion(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportVersions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Report Versions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJReportVersion_)
    async CreateMJReportVersion(
        @Arg('input', () => CreateMJReportVersionInput) input: CreateMJReportVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportVersion_)
    async UpdateMJReportVersion(
        @Arg('input', () => UpdateMJReportVersionInput) input: UpdateMJReportVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportVersion_)
    async DeleteMJReportVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Reports
//****************************************************************************
@ObjectType({ description: `Defines report configurations including data sources, layouts, filters, and scheduling for automated report generation.` })
export class MJReport_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `Field SharingScope for entity Reports.`}) 
    @MaxLength(20)
    SharingScope: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ConversationID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ConversationDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    DataContextID?: string;
        
    @Field({nullable: true, description: `Field Configuration for entity Reports.`}) 
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    OutputTriggerTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    OutputFormatTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    OutputDeliveryTypeID?: string;
        
    @Field({nullable: true, description: `For scheduled reports, the frequency of generation (Daily, Weekly, Monthly, etc.).`}) 
    @MaxLength(50)
    OutputFrequency?: string;
        
    @Field({nullable: true, description: `Email address(es) to send the report to when using email delivery.`}) 
    @MaxLength(255)
    OutputTargetEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    OutputWorkflowID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Thumbnail image for the report that can be displayed in gallery views. Can contain either a URL to an image file or a Base64-encoded image string.`}) 
    Thumbnail?: string;
        
    @Field() 
    @MaxLength(36)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Category?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Conversation?: string;
        
    @Field({nullable: true}) 
    ConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    DataContext?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    OutputTriggerType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    OutputFormatType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    OutputDeliveryType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OutputWorkflow?: string;
        
    @Field() 
    @MaxLength(255)
    Environment: string;
        
    @Field(() => [MJReportSnapshot_])
    MJReportSnapshots_ReportIDArray: MJReportSnapshot_[]; // Link to MJReportSnapshots
    
    @Field(() => [MJReportVersion_])
    MJReportVersions_ReportIDArray: MJReportVersion_[]; // Link to MJReportVersions
    
    @Field(() => [MJReportUserState_])
    MJReportUserStates_ReportIDArray: MJReportUserState_[]; // Link to MJReportUserStates
    
}

//****************************************************************************
// INPUT TYPE for MJ: Reports
//****************************************************************************
@InputType()
export class CreateMJReportInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID: string | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID: string | null;

    @Field({ nullable: true })
    OutputFrequency: string | null;

    @Field({ nullable: true })
    OutputTargetEmail: string | null;

    @Field({ nullable: true })
    OutputWorkflowID: string | null;

    @Field({ nullable: true })
    Thumbnail: string | null;

    @Field({ nullable: true })
    EnvironmentID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Reports
//****************************************************************************
@InputType()
export class UpdateMJReportInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID?: string | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID?: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID?: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID?: string | null;

    @Field({ nullable: true })
    OutputFrequency?: string | null;

    @Field({ nullable: true })
    OutputTargetEmail?: string | null;

    @Field({ nullable: true })
    OutputWorkflowID?: string | null;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Reports
//****************************************************************************
@ObjectType()
export class RunMJReportViewResult {
    @Field(() => [MJReport_])
    Results: MJReport_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReport_)
export class MJReportResolver extends ResolverBase {
    @Query(() => RunMJReportViewResult)
    async RunMJReportViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportViewResult)
    async RunMJReportViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportViewResult)
    async RunMJReportDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Reports';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReport_, { nullable: true })
    async MJReport(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReport_ | null> {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Reports', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReportSnapshot_])
    async MJReportSnapshots_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportSnapshots')} WHERE ${provider.QuoteIdentifier('ReportID')}='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report Snapshots', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportVersion_])
    async MJReportVersions_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportVersions')} WHERE ${provider.QuoteIdentifier('ReportID')}='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report Versions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportUserState_])
    async MJReportUserStates_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportUserStates')} WHERE ${provider.QuoteIdentifier('ReportID')}='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJReport_)
    async CreateMJReport(
        @Arg('input', () => CreateMJReportInput) input: CreateMJReportInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Reports', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReport_)
    async UpdateMJReport(
        @Arg('input', () => UpdateMJReportInput) input: UpdateMJReportInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Reports', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReport_)
    async DeleteMJReport(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Reports', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Resource Links
//****************************************************************************
@ObjectType({ description: `Table to track user links to shared resources such as views, dashboards, etc.` })
export class MJResourceLink_ {
    @Field({description: `Unique identifier for each resource link`}) 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign key to the user linking the resource`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `Foreign key to the resource type (view, dashboard, etc.)`}) 
    @MaxLength(36)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being linked`}) 
    @MaxLength(255)
    ResourceRecordID: string;
        
    @Field({nullable: true, description: `Optional folder where the user organizes the linked resource`}) 
    @MaxLength(255)
    FolderID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field() 
    @MaxLength(255)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Resource Links
//****************************************************************************
@InputType()
export class CreateMJResourceLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Resource Links
//****************************************************************************
@InputType()
export class UpdateMJResourceLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Resource Links
//****************************************************************************
@ObjectType()
export class RunMJResourceLinkViewResult {
    @Field(() => [MJResourceLink_])
    Results: MJResourceLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourceLink_)
export class MJResourceLinkResolver extends ResolverBase {
    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Resource Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourceLink_, { nullable: true })
    async MJResourceLink(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourceLink_ | null> {
        this.CheckUserReadPermissions('MJ: Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourceLinks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Resource Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJResourceLink_)
    async CreateMJResourceLink(
        @Arg('input', () => CreateMJResourceLinkInput) input: CreateMJResourceLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Resource Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJResourceLink_)
    async UpdateMJResourceLink(
        @Arg('input', () => UpdateMJResourceLinkInput) input: UpdateMJResourceLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Resource Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJResourceLink_)
    async DeleteMJResourceLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Resource Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Resource Permissions
//****************************************************************************
@ObjectType({ description: `Table for managing sharing of resources to users or roles with time constraints and permission levels` })
export class MJResourcePermission_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Reference to the type of resource being shared (View, Dashboard, Report, etc.)`}) 
    @MaxLength(36)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being shared`}) 
    @MaxLength(255)
    ResourceRecordID: string;
        
    @Field({description: `The level of sharing either Role or User`}) 
    @MaxLength(10)
    Type: string;
        
    @Field({nullable: true, description: `Optional: Date when sharing starts`}) 
    StartSharingAt?: Date;
        
    @Field({nullable: true, description: `Optional: Date when sharing ends`}) 
    EndSharingAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RoleID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field({nullable: true, description: `Permission level defining the type of access (View, Edit, Owner)`}) 
    @MaxLength(20)
    PermissionLevel?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the resource permission request. Possible values are Requested, Approved, Rejected, or Revoked.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    @MaxLength(255)
    ResourceType: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Role?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Resource Permissions
//****************************************************************************
@InputType()
export class CreateMJResourcePermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt: Date | null;

    @Field({ nullable: true })
    EndSharingAt: Date | null;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    PermissionLevel: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Resource Permissions
//****************************************************************************
@InputType()
export class UpdateMJResourcePermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt?: Date | null;

    @Field({ nullable: true })
    EndSharingAt?: Date | null;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    PermissionLevel?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Resource Permissions
//****************************************************************************
@ObjectType()
export class RunMJResourcePermissionViewResult {
    @Field(() => [MJResourcePermission_])
    Results: MJResourcePermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourcePermission_)
export class MJResourcePermissionResolver extends ResolverBase {
    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Resource Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourcePermission_, { nullable: true })
    async MJResourcePermission(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourcePermission_ | null> {
        this.CheckUserReadPermissions('MJ: Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourcePermissions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Resource Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJResourcePermission_)
    async CreateMJResourcePermission(
        @Arg('input', () => CreateMJResourcePermissionInput) input: CreateMJResourcePermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Resource Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJResourcePermission_)
    async UpdateMJResourcePermission(
        @Arg('input', () => UpdateMJResourcePermissionInput) input: UpdateMJResourcePermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Resource Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJResourcePermission_)
    async DeleteMJResourcePermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Resource Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Resource Types
//****************************************************************************
@ObjectType({ description: `Tracks types of system resources such as records, dashboards, and reports.` })
export class MJResourceType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({description: `Field DisplayName for entity Resource Types.`}) 
    @MaxLength(255)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Icon identifier for displaying this resource type in the UI.`}) 
    @MaxLength(100)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    EntityID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Nullable foreign key to the ID column in Entities entity, representing the category entity. ASSUMPTION: If provided, the assumption is there is a self-referencing/recursive foreign key establishing a hierarchy within the Category Entity, commonly called ParentID, but it can be named anything.`}) 
    @MaxLength(36)
    CategoryEntityID?: string;
        
    @Field({nullable: true, description: `The Angular component class name to instantiate for this resource type. NULL for Custom resource type (uses NavItem DriverClass instead).`}) 
    @MaxLength(255)
    DriverClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    CategoryEntity?: string;
        
    @Field(() => [MJWorkspaceItem_])
    MJWorkspaceItems_ResourceTypeIDArray: MJWorkspaceItem_[]; // Link to MJWorkspaceItems
    
    @Field(() => [MJUserNotification_])
    MJUserNotifications_ResourceTypeIDArray: MJUserNotification_[]; // Link to MJUserNotifications
    
    @Field(() => [MJResourceLink_])
    MJResourceLinks_ResourceTypeIDArray: MJResourceLink_[]; // Link to MJResourceLinks
    
    @Field(() => [MJResourcePermission_])
    MJResourcePermissions_ResourceTypeIDArray: MJResourcePermission_[]; // Link to MJResourcePermissions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Resource Types
//****************************************************************************
@InputType()
export class CreateMJResourceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    CategoryEntityID: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Resource Types
//****************************************************************************
@InputType()
export class UpdateMJResourceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    CategoryEntityID?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Resource Types
//****************************************************************************
@ObjectType()
export class RunMJResourceTypeViewResult {
    @Field(() => [MJResourceType_])
    Results: MJResourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourceType_)
export class MJResourceTypeResolver extends ResolverBase {
    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Resource Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourceType_, { nullable: true })
    async MJResourceType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourceType_ | null> {
        this.CheckUserReadPermissions('MJ: Resource Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourceTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Resource Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJWorkspaceItem_])
    async MJWorkspaceItems_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkspaceItems')} WHERE ${provider.QuoteIdentifier('ResourceTypeID')}='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Workspace Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotification_])
    async MJUserNotifications_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotifications')} WHERE ${provider.QuoteIdentifier('ResourceTypeID')}='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notifications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourceLink_])
    async MJResourceLinks_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourceLinks')} WHERE ${provider.QuoteIdentifier('ResourceTypeID')}='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Resource Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async MJResourcePermissions_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourcePermissions')} WHERE ${provider.QuoteIdentifier('ResourceTypeID')}='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Resource Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJResourceType_)
    async CreateMJResourceType(
        @Arg('input', () => CreateMJResourceTypeInput) input: CreateMJResourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Resource Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJResourceType_)
    async UpdateMJResourceType(
        @Arg('input', () => UpdateMJResourceTypeInput) input: UpdateMJResourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Resource Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJResourceType_)
    async DeleteMJResourceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Resource Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Roles
//****************************************************************************
@ObjectType({ description: `Roles are used for security administration and can have zero to many Users as members` })
export class MJRole_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Role with full permissions to manage AI agents and all related entities. This role is required for AgentSpecSync operations to function correctly, allowing create, read, update, and delete operations on agents, prompts, actions, relationships, steps, and paths.`}) 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true, description: `Description of the role`}) 
    Description?: string;
        
    @Field({nullable: true, description: `The unique ID of the role in the directory being used for authentication, for example an ID in Azure.`}) 
    @MaxLength(250)
    DirectoryID?: string;
        
    @Field({nullable: true, description: `The name of the role in the database, this is used for auto-generating permission statements by CodeGen`}) 
    @MaxLength(250)
    SQLName?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEmployeeRole_])
    MJEmployeeRoles_RoleIDArray: MJEmployeeRole_[]; // Link to MJEmployeeRoles
    
    @Field(() => [MJEntityPermission_])
    MJEntityPermissions_RoleIDArray: MJEntityPermission_[]; // Link to MJEntityPermissions
    
    @Field(() => [MJUserRole_])
    MJUserRoles_RoleIDArray: MJUserRole_[]; // Link to MJUserRoles
    
    @Field(() => [MJAuthorizationRole_])
    MJAuthorizationRoles_RoleIDArray: MJAuthorizationRole_[]; // Link to MJAuthorizationRoles
    
    @Field(() => [MJQueryPermission_])
    MJQueryPermissions_RoleIDArray: MJQueryPermission_[]; // Link to MJQueryPermissions
    
    @Field(() => [MJResourcePermission_])
    MJResourcePermissions_RoleIDArray: MJResourcePermission_[]; // Link to MJResourcePermissions
    
    @Field(() => [MJMCPServerConnectionPermission_])
    MJMCPServerConnectionPermissions_RoleIDArray: MJMCPServerConnectionPermission_[]; // Link to MJMCPServerConnectionPermissions
    
    @Field(() => [MJAIAgentPermission_])
    MJAIAgentPermissions_RoleIDArray: MJAIAgentPermission_[]; // Link to MJAIAgentPermissions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Roles
//****************************************************************************
@InputType()
export class CreateMJRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DirectoryID: string | null;

    @Field({ nullable: true })
    SQLName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Roles
//****************************************************************************
@InputType()
export class UpdateMJRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DirectoryID?: string | null;

    @Field({ nullable: true })
    SQLName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Roles
//****************************************************************************
@ObjectType()
export class RunMJRoleViewResult {
    @Field(() => [MJRole_])
    Results: MJRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRole_)
export class MJRoleResolver extends ResolverBase {
    @Query(() => RunMJRoleViewResult)
    async RunMJRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRoleViewResult)
    async RunMJRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRoleViewResult)
    async RunMJRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRole_, { nullable: true })
    async MJRole(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRole_ | null> {
        this.CheckUserReadPermissions('MJ: Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRoles')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Roles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJRole_])
    async AllMJRoles(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRoles')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEmployeeRole_])
    async MJEmployeeRoles_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeRoles')} WHERE ${provider.QuoteIdentifier('RoleID')}='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employee Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityPermission_])
    async MJEntityPermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityPermissions')} WHERE ${provider.QuoteIdentifier('RoleID')}='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserRole_])
    async MJUserRoles_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserRoles')} WHERE ${provider.QuoteIdentifier('RoleID')}='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuthorizationRole_])
    async MJAuthorizationRoles_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuthorizationRoles')} WHERE ${provider.QuoteIdentifier('RoleID')}='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Authorization Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryPermission_])
    async MJQueryPermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryPermissions')} WHERE ${provider.QuoteIdentifier('RoleID')}='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async MJResourcePermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourcePermissions')} WHERE ${provider.QuoteIdentifier('RoleID')}='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Resource Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnectionPermission_])
    async MJMCPServerConnectionPermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnectionPermissions')} WHERE ${provider.QuoteIdentifier('RoleID')}='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPermission_])
    async MJAIAgentPermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentPermissions')} WHERE ${provider.QuoteIdentifier('RoleID')}='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRole_)
    async CreateMJRole(
        @Arg('input', () => CreateMJRoleInput) input: CreateMJRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRole_)
    async UpdateMJRole(
        @Arg('input', () => UpdateMJRoleInput) input: UpdateMJRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRole_)
    async DeleteMJRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Row Level Security Filters
//****************************************************************************
@ObjectType({ description: `Defines data access rules that filter records based on user context, implementing fine-grained security at the row level.` })
export class MJRowLevelSecurityFilter_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `SQL WHERE clause template that filters records based on user context variables.`}) 
    FilterText?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityPermission_])
    MJEntityPermissions_ReadRLSFilterIDArray: MJEntityPermission_[]; // Link to MJEntityPermissions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Row Level Security Filters
//****************************************************************************
@InputType()
export class CreateMJRowLevelSecurityFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    FilterText: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Row Level Security Filters
//****************************************************************************
@InputType()
export class UpdateMJRowLevelSecurityFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    FilterText?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Row Level Security Filters
//****************************************************************************
@ObjectType()
export class RunMJRowLevelSecurityFilterViewResult {
    @Field(() => [MJRowLevelSecurityFilter_])
    Results: MJRowLevelSecurityFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRowLevelSecurityFilter_)
export class MJRowLevelSecurityFilterResolver extends ResolverBase {
    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Row Level Security Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRowLevelSecurityFilter_, { nullable: true })
    async MJRowLevelSecurityFilter(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRowLevelSecurityFilter_ | null> {
        this.CheckUserReadPermissions('MJ: Row Level Security Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRowLevelSecurityFilters')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Row Level Security Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Row Level Security Filters', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJRowLevelSecurityFilter_])
    async AllMJRowLevelSecurityFilters(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Row Level Security Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRowLevelSecurityFilters')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Row Level Security Filters', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Row Level Security Filters', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityPermission_])
    async MJEntityPermissions_ReadRLSFilterIDArray(@Root() mjrowlevelsecurityfilter_: MJRowLevelSecurityFilter_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityPermissions')} WHERE ${provider.QuoteIdentifier('ReadRLSFilterID')}='${mjrowlevelsecurityfilter_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRowLevelSecurityFilter_)
    async CreateMJRowLevelSecurityFilter(
        @Arg('input', () => CreateMJRowLevelSecurityFilterInput) input: CreateMJRowLevelSecurityFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Row Level Security Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRowLevelSecurityFilter_)
    async UpdateMJRowLevelSecurityFilter(
        @Arg('input', () => UpdateMJRowLevelSecurityFilterInput) input: UpdateMJRowLevelSecurityFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Row Level Security Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRowLevelSecurityFilter_)
    async DeleteMJRowLevelSecurityFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Row Level Security Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Scheduled Action Params
//****************************************************************************
@ObjectType({ description: `Stores parameter values for scheduled action executions, configuring inputs for automated action runs.` })
export class MJScheduledActionParam_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ScheduledActionID: string;
        
    @Field() 
    @MaxLength(36)
    ActionParamID: string;
        
    @Field({description: `Field ValueType for entity Scheduled Action Params.`}) 
    @MaxLength(20)
    ValueType: string;
        
    @Field({nullable: true, description: `Field Value for entity Scheduled Action Params.`}) 
    Value?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    ScheduledAction: string;
        
    @Field() 
    @MaxLength(255)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Action Params
//****************************************************************************
@InputType()
export class CreateMJScheduledActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Action Params
//****************************************************************************
@InputType()
export class UpdateMJScheduledActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Scheduled Action Params
//****************************************************************************
@ObjectType()
export class RunMJScheduledActionParamViewResult {
    @Field(() => [MJScheduledActionParam_])
    Results: MJScheduledActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledActionParam_)
export class MJScheduledActionParamResolver extends ResolverBase {
    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Scheduled Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledActionParam_, { nullable: true })
    async MJScheduledActionParam(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledActionParam_ | null> {
        this.CheckUserReadPermissions('MJ: Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledActionParams')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Scheduled Action Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJScheduledActionParam_)
    async CreateMJScheduledActionParam(
        @Arg('input', () => CreateMJScheduledActionParamInput) input: CreateMJScheduledActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Scheduled Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledActionParam_)
    async UpdateMJScheduledActionParam(
        @Arg('input', () => UpdateMJScheduledActionParamInput) input: UpdateMJScheduledActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Scheduled Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledActionParam_)
    async DeleteMJScheduledActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Scheduled Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Scheduled Actions
//****************************************************************************
@ObjectType({ description: `Track scheduled actions and their details` })
export class MJScheduledAction_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    CreatedByUserID: string;
        
    @Field() 
    @MaxLength(36)
    ActionID: string;
        
    @Field({description: `Type of the scheduled action (Daily, Weekly, Monthly, Yearly, Custom)`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `Cron expression defining the schedule, automatically maintained by the system unless Type is Custom, in which case the user directly sets this`}) 
    @MaxLength(100)
    CronExpression?: string;
        
    @Field({description: `Timezone for the scheduled action, if not specified defaults to UTC/Z`}) 
    @MaxLength(100)
    Timezone: string;
        
    @Field({description: `Status of the scheduled action (Pending, Active, Disabled, Expired)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Interval in days for the scheduled action`}) 
    IntervalDays?: number;
        
    @Field({nullable: true, description: `Day of the week for the scheduled action`}) 
    @MaxLength(20)
    DayOfWeek?: string;
        
    @Field(() => Int, {nullable: true, description: `Day of the month for the scheduled action`}) 
    DayOfMonth?: number;
        
    @Field({nullable: true, description: `Month for the scheduled action`}) 
    @MaxLength(20)
    Month?: string;
        
    @Field({nullable: true, description: `Field CustomCronExpression for entity Scheduled Actions.`}) 
    @MaxLength(255)
    CustomCronExpression?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    CreatedByUser: string;
        
    @Field() 
    @MaxLength(425)
    Action: string;
        
    @Field(() => [MJScheduledActionParam_])
    MJScheduledActionParams_ScheduledActionIDArray: MJScheduledActionParam_[]; // Link to MJScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Actions
//****************************************************************************
@InputType()
export class CreateMJScheduledActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays: number | null;

    @Field({ nullable: true })
    DayOfWeek: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth: number | null;

    @Field({ nullable: true })
    Month: string | null;

    @Field({ nullable: true })
    CustomCronExpression: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Actions
//****************************************************************************
@InputType()
export class UpdateMJScheduledActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression?: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays?: number | null;

    @Field({ nullable: true })
    DayOfWeek?: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth?: number | null;

    @Field({ nullable: true })
    Month?: string | null;

    @Field({ nullable: true })
    CustomCronExpression?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Scheduled Actions
//****************************************************************************
@ObjectType()
export class RunMJScheduledActionViewResult {
    @Field(() => [MJScheduledAction_])
    Results: MJScheduledAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledAction_)
export class MJScheduledActionResolver extends ResolverBase {
    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Scheduled Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledAction_, { nullable: true })
    async MJScheduledAction(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledAction_ | null> {
        this.CheckUserReadPermissions('MJ: Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledActions')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Scheduled Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJScheduledActionParam_])
    async MJScheduledActionParams_ScheduledActionIDArray(@Root() mjscheduledaction_: MJScheduledAction_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledActionParams')} WHERE ${provider.QuoteIdentifier('ScheduledActionID')}='${mjscheduledaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJScheduledAction_)
    async CreateMJScheduledAction(
        @Arg('input', () => CreateMJScheduledActionInput) input: CreateMJScheduledActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Scheduled Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledAction_)
    async UpdateMJScheduledAction(
        @Arg('input', () => UpdateMJScheduledActionInput) input: UpdateMJScheduledActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Scheduled Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledAction_)
    async DeleteMJScheduledAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Scheduled Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Scheduled Job Runs
//****************************************************************************
@ObjectType({ description: `Records execution history for scheduled jobs. Provides uniform tracking across all job types. Each record represents one execution attempt of a scheduled job.` })
export class MJScheduledJobRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    ScheduledJobID: string;
        
    @Field({description: `Timestamp when this job execution began. Set immediately before calling the job plugin's Execute method.`}) 
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when this job execution completed (successfully or with failure). NULL while the job is still running.`}) 
    CompletedAt?: Date;
        
    @Field({description: `Current status of the job execution. Running=currently executing, Completed=finished (check Success for outcome), Failed=exception during execution, Cancelled=manually cancelled, Timeout=exceeded maximum execution time.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field(() => Boolean, {nullable: true, description: `Whether the job execution completed successfully. NULL while running, TRUE if successful, FALSE if failed. This is the job-level success from the plugin's Execute method, separate from domain-specific success tracking.`}) 
    Success?: boolean;
        
    @Field({nullable: true, description: `Error message if the job failed. NULL for successful runs. Contains exception messages or error details from the plugin's Execute method.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `Job-type specific execution details stored as JSON. May include references to domain-specific run records (e.g., {"AgentRunID": "...", "TokensUsed": 5000}), performance metrics, or other execution metadata. Schema is defined by the job type plugin.`}) 
    Details?: string;
        
    @Field({nullable: true, description: `User context under which the job was executed. Typically the OwnerUserID from the schedule, but can be overridden in job-specific configuration.`}) 
    @MaxLength(36)
    ExecutedByUserID?: string;
        
    @Field({nullable: true, description: `Timestamp when this execution was queued (for ConcurrencyMode=Queue). NULL for immediate executions. When set, indicates this run is waiting for a previous execution to complete before starting.`}) 
    QueuedAt?: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    ScheduledJob: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ExecutedByUser?: string;
        
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_ScheduledJobRunIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Job Runs
//****************************************************************************
@InputType()
export class CreateMJScheduledJobRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ScheduledJobID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Success: boolean | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Details: string | null;

    @Field({ nullable: true })
    ExecutedByUserID: string | null;

    @Field({ nullable: true })
    QueuedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Job Runs
//****************************************************************************
@InputType()
export class UpdateMJScheduledJobRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ScheduledJobID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field({ nullable: true })
    ExecutedByUserID?: string | null;

    @Field({ nullable: true })
    QueuedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Scheduled Job Runs
//****************************************************************************
@ObjectType()
export class RunMJScheduledJobRunViewResult {
    @Field(() => [MJScheduledJobRun_])
    Results: MJScheduledJobRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledJobRun_)
export class MJScheduledJobRunResolver extends ResolverBase {
    @Query(() => RunMJScheduledJobRunViewResult)
    async RunMJScheduledJobRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobRunViewResult)
    async RunMJScheduledJobRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobRunViewResult)
    async RunMJScheduledJobRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Scheduled Job Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledJobRun_, { nullable: true })
    async MJScheduledJobRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledJobRun_ | null> {
        this.CheckUserReadPermissions('MJ: Scheduled Job Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledJobRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Job Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Scheduled Job Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_ScheduledJobRunIDArray(@Root() mjscheduledjobrun_: MJScheduledJobRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('ScheduledJobRunID')}='${mjscheduledjobrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJScheduledJobRun_)
    async CreateMJScheduledJobRun(
        @Arg('input', () => CreateMJScheduledJobRunInput) input: CreateMJScheduledJobRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Scheduled Job Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledJobRun_)
    async UpdateMJScheduledJobRun(
        @Arg('input', () => UpdateMJScheduledJobRunInput) input: UpdateMJScheduledJobRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Scheduled Job Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledJobRun_)
    async DeleteMJScheduledJobRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Scheduled Job Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Scheduled Job Types
//****************************************************************************
@ObjectType({ description: `Defines types of schedulable jobs and their plugin implementations. Each job type represents a different kind of work that can be scheduled (e.g., Agents, Actions, Reports).` })
export class MJScheduledJobType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name identifying this job type (e.g., Agent, Action, Report).`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Human-readable description of what this job type does and when it should be used.`}) 
    Description?: string;
        
    @Field({description: `TypeScript class name that implements BaseScheduledJob for this job type. Used by ClassFactory to instantiate the correct plugin at runtime.`}) 
    @MaxLength(255)
    DriverClass: string;
        
    @Field({nullable: true, description: `Name of the entity that stores execution records for this job type (e.g., "MJ: AI Agent Runs", "Action Execution Logs"). Used for generic UI linking to domain-specific run records. NULL if job type uses ScheduledJobRun as its only execution record.`}) 
    @MaxLength(255)
    DomainRunEntity?: string;
        
    @Field({nullable: true, description: `Name of the foreign key field in the DomainRunEntity that links back to ScheduledJobRun (e.g., "ScheduleID"). Used for querying related domain runs. NULL if DomainRunEntity is NULL.`}) 
    @MaxLength(100)
    DomainRunEntityFKey?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this job type supports sending notifications on completion or failure.`}) 
    NotificationsAvailable: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJScheduledJob_])
    MJScheduledJobs_JobTypeIDArray: MJScheduledJob_[]; // Link to MJScheduledJobs
    
}

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Job Types
//****************************************************************************
@InputType()
export class CreateMJScheduledJobTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DomainRunEntity: string | null;

    @Field({ nullable: true })
    DomainRunEntityFKey: string | null;

    @Field(() => Boolean, { nullable: true })
    NotificationsAvailable?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Job Types
//****************************************************************************
@InputType()
export class UpdateMJScheduledJobTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DomainRunEntity?: string | null;

    @Field({ nullable: true })
    DomainRunEntityFKey?: string | null;

    @Field(() => Boolean, { nullable: true })
    NotificationsAvailable?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Scheduled Job Types
//****************************************************************************
@ObjectType()
export class RunMJScheduledJobTypeViewResult {
    @Field(() => [MJScheduledJobType_])
    Results: MJScheduledJobType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledJobType_)
export class MJScheduledJobTypeResolver extends ResolverBase {
    @Query(() => RunMJScheduledJobTypeViewResult)
    async RunMJScheduledJobTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobTypeViewResult)
    async RunMJScheduledJobTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobTypeViewResult)
    async RunMJScheduledJobTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Scheduled Job Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledJobType_, { nullable: true })
    async MJScheduledJobType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledJobType_ | null> {
        this.CheckUserReadPermissions('MJ: Scheduled Job Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledJobTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Job Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Scheduled Job Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJScheduledJob_])
    async MJScheduledJobs_JobTypeIDArray(@Root() mjscheduledjobtype_: MJScheduledJobType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Jobs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledJobs')} WHERE ${provider.QuoteIdentifier('JobTypeID')}='${mjscheduledjobtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Jobs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Jobs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJScheduledJobType_)
    async CreateMJScheduledJobType(
        @Arg('input', () => CreateMJScheduledJobTypeInput) input: CreateMJScheduledJobTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Scheduled Job Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledJobType_)
    async UpdateMJScheduledJobType(
        @Arg('input', () => UpdateMJScheduledJobTypeInput) input: UpdateMJScheduledJobTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Scheduled Job Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledJobType_)
    async DeleteMJScheduledJobType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Scheduled Job Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Scheduled Jobs
//****************************************************************************
@ObjectType({ description: `Defines schedules for automated job execution across all schedulable types. Each record represents a scheduled job with its cron expression, configuration, and execution tracking.` })
export class MJScheduledJob_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    JobTypeID: string;
        
    @Field({description: `Human-readable name for this scheduled job. Should clearly identify what the job does.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the job's purpose, what it does, and any important notes about its execution.`}) 
    Description?: string;
        
    @Field({description: `Cron expression defining when the job should execute (e.g., "0 30 9 * * MON-FRI" for weekdays at 9:30 AM). Uses standard cron syntax with seconds precision.`}) 
    @MaxLength(120)
    CronExpression: string;
        
    @Field({description: `IANA timezone identifier for interpreting the cron expression (e.g., "America/Chicago", "UTC"). Ensures consistent scheduling across different server locations.`}) 
    @MaxLength(64)
    Timezone: string;
        
    @Field({nullable: true, description: `Optional start date/time for when this schedule becomes active. Job will not execute before this time. NULL means active immediately upon creation.`}) 
    StartAt?: Date;
        
    @Field({nullable: true, description: `Optional end date/time for when this schedule expires. Job will not execute after this time. NULL means no expiration.`}) 
    EndAt?: Date;
        
    @Field({description: `Current status of the schedule. Pending=created but not yet active, Active=currently running on schedule, Paused=temporarily stopped, Disabled=manually disabled, Expired=past EndAt date.`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Job-type specific configuration stored as JSON. Schema is defined by the ScheduledJobType plugin. For Agents: includes AgentID, StartingPayload, InitialMessage, etc. For Actions: includes ActionID and parameter mappings.`}) 
    Configuration?: string;
        
    @Field({nullable: true, description: `User who owns this schedule. Used as the execution context if no specific user is configured in the job-specific configuration.`}) 
    @MaxLength(36)
    OwnerUserID?: string;
        
    @Field({nullable: true, description: `Timestamp of the most recent execution. Updated after each run. Used for monitoring and dashboard displays.`}) 
    LastRunAt?: Date;
        
    @Field({nullable: true, description: `Calculated timestamp of when this job should next execute based on the cron expression. Updated after each run. Used by scheduler to determine which jobs are due.`}) 
    NextRunAt?: Date;
        
    @Field(() => Int, {description: `Total number of times this schedule has been executed, including both successful and failed runs.`}) 
    RunCount: number;
        
    @Field(() => Int, {description: `Number of times this schedule has executed successfully (Success = true in ScheduledJobRun).`}) 
    SuccessCount: number;
        
    @Field(() => Int, {description: `Number of times this schedule has executed but failed (Success = false in ScheduledJobRun).`}) 
    FailureCount: number;
        
    @Field(() => Boolean, {description: `Whether to send notifications when the job completes successfully.`}) 
    NotifyOnSuccess: boolean;
        
    @Field(() => Boolean, {description: `Whether to send notifications when the job fails. Defaults to true for alerting on failures.`}) 
    NotifyOnFailure: boolean;
        
    @Field({nullable: true, description: `User to notify about job execution results. If NULL and notifications are enabled, falls back to OwnerUserID.`}) 
    @MaxLength(36)
    NotifyUserID?: string;
        
    @Field(() => Boolean, {description: `Whether to send email notifications. Requires NotifyOnSuccess or NotifyOnFailure to also be enabled.`}) 
    NotifyViaEmail: boolean;
        
    @Field(() => Boolean, {description: `Whether to send in-app notifications. Requires NotifyOnSuccess or NotifyOnFailure to also be enabled. Defaults to true.`}) 
    NotifyViaInApp: boolean;
        
    @Field({nullable: true, description: `Unique token used for distributed locking across multiple server instances. Set when a server claims the job for execution. Prevents duplicate executions in multi-server environments.`}) 
    @MaxLength(36)
    LockToken?: string;
        
    @Field({nullable: true, description: `Timestamp when the lock was acquired. Used with ExpectedCompletionAt to detect stale locks from crashed server instances.`}) 
    LockedAt?: Date;
        
    @Field({nullable: true, description: `Identifier of the server instance that currently holds the lock (e.g., "hostname-12345"). Used for troubleshooting and monitoring which server is executing which job.`}) 
    @MaxLength(255)
    LockedByInstance?: string;
        
    @Field({nullable: true, description: `Expected completion time for the current execution. If current time exceeds this and lock still exists, the lock is considered stale and can be claimed by another instance. Handles crashed server cleanup.`}) 
    ExpectedCompletionAt?: Date;
        
    @Field({description: `Controls behavior when a new execution is scheduled while a previous execution is still running. Skip=do not start new execution (default), Queue=wait for current to finish then execute, Concurrent=allow multiple simultaneous executions.`}) 
    @MaxLength(20)
    ConcurrencyMode: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    JobType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OwnerUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    NotifyUser?: string;
        
    @Field(() => [MJScheduledJobRun_])
    MJScheduledJobRuns_ScheduledJobIDArray: MJScheduledJobRun_[]; // Link to MJScheduledJobRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Jobs
//****************************************************************************
@InputType()
export class CreateMJScheduledJobInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    JobTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CronExpression?: string;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    StartAt: Date | null;

    @Field({ nullable: true })
    EndAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    OwnerUserID: string | null;

    @Field({ nullable: true })
    LastRunAt: Date | null;

    @Field({ nullable: true })
    NextRunAt: Date | null;

    @Field(() => Int, { nullable: true })
    RunCount?: number;

    @Field(() => Int, { nullable: true })
    SuccessCount?: number;

    @Field(() => Int, { nullable: true })
    FailureCount?: number;

    @Field(() => Boolean, { nullable: true })
    NotifyOnSuccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    NotifyOnFailure?: boolean;

    @Field({ nullable: true })
    NotifyUserID: string | null;

    @Field(() => Boolean, { nullable: true })
    NotifyViaEmail?: boolean;

    @Field(() => Boolean, { nullable: true })
    NotifyViaInApp?: boolean;

    @Field({ nullable: true })
    LockToken: string | null;

    @Field({ nullable: true })
    LockedAt: Date | null;

    @Field({ nullable: true })
    LockedByInstance: string | null;

    @Field({ nullable: true })
    ExpectedCompletionAt: Date | null;

    @Field({ nullable: true })
    ConcurrencyMode?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Jobs
//****************************************************************************
@InputType()
export class UpdateMJScheduledJobInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    JobTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CronExpression?: string;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    StartAt?: Date | null;

    @Field({ nullable: true })
    EndAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    OwnerUserID?: string | null;

    @Field({ nullable: true })
    LastRunAt?: Date | null;

    @Field({ nullable: true })
    NextRunAt?: Date | null;

    @Field(() => Int, { nullable: true })
    RunCount?: number;

    @Field(() => Int, { nullable: true })
    SuccessCount?: number;

    @Field(() => Int, { nullable: true })
    FailureCount?: number;

    @Field(() => Boolean, { nullable: true })
    NotifyOnSuccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    NotifyOnFailure?: boolean;

    @Field({ nullable: true })
    NotifyUserID?: string | null;

    @Field(() => Boolean, { nullable: true })
    NotifyViaEmail?: boolean;

    @Field(() => Boolean, { nullable: true })
    NotifyViaInApp?: boolean;

    @Field({ nullable: true })
    LockToken?: string | null;

    @Field({ nullable: true })
    LockedAt?: Date | null;

    @Field({ nullable: true })
    LockedByInstance?: string | null;

    @Field({ nullable: true })
    ExpectedCompletionAt?: Date | null;

    @Field({ nullable: true })
    ConcurrencyMode?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Scheduled Jobs
//****************************************************************************
@ObjectType()
export class RunMJScheduledJobViewResult {
    @Field(() => [MJScheduledJob_])
    Results: MJScheduledJob_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledJob_)
export class MJScheduledJobResolver extends ResolverBase {
    @Query(() => RunMJScheduledJobViewResult)
    async RunMJScheduledJobViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobViewResult)
    async RunMJScheduledJobViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobViewResult)
    async RunMJScheduledJobDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Scheduled Jobs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledJob_, { nullable: true })
    async MJScheduledJob(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledJob_ | null> {
        this.CheckUserReadPermissions('MJ: Scheduled Jobs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledJobs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Jobs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Scheduled Jobs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJScheduledJobRun_])
    async MJScheduledJobRuns_ScheduledJobIDArray(@Root() mjscheduledjob_: MJScheduledJob_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Job Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledJobRuns')} WHERE ${provider.QuoteIdentifier('ScheduledJobID')}='${mjscheduledjob_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Job Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Job Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJScheduledJob_)
    async CreateMJScheduledJob(
        @Arg('input', () => CreateMJScheduledJobInput) input: CreateMJScheduledJobInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Scheduled Jobs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledJob_)
    async UpdateMJScheduledJob(
        @Arg('input', () => UpdateMJScheduledJobInput) input: UpdateMJScheduledJobInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Scheduled Jobs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledJob_)
    async DeleteMJScheduledJob(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Scheduled Jobs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Schema Info
//****************************************************************************
@ObjectType({ description: `Tracks the schemas in the system and the ID ranges that are valid for entities within each schema.` })
export class MJSchemaInfo_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The database schema this information applies to.`}) 
    @MaxLength(50)
    SchemaName: string;
        
    @Field(() => Int, {description: `Field EntityIDMin for entity Schema Info.`}) 
    EntityIDMin: number;
        
    @Field(() => Int, {description: `Field EntityIDMax for entity Schema Info.`}) 
    EntityIDMax: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Optional prefix to prepend to entity names generated for this schema. For example, setting this to "Committees: " would result in entity names like "Committees: Individuals". Can be overridden by mj.config.cjs NameRulesBySchema settings.`}) 
    @MaxLength(25)
    EntityNamePrefix?: string;
        
    @Field({nullable: true, description: `Optional suffix to append to entity names generated for this schema. Can be overridden by mj.config.cjs NameRulesBySchema settings.`}) 
    @MaxLength(25)
    EntityNameSuffix?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Schema Info
//****************************************************************************
@InputType()
export class CreateMJSchemaInfoInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EntityNamePrefix: string | null;

    @Field({ nullable: true })
    EntityNameSuffix: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Schema Info
//****************************************************************************
@InputType()
export class UpdateMJSchemaInfoInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EntityNamePrefix?: string | null;

    @Field({ nullable: true })
    EntityNameSuffix?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Schema Info
//****************************************************************************
@ObjectType()
export class RunMJSchemaInfoViewResult {
    @Field(() => [MJSchemaInfo_])
    Results: MJSchemaInfo_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJSchemaInfo_)
export class MJSchemaInfoResolver extends ResolverBase {
    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Schema Info';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJSchemaInfo_, { nullable: true })
    async MJSchemaInfo(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJSchemaInfo_ | null> {
        this.CheckUserReadPermissions('MJ: Schema Info', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwSchemaInfos')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Schema Info', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Schema Info', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJSchemaInfo_)
    async CreateMJSchemaInfo(
        @Arg('input', () => CreateMJSchemaInfoInput) input: CreateMJSchemaInfoInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Schema Info', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJSchemaInfo_)
    async UpdateMJSchemaInfo(
        @Arg('input', () => UpdateMJSchemaInfoInput) input: UpdateMJSchemaInfoInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Schema Info', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJSchemaInfo_)
    async DeleteMJSchemaInfo(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Schema Info', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Skills
//****************************************************************************
@ObjectType({ description: `A hierarchical list of possible skills that are linked to Employees and can also be linked to any other entity` })
export class MJSkill_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(50)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJEmployeeSkill_])
    MJEmployeeSkills_SkillIDArray: MJEmployeeSkill_[]; // Link to MJEmployeeSkills
    
    @Field(() => [MJSkill_])
    MJSkills_ParentIDArray: MJSkill_[]; // Link to MJSkills
    
}

//****************************************************************************
// INPUT TYPE for MJ: Skills
//****************************************************************************
@InputType()
export class CreateMJSkillInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Skills
//****************************************************************************
@InputType()
export class UpdateMJSkillInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Skills
//****************************************************************************
@ObjectType()
export class RunMJSkillViewResult {
    @Field(() => [MJSkill_])
    Results: MJSkill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJSkill_)
export class MJSkillResolver extends ResolverBase {
    @Query(() => RunMJSkillViewResult)
    async RunMJSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSkillViewResult)
    async RunMJSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSkillViewResult)
    async RunMJSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Skills';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJSkill_, { nullable: true })
    async MJSkill(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJSkill_ | null> {
        this.CheckUserReadPermissions('MJ: Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwSkills')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Skills', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJSkill_])
    async AllMJSkills(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwSkills')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Skills', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Skills', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEmployeeSkill_])
    async MJEmployeeSkills_SkillIDArray(@Root() mjskill_: MJSkill_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEmployeeSkills')} WHERE ${provider.QuoteIdentifier('SkillID')}='${mjskill_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Employee Skills', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJSkill_])
    async MJSkills_ParentIDArray(@Root() mjskill_: MJSkill_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwSkills')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjskill_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Skills', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJSkill_)
    async CreateMJSkill(
        @Arg('input', () => CreateMJSkillInput) input: CreateMJSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Skills', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJSkill_)
    async UpdateMJSkill(
        @Arg('input', () => UpdateMJSkillInput) input: UpdateMJSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Skills', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJSkill_)
    async DeleteMJSkill(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Skills', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: SQL Dialects
//****************************************************************************
@ObjectType()
export class MJSQLDialect_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique display name for the SQL dialect (e.g., T-SQL, PostgreSQL)`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({description: `Lowercase identifier matching DatabasePlatform type in code (e.g., sqlserver, postgresql). Used by providers to find their dialect at runtime.`}) 
    @MaxLength(50)
    PlatformKey: string;
        
    @Field({description: `Name of the database engine (e.g., SQL Server, PostgreSQL, MySQL)`}) 
    @MaxLength(100)
    DatabaseName: string;
        
    @Field({description: `Name of the SQL language variant (e.g., T-SQL, PL/pgSQL, SQL/PSM)`}) 
    @MaxLength(100)
    LanguageName: string;
        
    @Field({nullable: true, description: `Primary vendor or organization behind this database (e.g., Microsoft, PostgreSQL Global Development Group)`}) 
    @MaxLength(200)
    VendorName?: string;
        
    @Field({nullable: true, description: `URL to the database vendor or documentation website`}) 
    @MaxLength(500)
    WebURL?: string;
        
    @Field({nullable: true, description: `CSS class or icon reference for UI display`}) 
    @MaxLength(500)
    Icon?: string;
        
    @Field({nullable: true, description: `Detailed description of this SQL dialect and its characteristics`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJQuerySQL_])
    MJQuerySQLs_SQLDialectIDArray: MJQuerySQL_[]; // Link to MJQuerySQLs
    
    @Field(() => [MJQuery_])
    MJQueries_SQLDialectIDArray: MJQuery_[]; // Link to MJQueries
    
}

//****************************************************************************
// INPUT TYPE for MJ: SQL Dialects
//****************************************************************************
@InputType()
export class CreateMJSQLDialectInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    PlatformKey?: string;

    @Field({ nullable: true })
    DatabaseName?: string;

    @Field({ nullable: true })
    LanguageName?: string;

    @Field({ nullable: true })
    VendorName: string | null;

    @Field({ nullable: true })
    WebURL: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: SQL Dialects
//****************************************************************************
@InputType()
export class UpdateMJSQLDialectInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    PlatformKey?: string;

    @Field({ nullable: true })
    DatabaseName?: string;

    @Field({ nullable: true })
    LanguageName?: string;

    @Field({ nullable: true })
    VendorName?: string | null;

    @Field({ nullable: true })
    WebURL?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: SQL Dialects
//****************************************************************************
@ObjectType()
export class RunMJSQLDialectViewResult {
    @Field(() => [MJSQLDialect_])
    Results: MJSQLDialect_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJSQLDialect_)
export class MJSQLDialectResolver extends ResolverBase {
    @Query(() => RunMJSQLDialectViewResult)
    async RunMJSQLDialectViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSQLDialectViewResult)
    async RunMJSQLDialectViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSQLDialectViewResult)
    async RunMJSQLDialectDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: SQL Dialects';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJSQLDialect_, { nullable: true })
    async MJSQLDialect(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJSQLDialect_ | null> {
        this.CheckUserReadPermissions('MJ: SQL Dialects', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwSQLDialects')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: SQL Dialects', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: SQL Dialects', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQuerySQL_])
    async MJQuerySQLs_SQLDialectIDArray(@Root() mjsqldialect_: MJSQLDialect_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query SQLs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQuerySQLs')} WHERE ${provider.QuoteIdentifier('SQLDialectID')}='${mjsqldialect_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query SQLs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query SQLs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQuery_])
    async MJQueries_SQLDialectIDArray(@Root() mjsqldialect_: MJSQLDialect_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueries')} WHERE ${provider.QuoteIdentifier('SQLDialectID')}='${mjsqldialect_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Queries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJSQLDialect_)
    async CreateMJSQLDialect(
        @Arg('input', () => CreateMJSQLDialectInput) input: CreateMJSQLDialectInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: SQL Dialects', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJSQLDialect_)
    async UpdateMJSQLDialect(
        @Arg('input', () => UpdateMJSQLDialectInput) input: UpdateMJSQLDialectInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: SQL Dialects', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJSQLDialect_)
    async DeleteMJSQLDialect(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: SQL Dialects', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Tagged Items
//****************************************************************************
@ObjectType({ description: `Tracks the links between any record in any entity with Tags` })
export class MJTaggedItem_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    TagID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `Field RecordID for entity Tagged Items.`}) 
    @MaxLength(450)
    RecordID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Tag: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Tagged Items
//****************************************************************************
@InputType()
export class CreateMJTaggedItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TagID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Tagged Items
//****************************************************************************
@InputType()
export class UpdateMJTaggedItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TagID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Tagged Items
//****************************************************************************
@ObjectType()
export class RunMJTaggedItemViewResult {
    @Field(() => [MJTaggedItem_])
    Results: MJTaggedItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTaggedItem_)
export class MJTaggedItemResolver extends ResolverBase {
    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Tagged Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTaggedItem_, { nullable: true })
    async MJTaggedItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTaggedItem_ | null> {
        this.CheckUserReadPermissions('MJ: Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTaggedItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Tagged Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTaggedItem_)
    async CreateMJTaggedItem(
        @Arg('input', () => CreateMJTaggedItemInput) input: CreateMJTaggedItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Tagged Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTaggedItem_)
    async UpdateMJTaggedItem(
        @Arg('input', () => UpdateMJTaggedItemInput) input: UpdateMJTaggedItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Tagged Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTaggedItem_)
    async DeleteMJTaggedItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Tagged Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Tags
//****************************************************************************
@ObjectType({ description: `Tags are used to arbitrarily associate any record in any entity with addtional information.` })
export class MJTag_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Field DisplayName for entity Tags.`}) 
    @MaxLength(255)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJTag_])
    MJTags_ParentIDArray: MJTag_[]; // Link to MJTags
    
    @Field(() => [MJTaggedItem_])
    MJTaggedItems_TagIDArray: MJTaggedItem_[]; // Link to MJTaggedItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Tags
//****************************************************************************
@InputType()
export class CreateMJTagInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Tags
//****************************************************************************
@InputType()
export class UpdateMJTagInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Tags
//****************************************************************************
@ObjectType()
export class RunMJTagViewResult {
    @Field(() => [MJTag_])
    Results: MJTag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTag_)
export class MJTagResolver extends ResolverBase {
    @Query(() => RunMJTagViewResult)
    async RunMJTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTagViewResult)
    async RunMJTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTagViewResult)
    async RunMJTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Tags';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTag_, { nullable: true })
    async MJTag(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTag_ | null> {
        this.CheckUserReadPermissions('MJ: Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTags')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Tags', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTag_])
    async MJTags_ParentIDArray(@Root() mjtag_: MJTag_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTags')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjtag_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tags', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTaggedItem_])
    async MJTaggedItems_TagIDArray(@Root() mjtag_: MJTag_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTaggedItems')} WHERE ${provider.QuoteIdentifier('TagID')}='${mjtag_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tagged Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTag_)
    async CreateMJTag(
        @Arg('input', () => CreateMJTagInput) input: CreateMJTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Tags', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTag_)
    async UpdateMJTag(
        @Arg('input', () => UpdateMJTagInput) input: UpdateMJTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Tags', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTag_)
    async DeleteMJTag(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Tags', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Task Dependencies
//****************************************************************************
@ObjectType({ description: `Defines dependencies between tasks to create a directed acyclic graph (DAG) for workflow orchestration` })
export class MJTaskDependency_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    TaskID: string;
        
    @Field() 
    @MaxLength(36)
    DependsOnTaskID: string;
        
    @Field({description: `Type of dependency relationship (Prerequisite, Corequisite, Optional)`}) 
    @MaxLength(50)
    DependencyType: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Task: string;
        
    @Field() 
    @MaxLength(255)
    DependsOnTask: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Task Dependencies
//****************************************************************************
@InputType()
export class CreateMJTaskDependencyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TaskID?: string;

    @Field({ nullable: true })
    DependsOnTaskID?: string;

    @Field({ nullable: true })
    DependencyType?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Task Dependencies
//****************************************************************************
@InputType()
export class UpdateMJTaskDependencyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TaskID?: string;

    @Field({ nullable: true })
    DependsOnTaskID?: string;

    @Field({ nullable: true })
    DependencyType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Task Dependencies
//****************************************************************************
@ObjectType()
export class RunMJTaskDependencyViewResult {
    @Field(() => [MJTaskDependency_])
    Results: MJTaskDependency_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTaskDependency_)
export class MJTaskDependencyResolver extends ResolverBase {
    @Query(() => RunMJTaskDependencyViewResult)
    async RunMJTaskDependencyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskDependencyViewResult)
    async RunMJTaskDependencyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskDependencyViewResult)
    async RunMJTaskDependencyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Task Dependencies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTaskDependency_, { nullable: true })
    async MJTaskDependency(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTaskDependency_ | null> {
        this.CheckUserReadPermissions('MJ: Task Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTaskDependencies')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Task Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Task Dependencies', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTaskDependency_)
    async CreateMJTaskDependency(
        @Arg('input', () => CreateMJTaskDependencyInput) input: CreateMJTaskDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Task Dependencies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTaskDependency_)
    async UpdateMJTaskDependency(
        @Arg('input', () => UpdateMJTaskDependencyInput) input: UpdateMJTaskDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Task Dependencies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTaskDependency_)
    async DeleteMJTaskDependency(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Task Dependencies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Task Types
//****************************************************************************
@ObjectType({ description: `Categorization system for different types of tasks that can be created and managed within the system` })
export class MJTaskType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Display name for the task type`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this task type represents and when it should be used`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJTask_])
    MJTasks_TypeIDArray: MJTask_[]; // Link to MJTasks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Task Types
//****************************************************************************
@InputType()
export class CreateMJTaskTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Task Types
//****************************************************************************
@InputType()
export class UpdateMJTaskTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Task Types
//****************************************************************************
@ObjectType()
export class RunMJTaskTypeViewResult {
    @Field(() => [MJTaskType_])
    Results: MJTaskType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTaskType_)
export class MJTaskTypeResolver extends ResolverBase {
    @Query(() => RunMJTaskTypeViewResult)
    async RunMJTaskTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskTypeViewResult)
    async RunMJTaskTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskTypeViewResult)
    async RunMJTaskTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Task Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTaskType_, { nullable: true })
    async MJTaskType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTaskType_ | null> {
        this.CheckUserReadPermissions('MJ: Task Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTaskTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Task Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Task Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTask_])
    async MJTasks_TypeIDArray(@Root() mjtasktype_: MJTaskType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTasks')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjtasktype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTaskType_)
    async CreateMJTaskType(
        @Arg('input', () => CreateMJTaskTypeInput) input: CreateMJTaskTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Task Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTaskType_)
    async UpdateMJTaskType(
        @Arg('input', () => UpdateMJTaskTypeInput) input: UpdateMJTaskTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Task Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTaskType_)
    async DeleteMJTaskType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Task Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Tasks
//****************************************************************************
@ObjectType({ description: `Core task management entity supporting multi-agent and multi-human collaboration with dependency tracking` })
export class MJTask_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Display name for the task`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the task requirements and objectives`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    TypeID: string;
        
    @Field() 
    @MaxLength(36)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ProjectID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ConversationDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    UserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    AgentID?: string;
        
    @Field({description: `Current status of the task (Pending, In Progress, Complete, Cancelled, Failed, Blocked, Deferred)`}) 
    @MaxLength(50)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Completion percentage for tracking progress (0-100)`}) 
    PercentComplete?: number;
        
    @Field({nullable: true, description: `Due date and time for task completion`}) 
    DueAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when work on the task began`}) 
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when the task was completed`}) 
    CompletedAt?: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field() 
    @MaxLength(255)
    Type: string;
        
    @Field() 
    @MaxLength(255)
    Environment: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Project?: string;
        
    @Field({nullable: true}) 
    ConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJTaskDependency_])
    MJTaskDependencies_DependsOnTaskIDArray: MJTaskDependency_[]; // Link to MJTaskDependencies
    
    @Field(() => [MJTaskDependency_])
    MJTaskDependencies_TaskIDArray: MJTaskDependency_[]; // Link to MJTaskDependencies
    
    @Field(() => [MJTask_])
    MJTasks_ParentIDArray: MJTask_[]; // Link to MJTasks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Tasks
//****************************************************************************
@InputType()
export class CreateMJTaskInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ProjectID: string | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    PercentComplete?: number | null;

    @Field({ nullable: true })
    DueAt: Date | null;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    CompletedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Tasks
//****************************************************************************
@InputType()
export class UpdateMJTaskInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ProjectID?: string | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    PercentComplete?: number | null;

    @Field({ nullable: true })
    DueAt?: Date | null;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Tasks
//****************************************************************************
@ObjectType()
export class RunMJTaskViewResult {
    @Field(() => [MJTask_])
    Results: MJTask_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTask_)
export class MJTaskResolver extends ResolverBase {
    @Query(() => RunMJTaskViewResult)
    async RunMJTaskViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskViewResult)
    async RunMJTaskViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskViewResult)
    async RunMJTaskDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Tasks';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTask_, { nullable: true })
    async MJTask(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTask_ | null> {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTasks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Tasks', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTaskDependency_])
    async MJTaskDependencies_DependsOnTaskIDArray(@Root() mjtask_: MJTask_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Task Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTaskDependencies')} WHERE ${provider.QuoteIdentifier('DependsOnTaskID')}='${mjtask_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Task Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Task Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTaskDependency_])
    async MJTaskDependencies_TaskIDArray(@Root() mjtask_: MJTask_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Task Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTaskDependencies')} WHERE ${provider.QuoteIdentifier('TaskID')}='${mjtask_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Task Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Task Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJTasks_ParentIDArray(@Root() mjtask_: MJTask_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTasks')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjtask_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTask_)
    async CreateMJTask(
        @Arg('input', () => CreateMJTaskInput) input: CreateMJTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Tasks', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTask_)
    async UpdateMJTask(
        @Arg('input', () => UpdateMJTaskInput) input: UpdateMJTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Tasks', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTask_)
    async DeleteMJTask(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Tasks', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Template Categories
//****************************************************************************
@ObjectType({ description: `Template categories for organizing templates` })
export class MJTemplateCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Name of the template category`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template category`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJTemplate_])
    MJTemplates_CategoryIDArray: MJTemplate_[]; // Link to MJTemplates
    
    @Field(() => [MJTemplateCategory_])
    MJTemplateCategories_ParentIDArray: MJTemplateCategory_[]; // Link to MJTemplateCategories
    
}

//****************************************************************************
// INPUT TYPE for MJ: Template Categories
//****************************************************************************
@InputType()
export class CreateMJTemplateCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Template Categories
//****************************************************************************
@InputType()
export class UpdateMJTemplateCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Template Categories
//****************************************************************************
@ObjectType()
export class RunMJTemplateCategoryViewResult {
    @Field(() => [MJTemplateCategory_])
    Results: MJTemplateCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateCategory_)
export class MJTemplateCategoryResolver extends ResolverBase {
    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Template Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateCategory_, { nullable: true })
    async MJTemplateCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateCategory_ | null> {
        this.CheckUserReadPermissions('MJ: Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Template Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTemplate_])
    async MJTemplates_CategoryIDArray(@Root() mjtemplatecategory_: MJTemplateCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplates')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjtemplatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Templates', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplateCategory_])
    async MJTemplateCategories_ParentIDArray(@Root() mjtemplatecategory_: MJTemplateCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjtemplatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Template Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTemplateCategory_)
    async CreateMJTemplateCategory(
        @Arg('input', () => CreateMJTemplateCategoryInput) input: CreateMJTemplateCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Template Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateCategory_)
    async UpdateMJTemplateCategory(
        @Arg('input', () => UpdateMJTemplateCategoryInput) input: UpdateMJTemplateCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Template Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateCategory_)
    async DeleteMJTemplateCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Template Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Template Content Types
//****************************************************************************
@ObjectType({ description: `Template content types for categorizing content within templates` })
export class MJTemplateContentType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Name of the template content type`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template content type`}) 
    Description?: string;
        
    @Field({description: `Refers to the primary language or codetype of the templates of this type, HTML, JSON, JavaScript, etc`}) 
    @MaxLength(25)
    CodeType: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJTemplateContent_])
    MJTemplateContents_TypeIDArray: MJTemplateContent_[]; // Link to MJTemplateContents
    
}

//****************************************************************************
// INPUT TYPE for MJ: Template Content Types
//****************************************************************************
@InputType()
export class CreateMJTemplateContentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CodeType?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Template Content Types
//****************************************************************************
@InputType()
export class UpdateMJTemplateContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CodeType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Template Content Types
//****************************************************************************
@ObjectType()
export class RunMJTemplateContentTypeViewResult {
    @Field(() => [MJTemplateContentType_])
    Results: MJTemplateContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateContentType_)
export class MJTemplateContentTypeResolver extends ResolverBase {
    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Template Content Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateContentType_, { nullable: true })
    async MJTemplateContentType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateContentType_ | null> {
        this.CheckUserReadPermissions('MJ: Template Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateContentTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Template Content Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTemplateContent_])
    async MJTemplateContents_TypeIDArray(@Root() mjtemplatecontenttype_: MJTemplateContentType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateContents')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjtemplatecontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Template Contents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTemplateContentType_)
    async CreateMJTemplateContentType(
        @Arg('input', () => CreateMJTemplateContentTypeInput) input: CreateMJTemplateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Template Content Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateContentType_)
    async UpdateMJTemplateContentType(
        @Arg('input', () => UpdateMJTemplateContentTypeInput) input: UpdateMJTemplateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Template Content Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateContentType_)
    async DeleteMJTemplateContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Template Content Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Template Contents
//****************************************************************************
@ObjectType({ description: `Template content for different versions of a template for purposes like HTML/Text/etc` })
export class MJTemplateContent_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    TemplateID: string;
        
    @Field() 
    @MaxLength(36)
    TypeID: string;
        
    @Field({nullable: true, description: `The actual text content for the template`}) 
    TemplateText?: string;
        
    @Field(() => Int, {description: `Priority of the content version, higher priority versions will be used ahead of lower priority versions for a given Type`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `Indicates whether the content is active or not. Use this to disable a particular Template Content item without having to remove it`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Template: string;
        
    @Field() 
    @MaxLength(255)
    Type: string;
        
    @Field(() => [MJTemplateParam_])
    MJTemplateParams_TemplateContentIDArray: MJTemplateParam_[]; // Link to MJTemplateParams
    
}

//****************************************************************************
// INPUT TYPE for MJ: Template Contents
//****************************************************************************
@InputType()
export class CreateMJTemplateContentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Template Contents
//****************************************************************************
@InputType()
export class UpdateMJTemplateContentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Template Contents
//****************************************************************************
@ObjectType()
export class RunMJTemplateContentViewResult {
    @Field(() => [MJTemplateContent_])
    Results: MJTemplateContent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateContent_)
export class MJTemplateContentResolver extends ResolverBase {
    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Template Contents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateContent_, { nullable: true })
    async MJTemplateContent(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateContent_ | null> {
        this.CheckUserReadPermissions('MJ: Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateContents')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Template Contents', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTemplateParam_])
    async MJTemplateParams_TemplateContentIDArray(@Root() mjtemplatecontent_: MJTemplateContent_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateParams')} WHERE ${provider.QuoteIdentifier('TemplateContentID')}='${mjtemplatecontent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Template Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTemplateContent_)
    async CreateMJTemplateContent(
        @Arg('input', () => CreateMJTemplateContentInput) input: CreateMJTemplateContentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Template Contents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateContent_)
    async UpdateMJTemplateContent(
        @Arg('input', () => UpdateMJTemplateContentInput) input: UpdateMJTemplateContentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Template Contents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateContent_)
    async DeleteMJTemplateContent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Template Contents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Template Params
//****************************************************************************
@ObjectType({ description: `Parameters allowed for use inside the template` })
export class MJTemplateParam_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    TemplateID: string;
        
    @Field({description: `Name of the parameter`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of the parameter`}) 
    Description?: string;
        
    @Field({description: `Type of the parameter - Record is an individual record within the entity specified by EntityID. Entity means an entire Entity or an entity filtered by the LinkedParameterName/Field attributes and/or ExtraFilter. Object is any valid JSON object. Array and Scalar have their common meanings.`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `Default value of the parameter`}) 
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `Whether this parameter must be provided when using the template.`}) 
    IsRequired: boolean;
        
    @Field({nullable: true, description: `Only used when Type=Entity, this is used to link an Entity parameter with another parameter so that the rows in the Entity parameter can be filtered automatically based on the FKEY relationship between the Record and this Entity parameter. For example, if the Entity-based parameter is for an entity like Activities and there is another parameter of type Record for an entity like Contacts, in that situation the Activities Parameter would point to the Contacts parameter as the LinkedParameterName because we would filter down the Activities in each template render to only those linked to the Contact.`}) 
    @MaxLength(255)
    LinkedParameterName?: string;
        
    @Field({nullable: true, description: `If the LinkedParameterName is specified, this is an optional setting to specify the field within the LinkedParameter that will be used for filtering. This is only needed if there is more than one foreign key relationship between the Entity parameter and the Linked parameter, or if there is no defined foreign key in the database between the two entities.`}) 
    @MaxLength(500)
    LinkedParameterField?: string;
        
    @Field({nullable: true, description: `Only used when Type = Entity, used to specify an optional filter to reduce the set of rows that are returned for each of the templates being rendered.`}) 
    ExtraFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    EntityID?: string;
        
    @Field({nullable: true, description: `Record ID, used only when Type is Record and a specific hardcoded record ID is desired, this is an uncommon use case, helpful for pulling in static types and metadata in some cases.`}) 
    @MaxLength(2000)
    RecordID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `This field is used only when the Type of the TemplateParam table is "Entity". It is an optional field used to specify the sorting order for the related entity data that is used in the template for the Entity specified.`}) 
    OrderBy?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific template content. When NULL, this parameter applies to all content items within the template. When set, this parameter applies only to the specified template content.`}) 
    @MaxLength(36)
    TemplateContentID?: string;
        
    @Field() 
    @MaxLength(255)
    Template: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    TemplateContent?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Template Params
//****************************************************************************
@InputType()
export class CreateMJTemplateParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName: string | null;

    @Field({ nullable: true })
    LinkedParameterField: string | null;

    @Field({ nullable: true })
    ExtraFilter: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    OrderBy: string | null;

    @Field({ nullable: true })
    TemplateContentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Template Params
//****************************************************************************
@InputType()
export class UpdateMJTemplateParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName?: string | null;

    @Field({ nullable: true })
    LinkedParameterField?: string | null;

    @Field({ nullable: true })
    ExtraFilter?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    OrderBy?: string | null;

    @Field({ nullable: true })
    TemplateContentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Template Params
//****************************************************************************
@ObjectType()
export class RunMJTemplateParamViewResult {
    @Field(() => [MJTemplateParam_])
    Results: MJTemplateParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateParam_)
export class MJTemplateParamResolver extends ResolverBase {
    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Template Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateParam_, { nullable: true })
    async MJTemplateParam(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateParam_ | null> {
        this.CheckUserReadPermissions('MJ: Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateParams')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Template Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTemplateParam_)
    async CreateMJTemplateParam(
        @Arg('input', () => CreateMJTemplateParamInput) input: CreateMJTemplateParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Template Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateParam_)
    async UpdateMJTemplateParam(
        @Arg('input', () => UpdateMJTemplateParamInput) input: UpdateMJTemplateParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Template Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateParam_)
    async DeleteMJTemplateParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Template Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Templates
//****************************************************************************
@ObjectType({ description: `Templates are used for dynamic expansion of a static template with data from a given context. Templates can be used to create documents, messages and anything else that requires dynamic document creation merging together static text, data and lightweight logic` })
export class MJTemplate_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Name of the template`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field({nullable: true, description: `This prompt will be used by the AI to generate template content as requested by the user.`}) 
    UserPrompt?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use until the specified date. Requires IsActive to be set to 1`}) 
    ActiveAt?: Date;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use after the specified date. If IsActive=0, this has no effect.`}) 
    DisabledAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 0, the template will be disabled regardless of the values in ActiveAt/DisabledAt. `}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Category?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field(() => [MJTemplateParam_])
    MJTemplateParams_TemplateIDArray: MJTemplateParam_[]; // Link to MJTemplateParams
    
    @Field(() => [MJTemplateContent_])
    MJTemplateContents_TemplateIDArray: MJTemplateContent_[]; // Link to MJTemplateContents
    
    @Field(() => [MJUserNotificationType_])
    MJUserNotificationTypes_SMSTemplateIDArray: MJUserNotificationType_[]; // Link to MJUserNotificationTypes
    
    @Field(() => [MJAIPrompt_])
    MJAIPrompts_TemplateIDArray: MJAIPrompt_[]; // Link to MJAIPrompts
    
    @Field(() => [MJUserNotificationType_])
    MJUserNotificationTypes_EmailTemplateIDArray: MJUserNotificationType_[]; // Link to MJUserNotificationTypes
    
    @Field(() => [MJEntityDocument_])
    MJEntityDocuments_TemplateIDArray: MJEntityDocument_[]; // Link to MJEntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for MJ: Templates
//****************************************************************************
@InputType()
export class CreateMJTemplateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt: Date | null;

    @Field({ nullable: true })
    DisabledAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Templates
//****************************************************************************
@InputType()
export class UpdateMJTemplateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt?: Date | null;

    @Field({ nullable: true })
    DisabledAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Templates
//****************************************************************************
@ObjectType()
export class RunMJTemplateViewResult {
    @Field(() => [MJTemplate_])
    Results: MJTemplate_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplate_)
export class MJTemplateResolver extends ResolverBase {
    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Templates';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplate_, { nullable: true })
    async MJTemplate(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplate_ | null> {
        this.CheckUserReadPermissions('MJ: Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplates')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Templates', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTemplateParam_])
    async MJTemplateParams_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateParams')} WHERE ${provider.QuoteIdentifier('TemplateID')}='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Template Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplateContent_])
    async MJTemplateContents_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateContents')} WHERE ${provider.QuoteIdentifier('TemplateID')}='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Template Contents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotificationType_])
    async MJUserNotificationTypes_SMSTemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notification Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotificationTypes')} WHERE ${provider.QuoteIdentifier('SMSTemplateID')}='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notification Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPrompt_])
    async MJAIPrompts_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPrompts')} WHERE ${provider.QuoteIdentifier('TemplateID')}='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotificationType_])
    async MJUserNotificationTypes_EmailTemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notification Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotificationTypes')} WHERE ${provider.QuoteIdentifier('EmailTemplateID')}='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notification Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async MJEntityDocuments_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocuments')} WHERE ${provider.QuoteIdentifier('TemplateID')}='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTemplate_)
    async CreateMJTemplate(
        @Arg('input', () => CreateMJTemplateInput) input: CreateMJTemplateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Templates', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplate_)
    async UpdateMJTemplate(
        @Arg('input', () => UpdateMJTemplateInput) input: UpdateMJTemplateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Templates', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplate_)
    async DeleteMJTemplate(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Templates', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Rubrics
//****************************************************************************
@ObjectType({ description: `Reusable evaluation criteria (rubrics) for consistent scoring across tests. Rubrics define structured evaluation dimensions and can include LLM prompts for automated judgment. Particularly useful for LLM-as-judge patterns where consistent evaluation criteria are critical.` })
export class MJTestRubric_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign Key - The test type this rubric applies to (e.g., Agent Eval, Code Generation)`}) 
    @MaxLength(36)
    TypeID: string;
        
    @Field({description: `Unique name for the rubric (e.g., "Component Quality Rubric v1", "Agent Response Quality")`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Description of what this rubric evaluates and when to use it`}) 
    Description?: string;
        
    @Field({nullable: true, description: `LLM prompt template for automated judgment. Can include placeholders for test inputs/outputs (e.g., "Evaluate the following React component for correctness, UX, and maintainability...")`}) 
    PromptTemplate?: string;
        
    @Field({nullable: true, description: `JSON object defining structured evaluation criteria with dimensions, weights, and scoring guidance (e.g., {correctness: {weight: 0.4, description: "..."}, ux: {weight: 0.3, description: "..."}})`}) 
    Criteria?: string;
        
    @Field({nullable: true, description: `Version identifier for the rubric. Allows tracking changes and comparing results across rubric versions.`}) 
    @MaxLength(50)
    Version?: string;
        
    @Field({description: `Status of the rubric: Pending (under development), Active (available for use), Disabled (deprecated)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Test Rubrics
//****************************************************************************
@InputType()
export class CreateMJTestRubricInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    PromptTemplate: string | null;

    @Field({ nullable: true })
    Criteria: string | null;

    @Field({ nullable: true })
    Version: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Rubrics
//****************************************************************************
@InputType()
export class UpdateMJTestRubricInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    PromptTemplate?: string | null;

    @Field({ nullable: true })
    Criteria?: string | null;

    @Field({ nullable: true })
    Version?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Rubrics
//****************************************************************************
@ObjectType()
export class RunMJTestRubricViewResult {
    @Field(() => [MJTestRubric_])
    Results: MJTestRubric_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestRubric_)
export class MJTestRubricResolver extends ResolverBase {
    @Query(() => RunMJTestRubricViewResult)
    async RunMJTestRubricViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRubricViewResult)
    async RunMJTestRubricViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRubricViewResult)
    async RunMJTestRubricDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Rubrics';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestRubric_, { nullable: true })
    async MJTestRubric(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestRubric_ | null> {
        this.CheckUserReadPermissions('MJ: Test Rubrics', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRubrics')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Rubrics', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Rubrics', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTestRubric_)
    async CreateMJTestRubric(
        @Arg('input', () => CreateMJTestRubricInput) input: CreateMJTestRubricInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Rubrics', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestRubric_)
    async UpdateMJTestRubric(
        @Arg('input', () => UpdateMJTestRubricInput) input: UpdateMJTestRubricInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Rubrics', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestRubric_)
    async DeleteMJTestRubric(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Rubrics', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Run Feedbacks
//****************************************************************************
@ObjectType({ description: `Human-in-the-loop feedback on test run results. Allows human reviewers to validate, correct, or override automated test results. Essential for training and improving automated evaluation criteria.` })
export class MJTestRunFeedback_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign Key - The test run being reviewed`}) 
    @MaxLength(36)
    TestRunID: string;
        
    @Field({description: `Foreign Key - The user providing the feedback`}) 
    @MaxLength(36)
    ReviewerUserID: string;
        
    @Field(() => Int, {nullable: true, description: `Numeric rating from 1 (poor) to 10 (excellent). Allows quantitative tracking of result quality.`}) 
    Rating?: number;
        
    @Field(() => Boolean, {nullable: true, description: `Boolean indicating if the automated test result was correct. Can override automated Pass/Fail status.`}) 
    IsCorrect?: boolean;
        
    @Field({nullable: true, description: `Summary of corrections or adjustments made by the human reviewer`}) 
    CorrectionSummary?: string;
        
    @Field({nullable: true, description: `Free-form comments from the reviewer about the test result, quality, or issues found`}) 
    Comments?: string;
        
    @Field({description: `Timestamp when the feedback was provided`}) 
    ReviewedAt: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    TestRun: string;
        
    @Field() 
    @MaxLength(100)
    ReviewerUser: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Test Run Feedbacks
//****************************************************************************
@InputType()
export class CreateMJTestRunFeedbackInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TestRunID?: string;

    @Field({ nullable: true })
    ReviewerUserID?: string;

    @Field(() => Int, { nullable: true })
    Rating: number | null;

    @Field(() => Boolean, { nullable: true })
    IsCorrect: boolean | null;

    @Field({ nullable: true })
    CorrectionSummary: string | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ReviewedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Run Feedbacks
//****************************************************************************
@InputType()
export class UpdateMJTestRunFeedbackInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TestRunID?: string;

    @Field({ nullable: true })
    ReviewerUserID?: string;

    @Field(() => Int, { nullable: true })
    Rating?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsCorrect?: boolean | null;

    @Field({ nullable: true })
    CorrectionSummary?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ReviewedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Run Feedbacks
//****************************************************************************
@ObjectType()
export class RunMJTestRunFeedbackViewResult {
    @Field(() => [MJTestRunFeedback_])
    Results: MJTestRunFeedback_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestRunFeedback_)
export class MJTestRunFeedbackResolver extends ResolverBase {
    @Query(() => RunMJTestRunFeedbackViewResult)
    async RunMJTestRunFeedbackViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunFeedbackViewResult)
    async RunMJTestRunFeedbackViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunFeedbackViewResult)
    async RunMJTestRunFeedbackDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Run Feedbacks';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestRunFeedback_, { nullable: true })
    async MJTestRunFeedback(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestRunFeedback_ | null> {
        this.CheckUserReadPermissions('MJ: Test Run Feedbacks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRunFeedbacks')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Feedbacks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Run Feedbacks', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTestRunFeedback_)
    async CreateMJTestRunFeedback(
        @Arg('input', () => CreateMJTestRunFeedbackInput) input: CreateMJTestRunFeedbackInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Run Feedbacks', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestRunFeedback_)
    async UpdateMJTestRunFeedback(
        @Arg('input', () => UpdateMJTestRunFeedbackInput) input: UpdateMJTestRunFeedbackInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Run Feedbacks', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestRunFeedback_)
    async DeleteMJTestRunFeedback(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Run Feedbacks', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Run Output Types
//****************************************************************************
@ObjectType()
export class MJTestRunOutputType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name identifying this output type (e.g., Screenshot, Log, Data, Video)`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Description of what this output type represents and when it is used`}) 
    Description?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJTestRunOutput_])
    MJTestRunOutputs_OutputTypeIDArray: MJTestRunOutput_[]; // Link to MJTestRunOutputs
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Run Output Types
//****************************************************************************
@InputType()
export class CreateMJTestRunOutputTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Run Output Types
//****************************************************************************
@InputType()
export class UpdateMJTestRunOutputTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Run Output Types
//****************************************************************************
@ObjectType()
export class RunMJTestRunOutputTypeViewResult {
    @Field(() => [MJTestRunOutputType_])
    Results: MJTestRunOutputType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestRunOutputType_)
export class MJTestRunOutputTypeResolver extends ResolverBase {
    @Query(() => RunMJTestRunOutputTypeViewResult)
    async RunMJTestRunOutputTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunOutputTypeViewResult)
    async RunMJTestRunOutputTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunOutputTypeViewResult)
    async RunMJTestRunOutputTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Run Output Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestRunOutputType_, { nullable: true })
    async MJTestRunOutputType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestRunOutputType_ | null> {
        this.CheckUserReadPermissions('MJ: Test Run Output Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRunOutputTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Output Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Run Output Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRunOutput_])
    async MJTestRunOutputs_OutputTypeIDArray(@Root() mjtestrunoutputtype_: MJTestRunOutputType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Run Outputs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRunOutputs')} WHERE ${provider.QuoteIdentifier('OutputTypeID')}='${mjtestrunoutputtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Outputs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Run Outputs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestRunOutputType_)
    async CreateMJTestRunOutputType(
        @Arg('input', () => CreateMJTestRunOutputTypeInput) input: CreateMJTestRunOutputTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Run Output Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestRunOutputType_)
    async UpdateMJTestRunOutputType(
        @Arg('input', () => UpdateMJTestRunOutputTypeInput) input: UpdateMJTestRunOutputTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Run Output Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestRunOutputType_)
    async DeleteMJTestRunOutputType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Run Output Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Run Outputs
//****************************************************************************
@ObjectType()
export class MJTestRunOutput_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign key to the parent test run that produced this output`}) 
    @MaxLength(36)
    TestRunID: string;
        
    @Field({description: `Foreign key to the output type category (Screenshot, Log, Video, etc.)`}) 
    @MaxLength(36)
    OutputTypeID: string;
        
    @Field(() => Int, {description: `Chronological ordering for storyboarding outputs across steps`}) 
    Sequence: number;
        
    @Field(() => Int, {nullable: true, description: `Which step produced this output, for step-based tests like Computer Use`}) 
    StepNumber?: number;
        
    @Field({nullable: true, description: `Human-readable label for this output (e.g., Step 3 Screenshot)`}) 
    @MaxLength(255)
    Name?: string;
        
    @Field({nullable: true, description: `Additional context about this output`}) 
    Description?: string;
        
    @Field({nullable: true, description: `MIME type of the output data (e.g., image/png, text/plain, application/json, video/mp4)`}) 
    @MaxLength(100)
    MimeType?: string;
        
    @Field({nullable: true, description: `Base64-encoded binary data (images, audio, video) or text content (logs, JSON, HTML)`}) 
    InlineData?: string;
        
    @Field(() => Int, {nullable: true, description: `Size of the output data in bytes`}) 
    FileSizeBytes?: number;
        
    @Field(() => Int, {nullable: true, description: `Width in pixels for image or video outputs`}) 
    Width?: number;
        
    @Field(() => Int, {nullable: true, description: `Height in pixels for image or video outputs`}) 
    Height?: number;
        
    @Field(() => Float, {nullable: true, description: `Duration in seconds for audio or video outputs`}) 
    DurationSeconds?: number;
        
    @Field({nullable: true, description: `JSON object with additional metadata about this output (e.g., URL at time of capture, tool calls, error info)`}) 
    Metadata?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    TestRun: string;
        
    @Field() 
    @MaxLength(100)
    OutputType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Test Run Outputs
//****************************************************************************
@InputType()
export class CreateMJTestRunOutputInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TestRunID?: string;

    @Field({ nullable: true })
    OutputTypeID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Int, { nullable: true })
    StepNumber: number | null;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    MimeType: string | null;

    @Field({ nullable: true })
    InlineData: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    Width: number | null;

    @Field(() => Int, { nullable: true })
    Height: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    Metadata: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Run Outputs
//****************************************************************************
@InputType()
export class UpdateMJTestRunOutputInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TestRunID?: string;

    @Field({ nullable: true })
    OutputTypeID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Int, { nullable: true })
    StepNumber?: number | null;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    MimeType?: string | null;

    @Field({ nullable: true })
    InlineData?: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    Width?: number | null;

    @Field(() => Int, { nullable: true })
    Height?: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    Metadata?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Run Outputs
//****************************************************************************
@ObjectType()
export class RunMJTestRunOutputViewResult {
    @Field(() => [MJTestRunOutput_])
    Results: MJTestRunOutput_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestRunOutput_)
export class MJTestRunOutputResolver extends ResolverBase {
    @Query(() => RunMJTestRunOutputViewResult)
    async RunMJTestRunOutputViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunOutputViewResult)
    async RunMJTestRunOutputViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunOutputViewResult)
    async RunMJTestRunOutputDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Run Outputs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestRunOutput_, { nullable: true })
    async MJTestRunOutput(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestRunOutput_ | null> {
        this.CheckUserReadPermissions('MJ: Test Run Outputs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRunOutputs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Outputs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Run Outputs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTestRunOutput_)
    async CreateMJTestRunOutput(
        @Arg('input', () => CreateMJTestRunOutputInput) input: CreateMJTestRunOutputInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Run Outputs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestRunOutput_)
    async UpdateMJTestRunOutput(
        @Arg('input', () => UpdateMJTestRunOutputInput) input: UpdateMJTestRunOutputInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Run Outputs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestRunOutput_)
    async DeleteMJTestRunOutput(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Run Outputs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Runs
//****************************************************************************
@ObjectType({ description: `Execution instance of a single test. Captures inputs, outputs, results, and links to the target being tested (e.g., Agent Run). Can be part of a suite run or standalone. The TargetLogID links to type-specific execution logs (AgentRun, WorkflowRun, etc.) which contain the detailed trace information.` })
export class MJTestRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign Key - The test definition that was executed`}) 
    @MaxLength(36)
    TestID: string;
        
    @Field({nullable: true, description: `Foreign Key - Optional parent suite run if this test was part of a suite execution. NULL for standalone test runs.`}) 
    @MaxLength(36)
    TestSuiteRunID?: string;
        
    @Field({description: `Foreign Key - The user who triggered the test run (could be system user for automated runs)`}) 
    @MaxLength(36)
    RunByUserID: string;
        
    @Field(() => Int, {nullable: true, description: `Execution sequence within the suite run. Indicates order of execution for tests in the same suite.`}) 
    Sequence?: number;
        
    @Field({nullable: true, description: `Optional sub-category or variant label for the test target. Use this to distinguish between different test scenarios within the same entity type (e.g., "Summarization", "Classification", "Code Review" for AI Agent tests). The entity type itself should be specified via TargetLogEntityID.`}) 
    @MaxLength(100)
    TargetType?: string;
        
    @Field({nullable: true, description: `ID of the target execution log (e.g., AIAgentRun.ID, WorkflowRun.ID). This is a soft FK - the actual entity depends on TargetType. The target entity should have a reverse FK back to TestRun for bidirectional navigation.`}) 
    @MaxLength(36)
    TargetLogID?: string;
        
    @Field({description: `Current status of the test run: Pending (queued), Running (in progress), Passed (all checks passed), Failed (at least one check failed), Skipped (not executed), Error (execution error before validation), Timeout (execution exceeded time limit and was cancelled)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp when the test run started execution`}) 
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when the test run completed`}) 
    CompletedAt?: Date;
        
    @Field(() => Float, {nullable: true, description: `Execution time in seconds for this test`}) 
    DurationSeconds?: number;
        
    @Field({nullable: true, description: `JSON object with the actual inputs used for this test run (may differ from test definition if parameterized)`}) 
    InputData?: string;
        
    @Field({nullable: true, description: `JSON object with the expected outputs/outcomes for this test run`}) 
    ExpectedOutputData?: string;
        
    @Field({nullable: true, description: `JSON object with the actual outputs produced by the test execution`}) 
    ActualOutputData?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of validation checks that passed`}) 
    PassedChecks?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of validation checks that failed`}) 
    FailedChecks?: number;
        
    @Field(() => Int, {nullable: true, description: `Total number of validation checks performed`}) 
    TotalChecks?: number;
        
    @Field(() => Float, {nullable: true, description: `Overall test score from 0.0000 to 1.0000 (0-100%). Calculated by test driver based on passed/failed checks and weights.`}) 
    Score?: number;
        
    @Field(() => Float, {nullable: true, description: `Cost in USD for running this test (e.g., LLM token costs, compute resources)`}) 
    CostUSD?: number;
        
    @Field({nullable: true, description: `Error message if the test encountered an execution error`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON object with detailed results including individual check results, metrics, oracle outputs, and diagnostic information`}) 
    ResultDetails?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Detailed execution log capturing status messages, diagnostic output, and driver-specific information streamed during test execution. Format is timestamped log lines.`}) 
    Log?: string;
        
    @Field({nullable: true, description: `JSON array of user-assigned tags/labels for this test run. Used for categorization, filtering, and comparing runs with different configurations. Inherits from parent suite run tags if not explicitly set.`}) 
    Tags?: string;
        
    @Field({nullable: true, description: `Hostname of the machine that executed this test. Used for identifying the execution environment and debugging infrastructure-specific issues.`}) 
    @MaxLength(255)
    MachineName?: string;
        
    @Field({nullable: true, description: `Unique machine identifier (typically MAC address) for the execution host. Enables deduplication and tracking of test execution across different machines.`}) 
    @MaxLength(255)
    MachineID?: string;
        
    @Field({nullable: true, description: `Denormalized user name who ran the test. Stored separately from RunByUserID to enable cross-server aggregation where user IDs differ but names remain consistent.`}) 
    @MaxLength(255)
    RunByUserName?: string;
        
    @Field({nullable: true, description: `Denormalized email address of the user who ran the test. Primary identifier for cross-server aggregation since email addresses are unique across MemberJunction instances.`}) 
    @MaxLength(255)
    RunByUserEmail?: string;
        
    @Field({nullable: true, description: `JSON object containing extensible execution context: osType, osVersion, nodeVersion, timezone, locale, ipAddress, and CI/CD metadata (ciProvider, pipelineId, buildNumber, branch, prNumber). Allows detailed environment tracking without schema changes.`}) 
    RunContextDetails?: string;
        
    @Field({nullable: true, description: `Foreign key to Entity table identifying the type of entity referenced by TargetLogID. When populated, TargetLogID is a record ID in this entity. Used for linking test runs to AI Agent Runs, Workflow Runs, or other entity types being tested.`}) 
    @MaxLength(36)
    TargetLogEntityID?: string;
        
    @Field({nullable: true, description: `JSON object containing the final resolved variable values used during test execution. Includes both the resolved values and the source of each value (run, suite, test, or type level). Stored for reproducibility and auditing.`}) 
    ResolvedVariables?: string;
        
    @Field() 
    @MaxLength(255)
    Test: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    TestSuiteRun?: string;
        
    @Field() 
    @MaxLength(100)
    RunByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    TargetLogEntity?: string;
        
    @Field(() => [MJTestRunOutput_])
    MJTestRunOutputs_TestRunIDArray: MJTestRunOutput_[]; // Link to MJTestRunOutputs
    
    @Field(() => [MJTestRunFeedback_])
    MJTestRunFeedbacks_TestRunIDArray: MJTestRunFeedback_[]; // Link to MJTestRunFeedbacks
    
    @Field(() => [MJAIPromptRun_])
    MJAIPromptRuns_TestRunIDArray: MJAIPromptRun_[]; // Link to MJAIPromptRuns
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_TestRunIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
    @Field(() => [MJConversation_])
    MJConversations_TestRunIDArray: MJConversation_[]; // Link to MJConversations
    
    @Field(() => [MJConversationDetail_])
    MJConversationDetails_TestRunIDArray: MJConversationDetail_[]; // Link to MJConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Runs
//****************************************************************************
@InputType()
export class CreateMJTestRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TestID?: string;

    @Field({ nullable: true })
    TestSuiteRunID: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => Int, { nullable: true })
    Sequence: number | null;

    @Field({ nullable: true })
    TargetType: string | null;

    @Field({ nullable: true })
    TargetLogID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    InputData: string | null;

    @Field({ nullable: true })
    ExpectedOutputData: string | null;

    @Field({ nullable: true })
    ActualOutputData: string | null;

    @Field(() => Int, { nullable: true })
    PassedChecks: number | null;

    @Field(() => Int, { nullable: true })
    FailedChecks: number | null;

    @Field(() => Int, { nullable: true })
    TotalChecks: number | null;

    @Field(() => Float, { nullable: true })
    Score: number | null;

    @Field(() => Float, { nullable: true })
    CostUSD: number | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ResultDetails: string | null;

    @Field({ nullable: true })
    Log: string | null;

    @Field({ nullable: true })
    Tags: string | null;

    @Field({ nullable: true })
    MachineName: string | null;

    @Field({ nullable: true })
    MachineID: string | null;

    @Field({ nullable: true })
    RunByUserName: string | null;

    @Field({ nullable: true })
    RunByUserEmail: string | null;

    @Field({ nullable: true })
    RunContextDetails: string | null;

    @Field({ nullable: true })
    TargetLogEntityID: string | null;

    @Field({ nullable: true })
    ResolvedVariables: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Runs
//****************************************************************************
@InputType()
export class UpdateMJTestRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TestID?: string;

    @Field({ nullable: true })
    TestSuiteRunID?: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number | null;

    @Field({ nullable: true })
    TargetType?: string | null;

    @Field({ nullable: true })
    TargetLogID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    InputData?: string | null;

    @Field({ nullable: true })
    ExpectedOutputData?: string | null;

    @Field({ nullable: true })
    ActualOutputData?: string | null;

    @Field(() => Int, { nullable: true })
    PassedChecks?: number | null;

    @Field(() => Int, { nullable: true })
    FailedChecks?: number | null;

    @Field(() => Int, { nullable: true })
    TotalChecks?: number | null;

    @Field(() => Float, { nullable: true })
    Score?: number | null;

    @Field(() => Float, { nullable: true })
    CostUSD?: number | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ResultDetails?: string | null;

    @Field({ nullable: true })
    Log?: string | null;

    @Field({ nullable: true })
    Tags?: string | null;

    @Field({ nullable: true })
    MachineName?: string | null;

    @Field({ nullable: true })
    MachineID?: string | null;

    @Field({ nullable: true })
    RunByUserName?: string | null;

    @Field({ nullable: true })
    RunByUserEmail?: string | null;

    @Field({ nullable: true })
    RunContextDetails?: string | null;

    @Field({ nullable: true })
    TargetLogEntityID?: string | null;

    @Field({ nullable: true })
    ResolvedVariables?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Runs
//****************************************************************************
@ObjectType()
export class RunMJTestRunViewResult {
    @Field(() => [MJTestRun_])
    Results: MJTestRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestRun_)
export class MJTestRunResolver extends ResolverBase {
    @Query(() => RunMJTestRunViewResult)
    async RunMJTestRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunViewResult)
    async RunMJTestRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunViewResult)
    async RunMJTestRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestRun_, { nullable: true })
    async MJTestRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestRun_ | null> {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRunOutput_])
    async MJTestRunOutputs_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Run Outputs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRunOutputs')} WHERE ${provider.QuoteIdentifier('TestRunID')}='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Outputs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Run Outputs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestRunFeedback_])
    async MJTestRunFeedbacks_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Run Feedbacks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRunFeedbacks')} WHERE ${provider.QuoteIdentifier('TestRunID')}='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Feedbacks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Run Feedbacks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJAIPromptRuns_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIPromptRuns')} WHERE ${provider.QuoteIdentifier('TestRunID')}='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('TestRunID')}='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async MJConversations_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversations')} WHERE ${provider.QuoteIdentifier('TestRunID')}='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async MJConversationDetails_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetails')} WHERE ${provider.QuoteIdentifier('TestRunID')}='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestRun_)
    async CreateMJTestRun(
        @Arg('input', () => CreateMJTestRunInput) input: CreateMJTestRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestRun_)
    async UpdateMJTestRun(
        @Arg('input', () => UpdateMJTestRunInput) input: UpdateMJTestRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestRun_)
    async DeleteMJTestRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Suite Runs
//****************************************************************************
@ObjectType({ description: `Execution instance of a test suite. Captures who ran it, when, in what environment, and aggregates results from all tests in the suite. Supports versioning via GitCommit and AgentVersion fields to track system state during execution.` })
export class MJTestSuiteRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign Key - The test suite that was executed`}) 
    @MaxLength(36)
    SuiteID: string;
        
    @Field({description: `Foreign Key - The user who triggered the suite run (could be system user for automated runs)`}) 
    @MaxLength(36)
    RunByUserID: string;
        
    @Field({nullable: true, description: `Environment where tests were executed (e.g., "dev", "staging", "prod", "ci")`}) 
    @MaxLength(50)
    Environment?: string;
        
    @Field({nullable: true, description: `How the run was triggered (e.g., "manual", "ci", "scheduled", "shadow", "release")`}) 
    @MaxLength(50)
    TriggerType?: string;
        
    @Field({nullable: true, description: `Git commit SHA of the code version being tested. Enables correlation between test results and code changes.`}) 
    @MaxLength(100)
    GitCommit?: string;
        
    @Field({nullable: true, description: `Version of the agent or system being tested (e.g., "skip-agent-2.1.0", "workflow-engine-3.4.2"). Enables version comparison and regression detection.`}) 
    @MaxLength(100)
    AgentVersion?: string;
        
    @Field({description: `Current status of the suite run: Pending (queued), Running (in progress), Completed (finished successfully), Failed (suite-level failure), Cancelled (stopped by user)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp when the suite run started execution`}) 
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when the suite run completed (successfully or with failures)`}) 
    CompletedAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total number of tests executed in this suite run`}) 
    TotalTests?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tests that passed all checks`}) 
    PassedTests?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tests that failed at least one check`}) 
    FailedTests?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tests that were skipped (not executed)`}) 
    SkippedTests?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tests that encountered execution errors (different from failing validation)`}) 
    ErrorTests?: number;
        
    @Field(() => Float, {nullable: true, description: `Total execution time in seconds for the entire suite`}) 
    TotalDurationSeconds?: number;
        
    @Field(() => Float, {nullable: true, description: `Total cost in USD for running the entire suite (sum of all test costs)`}) 
    TotalCostUSD?: number;
        
    @Field({nullable: true, description: `JSON snapshot of the runtime configuration used for this suite run`}) 
    Configuration?: string;
        
    @Field({nullable: true, description: `JSON object with aggregated results and statistics from the suite run`}) 
    ResultSummary?: string;
        
    @Field({nullable: true, description: `Error message if the suite-level execution failed (before individual tests could run)`}) 
    ErrorMessage?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON array of user-assigned tags/labels for this suite run. Used for categorization, filtering, and comparing runs with different configurations (e.g., ["Opus 4.5", "New Prompt v3", "Production Config"]).`}) 
    Tags?: string;
        
    @Field({nullable: true, description: `Hostname of the machine that executed this suite. Used for identifying the execution environment and debugging infrastructure-specific issues.`}) 
    @MaxLength(255)
    MachineName?: string;
        
    @Field({nullable: true, description: `Unique machine identifier (typically MAC address) for the execution host. Enables deduplication and tracking of suite execution across different machines.`}) 
    @MaxLength(255)
    MachineID?: string;
        
    @Field({nullable: true, description: `Denormalized user name who ran the suite. Stored separately from RunByUserID to enable cross-server aggregation where user IDs differ but names remain consistent.`}) 
    @MaxLength(255)
    RunByUserName?: string;
        
    @Field({nullable: true, description: `Denormalized email address of the user who ran the suite. Primary identifier for cross-server aggregation since email addresses are unique across MemberJunction instances.`}) 
    @MaxLength(255)
    RunByUserEmail?: string;
        
    @Field({nullable: true, description: `JSON object containing extensible execution context: osType, osVersion, nodeVersion, timezone, locale, ipAddress, and CI/CD metadata (ciProvider, pipelineId, buildNumber, branch, prNumber). Allows detailed environment tracking without schema changes.`}) 
    RunContextDetails?: string;
        
    @Field({nullable: true, description: `JSON object containing the variable values provided at suite run level. These values were applied to all tests in the suite run and can be seen on individual TestRun.ResolvedVariables with source="suite".`}) 
    ResolvedVariables?: string;
        
    @Field() 
    @MaxLength(255)
    Suite: string;
        
    @Field() 
    @MaxLength(100)
    RunByUser: string;
        
    @Field(() => [MJTestRun_])
    MJTestRuns_TestSuiteRunIDArray: MJTestRun_[]; // Link to MJTestRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Suite Runs
//****************************************************************************
@InputType()
export class CreateMJTestSuiteRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SuiteID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    Environment: string | null;

    @Field({ nullable: true })
    TriggerType: string | null;

    @Field({ nullable: true })
    GitCommit: string | null;

    @Field({ nullable: true })
    AgentVersion: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalTests: number | null;

    @Field(() => Int, { nullable: true })
    PassedTests: number | null;

    @Field(() => Int, { nullable: true })
    FailedTests: number | null;

    @Field(() => Int, { nullable: true })
    SkippedTests: number | null;

    @Field(() => Int, { nullable: true })
    ErrorTests: number | null;

    @Field(() => Float, { nullable: true })
    TotalDurationSeconds: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostUSD: number | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    ResultSummary: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Tags: string | null;

    @Field({ nullable: true })
    MachineName: string | null;

    @Field({ nullable: true })
    MachineID: string | null;

    @Field({ nullable: true })
    RunByUserName: string | null;

    @Field({ nullable: true })
    RunByUserEmail: string | null;

    @Field({ nullable: true })
    RunContextDetails: string | null;

    @Field({ nullable: true })
    ResolvedVariables: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Suite Runs
//****************************************************************************
@InputType()
export class UpdateMJTestSuiteRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SuiteID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    Environment?: string | null;

    @Field({ nullable: true })
    TriggerType?: string | null;

    @Field({ nullable: true })
    GitCommit?: string | null;

    @Field({ nullable: true })
    AgentVersion?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalTests?: number | null;

    @Field(() => Int, { nullable: true })
    PassedTests?: number | null;

    @Field(() => Int, { nullable: true })
    FailedTests?: number | null;

    @Field(() => Int, { nullable: true })
    SkippedTests?: number | null;

    @Field(() => Int, { nullable: true })
    ErrorTests?: number | null;

    @Field(() => Float, { nullable: true })
    TotalDurationSeconds?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostUSD?: number | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    ResultSummary?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Tags?: string | null;

    @Field({ nullable: true })
    MachineName?: string | null;

    @Field({ nullable: true })
    MachineID?: string | null;

    @Field({ nullable: true })
    RunByUserName?: string | null;

    @Field({ nullable: true })
    RunByUserEmail?: string | null;

    @Field({ nullable: true })
    RunContextDetails?: string | null;

    @Field({ nullable: true })
    ResolvedVariables?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Suite Runs
//****************************************************************************
@ObjectType()
export class RunMJTestSuiteRunViewResult {
    @Field(() => [MJTestSuiteRun_])
    Results: MJTestSuiteRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestSuiteRun_)
export class MJTestSuiteRunResolver extends ResolverBase {
    @Query(() => RunMJTestSuiteRunViewResult)
    async RunMJTestSuiteRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteRunViewResult)
    async RunMJTestSuiteRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteRunViewResult)
    async RunMJTestSuiteRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Suite Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestSuiteRun_, { nullable: true })
    async MJTestSuiteRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestSuiteRun_ | null> {
        this.CheckUserReadPermissions('MJ: Test Suite Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestSuiteRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Suite Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRun_])
    async MJTestRuns_TestSuiteRunIDArray(@Root() mjtestsuiterun_: MJTestSuiteRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRuns')} WHERE ${provider.QuoteIdentifier('TestSuiteRunID')}='${mjtestsuiterun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestSuiteRun_)
    async CreateMJTestSuiteRun(
        @Arg('input', () => CreateMJTestSuiteRunInput) input: CreateMJTestSuiteRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Suite Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestSuiteRun_)
    async UpdateMJTestSuiteRun(
        @Arg('input', () => UpdateMJTestSuiteRunInput) input: UpdateMJTestSuiteRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Suite Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestSuiteRun_)
    async DeleteMJTestSuiteRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Suite Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Suite Tests
//****************************************************************************
@ObjectType({ description: `Junction table linking tests to test suites. Allows many-to-many relationship where a test can belong to multiple suites and a suite can contain multiple tests. Includes sequence for execution order and configuration overrides specific to this suite-test pairing.` })
export class MJTestSuiteTest_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign Key - The test suite this relationship belongs to`}) 
    @MaxLength(36)
    SuiteID: string;
        
    @Field({description: `Foreign Key - The test included in this suite`}) 
    @MaxLength(36)
    TestID: string;
        
    @Field(() => Int, {description: `Execution sequence within the suite. Lower numbers run first. Tests with same sequence may run in parallel.`}) 
    Sequence: number;
        
    @Field({description: `Status of this test within this suite: Active (will run), Disabled (temporarily excluded), Skip (documented exclusion)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `JSON object to override test configuration for this specific suite. Allows same test to run with different parameters in different suites.`}) 
    Configuration?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Suite: string;
        
    @Field() 
    @MaxLength(255)
    Test: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Test Suite Tests
//****************************************************************************
@InputType()
export class CreateMJTestSuiteTestInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SuiteID?: string;

    @Field({ nullable: true })
    TestID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Suite Tests
//****************************************************************************
@InputType()
export class UpdateMJTestSuiteTestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SuiteID?: string;

    @Field({ nullable: true })
    TestID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Suite Tests
//****************************************************************************
@ObjectType()
export class RunMJTestSuiteTestViewResult {
    @Field(() => [MJTestSuiteTest_])
    Results: MJTestSuiteTest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestSuiteTest_)
export class MJTestSuiteTestResolver extends ResolverBase {
    @Query(() => RunMJTestSuiteTestViewResult)
    async RunMJTestSuiteTestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteTestViewResult)
    async RunMJTestSuiteTestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteTestViewResult)
    async RunMJTestSuiteTestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Suite Tests';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestSuiteTest_, { nullable: true })
    async MJTestSuiteTest(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestSuiteTest_ | null> {
        this.CheckUserReadPermissions('MJ: Test Suite Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestSuiteTests')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Suite Tests', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTestSuiteTest_)
    async CreateMJTestSuiteTest(
        @Arg('input', () => CreateMJTestSuiteTestInput) input: CreateMJTestSuiteTestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Suite Tests', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestSuiteTest_)
    async UpdateMJTestSuiteTest(
        @Arg('input', () => UpdateMJTestSuiteTestInput) input: UpdateMJTestSuiteTestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Suite Tests', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestSuiteTest_)
    async DeleteMJTestSuiteTest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Suite Tests', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Suites
//****************************************************************************
@ObjectType({ description: `Hierarchical organization of tests into suites. Test suites can contain other suites (via ParentID) and tests (via TestSuiteTest junction table). Suites provide logical grouping for running batches of related tests.` })
export class MJTestSuite_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({nullable: true, description: `Optional parent suite ID for hierarchical organization. NULL for root-level suites.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Name of the test suite (e.g., "Skip Component Generation Suite", "Agent Memory Tests")`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this suite tests and its purpose`}) 
    Description?: string;
        
    @Field({description: `Status of the suite: Pending (being configured), Active (available for use), Disabled (archived/not in use)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `JSON array of tags for categorization and filtering (e.g., ["smoke", "regression", "nightly"])`}) 
    Tags?: string;
        
    @Field({nullable: true, description: `JSON configuration object for suite-level settings (e.g., environment defaults, retry policies, notification settings)`}) 
    Configuration?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Maximum total execution time in milliseconds for the entire suite. If NULL, no suite-level timeout applies (individual test timeouts still apply). When exceeded, current test is cancelled and remaining tests are skipped.`}) 
    MaxExecutionTimeMS?: number;
        
    @Field({nullable: true, description: `JSON object containing variable values to apply to all tests in this suite. These values override test-level defaults but can be overridden by run-level values.`}) 
    Variables?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJTestSuite_])
    MJTestSuites_ParentIDArray: MJTestSuite_[]; // Link to MJTestSuites
    
    @Field(() => [MJTestSuiteTest_])
    MJTestSuiteTests_SuiteIDArray: MJTestSuiteTest_[]; // Link to MJTestSuiteTests
    
    @Field(() => [MJTestSuiteRun_])
    MJTestSuiteRuns_SuiteIDArray: MJTestSuiteRun_[]; // Link to MJTestSuiteRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Suites
//****************************************************************************
@InputType()
export class CreateMJTestSuiteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Tags: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionTimeMS: number | null;

    @Field({ nullable: true })
    Variables: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Suites
//****************************************************************************
@InputType()
export class UpdateMJTestSuiteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Tags?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionTimeMS?: number | null;

    @Field({ nullable: true })
    Variables?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Suites
//****************************************************************************
@ObjectType()
export class RunMJTestSuiteViewResult {
    @Field(() => [MJTestSuite_])
    Results: MJTestSuite_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestSuite_)
export class MJTestSuiteResolver extends ResolverBase {
    @Query(() => RunMJTestSuiteViewResult)
    async RunMJTestSuiteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteViewResult)
    async RunMJTestSuiteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteViewResult)
    async RunMJTestSuiteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Suites';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestSuite_, { nullable: true })
    async MJTestSuite(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestSuite_ | null> {
        this.CheckUserReadPermissions('MJ: Test Suites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestSuites')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Suites', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestSuite_])
    async MJTestSuites_ParentIDArray(@Root() mjtestsuite_: MJTestSuite_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestSuites')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjtestsuite_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suites', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestSuiteTest_])
    async MJTestSuiteTests_SuiteIDArray(@Root() mjtestsuite_: MJTestSuite_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suite Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestSuiteTests')} WHERE ${provider.QuoteIdentifier('SuiteID')}='${mjtestsuite_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suite Tests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestSuiteRun_])
    async MJTestSuiteRuns_SuiteIDArray(@Root() mjtestsuite_: MJTestSuite_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suite Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestSuiteRuns')} WHERE ${provider.QuoteIdentifier('SuiteID')}='${mjtestsuite_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suite Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestSuite_)
    async CreateMJTestSuite(
        @Arg('input', () => CreateMJTestSuiteInput) input: CreateMJTestSuiteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Suites', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestSuite_)
    async UpdateMJTestSuite(
        @Arg('input', () => UpdateMJTestSuiteInput) input: UpdateMJTestSuiteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Suites', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestSuite_)
    async DeleteMJTestSuite(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Suites', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Types
//****************************************************************************
@ObjectType({ description: `Defines test type drivers that can be dynamically instantiated via MJGlobal.Instance.ClassFactory.CreateInstance(BaseTestDriver, DriverClass). Each test type represents a different category of testing (e.g., Agent Evals, Workflow Tests, Code Generation Tests).` })
export class MJTestType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name for the test type (e.g., "Agent Eval", "Workflow Test", "Code Generation Test")`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this test type validates and how it works`}) 
    Description?: string;
        
    @Field({description: `Class name for the driver implementation (e.g., "AgentEvalDriver"). Used with ClassFactory to instantiate the appropriate BaseTestDriver subclass.`}) 
    @MaxLength(255)
    DriverClass: string;
        
    @Field({description: `Status of the test type: Pending (under development), Active (available for use), Disabled (no longer available)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON schema defining the variables available for tests of this type. Contains schemaVersion and array of variable definitions with name, displayName, description, dataType, valueSource, possibleValues, defaultValue, and required fields.`}) 
    VariablesSchema?: string;
        
    @Field(() => [MJTestRubric_])
    MJTestRubrics_TypeIDArray: MJTestRubric_[]; // Link to MJTestRubrics
    
    @Field(() => [MJTest_])
    MJTests_TypeIDArray: MJTest_[]; // Link to MJTests
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Types
//****************************************************************************
@InputType()
export class CreateMJTestTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    VariablesSchema: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Types
//****************************************************************************
@InputType()
export class UpdateMJTestTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    VariablesSchema?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Types
//****************************************************************************
@ObjectType()
export class RunMJTestTypeViewResult {
    @Field(() => [MJTestType_])
    Results: MJTestType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestType_)
export class MJTestTypeResolver extends ResolverBase {
    @Query(() => RunMJTestTypeViewResult)
    async RunMJTestTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestTypeViewResult)
    async RunMJTestTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestTypeViewResult)
    async RunMJTestTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestType_, { nullable: true })
    async MJTestType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestType_ | null> {
        this.CheckUserReadPermissions('MJ: Test Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRubric_])
    async MJTestRubrics_TypeIDArray(@Root() mjtesttype_: MJTestType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Rubrics', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRubrics')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjtesttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Rubrics', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Rubrics', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTest_])
    async MJTests_TypeIDArray(@Root() mjtesttype_: MJTestType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTests')} WHERE ${provider.QuoteIdentifier('TypeID')}='${mjtesttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestType_)
    async CreateMJTestType(
        @Arg('input', () => CreateMJTestTypeInput) input: CreateMJTestTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestType_)
    async UpdateMJTestType(
        @Arg('input', () => UpdateMJTestTypeInput) input: UpdateMJTestTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestType_)
    async DeleteMJTestType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Tests
//****************************************************************************
@ObjectType({ description: `Individual test definitions. Each test has a specific type (via TypeID) which determines how it executes. Tests store their inputs, expected outcomes, and configuration as JSON, allowing flexibility for different test types while maintaining a common schema.` })
export class MJTest_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Foreign Key - The type of test (e.g., Agent Eval, Workflow Test). Determines which driver class handles execution.`}) 
    @MaxLength(36)
    TypeID: string;
        
    @Field({description: `Name of the test (e.g., "Pie Chart with Drilldown", "Memory Recall Accuracy")`}) 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this test validates and why it matters`}) 
    Description?: string;
        
    @Field({description: `Status of the test: Pending (being configured), Active (ready to run), Disabled (archived/not in use)`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `JSON object defining the inputs/parameters for the test. Structure varies by test type (e.g., for Agent Eval: {prompt, context, conversationHistory})`}) 
    InputDefinition?: string;
        
    @Field({nullable: true, description: `JSON object defining what success looks like. Structure varies by test type (e.g., for Agent Eval: {toolCalls, outputFormat, semanticGoals, dataAssertions})`}) 
    ExpectedOutcomes?: string;
        
    @Field({nullable: true, description: `JSON object for test-specific configuration (e.g., oracles to use, rubrics, retry policies, timeout settings)`}) 
    Configuration?: string;
        
    @Field({nullable: true, description: `JSON array of tags for categorization and filtering (e.g., ["smoke", "agent-quality", "performance"])`}) 
    Tags?: string;
        
    @Field(() => Int, {nullable: true, description: `Priority for execution ordering. Lower numbers run first. Useful for dependencies or critical path tests.`}) 
    Priority?: number;
        
    @Field(() => Int, {nullable: true, description: `Estimated execution time in seconds. Used for scheduling and timeout calculations.`}) 
    EstimatedDurationSeconds?: number;
        
    @Field(() => Float, {nullable: true, description: `Estimated cost in USD for running this test (e.g., LLM token costs, compute resources). Used for budgeting and optimization.`}) 
    EstimatedCostUSD?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Number of times to repeat this test execution. NULL or 1 = single execution. Values > 1 will create multiple test runs for statistical analysis.`}) 
    RepeatCount?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum execution time in milliseconds for this test. If NULL, uses default (300000ms = 5 minutes). Can be overridden by Configuration JSON maxExecutionTime field for backward compatibility.`}) 
    MaxExecutionTimeMS?: number;
        
    @Field({nullable: true, description: `JSON configuration for which test type variables are exposed by this test, along with test-level defaults, locks, and value restrictions. References variables defined in the parent TestType.VariablesSchema.`}) 
    Variables?: string;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
    @Field(() => [MJTestRun_])
    MJTestRuns_TestIDArray: MJTestRun_[]; // Link to MJTestRuns
    
    @Field(() => [MJTestSuiteTest_])
    MJTestSuiteTests_TestIDArray: MJTestSuiteTest_[]; // Link to MJTestSuiteTests
    
}

//****************************************************************************
// INPUT TYPE for MJ: Tests
//****************************************************************************
@InputType()
export class CreateMJTestInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InputDefinition: string | null;

    @Field({ nullable: true })
    ExpectedOutcomes: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    Tags: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => Int, { nullable: true })
    EstimatedDurationSeconds: number | null;

    @Field(() => Float, { nullable: true })
    EstimatedCostUSD: number | null;

    @Field(() => Int, { nullable: true })
    RepeatCount: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionTimeMS: number | null;

    @Field({ nullable: true })
    Variables: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Tests
//****************************************************************************
@InputType()
export class UpdateMJTestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InputDefinition?: string | null;

    @Field({ nullable: true })
    ExpectedOutcomes?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    Tags?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => Int, { nullable: true })
    EstimatedDurationSeconds?: number | null;

    @Field(() => Float, { nullable: true })
    EstimatedCostUSD?: number | null;

    @Field(() => Int, { nullable: true })
    RepeatCount?: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionTimeMS?: number | null;

    @Field({ nullable: true })
    Variables?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Tests
//****************************************************************************
@ObjectType()
export class RunMJTestViewResult {
    @Field(() => [MJTest_])
    Results: MJTest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTest_)
export class MJTestResolver extends ResolverBase {
    @Query(() => RunMJTestViewResult)
    async RunMJTestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestViewResult)
    async RunMJTestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestViewResult)
    async RunMJTestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Tests';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTest_, { nullable: true })
    async MJTest(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTest_ | null> {
        this.CheckUserReadPermissions('MJ: Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTests')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Tests', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRun_])
    async MJTestRuns_TestIDArray(@Root() mjtest_: MJTest_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRuns')} WHERE ${provider.QuoteIdentifier('TestID')}='${mjtest_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestSuiteTest_])
    async MJTestSuiteTests_TestIDArray(@Root() mjtest_: MJTest_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suite Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestSuiteTests')} WHERE ${provider.QuoteIdentifier('TestID')}='${mjtest_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suite Tests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTest_)
    async CreateMJTest(
        @Arg('input', () => CreateMJTestInput) input: CreateMJTestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Tests', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTest_)
    async UpdateMJTest(
        @Arg('input', () => UpdateMJTestInput) input: UpdateMJTestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Tests', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTest_)
    async DeleteMJTest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Tests', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Application Entities
//****************************************************************************
@ObjectType({ description: `Links users to specific entities within applications, managing entity-level personalization.` })
export class MJUserApplicationEntity_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserApplicationID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of this entity for the user within the application.`}) 
    Sequence: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Application: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Application Entities
//****************************************************************************
@InputType()
export class CreateMJUserApplicationEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Application Entities
//****************************************************************************
@InputType()
export class UpdateMJUserApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Application Entities
//****************************************************************************
@ObjectType()
export class RunMJUserApplicationEntityViewResult {
    @Field(() => [MJUserApplicationEntity_])
    Results: MJUserApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserApplicationEntity_)
export class MJUserApplicationEntityResolver extends ResolverBase {
    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Application Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserApplicationEntity_, { nullable: true })
    async MJUserApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserApplicationEntity_ | null> {
        this.CheckUserReadPermissions('MJ: User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserApplicationEntities')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Application Entities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserApplicationEntity_)
    async CreateMJUserApplicationEntity(
        @Arg('input', () => CreateMJUserApplicationEntityInput) input: CreateMJUserApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Application Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserApplicationEntity_)
    async UpdateMJUserApplicationEntity(
        @Arg('input', () => UpdateMJUserApplicationEntityInput) input: UpdateMJUserApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Application Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserApplicationEntity_)
    async DeleteMJUserApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Application Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Applications
//****************************************************************************
@ObjectType({ description: `Tracks which applications users have configured to display.` })
export class MJUserApplication_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    @MaxLength(36)
    ApplicationID: string;
        
    @Field(() => Int, {description: `Display order of this application in the user's navigation.`}) 
    Sequence: number;
        
    @Field(() => Boolean, {description: `Whether this application is currently visible to the user.`}) 
    IsActive: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field() 
    @MaxLength(100)
    Application: string;
        
    @Field(() => [MJUserApplicationEntity_])
    MJUserApplicationEntities_UserApplicationIDArray: MJUserApplicationEntity_[]; // Link to MJUserApplicationEntities
    
}

//****************************************************************************
// INPUT TYPE for MJ: User Applications
//****************************************************************************
@InputType()
export class CreateMJUserApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Applications
//****************************************************************************
@InputType()
export class UpdateMJUserApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Applications
//****************************************************************************
@ObjectType()
export class RunMJUserApplicationViewResult {
    @Field(() => [MJUserApplication_])
    Results: MJUserApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserApplication_)
export class MJUserApplicationResolver extends ResolverBase {
    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserApplication_, { nullable: true })
    async MJUserApplication(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserApplication_ | null> {
        this.CheckUserReadPermissions('MJ: User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserApplications')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Applications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserApplicationEntity_])
    async MJUserApplicationEntities_UserApplicationIDArray(@Root() mjuserapplication_: MJUserApplication_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserApplicationEntities')} WHERE ${provider.QuoteIdentifier('UserApplicationID')}='${mjuserapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Application Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserApplication_)
    async CreateMJUserApplication(
        @Arg('input', () => CreateMJUserApplicationInput) input: CreateMJUserApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserApplication_)
    async UpdateMJUserApplication(
        @Arg('input', () => UpdateMJUserApplicationInput) input: UpdateMJUserApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserApplication_)
    async DeleteMJUserApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Favorites
//****************************************************************************
@ObjectType({ description: `Records that each user can mark as a favorite for easy access` })
export class MJUserFavorite_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `The ID of the favorited record.`}) 
    @MaxLength(450)
    RecordID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(255)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(255)
    EntityBaseView: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Favorites
//****************************************************************************
@InputType()
export class CreateMJUserFavoriteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Favorites
//****************************************************************************
@InputType()
export class UpdateMJUserFavoriteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Favorites
//****************************************************************************
@ObjectType()
export class RunMJUserFavoriteViewResult {
    @Field(() => [MJUserFavorite_])
    Results: MJUserFavorite_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserFavorite_)
export class MJUserFavoriteResolverBase extends ResolverBase {
    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Favorites';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserFavorite_, { nullable: true })
    async MJUserFavorite(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserFavorite_ | null> {
        this.CheckUserReadPermissions('MJ: User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserFavorites')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Favorites', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserFavorite_)
    async CreateMJUserFavorite(
        @Arg('input', () => CreateMJUserFavoriteInput) input: CreateMJUserFavoriteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Favorites', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserFavorite_)
    async UpdateMJUserFavorite(
        @Arg('input', () => UpdateMJUserFavoriteInput) input: UpdateMJUserFavoriteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Favorites', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserFavorite_)
    async DeleteMJUserFavorite(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Favorites', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Notification Preferences
//****************************************************************************
@ObjectType({ description: `Per-user preferences for each notification type (delivery method overrides)` })
export class MJUserNotificationPreference_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    @MaxLength(36)
    NotificationTypeID: string;
        
    @Field(() => Boolean, {nullable: true, description: `User preference for in-app notifications (NULL = use default)`}) 
    InAppEnabled?: boolean;
        
    @Field(() => Boolean, {nullable: true, description: `User preference for email notifications (NULL = use default)`}) 
    EmailEnabled?: boolean;
        
    @Field(() => Boolean, {nullable: true, description: `User preference for SMS notifications (NULL = use default)`}) 
    SMSEnabled?: boolean;
        
    @Field(() => Boolean, {nullable: true}) 
    Enabled?: boolean;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field() 
    @MaxLength(100)
    NotificationType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Notification Preferences
//****************************************************************************
@InputType()
export class CreateMJUserNotificationPreferenceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    NotificationTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    InAppEnabled: boolean | null;

    @Field(() => Boolean, { nullable: true })
    EmailEnabled: boolean | null;

    @Field(() => Boolean, { nullable: true })
    SMSEnabled: boolean | null;

    @Field(() => Boolean, { nullable: true })
    Enabled?: boolean | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Notification Preferences
//****************************************************************************
@InputType()
export class UpdateMJUserNotificationPreferenceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    NotificationTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    InAppEnabled?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    EmailEnabled?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    SMSEnabled?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    Enabled?: boolean | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Notification Preferences
//****************************************************************************
@ObjectType()
export class RunMJUserNotificationPreferenceViewResult {
    @Field(() => [MJUserNotificationPreference_])
    Results: MJUserNotificationPreference_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserNotificationPreference_)
export class MJUserNotificationPreferenceResolver extends ResolverBase {
    @Query(() => RunMJUserNotificationPreferenceViewResult)
    async RunMJUserNotificationPreferenceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationPreferenceViewResult)
    async RunMJUserNotificationPreferenceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationPreferenceViewResult)
    async RunMJUserNotificationPreferenceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Notification Preferences';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserNotificationPreference_, { nullable: true })
    async MJUserNotificationPreference(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserNotificationPreference_ | null> {
        this.CheckUserReadPermissions('MJ: User Notification Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotificationPreferences')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Notification Preferences', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserNotificationPreference_)
    async CreateMJUserNotificationPreference(
        @Arg('input', () => CreateMJUserNotificationPreferenceInput) input: CreateMJUserNotificationPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Notification Preferences', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserNotificationPreference_)
    async UpdateMJUserNotificationPreference(
        @Arg('input', () => UpdateMJUserNotificationPreferenceInput) input: UpdateMJUserNotificationPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Notification Preferences', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserNotificationPreference_)
    async DeleteMJUserNotificationPreference(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Notification Preferences', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Notification Types
//****************************************************************************
@ObjectType({ description: `Defines categories of notifications with delivery configuration and template associations` })
export class MJUserNotificationType_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Unique name for the notification type (e.g., 'Agent Completion')`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Description?: string;
        
    @Field(() => Boolean, {description: `Whether in-app notifications are enabled by default for this type`}) 
    DefaultInApp: boolean;
        
    @Field(() => Boolean, {description: `Whether email notifications are enabled by default for this type`}) 
    DefaultEmail: boolean;
        
    @Field(() => Boolean, {description: `Whether SMS notifications are enabled by default for this type`}) 
    DefaultSMS: boolean;
        
    @Field(() => Boolean, {nullable: true, description: `Whether users can override the default delivery method`}) 
    AllowUserPreference?: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    EmailTemplateID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    SMSTemplateID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    Color?: string;
        
    @Field(() => Int, {nullable: true}) 
    AutoExpireDays?: number;
        
    @Field(() => Int, {nullable: true}) 
    Priority?: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    EmailTemplate?: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    SMSTemplate?: string;
        
    @Field(() => [MJUserNotification_])
    MJUserNotifications_NotificationTypeIDArray: MJUserNotification_[]; // Link to MJUserNotifications
    
    @Field(() => [MJUserNotificationPreference_])
    MJUserNotificationPreferences_NotificationTypeIDArray: MJUserNotificationPreference_[]; // Link to MJUserNotificationPreferences
    
}

//****************************************************************************
// INPUT TYPE for MJ: User Notification Types
//****************************************************************************
@InputType()
export class CreateMJUserNotificationTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInApp?: boolean;

    @Field(() => Boolean, { nullable: true })
    DefaultEmail?: boolean;

    @Field(() => Boolean, { nullable: true })
    DefaultSMS?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserPreference?: boolean | null;

    @Field({ nullable: true })
    EmailTemplateID: string | null;

    @Field({ nullable: true })
    SMSTemplateID: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field(() => Int, { nullable: true })
    AutoExpireDays: number | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Notification Types
//****************************************************************************
@InputType()
export class UpdateMJUserNotificationTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInApp?: boolean;

    @Field(() => Boolean, { nullable: true })
    DefaultEmail?: boolean;

    @Field(() => Boolean, { nullable: true })
    DefaultSMS?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserPreference?: boolean | null;

    @Field({ nullable: true })
    EmailTemplateID?: string | null;

    @Field({ nullable: true })
    SMSTemplateID?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field(() => Int, { nullable: true })
    AutoExpireDays?: number | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Notification Types
//****************************************************************************
@ObjectType()
export class RunMJUserNotificationTypeViewResult {
    @Field(() => [MJUserNotificationType_])
    Results: MJUserNotificationType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserNotificationType_)
export class MJUserNotificationTypeResolver extends ResolverBase {
    @Query(() => RunMJUserNotificationTypeViewResult)
    async RunMJUserNotificationTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationTypeViewResult)
    async RunMJUserNotificationTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationTypeViewResult)
    async RunMJUserNotificationTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Notification Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserNotificationType_, { nullable: true })
    async MJUserNotificationType(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserNotificationType_ | null> {
        this.CheckUserReadPermissions('MJ: User Notification Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotificationTypes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Notification Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserNotification_])
    async MJUserNotifications_NotificationTypeIDArray(@Root() mjusernotificationtype_: MJUserNotificationType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotifications')} WHERE ${provider.QuoteIdentifier('NotificationTypeID')}='${mjusernotificationtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notifications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotificationPreference_])
    async MJUserNotificationPreferences_NotificationTypeIDArray(@Root() mjusernotificationtype_: MJUserNotificationType_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notification Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotificationPreferences')} WHERE ${provider.QuoteIdentifier('NotificationTypeID')}='${mjusernotificationtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notification Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserNotificationType_)
    async CreateMJUserNotificationType(
        @Arg('input', () => CreateMJUserNotificationTypeInput) input: CreateMJUserNotificationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Notification Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserNotificationType_)
    async UpdateMJUserNotificationType(
        @Arg('input', () => UpdateMJUserNotificationTypeInput) input: UpdateMJUserNotificationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Notification Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserNotificationType_)
    async DeleteMJUserNotificationType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Notification Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Notifications
//****************************************************************************
@ObjectType({ description: `Manages notifications sent to users including alerts, messages, and system updates with read status and priority.` })
export class MJUserNotification_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field({nullable: true, description: `Brief title or subject of the notification.`}) 
    @MaxLength(255)
    Title?: string;
        
    @Field({nullable: true, description: `Full notification message content.`}) 
    Message?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ResourceTypeID?: string;
        
    @Field({nullable: true, description: `Field ResourceConfiguration for entity User Notifications.`}) 
    ResourceConfiguration?: string;
        
    @Field(() => Boolean, {description: `Field Unread for entity User Notifications.`}) 
    Unread: boolean;
        
    @Field({nullable: true, description: `Timestamp when the user read this notification.`}) 
    ReadAt?: Date;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `ID of the specific record this notification is about.`}) 
    @MaxLength(36)
    ResourceRecordID?: string;
        
    @Field({nullable: true, description: `Optional reference to notification type for categorization and delivery preferences`}) 
    @MaxLength(36)
    NotificationTypeID?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    ResourceType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    NotificationType?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Notifications
//****************************************************************************
@InputType()
export class CreateMJUserNotificationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    ResourceTypeID: string | null;

    @Field({ nullable: true })
    ResourceConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt: Date | null;

    @Field({ nullable: true })
    ResourceRecordID: string | null;

    @Field({ nullable: true })
    NotificationTypeID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Notifications
//****************************************************************************
@InputType()
export class UpdateMJUserNotificationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    ResourceTypeID?: string | null;

    @Field({ nullable: true })
    ResourceConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt?: Date | null;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field({ nullable: true })
    NotificationTypeID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Notifications
//****************************************************************************
@ObjectType()
export class RunMJUserNotificationViewResult {
    @Field(() => [MJUserNotification_])
    Results: MJUserNotification_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserNotification_)
export class MJUserNotificationResolver extends ResolverBase {
    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Notifications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserNotification_, { nullable: true })
    async MJUserNotification(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserNotification_ | null> {
        this.CheckUserReadPermissions('MJ: User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotifications')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Notifications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserNotification_)
    async CreateMJUserNotification(
        @Arg('input', () => CreateMJUserNotificationInput) input: CreateMJUserNotificationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Notifications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserNotification_)
    async UpdateMJUserNotification(
        @Arg('input', () => UpdateMJUserNotificationInput) input: UpdateMJUserNotificationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Notifications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserNotification_)
    async DeleteMJUserNotification(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Notifications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Record Logs
//****************************************************************************
@ObjectType({ description: `Tracks user interactions with specific records, maintaining an audit trail of views or other operations. Changes are managed separately in the Record Changes entity.` })
export class MJUserRecordLog_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `The ID of the accessed record.`}) 
    @MaxLength(450)
    RecordID: string;
        
    @Field({description: `Field EarliestAt for entity User Record Logs.`}) 
    EarliestAt: Date;
        
    @Field({description: `Field LatestAt for entity User Record Logs.`}) 
    LatestAt: Date;
        
    @Field(() => Int, {description: `Field TotalCount for entity User Record Logs.`}) 
    TotalCount: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(101)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(100)
    UserEmail: string;
        
    @Field({nullable: true}) 
    @MaxLength(81)
    UserSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    UserSupervisorEmail?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Record Logs
//****************************************************************************
@InputType()
export class CreateMJUserRecordLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EarliestAt?: Date;

    @Field({ nullable: true })
    LatestAt?: Date;

    @Field(() => Int, { nullable: true })
    TotalCount?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Record Logs
//****************************************************************************
@InputType()
export class UpdateMJUserRecordLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EarliestAt?: Date;

    @Field({ nullable: true })
    LatestAt?: Date;

    @Field(() => Int, { nullable: true })
    TotalCount?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Record Logs
//****************************************************************************
@ObjectType()
export class RunMJUserRecordLogViewResult {
    @Field(() => [MJUserRecordLog_])
    Results: MJUserRecordLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserRecordLog_)
export class MJUserRecordLogResolver extends ResolverBase {
    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Record Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserRecordLog_, { nullable: true })
    async MJUserRecordLog(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserRecordLog_ | null> {
        this.CheckUserReadPermissions('MJ: User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserRecordLogs')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Record Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserRecordLog_)
    async CreateMJUserRecordLog(
        @Arg('input', () => CreateMJUserRecordLogInput) input: CreateMJUserRecordLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Record Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserRecordLog_)
    async UpdateMJUserRecordLog(
        @Arg('input', () => UpdateMJUserRecordLogInput) input: UpdateMJUserRecordLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Record Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserRecordLog_)
    async DeleteMJUserRecordLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Record Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Roles
//****************************************************************************
@ObjectType({ description: `Associates users with roles in the system, managing role-based access control and permission inheritance.` })
export class MJUserRole_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    @MaxLength(36)
    RoleID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field() 
    @MaxLength(50)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Roles
//****************************************************************************
@InputType()
export class CreateMJUserRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Roles
//****************************************************************************
@InputType()
export class UpdateMJUserRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Roles
//****************************************************************************
@ObjectType()
export class RunMJUserRoleViewResult {
    @Field(() => [MJUserRole_])
    Results: MJUserRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserRole_)
export class MJUserRoleResolver extends ResolverBase {
    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserRole_, { nullable: true })
    async MJUserRole(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserRole_ | null> {
        this.CheckUserReadPermissions('MJ: User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserRoles')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Roles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJUserRole_])
    async AllMJUserRoles(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserRoles')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserRole_)
    async CreateMJUserRole(
        @Arg('input', () => CreateMJUserRoleInput) input: CreateMJUserRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserRole_)
    async UpdateMJUserRole(
        @Arg('input', () => UpdateMJUserRoleInput) input: UpdateMJUserRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserRole_)
    async DeleteMJUserRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Settings
//****************************************************************************
@ObjectType({ description: `Generic key-value store for per-user settings. Allows any application or feature to persist user preferences.` })
export class MJUserSetting_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The user this setting belongs to.`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field({description: `The setting key/name. Use namespaced keys like "DataExplorer.ViewMode" or "Dashboard.AI.CollapsedSections" to avoid collisions.`}) 
    @MaxLength(255)
    Setting: string;
        
    @Field({nullable: true, description: `The setting value. Can be simple text, numbers, booleans, or JSON for complex configuration objects.`}) 
    Value?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Settings
//****************************************************************************
@InputType()
export class CreateMJUserSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Setting?: string;

    @Field({ nullable: true })
    Value: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Settings
//****************************************************************************
@InputType()
export class UpdateMJUserSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Setting?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Settings
//****************************************************************************
@ObjectType()
export class RunMJUserSettingViewResult {
    @Field(() => [MJUserSetting_])
    Results: MJUserSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserSetting_)
export class MJUserSettingResolver extends ResolverBase {
    @Query(() => RunMJUserSettingViewResult)
    async RunMJUserSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserSettingViewResult)
    async RunMJUserSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserSettingViewResult)
    async RunMJUserSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserSetting_, { nullable: true })
    async MJUserSetting(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserSetting_ | null> {
        this.CheckUserReadPermissions('MJ: User Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserSettings')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Settings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserSetting_)
    async CreateMJUserSetting(
        @Arg('input', () => CreateMJUserSettingInput) input: CreateMJUserSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserSetting_)
    async UpdateMJUserSetting(
        @Arg('input', () => UpdateMJUserSettingInput) input: UpdateMJUserSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserSetting_)
    async DeleteMJUserSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User View Categories
//****************************************************************************
@ObjectType({ description: `Organizes user-created views into categories for personal organization and sharing within teams.` })
export class MJUserViewCategory_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJUserViewCategory_])
    MJUserViewCategories_ParentIDArray: MJUserViewCategory_[]; // Link to MJUserViewCategories
    
    @Field(() => [MJUserView_])
    MJUserViews_CategoryIDArray: MJUserView_[]; // Link to MJUserViews
    
}

//****************************************************************************
// INPUT TYPE for MJ: User View Categories
//****************************************************************************
@InputType()
export class CreateMJUserViewCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User View Categories
//****************************************************************************
@InputType()
export class UpdateMJUserViewCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User View Categories
//****************************************************************************
@ObjectType()
export class RunMJUserViewCategoryViewResult {
    @Field(() => [MJUserViewCategory_])
    Results: MJUserViewCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewCategory_)
export class MJUserViewCategoryResolver extends ResolverBase {
    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User View Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewCategory_, { nullable: true })
    async MJUserViewCategory(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewCategory_ | null> {
        this.CheckUserReadPermissions('MJ: User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewCategories')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User View Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserViewCategory_])
    async MJUserViewCategories_ParentIDArray(@Root() mjuserviewcategory_: MJUserViewCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewCategories')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjuserviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User View Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async MJUserViews_CategoryIDArray(@Root() mjuserviewcategory_: MJUserViewCategory_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViews')} WHERE ${provider.QuoteIdentifier('CategoryID')}='${mjuserviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Views', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserViewCategory_)
    async CreateMJUserViewCategory(
        @Arg('input', () => CreateMJUserViewCategoryInput) input: CreateMJUserViewCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User View Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewCategory_)
    async UpdateMJUserViewCategory(
        @Arg('input', () => UpdateMJUserViewCategoryInput) input: UpdateMJUserViewCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User View Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserViewCategory_)
    async DeleteMJUserViewCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User View Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User View Run Details
//****************************************************************************
@ObjectType({ description: `Tracks the set of records that were included in each run of a given user view.` })
export class MJUserViewRunDetail_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserViewRunID: string;
        
    @Field({description: `Field RecordID for entity User View Run Details.`}) 
    @MaxLength(450)
    RecordID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(36)
    UserViewID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User View Run Details
//****************************************************************************
@InputType()
export class CreateMJUserViewRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User View Run Details
//****************************************************************************
@InputType()
export class UpdateMJUserViewRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User View Run Details
//****************************************************************************
@ObjectType()
export class RunMJUserViewRunDetailViewResult {
    @Field(() => [MJUserViewRunDetail_])
    Results: MJUserViewRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewRunDetail_)
export class MJUserViewRunDetailResolver extends ResolverBase {
    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User View Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewRunDetail_, { nullable: true })
    async MJUserViewRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewRunDetail_ | null> {
        this.CheckUserReadPermissions('MJ: User View Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewRunDetails')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User View Run Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserViewRunDetail_)
    async CreateMJUserViewRunDetail(
        @Arg('input', () => CreateMJUserViewRunDetailInput) input: CreateMJUserViewRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User View Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewRunDetail_)
    async UpdateMJUserViewRunDetail(
        @Arg('input', () => UpdateMJUserViewRunDetailInput) input: UpdateMJUserViewRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User View Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserViewRunDetail_)
    async DeleteMJUserViewRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User View Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User View Runs
//****************************************************************************
@ObjectType({ description: `User Views can be logged when run to capture the date and user that ran the view as well as the output results.` })
export class MJUserViewRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserViewID: string;
        
    @Field({description: `Timestamp when the view was executed.`}) 
    RunAt: Date;
        
    @Field() 
    @MaxLength(36)
    RunByUserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    UserView: string;
        
    @Field() 
    @MaxLength(100)
    RunByUser: string;
        
    @Field(() => [MJUserViewRunDetail_])
    MJUserViewRunDetails_UserViewRunIDArray: MJUserViewRunDetail_[]; // Link to MJUserViewRunDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: User View Runs
//****************************************************************************
@InputType()
export class CreateMJUserViewRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User View Runs
//****************************************************************************
@InputType()
export class UpdateMJUserViewRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User View Runs
//****************************************************************************
@ObjectType()
export class RunMJUserViewRunViewResult {
    @Field(() => [MJUserViewRun_])
    Results: MJUserViewRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewRun_)
export class MJUserViewRunResolver extends ResolverBase {
    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User View Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewRun_, { nullable: true })
    async MJUserViewRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewRun_ | null> {
        this.CheckUserReadPermissions('MJ: User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User View Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserViewRunDetail_])
    async MJUserViewRunDetails_UserViewRunIDArray(@Root() mjuserviewrun_: MJUserViewRun_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User View Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewRunDetails')} WHERE ${provider.QuoteIdentifier('UserViewRunID')}='${mjuserviewrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User View Run Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserViewRun_)
    async CreateMJUserViewRun(
        @Arg('input', () => CreateMJUserViewRunInput) input: CreateMJUserViewRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User View Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewRun_)
    async UpdateMJUserViewRun(
        @Arg('input', () => UpdateMJUserViewRunInput) input: UpdateMJUserViewRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User View Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserViewRun_)
    async DeleteMJUserViewRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User View Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Views
//****************************************************************************
@ObjectType({ description: `Views are sets of records within a given entity defined by filtering rules. Views can be used programatically to retrieve dynamic sets of data and in user interfaces like MJ Explorer for end-user consumption.` })
export class MJUserView_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    @MaxLength(36)
    EntityID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    CategoryID?: string;
        
    @Field(() => Boolean, {description: `Whether this view is shared with other users.`}) 
    IsShared: boolean;
        
    @Field(() => Boolean, {description: `Whether this is the user's default view for the entity.`}) 
    IsDefault: boolean;
        
    @Field({nullable: true, description: `JSON storing complete grid configuration including columns, widths, and formatting.`}) 
    GridState?: string;
        
    @Field({nullable: true, description: `JSON storing the view's filter configuration.`}) 
    FilterState?: string;
        
    @Field(() => Boolean, {description: `Indicates if custom filters beyond standard options are applied.`}) 
    CustomFilterState: boolean;
        
    @Field(() => Boolean, {description: `Whether AI-powered smart filtering is enabled for this view.`}) 
    SmartFilterEnabled: boolean;
        
    @Field({nullable: true, description: `Natural language prompt for AI-powered filtering.`}) 
    SmartFilterPrompt?: string;
        
    @Field({nullable: true, description: `Generated WHERE clause from smart filter processing.`}) 
    SmartFilterWhereClause?: string;
        
    @Field({nullable: true, description: `AI-generated explanation of what the smart filter does.`}) 
    SmartFilterExplanation?: string;
        
    @Field({nullable: true, description: `Direct SQL WHERE clause for the view filter.`}) 
    WhereClause?: string;
        
    @Field(() => Boolean, {description: `Indicates if a custom WHERE clause is used instead of standard filters.`}) 
    CustomWhereClause: boolean;
        
    @Field({nullable: true, description: `JSON storing the view's sort configuration.`}) 
    SortState?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Thumbnail image for the user view that can be displayed in gallery views. Can contain either a URL to an image file or a Base64-encoded image string.`}) 
    Thumbnail?: string;
        
    @Field({nullable: true, description: `JSON configuration for card display mode in Data Explorer. Stores card layout settings including title field, subtitle, display fields, thumbnails, and layout density. When null, defaults are derived from entity metadata. See CardState interface in packages/Angular/Generic/entity-viewer/src/lib/types.ts for the current schema definition.`}) 
    CardState?: string;
        
    @Field({nullable: true, description: `JSON configuration for display mode settings. Stores default display mode (grid/cards/timeline/chart), available modes for sharing, and mode-specific configurations like timeline date field and segmentation. See ViewDisplayState interface in packages/Angular/Generic/entity-viewer/src/lib/types.ts for schema.`}) 
    DisplayState?: string;
        
    @Field() 
    @MaxLength(100)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(101)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(100)
    UserEmail: string;
        
    @Field() 
    @MaxLength(15)
    UserType: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
    @Field() 
    @MaxLength(255)
    EntityBaseView: string;
        
    @Field(() => [MJEntityRelationship_])
    MJEntityRelationships_DisplayUserViewGUIDArray: MJEntityRelationship_[]; // Link to MJEntityRelationships
    
    @Field(() => [MJUserViewRun_])
    MJUserViewRuns_UserViewIDArray: MJUserViewRun_[]; // Link to MJUserViewRuns
    
    @Field(() => [MJDataContextItem_])
    MJDataContextItems_ViewIDArray: MJDataContextItem_[]; // Link to MJDataContextItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: User Views
//****************************************************************************
@InputType()
export class CreateMJUserViewInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState: string | null;

    @Field({ nullable: true })
    FilterState: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation: string | null;

    @Field({ nullable: true })
    WhereClause: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState: string | null;

    @Field({ nullable: true })
    Thumbnail: string | null;

    @Field({ nullable: true })
    CardState: string | null;

    @Field({ nullable: true })
    DisplayState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Views
//****************************************************************************
@InputType()
export class UpdateMJUserViewInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState?: string | null;

    @Field({ nullable: true })
    FilterState?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt?: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause?: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation?: string | null;

    @Field({ nullable: true })
    WhereClause?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState?: string | null;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field({ nullable: true })
    CardState?: string | null;

    @Field({ nullable: true })
    DisplayState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Views
//****************************************************************************
@ObjectType()
export class RunMJUserViewViewResult {
    @Field(() => [MJUserView_])
    Results: MJUserView_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserView_)
export class MJUserViewResolverBase extends ResolverBase {
    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Views';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserView_, { nullable: true })
    async MJUserView(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserView_ | null> {
        this.CheckUserReadPermissions('MJ: User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViews')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Views', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJUserView_])
    async AllMJUserViews(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViews')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Views', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Views', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityRelationship_])
    async MJEntityRelationships_DisplayUserViewGUIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRelationships')} WHERE ${provider.QuoteIdentifier('DisplayUserViewGUID')}='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserViewRun_])
    async MJUserViewRuns_UserViewIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewRuns')} WHERE ${provider.QuoteIdentifier('UserViewID')}='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User View Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async MJDataContextItems_ViewIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDataContextItems')} WHERE ${provider.QuoteIdentifier('ViewID')}='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Data Context Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserView_)
    async CreateMJUserView(
        @Arg('input', () => CreateMJUserViewInput) input: CreateMJUserViewInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Views', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserView_)
    async UpdateMJUserView(
        @Arg('input', () => UpdateMJUserViewInput) input: UpdateMJUserViewInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Views', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserView_)
    async DeleteMJUserView(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Views', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Users
//****************************************************************************
@ObjectType({ description: `A list of all users who have or had access to the system` })
export class MJUser_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `User's first name or given name.`}) 
    @MaxLength(50)
    FirstName?: string;
        
    @Field({nullable: true, description: `User's last name or surname.`}) 
    @MaxLength(50)
    LastName?: string;
        
    @Field({nullable: true, description: `User's professional title or salutation.`}) 
    @MaxLength(50)
    Title?: string;
        
    @Field({description: `Unique email address for the user. This field must be unique across all users in the system.`}) 
    @MaxLength(100)
    Email: string;
        
    @Field({description: `User account type (User, Guest, System, API).`}) 
    @MaxLength(15)
    Type: string;
        
    @Field(() => Boolean, {description: `Whether this user account is currently active and can log in.`}) 
    IsActive: boolean;
        
    @Field({description: `Type of record this user is linked to (None, Employee, Contact, etc.).`}) 
    @MaxLength(10)
    LinkedRecordType: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `ID of the specific record this user is linked to.`}) 
    @MaxLength(450)
    LinkedEntityRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    EmployeeID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `User avatar image. Can be a Base64 encoded data URI (e.g., "data:image/png;base64,...") or a URL to an image file. Preferred over UserImageIconClass when present. Recommended for small thumbnail images only to maintain performance.`}) 
    UserImageURL?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for user avatar (e.g., "fa-solid fa-user-astronaut"). Used as fallback when UserImageURL is not provided. Example classes: "fa-solid fa-user", "fa-regular fa-circle-user", "fa-solid fa-user-tie".`}) 
    @MaxLength(100)
    UserImageIconClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(101)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(81)
    EmployeeFirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmployeeEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    EmployeeTitle?: string;
        
    @Field({nullable: true}) 
    @MaxLength(81)
    EmployeeSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmployeeSupervisorEmail?: string;
        
    @Field(() => [MJUserApplication_])
    MJUserApplications_UserIDArray: MJUserApplication_[]; // Link to MJUserApplications
    
    @Field(() => [MJUserRole_])
    MJUserRoles_UserIDArray: MJUserRole_[]; // Link to MJUserRoles
    
    @Field(() => [MJWorkspace_])
    MJWorkspaces_UserIDArray: MJWorkspace_[]; // Link to MJWorkspaces
    
    @Field(() => [MJReport_])
    MJReports_UserIDArray: MJReport_[]; // Link to MJReports
    
    @Field(() => [MJReportSnapshot_])
    MJReportSnapshots_UserIDArray: MJReportSnapshot_[]; // Link to MJReportSnapshots
    
    @Field(() => [MJRecordChange_])
    MJRecordChanges_UserIDArray: MJRecordChange_[]; // Link to MJRecordChanges
    
    @Field(() => [MJDashboard_])
    MJDashboards_UserIDArray: MJDashboard_[]; // Link to MJDashboards
    
    @Field(() => [MJUserViewRun_])
    MJUserViewRuns_RunByUserIDArray: MJUserViewRun_[]; // Link to MJUserViewRuns
    
    @Field(() => [MJAuditLog_])
    MJAuditLogs_UserIDArray: MJAuditLog_[]; // Link to MJAuditLogs
    
    @Field(() => [MJList_])
    MJLists_UserIDArray: MJList_[]; // Link to MJLists
    
    @Field(() => [MJUserFavorite_])
    MJUserFavorites_UserIDArray: MJUserFavorite_[]; // Link to MJUserFavorites
    
    @Field(() => [MJUserRecordLog_])
    MJUserRecordLogs_UserIDArray: MJUserRecordLog_[]; // Link to MJUserRecordLogs
    
    @Field(() => [MJUserView_])
    MJUserViews_UserIDArray: MJUserView_[]; // Link to MJUserViews
    
    @Field(() => [MJCompanyIntegrationRun_])
    MJCompanyIntegrationRuns_RunByUserIDArray: MJCompanyIntegrationRun_[]; // Link to MJCompanyIntegrationRuns
    
    @Field(() => [MJUserNotification_])
    MJUserNotifications_UserIDArray: MJUserNotification_[]; // Link to MJUserNotifications
    
    @Field(() => [MJConversation_])
    MJConversations_UserIDArray: MJConversation_[]; // Link to MJConversations
    
    @Field(() => [MJRecordMergeLog_])
    MJRecordMergeLogs_InitiatedByUserIDArray: MJRecordMergeLog_[]; // Link to MJRecordMergeLogs
    
    @Field(() => [MJDataContext_])
    MJDataContexts_UserIDArray: MJDataContext_[]; // Link to MJDataContexts
    
    @Field(() => [MJReportCategory_])
    MJReportCategories_UserIDArray: MJReportCategory_[]; // Link to MJReportCategories
    
    @Field(() => [MJUserViewCategory_])
    MJUserViewCategories_UserIDArray: MJUserViewCategory_[]; // Link to MJUserViewCategories
    
    @Field(() => [MJDashboardCategory_])
    MJDashboardCategories_UserIDArray: MJDashboardCategory_[]; // Link to MJDashboardCategories
    
    @Field(() => [MJQueryCategory_])
    MJQueryCategories_UserIDArray: MJQueryCategory_[]; // Link to MJQueryCategories
    
    @Field(() => [MJDuplicateRun_])
    MJDuplicateRuns_StartedByUserIDArray: MJDuplicateRun_[]; // Link to MJDuplicateRuns
    
    @Field(() => [MJActionExecutionLog_])
    MJActionExecutionLogs_UserIDArray: MJActionExecutionLog_[]; // Link to MJActionExecutionLogs
    
    @Field(() => [MJAction_])
    MJActions_CodeApprovedByUserIDArray: MJAction_[]; // Link to MJActions
    
    @Field(() => [MJCommunicationRun_])
    MJCommunicationRuns_UserIDArray: MJCommunicationRun_[]; // Link to MJCommunicationRuns
    
    @Field(() => [MJTemplate_])
    MJTemplates_UserIDArray: MJTemplate_[]; // Link to MJTemplates
    
    @Field(() => [MJTemplateCategory_])
    MJTemplateCategories_UserIDArray: MJTemplateCategory_[]; // Link to MJTemplateCategories
    
    @Field(() => [MJRecommendationRun_])
    MJRecommendationRuns_RunByUserIDArray: MJRecommendationRun_[]; // Link to MJRecommendationRuns
    
    @Field(() => [MJRecordChangeReplayRun_])
    MJRecordChangeReplayRuns_UserIDArray: MJRecordChangeReplayRun_[]; // Link to MJRecordChangeReplayRuns
    
    @Field(() => [MJListCategory_])
    MJListCategories_UserIDArray: MJListCategory_[]; // Link to MJListCategories
    
    @Field(() => [MJScheduledAction_])
    MJScheduledActions_CreatedByUserIDArray: MJScheduledAction_[]; // Link to MJScheduledActions
    
    @Field(() => [MJResourceLink_])
    MJResourceLinks_UserIDArray: MJResourceLink_[]; // Link to MJResourceLinks
    
    @Field(() => [MJAIAgentRequest_])
    MJAIAgentRequests_ResponseByUserIDArray: MJAIAgentRequest_[]; // Link to MJAIAgentRequests
    
    @Field(() => [MJAIAgentNote_])
    MJAIAgentNotes_UserIDArray: MJAIAgentNote_[]; // Link to MJAIAgentNotes
    
    @Field(() => [MJReportUserState_])
    MJReportUserStates_UserIDArray: MJReportUserState_[]; // Link to MJReportUserStates
    
    @Field(() => [MJDashboardUserPreference_])
    MJDashboardUserPreferences_UserIDArray: MJDashboardUserPreference_[]; // Link to MJDashboardUserPreferences
    
    @Field(() => [MJDashboardUserState_])
    MJDashboardUserStates_UserIDArray: MJDashboardUserState_[]; // Link to MJDashboardUserStates
    
    @Field(() => [MJArtifactVersion_])
    MJArtifactVersions_UserIDArray: MJArtifactVersion_[]; // Link to MJArtifactVersions
    
    @Field(() => [MJPublicLink_])
    MJPublicLinks_UserIDArray: MJPublicLink_[]; // Link to MJPublicLinks
    
    @Field(() => [MJScheduledJobRun_])
    MJScheduledJobRuns_ExecutedByUserIDArray: MJScheduledJobRun_[]; // Link to MJScheduledJobRuns
    
    @Field(() => [MJScheduledJob_])
    MJScheduledJobs_NotifyUserIDArray: MJScheduledJob_[]; // Link to MJScheduledJobs
    
    @Field(() => [MJArtifactPermission_])
    MJArtifactPermissions_UserIDArray: MJArtifactPermission_[]; // Link to MJArtifactPermissions
    
    @Field(() => [MJArtifactUse_])
    MJArtifactUses_UserIDArray: MJArtifactUse_[]; // Link to MJArtifactUses
    
    @Field(() => [MJConversationDetailRating_])
    MJConversationDetailRatings_UserIDArray: MJConversationDetailRating_[]; // Link to MJConversationDetailRatings
    
    @Field(() => [MJTestRunFeedback_])
    MJTestRunFeedbacks_ReviewerUserIDArray: MJTestRunFeedback_[]; // Link to MJTestRunFeedbacks
    
    @Field(() => [MJTestSuiteRun_])
    MJTestSuiteRuns_RunByUserIDArray: MJTestSuiteRun_[]; // Link to MJTestSuiteRuns
    
    @Field(() => [MJUserSetting_])
    MJUserSettings_UserIDArray: MJUserSetting_[]; // Link to MJUserSettings
    
    @Field(() => [MJListShare_])
    MJListShares_UserIDArray: MJListShare_[]; // Link to MJListShares
    
    @Field(() => [MJListInvitation_])
    MJListInvitations_CreatedByUserIDArray: MJListInvitation_[]; // Link to MJListInvitations
    
    @Field(() => [MJDashboardCategoryLink_])
    MJDashboardCategoryLinks_UserIDArray: MJDashboardCategoryLink_[]; // Link to MJDashboardCategoryLinks
    
    @Field(() => [MJDashboardCategoryPermission_])
    MJDashboardCategoryPermissions_UserIDArray: MJDashboardCategoryPermission_[]; // Link to MJDashboardCategoryPermissions
    
    @Field(() => [MJDashboardPermission_])
    MJDashboardPermissions_SharedByUserIDArray: MJDashboardPermission_[]; // Link to MJDashboardPermissions
    
    @Field(() => [MJAPIKey_])
    MJAPIKeys_UserIDArray: MJAPIKey_[]; // Link to MJAPIKeys
    
    @Field(() => [MJUserNotificationPreference_])
    MJUserNotificationPreferences_UserIDArray: MJUserNotificationPreference_[]; // Link to MJUserNotificationPreferences
    
    @Field(() => [MJMCPToolExecutionLog_])
    MJMCPToolExecutionLogs_UserIDArray: MJMCPToolExecutionLog_[]; // Link to MJMCPToolExecutionLogs
    
    @Field(() => [MJVersionLabelRestore_])
    MJVersionLabelRestores_UserIDArray: MJVersionLabelRestore_[]; // Link to MJVersionLabelRestores
    
    @Field(() => [MJOAuthAuthorizationState_])
    MJOAuthAuthorizationStates_UserIDArray: MJOAuthAuthorizationState_[]; // Link to MJOAuthAuthorizationStates
    
    @Field(() => [MJOpenAppInstallHistory_])
    MJOpenAppInstallHistories_ExecutedByUserIDArray: MJOpenAppInstallHistory_[]; // Link to MJOpenAppInstallHistories
    
    @Field(() => [MJOpenApp_])
    MJOpenApps_InstalledByUserIDArray: MJOpenApp_[]; // Link to MJOpenApps
    
    @Field(() => [MJResourcePermission_])
    MJResourcePermissions_UserIDArray: MJResourcePermission_[]; // Link to MJResourcePermissions
    
    @Field(() => [MJAIAgentRequest_])
    MJAIAgentRequests_RequestForUserIDArray: MJAIAgentRequest_[]; // Link to MJAIAgentRequests
    
    @Field(() => [MJConversationDetail_])
    MJConversationDetails_UserIDArray: MJConversationDetail_[]; // Link to MJConversationDetails
    
    @Field(() => [MJAccessControlRule_])
    MJAccessControlRules_GrantedByUserIDArray: MJAccessControlRule_[]; // Link to MJAccessControlRules
    
    @Field(() => [MJArtifact_])
    MJArtifacts_UserIDArray: MJArtifact_[]; // Link to MJArtifacts
    
    @Field(() => [MJScheduledJob_])
    MJScheduledJobs_OwnerUserIDArray: MJScheduledJob_[]; // Link to MJScheduledJobs
    
    @Field(() => [MJCollectionPermission_])
    MJCollectionPermissions_SharedByUserIDArray: MJCollectionPermission_[]; // Link to MJCollectionPermissions
    
    @Field(() => [MJArtifactPermission_])
    MJArtifactPermissions_SharedByUserIDArray: MJArtifactPermission_[]; // Link to MJArtifactPermissions
    
    @Field(() => [MJTestRun_])
    MJTestRuns_RunByUserIDArray: MJTestRun_[]; // Link to MJTestRuns
    
    @Field(() => [MJDashboardPermission_])
    MJDashboardPermissions_UserIDArray: MJDashboardPermission_[]; // Link to MJDashboardPermissions
    
    @Field(() => [MJDashboardCategoryPermission_])
    MJDashboardCategoryPermissions_SharedByUserIDArray: MJDashboardCategoryPermission_[]; // Link to MJDashboardCategoryPermissions
    
    @Field(() => [MJAPIKey_])
    MJAPIKeys_CreatedByUserIDArray: MJAPIKey_[]; // Link to MJAPIKeys
    
    @Field(() => [MJMCPServerConnectionPermission_])
    MJMCPServerConnectionPermissions_UserIDArray: MJMCPServerConnectionPermission_[]; // Link to MJMCPServerConnectionPermissions
    
    @Field(() => [MJVersionLabel_])
    MJVersionLabels_CreatedByUserIDArray: MJVersionLabel_[]; // Link to MJVersionLabels
    
    @Field(() => [MJAIAgentRun_])
    MJAIAgentRuns_UserIDArray: MJAIAgentRun_[]; // Link to MJAIAgentRuns
    
    @Field(() => [MJAIAgentPermission_])
    MJAIAgentPermissions_UserIDArray: MJAIAgentPermission_[]; // Link to MJAIAgentPermissions
    
    @Field(() => [MJCollection_])
    MJCollections_OwnerIDArray: MJCollection_[]; // Link to MJCollections
    
    @Field(() => [MJCollectionPermission_])
    MJCollectionPermissions_UserIDArray: MJCollectionPermission_[]; // Link to MJCollectionPermissions
    
    @Field(() => [MJTask_])
    MJTasks_UserIDArray: MJTask_[]; // Link to MJTasks
    
    @Field(() => [MJAIAgentExample_])
    MJAIAgentExamples_UserIDArray: MJAIAgentExample_[]; // Link to MJAIAgentExamples
    
    @Field(() => [MJAIAgent_])
    MJAIAgents_OwnerUserIDArray: MJAIAgent_[]; // Link to MJAIAgents
    
}

//****************************************************************************
// INPUT TYPE for MJ: Users
//****************************************************************************
@InputType()
export class CreateMJUserInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName: string | null;

    @Field({ nullable: true })
    LastName: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID: string | null;

    @Field({ nullable: true })
    EmployeeID: string | null;

    @Field({ nullable: true })
    UserImageURL: string | null;

    @Field({ nullable: true })
    UserImageIconClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Users
//****************************************************************************
@InputType()
export class UpdateMJUserInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName?: string | null;

    @Field({ nullable: true })
    LastName?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID?: string | null;

    @Field({ nullable: true })
    EmployeeID?: string | null;

    @Field({ nullable: true })
    UserImageURL?: string | null;

    @Field({ nullable: true })
    UserImageIconClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Users
//****************************************************************************
@ObjectType()
export class RunMJUserViewResult {
    @Field(() => [MJUser_])
    Results: MJUser_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUser_)
export class MJUserResolverBase extends ResolverBase {
    @Query(() => RunMJUserViewResult)
    async RunMJUserViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewResult)
    async RunMJUserViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewResult)
    async RunMJUserDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Users';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUser_, { nullable: true })
    async MJUser(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUser_ | null> {
        this.CheckUserReadPermissions('MJ: Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUsers')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Users', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJUser_])
    async AllMJUsers(@Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUsers')}` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Users', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Users', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserApplication_])
    async MJUserApplications_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserApplications')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserRole_])
    async MJUserRoles_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserRoles')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJWorkspace_])
    async MJWorkspaces_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Workspaces', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkspaces')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Workspaces', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async MJReports_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportSnapshot_])
    async MJReportSnapshots_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportSnapshots')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report Snapshots', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async MJRecordChanges_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordChanges')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Changes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboard_])
    async MJDashboards_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboards')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboards', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserViewRun_])
    async MJUserViewRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewRuns')} WHERE ${provider.QuoteIdentifier('RunByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User View Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async MJAuditLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAuditLogs')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Audit Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async MJLists_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwLists')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Lists', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserFavorite_])
    async MJUserFavorites_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserFavorites')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Favorites', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserRecordLog_])
    async MJUserRecordLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserRecordLogs')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Record Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async MJUserViews_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViews')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Views', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRun_])
    async MJCompanyIntegrationRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCompanyIntegrationRuns')} WHERE ${provider.QuoteIdentifier('RunByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Company Integration Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotification_])
    async MJUserNotifications_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotifications')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notifications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async MJConversations_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversations')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordMergeLog_])
    async MJRecordMergeLogs_InitiatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordMergeLogs')} WHERE ${provider.QuoteIdentifier('InitiatedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Merge Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDataContext_])
    async MJDataContexts_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Data Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDataContexts')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Data Contexts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportCategory_])
    async MJReportCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportCategories')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserViewCategory_])
    async MJUserViewCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserViewCategories')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User View Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategory_])
    async MJDashboardCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategories')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryCategory_])
    async MJQueryCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwQueryCategories')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async MJDuplicateRuns_StartedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDuplicateRuns')} WHERE ${provider.QuoteIdentifier('StartedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Duplicate Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionExecutionLog_])
    async MJActionExecutionLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActionExecutionLogs')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Action Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async MJActions_CodeApprovedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwActions')} WHERE ${provider.QuoteIdentifier('CodeApprovedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCommunicationRun_])
    async MJCommunicationRuns_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Communication Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCommunicationRuns')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Communication Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplate_])
    async MJTemplates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplates')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Templates', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplateCategory_])
    async MJTemplateCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTemplateCategories')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Template Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecommendationRun_])
    async MJRecommendationRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecommendationRuns')} WHERE ${provider.QuoteIdentifier('RunByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Recommendation Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordChangeReplayRun_])
    async MJRecordChangeReplayRuns_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Change Replay Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwRecordChangeReplayRuns')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Change Replay Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListCategory_])
    async MJListCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListCategories')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledAction_])
    async MJScheduledActions_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledActions')} WHERE ${provider.QuoteIdentifier('CreatedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourceLink_])
    async MJResourceLinks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourceLinks')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Resource Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async MJAIAgentRequests_ResponseByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRequests')} WHERE ${provider.QuoteIdentifier('ResponseByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Requests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async MJAIAgentNotes_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentNotes')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportUserState_])
    async MJReportUserStates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReportUserStates')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardUserPreference_])
    async MJDashboardUserPreferences_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardUserPreferences')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardUserState_])
    async MJDashboardUserStates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardUserStates')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactVersion_])
    async MJArtifactVersions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactVersions')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Versions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJPublicLink_])
    async MJPublicLinks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Public Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwPublicLinks')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Public Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Public Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledJobRun_])
    async MJScheduledJobRuns_ExecutedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Job Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledJobRuns')} WHERE ${provider.QuoteIdentifier('ExecutedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Job Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Job Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledJob_])
    async MJScheduledJobs_NotifyUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Jobs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledJobs')} WHERE ${provider.QuoteIdentifier('NotifyUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Jobs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Jobs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactPermission_])
    async MJArtifactPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactPermissions')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactUse_])
    async MJArtifactUses_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Uses', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactUses')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Uses', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Uses', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailRating_])
    async MJConversationDetailRatings_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Ratings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetailRatings')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Ratings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Ratings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestRunFeedback_])
    async MJTestRunFeedbacks_ReviewerUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Run Feedbacks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRunFeedbacks')} WHERE ${provider.QuoteIdentifier('ReviewerUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Feedbacks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Run Feedbacks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestSuiteRun_])
    async MJTestSuiteRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suite Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestSuiteRuns')} WHERE ${provider.QuoteIdentifier('RunByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suite Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserSetting_])
    async MJUserSettings_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserSettings')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Settings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListShare_])
    async MJListShares_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Shares', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListShares')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Shares', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Shares', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListInvitation_])
    async MJListInvitations_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Invitations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwListInvitations')} WHERE ${provider.QuoteIdentifier('CreatedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Invitations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Invitations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryLink_])
    async MJDashboardCategoryLinks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategoryLinks')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryPermission_])
    async MJDashboardCategoryPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategoryPermissions')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardPermission_])
    async MJDashboardPermissions_SharedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardPermissions')} WHERE ${provider.QuoteIdentifier('SharedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKey_])
    async MJAPIKeys_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeys')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Keys', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotificationPreference_])
    async MJUserNotificationPreferences_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notification Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwUserNotificationPreferences')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notification Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPToolExecutionLog_])
    async MJMCPToolExecutionLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Tool Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPToolExecutionLogs')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Tool Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Tool Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabelRestore_])
    async MJVersionLabelRestores_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Restores', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabelRestores')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Restores', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Restores', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOAuthAuthorizationState_])
    async MJOAuthAuthorizationStates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Authorization States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOAuthAuthorizationStates')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Authorization States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Authorization States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOpenAppInstallHistory_])
    async MJOpenAppInstallHistories_ExecutedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Open App Install Histories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOpenAppInstallHistories')} WHERE ${provider.QuoteIdentifier('ExecutedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Open App Install Histories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Open App Install Histories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOpenApp_])
    async MJOpenApps_InstalledByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Open Apps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwOpenApps')} WHERE ${provider.QuoteIdentifier('InstalledByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Open Apps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Open Apps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async MJResourcePermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwResourcePermissions')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Resource Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async MJAIAgentRequests_RequestForUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRequests')} WHERE ${provider.QuoteIdentifier('RequestForUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Requests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async MJConversationDetails_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwConversationDetails')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAccessControlRule_])
    async MJAccessControlRules_GrantedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Access Control Rules', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAccessControlRules')} WHERE ${provider.QuoteIdentifier('GrantedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Access Control Rules', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Access Control Rules', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifact_])
    async MJArtifacts_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifacts')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledJob_])
    async MJScheduledJobs_OwnerUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Jobs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwScheduledJobs')} WHERE ${provider.QuoteIdentifier('OwnerUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Jobs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Jobs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionPermission_])
    async MJCollectionPermissions_SharedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollectionPermissions')} WHERE ${provider.QuoteIdentifier('SharedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactPermission_])
    async MJArtifactPermissions_SharedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwArtifactPermissions')} WHERE ${provider.QuoteIdentifier('SharedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestRun_])
    async MJTestRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTestRuns')} WHERE ${provider.QuoteIdentifier('RunByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardPermission_])
    async MJDashboardPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardPermissions')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryPermission_])
    async MJDashboardCategoryPermissions_SharedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwDashboardCategoryPermissions')} WHERE ${provider.QuoteIdentifier('SharedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKey_])
    async MJAPIKeys_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAPIKeys')} WHERE ${provider.QuoteIdentifier('CreatedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Keys', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnectionPermission_])
    async MJMCPServerConnectionPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwMCPServerConnectionPermissions')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabel_])
    async MJVersionLabels_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Labels', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabels')} WHERE ${provider.QuoteIdentifier('CreatedByUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Labels', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Labels', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJAIAgentRuns_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentRuns')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPermission_])
    async MJAIAgentPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentPermissions')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollection_])
    async MJCollections_OwnerIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollections')} WHERE ${provider.QuoteIdentifier('OwnerID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionPermission_])
    async MJCollectionPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwCollectionPermissions')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJTasks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwTasks')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJAIAgentExamples_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgentExamples')} WHERE ${provider.QuoteIdentifier('UserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async MJAIAgents_OwnerUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwAIAgents')} WHERE ${provider.QuoteIdentifier('OwnerUserID')}='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUser_)
    async CreateMJUser(
        @Arg('input', () => CreateMJUserInput) input: CreateMJUserInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Users', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUser_)
    async UpdateMJUser(
        @Arg('input', () => UpdateMJUserInput) input: UpdateMJUserInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Users', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUser_)
    async DeleteMJUser(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Users', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Vector Databases
//****************************************************************************
@ObjectType({ description: `Configures connections to vector database systems for AI embeddings, similarity search, and semantic operations.` })
export class MJVectorDatabase_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Field DefaultURL for entity Vector Databases.`}) 
    @MaxLength(255)
    DefaultURL?: string;
        
    @Field({nullable: true, description: `Field ClassKey for entity Vector Databases.`}) 
    @MaxLength(100)
    ClassKey?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJVectorIndex_])
    MJVectorIndexes_VectorDatabaseIDArray: MJVectorIndex_[]; // Link to MJVectorIndexes
    
    @Field(() => [MJEntityDocument_])
    MJEntityDocuments_IDArray: MJEntityDocument_[]; // Link to MJEntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for MJ: Vector Databases
//****************************************************************************
@InputType()
export class CreateMJVectorDatabaseInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultURL: string | null;

    @Field({ nullable: true })
    ClassKey: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Vector Databases
//****************************************************************************
@InputType()
export class UpdateMJVectorDatabaseInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultURL?: string | null;

    @Field({ nullable: true })
    ClassKey?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Vector Databases
//****************************************************************************
@ObjectType()
export class RunMJVectorDatabaseViewResult {
    @Field(() => [MJVectorDatabase_])
    Results: MJVectorDatabase_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVectorDatabase_)
export class MJVectorDatabaseResolver extends ResolverBase {
    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Vector Databases';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVectorDatabase_, { nullable: true })
    async MJVectorDatabase(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVectorDatabase_ | null> {
        this.CheckUserReadPermissions('MJ: Vector Databases', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVectorDatabases')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Vector Databases', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Vector Databases', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJVectorIndex_])
    async MJVectorIndexes_VectorDatabaseIDArray(@Root() mjvectordatabase_: MJVectorDatabase_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVectorIndexes')} WHERE ${provider.QuoteIdentifier('VectorDatabaseID')}='${mjvectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Vector Indexes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async MJEntityDocuments_IDArray(@Root() mjvectordatabase_: MJVectorDatabase_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityDocuments')} WHERE ${provider.QuoteIdentifier('ID')}='${mjvectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJVectorDatabase_)
    async CreateMJVectorDatabase(
        @Arg('input', () => CreateMJVectorDatabaseInput) input: CreateMJVectorDatabaseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Vector Databases', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVectorDatabase_)
    async UpdateMJVectorDatabase(
        @Arg('input', () => UpdateMJVectorDatabaseInput) input: UpdateMJVectorDatabaseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Vector Databases', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVectorDatabase_)
    async DeleteMJVectorDatabase(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Vector Databases', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Vector Indexes
//****************************************************************************
@ObjectType({ description: `Defines vector indexes within a given Vector Database.` })
export class MJVectorIndex_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(36)
    EmbeddingModelID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(50)
    EmbeddingModel: string;
        
    @Field(() => [MJEntityRecordDocument_])
    MJEntityRecordDocuments_VectorIndexIDArray: MJEntityRecordDocument_[]; // Link to MJEntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for MJ: Vector Indexes
//****************************************************************************
@InputType()
export class CreateMJVectorIndexInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Vector Indexes
//****************************************************************************
@InputType()
export class UpdateMJVectorIndexInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Vector Indexes
//****************************************************************************
@ObjectType()
export class RunMJVectorIndexViewResult {
    @Field(() => [MJVectorIndex_])
    Results: MJVectorIndex_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVectorIndex_)
export class MJVectorIndexResolver extends ResolverBase {
    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Vector Indexes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVectorIndex_, { nullable: true })
    async MJVectorIndex(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVectorIndex_ | null> {
        this.CheckUserReadPermissions('MJ: Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVectorIndexes')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Vector Indexes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityRecordDocument_])
    async MJEntityRecordDocuments_VectorIndexIDArray(@Root() mjvectorindex_: MJVectorIndex_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwEntityRecordDocuments')} WHERE ${provider.QuoteIdentifier('VectorIndexID')}='${mjvectorindex_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Entity Record Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJVectorIndex_)
    async CreateMJVectorIndex(
        @Arg('input', () => CreateMJVectorIndexInput) input: CreateMJVectorIndexInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Vector Indexes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVectorIndex_)
    async UpdateMJVectorIndex(
        @Arg('input', () => UpdateMJVectorIndexInput) input: UpdateMJVectorIndexInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Vector Indexes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVectorIndex_)
    async DeleteMJVectorIndex(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Vector Indexes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Version Installations
//****************************************************************************
@ObjectType({ description: `Records installation history of system versions, tracking deployments, rollbacks, and version-specific configurations.` })
export class MJVersionInstallation_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field(() => Int, {description: `Major version number installed.`}) 
    MajorVersion: number;
        
    @Field(() => Int, {description: `Minor version number installed.`}) 
    MinorVersion: number;
        
    @Field(() => Int, {description: `Patch version number installed.`}) 
    PatchVersion: number;
        
    @Field({nullable: true, description: `What type of installation was applied`}) 
    @MaxLength(20)
    Type?: string;
        
    @Field({description: `Timestamp when this version was installed.`}) 
    InstalledAt: Date;
        
    @Field({description: `Pending, Complete, Failed`}) 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Any logging that was saved from the installation process`}) 
    InstallLog?: string;
        
    @Field({nullable: true, description: `Optional, comments the administrator wants to save for each installed version`}) 
    Comments?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(302)
    CompleteVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Version Installations
//****************************************************************************
@InputType()
export class CreateMJVersionInstallationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Version Installations
//****************************************************************************
@InputType()
export class UpdateMJVersionInstallationInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Version Installations
//****************************************************************************
@ObjectType()
export class RunMJVersionInstallationViewResult {
    @Field(() => [MJVersionInstallation_])
    Results: MJVersionInstallation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionInstallation_)
export class MJVersionInstallationResolver extends ResolverBase {
    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Version Installations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionInstallation_, { nullable: true })
    async MJVersionInstallation(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionInstallation_ | null> {
        this.CheckUserReadPermissions('MJ: Version Installations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionInstallations')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Installations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Version Installations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJVersionInstallation_)
    async CreateMJVersionInstallation(
        @Arg('input', () => CreateMJVersionInstallationInput) input: CreateMJVersionInstallationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Version Installations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionInstallation_)
    async UpdateMJVersionInstallation(
        @Arg('input', () => UpdateMJVersionInstallationInput) input: UpdateMJVersionInstallationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Version Installations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVersionInstallation_)
    async DeleteMJVersionInstallation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Version Installations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Version Label Items
//****************************************************************************
@ObjectType({ description: `Links a Version Label to the specific RecordChange snapshot for each record captured by that label. Denormalizes EntityID and RecordID for efficient querying.` })
export class MJVersionLabelItem_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The version label this item belongs to`}) 
    @MaxLength(36)
    VersionLabelID: string;
        
    @Field({description: `The specific RecordChange entry representing the record state at label creation time`}) 
    @MaxLength(36)
    RecordChangeID: string;
        
    @Field({description: `Denormalized entity reference for query performance`}) 
    @MaxLength(36)
    EntityID: string;
        
    @Field({description: `Denormalized record primary key for query performance`}) 
    @MaxLength(750)
    RecordID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    VersionLabel: string;
        
    @Field() 
    RecordChange: string;
        
    @Field() 
    @MaxLength(255)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Version Label Items
//****************************************************************************
@InputType()
export class CreateMJVersionLabelItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    VersionLabelID?: string;

    @Field({ nullable: true })
    RecordChangeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Version Label Items
//****************************************************************************
@InputType()
export class UpdateMJVersionLabelItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    VersionLabelID?: string;

    @Field({ nullable: true })
    RecordChangeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Version Label Items
//****************************************************************************
@ObjectType()
export class RunMJVersionLabelItemViewResult {
    @Field(() => [MJVersionLabelItem_])
    Results: MJVersionLabelItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionLabelItem_)
export class MJVersionLabelItemResolver extends ResolverBase {
    @Query(() => RunMJVersionLabelItemViewResult)
    async RunMJVersionLabelItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelItemViewResult)
    async RunMJVersionLabelItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelItemViewResult)
    async RunMJVersionLabelItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Version Label Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionLabelItem_, { nullable: true })
    async MJVersionLabelItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionLabelItem_ | null> {
        this.CheckUserReadPermissions('MJ: Version Label Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabelItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Version Label Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJVersionLabelItem_)
    async CreateMJVersionLabelItem(
        @Arg('input', () => CreateMJVersionLabelItemInput) input: CreateMJVersionLabelItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Version Label Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionLabelItem_)
    async UpdateMJVersionLabelItem(
        @Arg('input', () => UpdateMJVersionLabelItemInput) input: UpdateMJVersionLabelItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Version Label Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVersionLabelItem_)
    async DeleteMJVersionLabelItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Version Label Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Version Label Restores
//****************************************************************************
@ObjectType({ description: `Audit trail for restore operations performed against version labels. Tracks progress, success/failure counts, and links to the safety-net pre-restore label.` })
export class MJVersionLabelRestore_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `The version label being restored to`}) 
    @MaxLength(36)
    VersionLabelID: string;
        
    @Field({description: `Current status of the restore operation`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({description: `When the restore operation began`}) 
    StartedAt: Date;
        
    @Field({nullable: true, description: `When the restore operation completed or failed`}) 
    EndedAt?: Date;
        
    @Field({description: `The user who initiated the restore`}) 
    @MaxLength(36)
    UserID: string;
        
    @Field(() => Int, {description: `Total number of records to restore`}) 
    TotalItems: number;
        
    @Field(() => Int, {description: `Number of records successfully restored so far`}) 
    CompletedItems: number;
        
    @Field(() => Int, {description: `Number of records that failed to restore`}) 
    FailedItems: number;
        
    @Field({nullable: true, description: `Detailed error information for failed restore items`}) 
    ErrorLog?: string;
        
    @Field({nullable: true, description: `Reference to the automatically created safety-net label that captured state before the restore began`}) 
    @MaxLength(36)
    PreRestoreLabelID?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    VersionLabel: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    PreRestoreLabel?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Version Label Restores
//****************************************************************************
@InputType()
export class CreateMJVersionLabelRestoreInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    VersionLabelID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    TotalItems?: number;

    @Field(() => Int, { nullable: true })
    CompletedItems?: number;

    @Field(() => Int, { nullable: true })
    FailedItems?: number;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    PreRestoreLabelID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Version Label Restores
//****************************************************************************
@InputType()
export class UpdateMJVersionLabelRestoreInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    VersionLabelID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    TotalItems?: number;

    @Field(() => Int, { nullable: true })
    CompletedItems?: number;

    @Field(() => Int, { nullable: true })
    FailedItems?: number;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    PreRestoreLabelID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Version Label Restores
//****************************************************************************
@ObjectType()
export class RunMJVersionLabelRestoreViewResult {
    @Field(() => [MJVersionLabelRestore_])
    Results: MJVersionLabelRestore_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionLabelRestore_)
export class MJVersionLabelRestoreResolver extends ResolverBase {
    @Query(() => RunMJVersionLabelRestoreViewResult)
    async RunMJVersionLabelRestoreViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelRestoreViewResult)
    async RunMJVersionLabelRestoreViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelRestoreViewResult)
    async RunMJVersionLabelRestoreDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Version Label Restores';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionLabelRestore_, { nullable: true })
    async MJVersionLabelRestore(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionLabelRestore_ | null> {
        this.CheckUserReadPermissions('MJ: Version Label Restores', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabelRestores')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Restores', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Version Label Restores', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJVersionLabelRestore_)
    async CreateMJVersionLabelRestore(
        @Arg('input', () => CreateMJVersionLabelRestoreInput) input: CreateMJVersionLabelRestoreInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Version Label Restores', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionLabelRestore_)
    async UpdateMJVersionLabelRestore(
        @Arg('input', () => UpdateMJVersionLabelRestoreInput) input: UpdateMJVersionLabelRestoreInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Version Label Restores', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVersionLabelRestore_)
    async DeleteMJVersionLabelRestore(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Version Label Restores', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Version Labels
//****************************************************************************
@ObjectType({ description: `A named point-in-time bookmark into the RecordChange history, used for versioning, diffing, and restoration.` })
export class MJVersionLabel_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field({description: `Human-readable label name, e.g. Release 2.5, Pre-Refactor Snapshot`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Optional longer description of what this label represents`}) 
    Description?: string;
        
    @Field({description: `Breadth of the label: Record (one record and its dependency graph, the primary use case), Entity (one entity type), or System (all entities). Parent grouping labels may use any scope as a logical container.`}) 
    @MaxLength(50)
    Scope: string;
        
    @Field({nullable: true, description: `When Scope is Entity or Record, identifies the target entity. NULL for System scope.`}) 
    @MaxLength(36)
    EntityID?: string;
        
    @Field({nullable: true, description: `When Scope is Record, identifies the specific record. NULL for System and Entity scopes.`}) 
    @MaxLength(750)
    RecordID?: string;
        
    @Field({nullable: true, description: `Self-referencing parent for grouping related labels. When a user labels multiple records of the same entity, a parent label is created as the container and each individual record label references it via ParentID.`}) 
    @MaxLength(36)
    ParentID?: string;
        
    @Field({description: `Lifecycle state: Active (current), Archived (historical reference only), Restored (this label was used in a restore operation)`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({description: `The user who created this version label`}) 
    @MaxLength(36)
    CreatedByUserID: string;
        
    @Field({nullable: true, description: `Optional reference to an external system identifier such as a git SHA, release tag, or deployment ID`}) 
    @MaxLength(200)
    ExternalSystemID?: string;
        
    @Field(() => Int, {description: `Total number of VersionLabelItem rows created for this label. Populated after label creation completes.`}) 
    ItemCount: number;
        
    @Field(() => Int, {description: `Time in milliseconds taken to create this label and all its items. Used for estimation of future label creation operations.`}) 
    CreationDurationMS: number;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(255)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(100)
    CreatedByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(36)
    RootParentID?: string;
        
    @Field(() => [MJVersionLabelRestore_])
    MJVersionLabelRestores_PreRestoreLabelIDArray: MJVersionLabelRestore_[]; // Link to MJVersionLabelRestores
    
    @Field(() => [MJVersionLabelItem_])
    MJVersionLabelItems_VersionLabelIDArray: MJVersionLabelItem_[]; // Link to MJVersionLabelItems
    
    @Field(() => [MJVersionLabelRestore_])
    MJVersionLabelRestores_VersionLabelIDArray: MJVersionLabelRestore_[]; // Link to MJVersionLabelRestores
    
    @Field(() => [MJVersionLabel_])
    MJVersionLabels_ParentIDArray: MJVersionLabel_[]; // Link to MJVersionLabels
    
}

//****************************************************************************
// INPUT TYPE for MJ: Version Labels
//****************************************************************************
@InputType()
export class CreateMJVersionLabelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ExternalSystemID: string | null;

    @Field(() => Int, { nullable: true })
    ItemCount?: number;

    @Field(() => Int, { nullable: true })
    CreationDurationMS?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Version Labels
//****************************************************************************
@InputType()
export class UpdateMJVersionLabelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ExternalSystemID?: string | null;

    @Field(() => Int, { nullable: true })
    ItemCount?: number;

    @Field(() => Int, { nullable: true })
    CreationDurationMS?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Version Labels
//****************************************************************************
@ObjectType()
export class RunMJVersionLabelViewResult {
    @Field(() => [MJVersionLabel_])
    Results: MJVersionLabel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionLabel_)
export class MJVersionLabelResolver extends ResolverBase {
    @Query(() => RunMJVersionLabelViewResult)
    async RunMJVersionLabelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelViewResult)
    async RunMJVersionLabelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelViewResult)
    async RunMJVersionLabelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Version Labels';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionLabel_, { nullable: true })
    async MJVersionLabel(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionLabel_ | null> {
        this.CheckUserReadPermissions('MJ: Version Labels', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabels')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Labels', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Version Labels', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJVersionLabelRestore_])
    async MJVersionLabelRestores_PreRestoreLabelIDArray(@Root() mjversionlabel_: MJVersionLabel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Restores', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabelRestores')} WHERE ${provider.QuoteIdentifier('PreRestoreLabelID')}='${mjversionlabel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Restores', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Restores', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabelItem_])
    async MJVersionLabelItems_VersionLabelIDArray(@Root() mjversionlabel_: MJVersionLabel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabelItems')} WHERE ${provider.QuoteIdentifier('VersionLabelID')}='${mjversionlabel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabelRestore_])
    async MJVersionLabelRestores_VersionLabelIDArray(@Root() mjversionlabel_: MJVersionLabel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Restores', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabelRestores')} WHERE ${provider.QuoteIdentifier('VersionLabelID')}='${mjversionlabel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Restores', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Restores', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabel_])
    async MJVersionLabels_ParentIDArray(@Root() mjversionlabel_: MJVersionLabel_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Labels', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwVersionLabels')} WHERE ${provider.QuoteIdentifier('ParentID')}='${mjversionlabel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Labels', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Labels', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJVersionLabel_)
    async CreateMJVersionLabel(
        @Arg('input', () => CreateMJVersionLabelInput) input: CreateMJVersionLabelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Version Labels', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionLabel_)
    async UpdateMJVersionLabel(
        @Arg('input', () => UpdateMJVersionLabelInput) input: UpdateMJVersionLabelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Version Labels', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVersionLabel_)
    async DeleteMJVersionLabel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Version Labels', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Workflow Engines
//****************************************************************************
@ObjectType({ description: `Registers available workflow execution engines with their capabilities, configuration, and supported workflow types.` })
export class MJWorkflowEngine_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Import path for the workflow engine driver.`}) 
    @MaxLength(500)
    DriverPath: string;
        
    @Field({description: `Class name implementing the workflow engine interface.`}) 
    @MaxLength(100)
    DriverClass: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJWorkflow_])
    MJWorkflows_WorkflowEngineNameArray: MJWorkflow_[]; // Link to MJWorkflows
    
}

//****************************************************************************
// INPUT TYPE for MJ: Workflow Engines
//****************************************************************************
@InputType()
export class CreateMJWorkflowEngineInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverPath?: string;

    @Field({ nullable: true })
    DriverClass?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Workflow Engines
//****************************************************************************
@InputType()
export class UpdateMJWorkflowEngineInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverPath?: string;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Workflow Engines
//****************************************************************************
@ObjectType()
export class RunMJWorkflowEngineViewResult {
    @Field(() => [MJWorkflowEngine_])
    Results: MJWorkflowEngine_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflowEngine_)
export class MJWorkflowEngineResolver extends ResolverBase {
    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Workflow Engines';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflowEngine_, { nullable: true })
    async MJWorkflowEngine(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflowEngine_ | null> {
        this.CheckUserReadPermissions('MJ: Workflow Engines', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkflowEngines')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workflow Engines', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Workflow Engines', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJWorkflow_])
    async MJWorkflows_WorkflowEngineNameArray(@Root() mjworkflowengine_: MJWorkflowEngine_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkflows')} WHERE ${provider.QuoteIdentifier('WorkflowEngineName')}='${mjworkflowengine_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Workflows', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJWorkflowEngine_)
    async CreateMJWorkflowEngine(
        @Arg('input', () => CreateMJWorkflowEngineInput) input: CreateMJWorkflowEngineInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Workflow Engines', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkflowEngine_)
    async UpdateMJWorkflowEngine(
        @Arg('input', () => UpdateMJWorkflowEngineInput) input: UpdateMJWorkflowEngineInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Workflow Engines', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkflowEngine_)
    async DeleteMJWorkflowEngine(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Workflow Engines', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Workflow Runs
//****************************************************************************
@ObjectType({ description: `Tracks execution instances of workflows including status, timing, context data, and detailed step-by-step results.` })
export class MJWorkflowRun_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(36)
    WorkflowID: string;
        
    @Field({description: `Field ExternalSystemRecordID for entity Workflow Runs.`}) 
    @MaxLength(500)
    ExternalSystemRecordID: string;
        
    @Field() 
    StartedAt: Date;
        
    @Field({nullable: true}) 
    EndedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    Status: string;
        
    @Field({nullable: true, description: `JSON-formatted detailed results from the workflow execution, including outputs from each step and any error information.`}) 
    Results?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Workflow: string;
        
    @Field() 
    @MaxLength(100)
    WorkflowEngineName: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Workflow Runs
//****************************************************************************
@InputType()
export class CreateMJWorkflowRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    WorkflowID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Results: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Workflow Runs
//****************************************************************************
@InputType()
export class UpdateMJWorkflowRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    WorkflowID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Results?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Workflow Runs
//****************************************************************************
@ObjectType()
export class RunMJWorkflowRunViewResult {
    @Field(() => [MJWorkflowRun_])
    Results: MJWorkflowRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflowRun_)
export class MJWorkflowRunResolver extends ResolverBase {
    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Workflow Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflowRun_, { nullable: true })
    async MJWorkflowRun(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflowRun_ | null> {
        this.CheckUserReadPermissions('MJ: Workflow Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkflowRuns')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Workflow Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJWorkflowRun_)
    async CreateMJWorkflowRun(
        @Arg('input', () => CreateMJWorkflowRunInput) input: CreateMJWorkflowRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Workflow Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkflowRun_)
    async UpdateMJWorkflowRun(
        @Arg('input', () => UpdateMJWorkflowRunInput) input: UpdateMJWorkflowRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Workflow Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkflowRun_)
    async DeleteMJWorkflowRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Workflow Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Workflows
//****************************************************************************
@ObjectType({ description: `Defines automated workflows with steps, conditions, and actions for orchestrating complex business processes.` })
export class MJWorkflow_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    WorkflowEngineID: string;
        
    @Field({description: `The unique identifier of this workflow in an external system, used for synchronization with external workflow engines.`}) 
    @MaxLength(100)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean, {description: `If set to 1, the workflow will be run automatically on the interval specified by the AutoRunIntervalType and AutoRunInterval fields`}) 
    AutoRunEnabled: boolean;
        
    @Field({nullable: true, description: `Minutes, Hours, Days, Weeks, Months, Years`}) 
    @MaxLength(20)
    AutoRunIntervalUnits?: string;
        
    @Field(() => Int, {nullable: true, description: `The interval, denominated in the units specified in the AutoRunIntervalUnits column, between auto runs of this workflow.`}) 
    AutoRunInterval?: number;
        
    @Field({nullable: true, description: `If specified, this subclass key, via the ClassFactory, will be instantiated, to execute this workflow. If not specified the WorkflowBase class will be used by default.`}) 
    @MaxLength(200)
    SubclassName?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true}) 
    AutoRunIntervalMinutes?: number;
        
    @Field(() => [MJReport_])
    MJReports_OutputWorkflowIDArray: MJReport_[]; // Link to MJReports
    
    @Field(() => [MJWorkflowRun_])
    MJWorkflowRuns_WorkflowNameArray: MJWorkflowRun_[]; // Link to MJWorkflowRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Workflows
//****************************************************************************
@InputType()
export class CreateMJWorkflowInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    WorkflowEngineID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    AutoRunEnabled?: boolean;

    @Field({ nullable: true })
    AutoRunIntervalUnits: string | null;

    @Field(() => Int, { nullable: true })
    AutoRunInterval: number | null;

    @Field({ nullable: true })
    SubclassName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Workflows
//****************************************************************************
@InputType()
export class UpdateMJWorkflowInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkflowEngineID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    AutoRunEnabled?: boolean;

    @Field({ nullable: true })
    AutoRunIntervalUnits?: string | null;

    @Field(() => Int, { nullable: true })
    AutoRunInterval?: number | null;

    @Field({ nullable: true })
    SubclassName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Workflows
//****************************************************************************
@ObjectType()
export class RunMJWorkflowViewResult {
    @Field(() => [MJWorkflow_])
    Results: MJWorkflow_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflow_)
export class MJWorkflowResolver extends ResolverBase {
    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Workflows';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflow_, { nullable: true })
    async MJWorkflow(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflow_ | null> {
        this.CheckUserReadPermissions('MJ: Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkflows')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Workflows', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async MJReports_OutputWorkflowIDArray(@Root() mjworkflow_: MJWorkflow_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwReports')} WHERE ${provider.QuoteIdentifier('OutputWorkflowID')}='${mjworkflow_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJWorkflowRun_])
    async MJWorkflowRuns_WorkflowNameArray(@Root() mjworkflow_: MJWorkflow_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Workflow Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkflowRuns')} WHERE ${provider.QuoteIdentifier('WorkflowName')}='${mjworkflow_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Workflow Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJWorkflow_)
    async CreateMJWorkflow(
        @Arg('input', () => CreateMJWorkflowInput) input: CreateMJWorkflowInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Workflows', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkflow_)
    async UpdateMJWorkflow(
        @Arg('input', () => UpdateMJWorkflowInput) input: UpdateMJWorkflowInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Workflows', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkflow_)
    async DeleteMJWorkflow(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Workflows', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Workspace Items
//****************************************************************************
@ObjectType({ description: `Tracks the resources that are active within a given worksapce` })
export class MJWorkspaceItem_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    WorkspaceID: string;
        
    @Field() 
    @MaxLength(36)
    ResourceTypeID: string;
        
    @Field({nullable: true, description: `The ID of the resource (such as a view, dashboard, or other entity record) that is included in this workspace.`}) 
    @MaxLength(2000)
    ResourceRecordID?: string;
        
    @Field(() => Int, {description: `The display order of this item within the workspace, used for arranging resources in the user interface.`}) 
    Sequence: number;
        
    @Field({nullable: true, description: `JSON configuration data specific to this workspace item, storing custom settings and state information.`}) 
    Configuration?: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(255)
    Workspace: string;
        
    @Field() 
    @MaxLength(255)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Workspace Items
//****************************************************************************
@InputType()
export class CreateMJWorkspaceItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Workspace Items
//****************************************************************************
@InputType()
export class UpdateMJWorkspaceItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Workspace Items
//****************************************************************************
@ObjectType()
export class RunMJWorkspaceItemViewResult {
    @Field(() => [MJWorkspaceItem_])
    Results: MJWorkspaceItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkspaceItem_)
export class MJWorkspaceItemResolver extends ResolverBase {
    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Workspace Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkspaceItem_, { nullable: true })
    async MJWorkspaceItem(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkspaceItem_ | null> {
        this.CheckUserReadPermissions('MJ: Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkspaceItems')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Workspace Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJWorkspaceItem_)
    async CreateMJWorkspaceItem(
        @Arg('input', () => CreateMJWorkspaceItemInput) input: CreateMJWorkspaceItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Workspace Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkspaceItem_)
    async UpdateMJWorkspaceItem(
        @Arg('input', () => UpdateMJWorkspaceItemInput) input: UpdateMJWorkspaceItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Workspace Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkspaceItem_)
    async DeleteMJWorkspaceItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Workspace Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Workspaces
//****************************************************************************
@ObjectType({ description: `A user can have one or more workspaces` })
export class MJWorkspace_ {
    @Field() 
    @MaxLength(36)
    ID: string;
        
    @Field() 
    @MaxLength(255)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(36)
    UserID: string;
        
    @Field() 
    _mj__CreatedAt: Date;
        
    @Field() 
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON blob containing all workspace state: tabs, layout configuration, theme preferences, and active tab. Replaces WorkspaceItem table.`}) 
    Configuration?: string;
        
    @Field() 
    @MaxLength(100)
    User: string;
        
    @Field(() => [MJWorkspaceItem_])
    MJWorkspaceItems_WorkSpaceIDArray: MJWorkspaceItem_[]; // Link to MJWorkspaceItems
    
}

//****************************************************************************
// INPUT TYPE for MJ: Workspaces
//****************************************************************************
@InputType()
export class CreateMJWorkspaceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Workspaces
//****************************************************************************
@InputType()
export class UpdateMJWorkspaceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Workspaces
//****************************************************************************
@ObjectType()
export class RunMJWorkspaceViewResult {
    @Field(() => [MJWorkspace_])
    Results: MJWorkspace_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkspace_)
export class MJWorkspaceResolver extends ResolverBase {
    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Workspaces';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkspace_, { nullable: true })
    async MJWorkspace(@Arg('ID', () => String) ID: string, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkspace_ | null> {
        this.CheckUserReadPermissions('MJ: Workspaces', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkspaces')} WHERE ${provider.QuoteIdentifier('ID')}='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Workspaces', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJWorkspaceItem_])
    async MJWorkspaceItems_WorkSpaceIDArray(@Root() mjworkspace_: MJWorkspace_, @Ctx() { userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM ${provider.QuoteSchemaAndView(Metadata.Provider.ConfigData.MJCoreSchemaName, 'vwWorkspaceItems')} WHERE ${provider.QuoteIdentifier('WorkSpaceID')}='${mjworkspace_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await provider.ExecuteSQL(sSQL, undefined, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Workspace Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJWorkspace_)
    async CreateMJWorkspace(
        @Arg('input', () => CreateMJWorkspaceInput) input: CreateMJWorkspaceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Workspaces', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkspace_)
    async UpdateMJWorkspace(
        @Arg('input', () => UpdateMJWorkspaceInput) input: UpdateMJWorkspaceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Workspaces', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkspace_)
    async DeleteMJWorkspace(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Workspaces', key, options, provider, userPayload, pubSub);
    }
    
}